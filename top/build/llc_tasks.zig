const fmt = @import("../fmt.zig");
const mem = @import("../mem.zig");
const debug = @import("../debug.zig");
const parse = @import("../parse.zig");
const builtin = @import("../builtin.zig");
const types = @import("types.zig");
const tasks = @import("tasks.zig");
pub const PathUnion = union(enum) {
    yes: ?types.Path,
    no,
};
pub const StringUnion = union(enum) {
    yes: ?[]const u8,
    no,
};
pub const LLCCommand = struct {
    /// Always modify dest registers regardless of color
    aarch64_a57_fp_load_balancing_force_all: bool = false,
    /// Ignore balance information, always return (1: Even, 2: Odd).
    aarch64_a57_fp_load_balancing_override: ?usize = null,
    /// Restrict range of Bcc instructions (DEBUG)
    aarch64_bcc_offset_bits: ?usize = null,
    /// Restrict range of CB[N]Z instructions (DEBUG)
    aarch64_cbz_offset_bits: ?usize = null,
    /// Maximum number of instructions per speculated block.
    aarch64_ccmp_limit: ?usize = null,
    /// Enable the early if converter pass
    aarch64_early_ifcvt: bool = false,
    /// Allow AArch64 Local Dynamic TLS code generation
    aarch64_elf_ldtls_generation: bool = false,
    /// Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information
    aarch64_enable_atomic_cfg_tidy: bool = false,
    /// Relax out of range conditional branches
    aarch64_enable_branch_relax: bool = false,
    /// Enable the AArch64 branch target pass
    aarch64_enable_branch_targets: bool = false,
    /// Enable the CCMP formation pass
    aarch64_enable_ccmp: bool = false,
    /// Enable the pass that emits the linker optimization hints (LOH)
    aarch64_enable_collect_loh: bool = false,
    /// Use smallest entry possible for jump tables
    aarch64_enable_compress_jump_tables: bool = false,
    /// Enable the conditional branch tuning pass
    aarch64_enable_cond_br_tune: bool = false,
    /// Enable the condition optimizer pass
    aarch64_enable_condopt: bool = false,
    /// Enable the copy propagation with AArch64 copy instr
    aarch64_enable_copy_propagation: bool = false,
    /// Enable the redundant copy elimination pass
    aarch64_enable_copyelim: bool = false,
    /// Enable the pass that removes dead definitons and replaces stores to them with stores to the zero register
    aarch64_enable_dead_defs: bool = false,
    /// Run early if-conversion
    aarch64_enable_early_ifcvt: bool = false,
    aarch64_enable_falkor_hwpf_fix: bool = false,
    /// Enable optimizations on complex GEPs
    aarch64_enable_gep_opt: bool = false,
    /// Enable GlobalISel's post-legalizer load/store optimization pass
    aarch64_enable_gisel_ldst_postlegal: bool = false,
    /// Enable GlobalISel's pre-legalizer load/store optimization pass
    aarch64_enable_gisel_ldst_prelegal: bool = false,
    /// Enable GlobalISel at or below an opt level (-1 to disable)
    aarch64_enable_global_isel_at_O: ?usize = null,
    /// Enable the global merge pass
    aarch64_enable_global_merge: bool = false,
    /// Enable the load/store pair optimization pass
    aarch64_enable_ldst_opt: bool = false,
    /// Enable AArch64 logical imm instruction optimization
    aarch64_enable_logical_imm: bool = false,
    /// Enable the loop data prefetch pass
    aarch64_enable_loop_data_prefetch: bool = false,
    /// Enable the machine combiner pass
    aarch64_enable_mcr: bool = false,
    /// Combine extends of AArch64 masked gather intrinsics
    aarch64_enable_mgather_combine: bool = false,
    /// Call nonlazybind functions via direct GOT load
    aarch64_enable_nonlazybind: bool = false,
    /// Enable the promote constant pass
    aarch64_enable_promote_const: bool = false,
    /// Enable use of AdvSIMD scalar integer instructions
    aarch64_enable_simd_scalar: bool = false,
    /// Suppress STP for AArch64
    aarch64_enable_stp_suppress: bool = false,
    /// Enable SVE intrinsic opts
    aarch64_enable_sve_intrinsic_opts: bool = false,
    /// Base cost of vector insert/extract element
    aarch64_insert_extract_base_cost: ?usize = null,
    aarch64_load_store_renaming: bool = false,
    aarch64_load_store_scan_limit: ?usize = null,
    /// Add .note.gnu.property with BTI to assembly files
    aarch64_mark_bti_property: bool = false,
    /// Maximum of xors
    aarch64_max_xors: ?usize = null,
    /// Choose style of NEON code to emit from AArch64 backend:
    aarch64_neon_syntax: ?enum(u1) {
        generic = 0,
        apple = 1,
    } = null,
    /// sort stack allocations
    aarch64_order_frame_objects: bool = false,
    /// enable use of redzone on AArch64
    aarch64_redzone: bool = false,
    /// Enable select to branch optimizations
    aarch64_select_opt: bool = false,
    /// Force use of AdvSIMD scalar instructions everywhere
    aarch64_simd_scalar_force_all: bool = false,
    /// Sanitize loads from memory.
    aarch64_slh_loads: bool = false,
    /// Turn all knobs to 11
    aarch64_stress_ccmp: bool = false,
    /// Promote all vector constants
    aarch64_stress_promote_const: bool = false,
    /// Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.
    aarch64_sve_vector_bits_max: ?usize = null,
    /// Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.
    aarch64_sve_vector_bits_min: ?usize = null,
    /// Restrict range of TB[N]Z instructions (DEBUG)
    aarch64_tbz_offset_bits: ?usize = null,
    aarch64_update_scan_limit: ?usize = null,
    /// Enable the use of AA during codegen.
    aarch64_use_aa: bool = false,
    /// Assume that top byte of an address is ignored
    aarch64_use_tbi: bool = false,
    /// Disable one or more combiner rules temporarily in the AArch64O0PreLegalizerCombinerHelper pass
    aarch64o0prelegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AArch64O0PreLegalizerCombinerHelper pass then re-enable the specified ones
    aarch64o0prelegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the AArch64PostLegalizerCombinerHelper pass
    aarch64postlegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AArch64PostLegalizerCombinerHelper pass then re-enable the specified ones
    aarch64postlegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the AArch64PostLegalizerLoweringHelper pass
    aarch64postlegalizerloweringhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AArch64PostLegalizerLoweringHelper pass then re-enable the specified ones
    aarch64postlegalizerloweringhelper_only_enable_rule: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the AArch64PreLegalizerCombinerHelper pass
    aarch64prelegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AArch64PreLegalizerCombinerHelper pass then re-enable the specified ones
    aarch64prelegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Abort when the max iterations for devirtualization CGSCC repeat pass is reached
    abort_on_max_devirt_iterations_reached: bool = false,
    /// Output dwarf accelerator tables.
    accel_tables: ?enum(u2) {
        Default = 0,
        Disable = 1,
        Apple = 2,
        Dwarf = 3,
    } = null,
    adce_remove_control_flow: bool = false,
    adce_remove_loops: bool = false,
    /// Allow combining of BaseGV field in Address sinking.
    addr_sink_combine_base_gv: bool = false,
    /// Allow combining of BaseOffs field in Address sinking.
    addr_sink_combine_base_offs: bool = false,
    /// Allow combining of BaseReg field in Address sinking.
    addr_sink_combine_base_reg: bool = false,
    /// Allow combining of ScaledReg field in Address sinking.
    addr_sink_combine_scaled_reg: bool = false,
    /// Allow creation of Phis in Address sinking.
    addr_sink_new_phis: bool = false,
    /// Allow creation of selects in Address sinking.
    addr_sink_new_select: bool = false,
    /// Address sinking in CGP using GEPs.
    addr_sink_using_gep: bool = false,
    /// Emit an address-significance table
    addrsig: bool = false,
    /// Debug control for aggressive anti-dep breaker
    agg_antidep_debugdiv: ?usize = null,
    /// Debug control for aggressive anti-dep breaker
    agg_antidep_debugmod: ?usize = null,
    /// Aggregate arguments to code-extracted functions
    aggregate_extracted_args: bool = false,
    /// Aggressive extension optimization
    aggressive_ext_opt: bool = false,
    /// Max number of instructions to scan for aggressive instcombine.
    aggressive_instcombine_max_scan_instrs: ?usize = null,
    /// Enable Passing SSP Canary info in Trackback on AIX
    aix_ssp_tb_bit: bool = false,
    /// The maximum number of pointers may-alias sets may contain before degradation
    alias_set_saturation_threshold: ?usize = null,
    /// Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).
    align_all_blocks: ?usize = null,
    /// Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).
    align_all_functions: ?usize = null,
    /// Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries).
    align_all_nofallthru_blocks: ?usize = null,
    /// Default alignment for loops
    align_loops: ?usize = null,
    /// Align ARM NEON spills in prolog and epilog
    align_neon_spills: bool = false,
    /// Enable the generation of WLS loops
    allow_arm_wlsloops: bool = false,
    /// Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.
    allow_ginsert_as_artifact: bool = false,
    /// Allows loops to be unroll-and-jammed.
    allow_unroll_and_jam: bool = false,
    /// Use this to skip inserting cache invalidating instructions.
    amdgcn_skip_cache_invalidations: bool = false,
    /// Replace pointer out arguments with struct returns for non-private address space
    amdgpu_any_address_space_out_arguments: bool = false,
    /// Assumed extra stack use if there are any variable sized objects (in bytes)
    amdgpu_assume_dynamic_stack_object_size: ?usize = null,
    /// Assumed stack use of any external call (in bytes)
    amdgpu_assume_external_call_stack_size: ?usize = null,
    /// Enable atomic optimizations
    amdgpu_atomic_optimizations: bool = false,
    /// Skip 64-bit divide for dynamic 32-bit values
    amdgpu_bypass_slow_div: bool = false,
    /// Enable machine DCE inside regalloc
    amdgpu_dce_in_ra: bool = false,
    /// Do not align and prefetch loops
    amdgpu_disable_loop_alignment: bool = false,
    /// Disable unclustred high register pressure reduction scheduling stage.
    amdgpu_disable_unclustred_high_rp_reschedule: bool = false,
    /// Enable DPP combiner
    amdgpu_dpp_combine: bool = false,
    /// Dump AMDGPU HSA Metadata
    amdgpu_dump_hsa_metadata: bool = false,
    /// Run early if-conversion
    amdgpu_early_ifcvt: bool = false,
    /// Inline all functions early
    amdgpu_early_inline_all: bool = false,
    /// Enable s_delay_alu insertion
    amdgpu_enable_delay_alu: bool = false,
    /// Enable LDS replace with pointer pass
    amdgpu_enable_lds_replace_with_pointer: bool = false,
    /// Enable lower module lds pass
    amdgpu_enable_lower_module_lds: bool = false,
    /// Enable scheduling strategy to maximize ILP for a single wave.
    amdgpu_enable_max_ilp_scheduling_strategy: bool = false,
    /// Merge and hoist M0 initializations
    amdgpu_enable_merge_m0: bool = false,
    /// Enable scheduling to minimize mAI power bursts
    amdgpu_enable_power_sched: bool = false,
    /// Enable Pre-RA optimizations pass
    amdgpu_enable_pre_ra_optimizations: bool = false,
    /// Enable promotion of flat kernel pointer arguments to global
    amdgpu_enable_promote_kernel_arguments: bool = false,
    /// Enable workarounds for the StructurizeCFG pass
    amdgpu_enable_structurizer_workarounds: bool = false,
    /// Enable VOPD, dual issue of VALU in wave32
    amdgpu_enable_vopd: bool = false,
    /// Enable AMDGPU function call support
    amdgpu_function_calls: bool = false,
    /// Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.
    amdgpu_igrouplp_exact_solver: bool = false,
    /// Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order. Attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.
    amdgpu_igrouplp_exact_solver_cost_heur: bool = false,
    /// The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver)
    amdgpu_igrouplp_exact_solver_cutoff: ?usize = null,
    /// The amount of branches that we are willing to explore with the exact algorithm before giving up.
    amdgpu_igrouplp_exact_solver_max_branches: ?usize = null,
    /// Indirect access memory instruction weight
    amdgpu_indirect_access_weight: ?usize = null,
    /// Cost of alloca argument
    amdgpu_inline_arg_alloca_cost: ?usize = null,
    /// Maximum alloca size to use for inline cost
    amdgpu_inline_arg_alloca_cutoff: ?usize = null,
    /// Maximum number of BBs allowed in a function after inlining (compile time constraint)
    amdgpu_inline_max_bb: ?usize = null,
    /// Enable elimination of non-kernel functions and unused globals
    amdgpu_internalize_symbols: bool = false,
    /// Lower kernel argument loads in IR pass
    amdgpu_ir_lower_kernel_arguments: bool = false,
    /// Large stride memory access threshold
    amdgpu_large_stride_threshold: ?usize = null,
    /// Large stride memory access weight
    amdgpu_large_stride_weight: ?usize = null,
    /// Enable late CFG structurization
    amdgpu_late_structurize: bool = false,
    /// Kernel limit wave threshold in %
    amdgpu_limit_wave_threshold: ?usize = null,
    /// Enable load store vectorizer
    amdgpu_load_store_vectorizer: bool = false,
    /// Specify lowering strategy for function LDS access:
    amdgpu_lower_module_lds_strategy: ?enum(u2) {
        table = 0,
        module = 1,
        kernel = 2,
        hybrid = 3,
    } = null,
    /// Maximum length of a memory clause, instructions
    amdgpu_max_memory_clause: ?usize = null,
    /// Approximately limit number of return registers for replacing out arguments
    amdgpu_max_return_arg_num_regs: ?usize = null,
    /// Set minimum mem intrinsic size to expand in IR
    amdgpu_mem_intrinsic_expand_size: ?usize = null,
    /// Function mem bound threshold in %
    amdgpu_membound_threshold: ?usize = null,
    /// Fill a percentage of the latency between neighboring MFMA with s_nops.
    amdgpu_mfma_padding_ratio: ?usize = null,
    /// Enable mode register pass
    amdgpu_mode_register: bool = false,
    /// Number of addresses from which to enable MIMG NSA.
    amdgpu_nsa_threshold: ?usize = null,
    /// Run pre-RA exec mask optimizations
    amdgpu_opt_exec_mask_pre_ra: bool = false,
    /// Enable VGPR liverange optimizations for if-else structure
    amdgpu_opt_vgpr_liverange: bool = false,
    /// Enable pre-link mode optimizations
    amdgpu_prelink: bool = false,
    /// Maximum byte size to consider promote alloca to vector
    amdgpu_promote_alloca_to_vector_limit: ?usize = null,
    /// Enable register reassign optimizations on gfx10+
    amdgpu_reassign_regs: bool = false,
    /// Enable scalar IR passes
    amdgpu_scalar_ir_passes: bool = false,
    /// Enable global load scalarization
    amdgpu_scalarize_global_loads: bool = false,
    /// Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.
    amdgpu_schedule_metric_bias: ?usize = null,
    /// Enable SDWA peepholer
    amdgpu_sdwa_peephole: bool = false,
    /// Adjust wave priority
    amdgpu_set_wave_priority: bool = false,
    /// VALU instruction count threshold for adjusting wave priority
    amdgpu_set_wave_priority_valu_insts_threshold: ?usize = null,
    /// Enable amdgpu library simplifications
    amdgpu_simplify_libcall: bool = false,
    /// Number of instructions before jumping over divergent control flow
    amdgpu_skip_threshold: ?usize = null,
    /// Force all functions to be noinline
    amdgpu_stress_function_calls: bool = false,
    /// Increase alignment of LDS if it is not on align boundary
    amdgpu_super_align_lds_globals: bool = false,
    /// Inner loop block size threshold to analyze in unroll for AMDGPU
    amdgpu_unroll_max_block_to_analyze: ?usize = null,
    /// Allow runtime unroll for AMDGPU if local memory used in a loop
    amdgpu_unroll_runtime_local: bool = false,
    /// Unroll threshold increment for AMDGPU for each if statement inside loop
    amdgpu_unroll_threshold_if: ?usize = null,
    /// Unroll threshold for AMDGPU if local memory used in a loop
    amdgpu_unroll_threshold_local: ?usize = null,
    /// Unroll threshold for AMDGPU if private memory used in a loop
    amdgpu_unroll_threshold_private: ?usize = null,
    /// Enable the use of AA during codegen.
    amdgpu_use_aa_in_codegen: bool = false,
    /// Use indirect register addressing for divergent indexes
    amdgpu_use_divergent_register_indexing: bool = false,
    /// Enable legacy divergence analysis for AMDGPU
    amdgpu_use_legacy_divergence_analysis: bool = false,
    /// Comma separated list of functions to replace with native, or all
    amdgpu_use_native: ?[]const u8 = null,
    /// Verify AMDGPU HSA Metadata
    amdgpu_verify_hsa_metadata: bool = false,
    /// Use GPR indexing mode instead of movrel for vector indexing
    amdgpu_vgpr_index_mode: bool = false,
    /// Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
    amdgpu_waitcnt_forcezero: bool = false,
    /// Disable one or more combiner rules temporarily in the AMDGPUPostLegalizerCombinerHelper pass
    amdgpupostlegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AMDGPUPostLegalizerCombinerHelper pass then re-enable the specified ones
    amdgpupostlegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the AMDGPUPreLegalizerCombinerHelper pass
    amdgpuprelegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AMDGPUPreLegalizerCombinerHelper pass then re-enable the specified ones
    amdgpuprelegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the AMDGPURegBankCombinerHelper pass
    amdgpuregbankcombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the AMDGPURegBankCombinerHelper pass then re-enable the specified ones
    amdgpuregbankcombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// AMDHSA Code Object Version
    amdhsa_code_object_version: ?usize = null,
    /// If true, annotate inline advisor remarks with LTO and pass information.
    annotate_inline_phase: bool = false,
    /// Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.
    annotate_sample_profile_inline_phase: bool = false,
    /// Maximum number of ptr states the optimizer keeps track of
    arc_opt_max_ptr_states: ?usize = null,
    arm_add_build_attributes: bool = false,
    /// Adjust basic block layout to better use TB[BH]
    arm_adjust_jump_tables: bool = false,
    arm_assume_itcm_bankconflict: bool = false,
    /// Be more conservative in ARM load/store opt
    arm_assume_misaligned_load_store: bool = false,
    /// Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information
    arm_atomic_cfg_tidy: bool = false,
    /// The max number of iteration for converge
    arm_constant_island_max_iteration: ?usize = null,
    arm_data_bank_mask: ?usize = null,
    /// Disable omitting 'dls lr, lr' instructions
    arm_disable_omit_dls: bool = false,
    /// Enable merging Loop End and Dec instructions.
    arm_enable_merge_loopenddec: bool = false,
    arm_enable_subreg_liveness: bool = false,
    arm_force_fast_isel: bool = false,
    /// Enable the global merge pass
    arm_global_merge: bool = false,
    /// Allow conditional instructions outdside of an IT block
    arm_implicit_it: ?enum(u2) {
        always = 0,
        never = 1,
        arm = 2,
        thumb = 3,
    } = null,
    /// Enable / disable ARM interworking (for debugging only)
    arm_interworking: bool = false,
    /// Enable ARM load/store optimization pass
    arm_load_store_opt: bool = false,
    /// Disable tail-predication in the ARM LowOverheadLoop pass
    arm_loloops_disable_tailpred: bool = false,
    /// Control conversion of memcpy to Tail predicated loops (WLSTP)
    arm_memtransfer_tploop: ?enum(u2) {
        @"force-disabled" = 0,
        @"force-enabled" = 1,
        allow = 2,
    } = null,
    /// Limit the number of loads analysed
    arm_parallel_dsp_load_limit: ?usize = null,
    arm_prera_ldst_opt_reorder_limit: ?usize = null,
    /// Enable / disable promotion of unnamed_addr constants into constant pools
    arm_promote_constant: bool = false,
    /// Maximum size of constant to promote into a constant pool
    arm_promote_constant_max_size: ?usize = null,
    /// Maximum size of ALL constants to promote into a constant pool
    arm_promote_constant_max_total: ?usize = null,
    /// Generate any type of IT block
    arm_default_it: bool = false,
    /// Disallow complex IT blocks
    arm_restrict_it: bool = false,
    /// Enable setting lr as a predicate in tail predication regions.
    arm_set_lr_predicate: bool = false,
    /// Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions
    arm_synthesize_thumb_1_tbb: bool = false,
    arm_use_mulops: bool = false,
    /// As secure log file name
    as_secure_log_file: ?[]const u8 = null,
    /// use instrumentation with slow path for all accesses
    asan_always_slow_path: bool = false,
    /// Sets the ASan constructor kind
    asan_constructor_kind: ?enum(u1) {
        none = 0,
        global = 1,
    } = null,
    /// debug
    asan_debug: ?usize = null,
    /// Debug func
    asan_debug_func: ?[]const u8 = null,
    /// Debug max inst
    asan_debug_max: ?usize = null,
    /// Debug min inst
    asan_debug_min: ?usize = null,
    /// debug stack
    asan_debug_stack: ?usize = null,
    /// Sets the ASan destructor kind. The default is to use the value provided to the pass constructor
    asan_destructor_kind: ?enum(u1) {
        none = 0,
        global = 1,
    } = null,
    /// Instrument <, <=, >, >= with pointer operands
    asan_detect_invalid_pointer_cmp: bool = false,
    /// Instrument <, <=, >, >=, - with pointer operands
    asan_detect_invalid_pointer_pair: bool = false,
    /// Instrument - operations with pointer operands
    asan_detect_invalid_pointer_sub: bool = false,
    /// Load shadow address into a local variable for each function
    asan_force_dynamic_shadow: bool = false,
    /// Force optimization experiment (for testing)
    asan_force_experiment: ?usize = null,
    /// Handle global objects
    asan_globals: bool = false,
    /// Use linker features to support dead code stripping of globals
    asan_globals_live_support: bool = false,
    /// Guard against compiler/runtime version mismatch.
    asan_guard_against_version_mismatch: bool = false,
    /// Handle C++ initializer order
    asan_initialization_order: bool = false,
    /// instrument atomic instructions (rmw, cmpxchg)
    asan_instrument_atomics: bool = false,
    /// instrument byval call arguments
    asan_instrument_byval: bool = false,
    /// instrument dynamic allocas
    asan_instrument_dynamic_allocas: bool = false,
    /// instrument read instructions
    asan_instrument_reads: bool = false,
    /// instrument write instructions
    asan_instrument_writes: bool = false,
    /// If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).
    asan_instrumentation_with_call_threshold: ?usize = null,
    /// Enable KernelAddressSanitizer instrumentation
    asan_kernel: bool = false,
    /// Use prefix for memory intrinsics in KASAN mode
    asan_kernel_mem_intrinsic_prefix: bool = false,
    /// offset of asan shadow mapping [EXPERIMENTAL]
    asan_mapping_offset: ?usize = null,
    /// scale of asan shadow mapping
    asan_mapping_scale: ?usize = null,
    /// Inline shadow poisoning for blocks up to the given size in bytes.
    asan_max_inline_poisoning_size: ?usize = null,
    /// maximal number of instructions to instrument in any given BB
    asan_max_ins_per_bb: ?usize = null,
    /// Prefix for memory access callbacks
    asan_memory_access_callback_prefix: ?[]const u8 = null,
    /// Optimize instrumentation
    asan_opt: bool = false,
    /// Don't instrument scalar globals
    asan_opt_globals: bool = false,
    /// Instrument the same temp just once
    asan_opt_same_temp: bool = false,
    /// Don't instrument scalar stack variables
    asan_opt_stack: bool = false,
    /// Optimize callbacks
    asan_optimize_callbacks: bool = false,
    /// Realign stack to the value of this flag (power of two)
    asan_realign_stack: ?usize = null,
    /// Enable recovery mode (continue-after-error).
    asan_recover: bool = false,
    /// Create redzones for byval arguments (extra copy required)
    asan_redzone_byval_args: bool = false,
    /// Do not instrument promotable allocas
    asan_skip_promotable_allocas: bool = false,
    /// Handle stack memory
    asan_stack: bool = false,
    /// Use dynamic alloca to represent stack variables
    asan_stack_dynamic_alloca: bool = false,
    /// Sets the mode of detection for stack-use-after-return.
    asan_use_after_return: ?enum(u2) {
        never = 0,
        runtime = 1,
        always = 2,
    } = null,
    /// Check stack-use-after-scope
    asan_use_after_scope: bool = false,
    /// Use odr indicators to improve ODR reporting
    asan_use_odr_indicator: bool = false,
    /// Use private aliases for global variables
    asan_use_private_alias: bool = false,
    /// Use Stack Safety analysis results
    asan_use_stack_safety: bool = false,
    /// Place ASan constructors in comdat sections
    asan_with_comdat: bool = false,
    /// Access dynamic shadow through an ifunc global on platforms that support this
    asan_with_ifunc: bool = false,
    /// Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.
    asan_with_ifunc_suppress_remat: bool = false,
    /// The maximum nesting depth allowed for assembly macros.
    asm_macro_max_nesting_depth: ?usize = null,
    /// Emit internal instruction representation to assembly file
    asm_show_inst: bool = false,
    /// Add comments to directives.
    asm_verbose: bool = false,
    /// enable preservation of all attrbitues. even those that are unlikely to be usefull
    assume_preserve_all: bool = false,
    /// Do counter update using atomic fetch add  for promoted counters only
    atomic_counter_update_promoted: bool = false,
    /// Use atomic fetch add for first counter in a function (usually the entry counter)
    atomic_first_counter: bool = false,
    /// Allow the Attributor to use IP information derived from non-exact functions via cloning
    attributor_allow_deep_wrappers: bool = false,
    /// Allow the Attributor to create shallow wrappers for non-exact definitions.
    attributor_allow_shallow_wrappers: bool = false,
    /// Annotate call sites of function declarations.
    attributor_annotate_decl_cs: bool = false,
    /// The prefix used for the CallGraph dot file names.
    attributor_depgraph_dot_filename_prefix: ?[]const u8 = null,
    /// Dump the dependency graph to dot files.
    attributor_dump_dep_graph: bool = false,
    /// Enable the attributor inter-procedural deduction pass
    attributor_enable: ?enum(u2) {
        all = 0,
        module = 1,
        cgscc = 2,
        none = 3,
    } = null,
    /// Allow the Attributor to do call site specific analysis
    attributor_enable_call_site_specific_deduction: bool = false,
    /// Manifest Attributor internal string attributes.
    attributor_manifest_internal: bool = false,
    /// Maximal number of chained initializations (to avoid stack overflows)
    attributor_max_initialization_chain_length: ?usize = null,
    /// Maximal number of fixpoint iterations.
    attributor_max_iterations: ?usize = null,
    /// Verify that max-iterations is a tight bound for a fixpoint
    attributor_max_iterations_verify: bool = false,
    /// Maximum number of potential values to be tracked for each position.
    attributor_max_potential_values: ?usize = null,
    /// Maximum number of iterations we keep dismantling potential values.
    attributor_max_potential_values_iterations: ?usize = null,
    /// Print Attributor's internal call graph
    attributor_print_call_graph: bool = false,
    /// Print attribute dependencies
    attributor_print_dep: bool = false,
    /// Try to simplify all loads.
    attributor_simplify_all_loads: bool = false,
    /// View the dependency graph.
    attributor_view_dep_graph: bool = false,
    /// Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
    available_load_scan_limit: ?usize = null,
    /// MachineLICM should avoid speculation
    avoid_speculation: bool = false,
    basic_aa_recphi: bool = false,
    basic_aa_separate_storage: bool = false,
    /// The text prefix to use for cold basic block clusters
    bbsections_cold_text_prefix: ?[]const u8 = null,
    /// This checks if there is a fdo instr. profile hash mismatch for this function
    bbsections_detect_source_drift: bool = false,
    /// Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles.
    bbsections_guided_section_prefix: bool = false,
    /// Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support
    binutils_version: ?[]const u8 = null,
    /// The threshold (unit M) for flushing LLVM bitcode.
    bitcode_flush_threshold: ?usize = null,
    /// Number of metadatas above which we emit an index to enable lazy-loading
    bitcode_mdindex_threshold: ?usize = null,
    /// Do not hoist instructions if targetblock is N times hotter than the source.
    block_freq_ratio_threshold: ?usize = null,
    /// Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.
    block_placement_exit_block_bias: ?usize = null,
    /// Control the number of bonus instructions (default = 1)
    bonus_inst_threshold: ?usize = null,
    /// Use one trap block per function
    bounds_checking_single_trap: bool = false,
    /// BPF: Disable Avoiding Speculative Code Motion.
    bpf_disable_avoid_speculation: bool = false,
    /// BPF: Disable Serializing ICMP insns.
    bpf_disable_serialize_icmp: bool = false,
    /// Expand memcpy into load/store pairs in order
    bpf_expand_memcpy_in_order: bool = false,
    /// Perform branch folding during placement. Reduces code size.
    branch_fold_placement: bool = false,
    /// branch relax asm
    branch_relax_asm_large: bool = false,
    /// safety buffer size
    branch_relax_safety_buffer: ?usize = null,
    /// Break post-RA scheduling anti-dependencies: "critical", "all", or "none"
    break_anti_dependencies: ?[]const u8 = null,
    /// Use this to override the target cache line size when specified by the user.
    cache_line_size: ?usize = null,
    /// The prefix used for the CallGraph dot file names.
    callgraph_dot_filename_prefix: ?[]const u8 = null,
    /// Show heat colors in call-graph
    callgraph_heat_colors: bool = false,
    /// Show call-multigraph (do not remove parallel edges)
    callgraph_multigraph: bool = false,
    /// Show edges labeled with weights
    callgraph_show_weights: bool = false,
    /// Only allow instructions before a call, if their cost is below DuplicationThreshold
    callsite_splitting_duplication_threshold: ?usize = null,
    /// Function number to canonicalize.
    canon_nth_function: ?usize = null,
    /// Enables canonicalization of signed relational predicates to unsigned (e.g. sgt => ugt)
    canonicalize_icmp_predicates_to_unsigned: bool = false,
    /// Maximal number of uses to explore.
    capture_tracking_max_uses_to_explore: ?usize = null,
    /// The prefix used for the CFG dot file names.
    cfg_dot_filename_prefix: ?[]const u8 = null,
    /// The name of a function (or its substring) whose CFG is viewed/printed.
    cfg_func_name: ?[]const u8 = null,
    /// Show heat colors in CFG
    cfg_heat_colors: bool = false,
    /// Hide blocks with relative frequency below the given value
    cfg_hide_cold_paths: ?usize = null,
    cfg_hide_deoptimize_paths: bool = false,
    cfg_hide_unreachable_paths: bool = false,
    /// Use raw weights for labels. Use percentages as default.
    cfg_raw_weights: bool = false,
    /// Show edges labeled with weights
    cfg_weights: bool = false,
    /// Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio
    cgp_freq_ratio_to_skip_merge: ?usize = null,
    /// Enable ICMP_EQ to ICMP_S(L|G)T conversion.
    cgp_icmp_eq2icmp_st: bool = false,
    /// Enable converting phi types in CodeGenPrepare
    cgp_optimize_phi_types: bool = false,
    /// Enable splitting large offset of GEP.
    cgp_split_large_offset_gep: bool = false,
    /// Enable merging of redundant sexts when one is dominating the other.
    cgp_type_promotion_merge: bool = false,
    /// Enable BFI update verification for CodeGenPrepare.
    cgp_verify_bfi_updates: bool = false,
    /// Least BB number of huge function.
    cgpp_huge_func: ?usize = null,
    /// Optimization remarks file containing inline remarks to be replayed by cgscc inlining.
    cgscc_inline_replay: bool = false,
    /// How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay
    cgscc_inline_replay_fallback: ?enum(u2) {
        Original = 0,
        AlwaysInline = 1,
        NeverInline = 2,
    } = null,
    /// How cgscc inline replay file is formatted
    cgscc_inline_replay_format: ?enum(u2) {
        Line = 0,
        LineColumn = 1,
        LineDiscriminator = 2,
        LineColumnDiscriminator = 3,
    } = null,
    /// Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.
    cgscc_inline_replay_scope: ?enum(u1) {
        Function = 0,
        Module = 1,
    } = null,
    /// Check if block frequency is queried for an unknown block for debugging missed BFI updates
    check_bfi_unknown_block_queries: bool = false,
    check_early_avail: bool = false,
    /// CHR considers a branch bias greater than this ratio as biased
    chr_bias_threshold: ?usize = null,
    /// Max number of duplications by CHR for a region
    chr_dup_threshold: ?usize = null,
    /// Specify file to retrieve the list of functions to apply CHR to
    chr_function_list: ?[]const u8 = null,
    /// CHR merges a group of N branches/selects where N >= this value
    chr_merge_threshold: ?usize = null,
    /// Specify file to retrieve the list of modules to apply CHR to
    chr_module_list: ?[]const u8 = null,
    /// Choose code model
    code_model: ?enum(u3) {
        tiny = 0,
        small = 1,
        kernel = 2,
        medium = 3,
        large = 4,
    } = null,
    /// Minimum BranchProbability to consider a region cold.
    cold_branch_ratio: ?usize = null,
    /// Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
    cold_callsite_rel_freq: ?usize = null,
    /// Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.
    cold_operand_max_cost_multiplier: ?usize = null,
    /// Maximum frequency of path for an operand to be considered cold.
    cold_operand_threshold: ?usize = null,
    /// Initial synthetic entry count for cold functions.
    cold_synthetic_count: ?usize = null,
    /// Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
    coldcc_rel_freq: ?usize = null,
    /// Use colors in output (default=autodetect)
    color: bool = false,
    /// Enable DAG combiner's use of IR alias analysis
    combiner_global_alias_analysis: bool = false,
    /// DAG combiner enable reducing the width of load/op/store sequence
    combiner_reduce_load_op_store_width: bool = false,
    /// DAG combiner enable load/<replace bytes>/store with a narrower store
    combiner_shrink_load_replace_store_with_store: bool = false,
    /// DAG combiner may split indexing from loads
    combiner_split_load_index: bool = false,
    /// Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check
    combiner_store_merge_dependence_limit: ?usize = null,
    /// DAG combiner enable merging multiple stores into a wider store
    combiner_store_merging: bool = false,
    /// Bypass the profitability model of load slicing
    combiner_stress_load_slicing: bool = false,
    /// Limit the number of operands to inline for Token Factors
    combiner_tokenfactor_inline_limit: ?usize = null,
    /// Enable DAG combiner's use of TBAA
    combiner_use_tbaa: bool = false,
    /// Enable merging extends and rounds into FCOPYSIGN on vector types
    combiner_vector_fcopysign_extend_round: bool = false,
    commgep_const: bool = false,
    commgep_inv: bool = false,
    commgep_speculate: bool = false,
    /// Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.
    compile_time_mem_idiom_threshold: ?usize = null,
    /// Run everything twice, re-using the same pass manager and verify the result is the same.
    compile_twice: bool = false,
    /// Compute dead symbols
    compute_dead: bool = false,
    /// Try hoisting constant gep expressions
    consthoist_gep: bool = false,
    /// Do not rebase if number of dependent constants of a Base is less than this number.
    consthoist_min_num_to_rebase: ?usize = null,
    /// Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
    consthoist_with_block_frequency: bool = false,
    /// Maximum number of rows to keep in constraint system
    constraint_elimination_max_rows: ?usize = null,
    /// Target cost kind
    cost_kind: ?enum(u2) {
        throughput = 0,
        latency = 1,
        @"code-size" = 2,
        @"size-latency" = 3,
    } = null,
    /// Recognize reduction patterns.
    costmodel_reduxcost: bool = false,
    /// Directory for crash diagnostic files.
    crash_diagnostics_dir: ?[]const u8 = null,
    /// Causes the backend to crash instead of generating a nop VSX copy
    crash_on_ppc_vsx_self_copy: bool = false,
    /// Perform context sensitive PGO instrumentation
    cs_profile_generate: bool = false,
    /// Context sensitive profile file path
    cs_profile_path: ?[]const u8 = null,
    /// Threshold for the size of CSUses
    csuses_threshold: ?usize = null,
    /// The maximum number of functions to track per lattice value
    cvp_max_functions_per_value: ?usize = null,
    /// Try to delinearize array references.
    da_delinearize: bool = false,
    /// Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.
    da_disable_delinearization_checks: bool = false,
    /// Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.
    da_miv_max_level_threshold: ?usize = null,
    /// Display more information when dumping selection DAG nodes.
    dag_dump_verbose: bool = false,
    /// The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.
    dag_maps_huge_region: ?usize = null,
    /// A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.
    dag_maps_reduction_size: ?usize = null,
    /// Emit data into separate sections
    data_sections: bool = false,
    /// Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands
    dataflow_edge_limit: ?usize = null,
    /// Create pi-block nodes.
    ddg_pi_blocks: bool = false,
    /// Simplify DDG by merging nodes that have less interesting edges.
    ddg_simplify: bool = false,
    /// Maximum num basic blocks before debug info dropped
    debug_ata_max_blocks: ?usize = null,
    /// Comma separated list of debug counter skip and count
    debug_counter: bool = false,
    /// Enable debug info for the debug entry values.
    debug_entry_values: bool = false,
    /// Use debug info to correlate profiles.
    debug_info_correlate: bool = false,
    /// Print legacy PassManager debugging information
    debug_pass: ?enum(u3) {
        Disabled = 0,
        Arguments = 1,
        Structure = 2,
        Executions = 3,
        Details = 4,
    } = null,
    /// Tune debug info for a particular debugger
    debugger_tune: ?enum(u2) {
        gdb = 0,
        lldb = 1,
        dbx = 2,
        sce = 3,
    } = null,
    /// Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present
    debugify_and_strip_all_safe: bool = false,
    /// Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present
    debugify_check_and_strip_all_safe: bool = false,
    /// Set max number of processed functions per pass.
    debugify_func_limit: ?usize = null,
    /// Kind of debug info to add
    debugify_level: ?enum(u1) {
        locations = 0,
        @"location+variables" = 1,
    } = null,
    /// Suppress verbose debugify output
    debugify_quiet: bool = false,
    default_gcov_version: ?[]const u8 = null,
    /// Use this to specify the default trip count of a loop
    default_trip_count: ?usize = null,
    /// Demote catchswitch BBs only (for wasm EH)
    demote_catchswitch_only: bool = false,
    /// Select which denormal numbers the code is permitted to require
    denormal_fp_math: ?enum(u2) {
        ieee = 0,
        @"preserve-sign" = 1,
        @"positive-zero" = 2,
    } = null,
    /// Select which denormal numbers the code is permitted to require for float
    denormal_fp_math_f32: ?enum(u2) {
        ieee = 0,
        @"preserve-sign" = 1,
        @"positive-zero" = 2,
    } = null,
    /// Maximum cost accepted for the transformation
    dfa_cost_threshold: ?usize = null,
    /// Use the DFA based hazard recognizer.
    dfa_hazard_rec: bool = false,
    /// If present, stops packetizing after N instructions
    dfa_instr_limit: ?usize = null,
    /// View the CFG before DFA Jump Threading
    dfa_jump_view_cfg_before: bool = false,
    /// Max number of paths enumerated around a switch
    dfa_max_num_paths: ?usize = null,
    /// Max number of blocks searched to find a threading path
    dfa_max_path_length: ?usize = null,
    /// Track reg pressure and switch priority to in-depth
    dfa_sched_reg_pressure_threshold: ?usize = null,
    /// File listing native ABI functions and how the pass treats them
    dfsan_abilist: ?[]const u8 = null,
    /// Combine the label of the offset with the label of the pointer when doing pointer arithmetic.
    dfsan_combine_offset_labels_on_gep: bool = false,
    /// Combine the label of the pointer with the label of the data when loading from memory.
    dfsan_combine_pointer_labels_on_load: bool = false,
    /// Combine the label of the pointer with the label of the data when storing in memory.
    dfsan_combine_pointer_labels_on_store: bool = false,
    /// When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).
    dfsan_combine_taint_lookup_table: ?[]const u8 = null,
    /// Insert calls to callback functions on conditionals.
    dfsan_conditional_callbacks: bool = false,
    /// Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label
    dfsan_debug_nonzero_labels: bool = false,
    /// Insert calls to __dfsan_*_callback functions on data events.
    dfsan_event_callbacks: bool = false,
    /// If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.
    dfsan_ignore_personality_routine: bool = false,
    /// If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).
    dfsan_instrument_with_call_threshold: ?usize = null,
    /// respect alignment requirements provided by input IR
    dfsan_preserve_alignment: bool = false,
    /// Insert calls to callback functions on data reaching a function.
    dfsan_reaches_function_callbacks: bool = false,
    /// Track origins of labels
    dfsan_track_origins: ?usize = null,
    /// Propagate labels from condition values of select instructions to results.
    dfsan_track_select_control_flow: bool = false,
    /// Disable scheduler's two-address hack
    disable_2addr_hack: bool = false,
    /// Inhibit optimization of S->D register accesses on A15
    disable_a15_sd_optimization: bool = false,
    /// Disable advanced copy optimization
    disable_adv_copy_opt: bool = false,
    /// Disable advance peeling. Issues for convergent targets (D134803).
    disable_advanced_peeling: bool = false,
    /// Disable the generation of low-overhead loops
    disable_arm_loloops: bool = false,
    /// Disable the ARM Parallel DSP pass
    disable_arm_parallel_dsp: bool = false,
    /// disable automatically generated 32byte paired vector stores
    disable_auto_paired_vec_st: bool = false,
    disable_basic_aa: bool = false,
    /// Disable binop extract to shuffle transforms
    disable_binop_extract_shuffle: bool = false,
    /// Disable automatic bitcode upgrade for version mismatch
    disable_bitcode_version_upgrade: bool = false,
    /// Disable probability-driven block placement
    disable_block_placement: bool = false,
    /// Disable machine peepholes for BPF
    disable_bpf_peephole: bool = false,
    /// Disable branch folding
    disable_branch_fold: bool = false,
    /// Disable the CFI fixup pass
    disable_cfi_fixup: bool = false,
    /// Disable Codegen Prepare
    disable_cgp: bool = false,
    /// Disable branch optimizations in CodeGenPrepare
    disable_cgp_branch_opts: bool = false,
    /// Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare
    disable_cgp_ext_ld_promotion: bool = false,
    /// Disable GC optimizations in CodeGenPrepare
    disable_cgp_gc_opts: bool = false,
    /// Disable select to branch conversion.
    disable_cgp_select2branch: bool = false,
    /// Disable store(extract) optimizations in CodeGenPrepare
    disable_cgp_store_extract: bool = false,
    disable_check_noreturn_call: bool = false,
    /// Disable CHR for all functions
    disable_chr: bool = false,
    /// Do not remove implausible terminators or other similar cleanups
    disable_cleanups: bool = false,
    /// Disables combining addressing modes with different parts in optimizeMemoryInst.
    disable_complex_addr_modes: bool = false,
    /// Disable generation of const64
    disable_const64: bool = false,
    /// Disable ConstantHoisting
    disable_constant_hoisting: bool = false,
    /// Disable Copy Propagation pass
    disable_copyprop: bool = false,
    /// Disable debug info printing
    disable_debug_info_print: bool = false,
    /// Clone multicolor basic blocks but do not demote cross scopes
    disable_demotion: bool = false,
    /// Disable use of DFA during scheduling
    disable_dfa_sched: bool = false,
    /// Disable Early If-conversion
    disable_early_ifcvt: bool = false,
    /// Disable pre-register allocation tail duplication
    disable_early_taildup: bool = false,
    /// Disable the expand reduction intrinsics pass from running
    disable_expand_reductions: bool = false,
    /// Disables evaluation of GetElementPtr with constant operands
    disable_gep_const_evaluation: bool = false,
    /// Don't verify that MIR is fully legal between GlobalISel passes
    disable_gisel_legality_check: bool = false,
    /// Disable Hexagon constant propagation
    disable_hcp: bool = false,
    /// Disable Hexagon Addressing Mode Optimization
    disable_hexagon_amodeopt: bool = false,
    /// Disable Hexagon CFG Optimization
    disable_hexagon_cfgopt: bool = false,
    /// Disable Dealloc Return for Hexagon target
    disable_hexagon_dealloc_ret: bool = false,
    /// Disable Hardware Loops for Hexagon target
    disable_hexagon_hwloops: bool = false,
    /// Disable Hexagon MI Scheduling
    disable_hexagon_misched: bool = false,
    /// Disable schedule adjustment for new value stores.
    disable_hexagon_nv_schedule: bool = false,
    /// Disable Optimization of extensions to i64.
    disable_hexagon_opt_ext_to_64: bool = false,
    /// Disable Optimization of Sign/Zero Extends
    disable_hexagon_optszext: bool = false,
    /// Disable Peephole Optimization
    disable_hexagon_peephole: bool = false,
    /// Disable Optimization of PNotP
    disable_hexagon_pnotp: bool = false,
    /// Disable Hexagon instruction shuffling
    disable_hexagon_shuffle: bool = false,
    /// Enable Hexagon-specific memcpy for volatile destination.
    disable_hexagon_volatile_memcpy: bool = false,
    /// Disable hoisting instructions to hotter blocks
    disable_hoisting_to_hotter_blocks: ?enum(u2) {
        none = 0,
        pgo = 1,
        all = 2,
    } = null,
    /// Disable splitting double registers
    disable_hsdr: bool = false,
    /// Disables inttoptr/ptrtoint roundtrip optimization
    disable_i2p_p2i_opt: bool = false,
    /// Disable indirect call promotion
    disable_icp: bool = false,
    disable_ifcvt_diamond: bool = false,
    disable_ifcvt_forked_diamond: bool = false,
    disable_ifcvt_simple: bool = false,
    disable_ifcvt_simple_false: bool = false,
    disable_ifcvt_triangle: bool = false,
    disable_ifcvt_triangle_false: bool = false,
    disable_ifcvt_triangle_false_rev: bool = false,
    disable_ifcvt_triangle_rev: bool = false,
    disable_inlined_alloca_merging: bool = false,
    /// Disable combining of interleaved loads
    disable_interleaved_load_combine: bool = false,
    /// Do not combine ALU and memory operators
    disable_lanai_mem_alu_combiner: bool = false,
    /// Disable MIRProfileLoader before BlockPlacement
    disable_layout_fsprofile_loader: bool = false,
    /// Disable Linear Function Test Replace optimization
    disable_lftr: bool = false,
    /// Disable memory promotion in LICM pass
    disable_licm_promotion: bool = false,
    /// Disable loop-level heuristics.
    disable_loop_level_heuristics: bool = false,
    /// Disable Loop Strength Reduction Pass
    disable_lsr: bool = false,
    /// Disable Machine Common Subexpression Elimination
    disable_machine_cse: bool = false,
    /// Disable Machine Dead Code Elimination
    disable_machine_dce: bool = false,
    /// Disable Machine LICM
    disable_machine_licm: bool = false,
    /// Disable Machine Sinking
    disable_machine_sink: bool = false,
    /// Disable generation of memcpy in loop idiom recognition
    disable_memcpy_idiom: bool = false,
    /// Disable generation of memmove in loop idiom recognition
    disable_memmove_idiom: bool = false,
    /// Disable optimize
    disable_memop_opt: bool = false,
    /// Disable merging into combines
    disable_merge_into_combines: bool = false,
    /// Disable MergeICmps Pass
    disable_mergeicmps: bool = false,
    /// Fill all delay slots with NOPs.
    disable_mips_delay_filler: bool = false,
    /// Disallow MIPS delay filler to search backward.
    disable_mips_df_backward_search: bool = false,
    /// Disallow MIPS delay filler to search forward.
    disable_mips_df_forward_search: bool = false,
    /// Disallow MIPS delay filler to search successor basic blocks.
    disable_mips_df_succbb_search: bool = false,
    /// Disable multi-region partial inlining
    disable_mr_partial_inlining: bool = false,
    /// Stop inferring nofree attribute during function-attrs pass
    disable_nofree_inference: bool = false,
    /// Disable non-allocatable physical register copy optimization
    disable_non_allocatable_phys_copy_opt: bool = false,
    /// Stop inferring nounwind attribute during function-attrs pass
    disable_nounwind_inference: bool = false,
    /// Disable New Value Jumps
    disable_nvjump: bool = false,
    /// Disable load/store vectorizer
    disable_nvptx_load_store_vectorizer: bool = false,
    /// Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen.
    disable_nvptx_require_structured_cfg: bool = false,
    /// Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
    disable_ondemand_mds_loading: bool = false,
    /// Disable Hexagon packetizer pass
    disable_packetizer: bool = false,
    /// Disable partial inlining
    disable_partial_inlining: bool = false,
    /// Disable Partial Libcall Inlining
    disable_partial_libcall_inlining: bool = false,
    /// Disable the peephole optimizer
    disable_peephole: bool = false,
    /// Disable critical edge splitting during PHI elimination
    disable_phi_elim_edge_splitting: bool = false,
    /// Disable Post Regalloc Scheduler
    disable_post_ra: bool = false,
    /// Disable Machine LICM
    disable_postra_machine_licm: bool = false,
    /// Disable PostRA Machine Sinking
    disable_postra_machine_sink: bool = false,
    /// Disable compare instruction optimization
    disable_ppc_cmp_opt: bool = false,
    /// disable constant hoisting on PPC
    disable_ppc_constant_hoisting: bool = false,
    /// Disable analysis for CTR loops
    disable_ppc_ctrloop_analysis: bool = false,
    /// Disable CTR loops for PPC
    disable_ppc_ctrloops: bool = false,
    /// disable setting the node scheduling preference to ILP on PPC
    disable_ppc_ilp_pref: bool = false,
    /// don't always align innermost loop to 32 bytes on ppc
    disable_ppc_innermost_loop_align32: bool = false,
    /// Disable PPC loop instr form prep
    disable_ppc_instr_form_prep: bool = false,
    /// Disable machine peepholes for PPC
    disable_ppc_peephole: bool = false,
    /// disable preincrement load/store generation on PPC
    disable_ppc_preinc: bool = false,
    /// Disable scheduling addi instruction beforeload for ppc
    disable_ppc_sched_addi_load: bool = false,
    /// disable sibling call optimization on ppc
    disable_ppc_sco: bool = false,
    /// disable unaligned load/store generation on PPC
    disable_ppc_unaligned: bool = false,
    /// Disable VSX FMA instruction mutation
    disable_ppc_vsx_fma_mutation: bool = false,
    /// Disable VSX Swap Removal for PPC
    disable_ppc_vsx_swap_removal: bool = false,
    /// Disable protection against removing loop preheaders
    disable_preheader_prot: bool = false,
    /// Disable pre-instrumentation inliner
    disable_preinline: bool = false,
    /// Disable promote alloca to LDS
    disable_promote_alloca_to_lds: bool = false,
    /// Disable promote alloca to vector
    disable_promote_alloca_to_vector: bool = false,
    /// Disable MIRProfileLoader before RegAlloc
    disable_ra_fsprofile_loader: bool = false,
    /// If true, artifically skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).
    disable_sample_loader_inlining: bool = false,
    /// Disable critical path priority in sched=list-ilp
    disable_sched_critical_path: bool = false,
    /// Disable cycle-level precision during preRA scheduling
    disable_sched_cycles: bool = false,
    /// Disable hazard detection during preRA scheduling
    disable_sched_hazard: bool = false,
    /// Disable scheduled-height priority in sched=list-ilp
    disable_sched_height: bool = false,
    /// Disable live use priority in sched=list-ilp
    disable_sched_live_uses: bool = false,
    /// Disable physreg def-use affinity
    disable_sched_physreg_join: bool = false,
    /// Disable regpressure priority in sched=list-ilp
    disable_sched_reg_pressure: bool = false,
    /// Disable no-stall priority in sched=list-ilp
    disable_sched_stalls: bool = false,
    /// Disable virtual register cycle interference checks
    disable_sched_vrcycle: bool = false,
    /// Disable the select-optimization pass from running
    disable_select_optimize: bool = false,
    /// Do not separate the constant offset from a GEP instruction
    disable_separate_const_offset_from_gep: bool = false,
    /// Disable isel of shifter-op
    disable_shifter_op: bool = false,
    /// Disable simplify-libcalls
    disable_simplify_libcalls: bool = false,
    /// Disable the Sparc delay slot filler.
    disable_sparc_delay_filler: bool = false,
    /// Disable Sparc leaf procedure optimization.
    disable_sparc_leaf_proc: bool = false,
    /// Disable fusing of spill code into instructions
    disable_spill_fusing: bool = false,
    /// Disable inline spill hoisting
    disable_spill_hoist: bool = false,
    /// Disable Stack Slot Coloring
    disable_ssc: bool = false,
    /// Disable store widening
    disable_store_widen: bool = false,
    /// Don't mutate strict-float node to a legalize node
    disable_strictnode_mutation: bool = false,
    /// Disable symbolizing crash backtraces.
    disable_symbolication: bool = false,
    /// Never emit tail calls
    disable_tail_calls: bool = false,
    /// Disable tail duplication
    disable_tail_duplicate: bool = false,
    /// Don't propagate function-attrs in thinLTO
    disable_thinlto_funcattrs: bool = false,
    /// Disable type promotion pass
    disable_type_promotion: bool = false,
    /// Disable vector double new-value-stores
    disable_vecdbl_nv_stores: bool = false,
    /// Disable all vector combine transforms
    disable_vector_combine: bool = false,
    /// Do not verify input module
    disable_verify: bool = false,
    /// Disable Value Profiling
    disable_vp: bool = false,
    /// WebAssembly: Disable fallthrough-return optimizations.
    disable_wasm_fallthrough_return_opt: bool = false,
    /// Disable whole program visibility (overrides enabling options)
    disable_whole_program_visibility: bool = false,
    /// X86: Disable Virtual Register Reassignment.
    disable_x86_domain_reassignment: bool = false,
    /// X86: Disable LEA optimizations.
    disable_x86_lea_opt: bool = false,
    /// Discard names from Value (other than GlobalValue).
    discard_value_names: bool = false,
    /// Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner
    do_comdat_renaming: bool = false,
    /// Do counter register promotion
    do_counter_promotion: bool = false,
    dom_conditions_max_uses: ?usize = null,
    /// Max number of BBs to explore for reachability analysis
    dom_tree_reachability_max_bbs_to_explore: ?usize = null,
    /// Color for dot-cfg after elements
    dot_cfg_after_color: ?[]const u8 = null,
    /// Color for dot-cfg before elements
    dot_cfg_before_color: ?[]const u8 = null,
    /// Color for dot-cfg common elements
    dot_cfg_common_color: ?[]const u8 = null,
    /// Generate dot files into specified directory for changed IRs
    dot_cfg_dir: ?[]const u8 = null,
    /// The prefix used for the DDG dot file names.
    dot_ddg_filename_prefix: ?[]const u8 = null,
    /// simple ddg dot graph
    dot_ddg_only: bool = false,
    /// Print only the CFG without blocks body
    dot_mcfg_only: bool = false,
    /// The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)
    dse_memoryssa_defs_per_block_limit: ?usize = null,
    /// The cost of a step in a different basic block than the killing MemoryDef(default = 5)
    dse_memoryssa_otherbb_cost: ?usize = null,
    /// The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)
    dse_memoryssa_partial_store_limit: ?usize = null,
    /// The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)
    dse_memoryssa_path_check_limit: ?usize = null,
    /// The cost of a step in the same basic block as the killing MemoryDef(default = 1)
    dse_memoryssa_samebb_cost: ?usize = null,
    /// The number of memory instructions to scan for dead store elimination (default = 150)
    dse_memoryssa_scanlimit: ?usize = null,
    /// The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)
    dse_memoryssa_walklimit: ?usize = null,
    /// Allow DSE to optimize memory accesses.
    dse_optimize_memoryssa: bool = false,
    /// Dump the SCCs in the ThinLTO index's callgraph
    dump_thin_cg_sccs: bool = false,
    /// Use .file directives with an explicit directory
    dwarf_directory: bool = false,
    /// Disable emission of the extended flags in .loc directives.
    dwarf_extended_loc: ?enum(u2) {
        Default = 0,
        Enable = 1,
        Disable = 2,
    } = null,
    /// Use inlined strings rather than string section.
    dwarf_inlined_strings: ?enum(u2) {
        Default = 0,
        Enable = 1,
        Disable = 2,
    } = null,
    /// Which DWARF linkage-name attributes to emit.
    dwarf_linkage_names: ?enum(u2) {
        Default = 0,
        All = 1,
        Abstract = 2,
    } = null,
    /// Enable use of the DWARFv5 DW_OP_convert operator
    dwarf_op_convert: ?enum(u2) {
        Default = 0,
        Enable = 1,
        Disable = 2,
    } = null,
    /// Use sections+offset as references rather than labels.
    dwarf_sections_as_references: ?enum(u2) {
        Default = 0,
        Enable = 1,
        Disable = 2,
    } = null,
    /// Dwarf version
    dwarf_version: ?usize = null,
    /// Generate debugging info in the 64-bit DWARF format
    dwarf64: bool = false,
    /// Eagerly invalidate more analyses in default pipelines
    eagerly_invalidate_analyses: bool = false,
    /// Maximum number of instructions per speculated block.
    early_ifcvt_limit: ?usize = null,
    /// Run live interval analysis earlier in the pipeline
    early_live_intervals: bool = false,
    /// Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate
    earlycse_debug_hash: bool = false,
    /// Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.
    earlycse_mssa_optimization_cap: ?usize = null,
    /// Size limit in Hexagon early if-conversion
    eif_limit: ?usize = null,
    /// Do not convert branches that may exit the loop
    eif_no_loop_exit: bool = false,
    /// Emit call site debug information, if debug information is enabled.
    emit_call_site_info: bool = false,
    /// Whether to emit DWARF EH frame entries.
    emit_dwarf_unwind: ?enum(u2) {
        always = 0,
        @"no-compact-unwind" = 1,
        default = 2,
    } = null,
    /// The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)
    emscripten_cxx_exceptions_allowed: ?[]const u8 = null,
    /// Act like old LiveDebugValues did
    emulate_old_livedebugvalues: bool = false,
    /// Use emulated TLS model
    emulated_tls: bool = false,
    /// Enable use of AA during MI DAG construction
    enable_aa_sched_mi: bool = false,
    /// Enable vec acc forwarding
    enable_acc_forwarding: bool = false,
    /// Enable vec alu forwarding
    enable_alu_forwarding: bool = false,
    /// Enable AMDGPU Alias Analysis
    enable_amdgpu_aa: bool = false,
    /// Enable sinkinig and/cmp into branches.
    enable_andcmp_sinking: bool = false,
    /// Enable FP math optimizations that assume approx func
    enable_approx_func_fp_math: bool = false,
    /// Enable ARM 2-addr to 3-addr conv
    enable_arm_3_addr_conv: bool = false,
    /// Enable the generation of masked gathers and scatters
    enable_arm_maskedgatscat: bool = false,
    /// Enable the generation of masked loads and stores
    enable_arm_maskedldst: bool = false,
    /// Collect probability-driven block placement stats
    enable_block_placement_stats: bool = false,
    enable_bsb_sched: bool = false,
    /// Enable control height reduction optimization (CHR)
    enable_chr: bool = false,
    /// Enable placement of extracted cold functions into a separate section after hot-cold splitting.
    enable_cold_section: bool = false,
    /// Enable stress test of coldcc by adding calling conv to all internal functions.
    enable_coldcc_stress_test: bool = false,
    /// Enable generation of complex instructions
    enable_complex_deinterleaving: bool = false,
    /// Enable if predication of stores during vectorization.
    enable_cond_stores_vec: bool = false,
    /// Enable pass to eliminate conditions based on linear constraints
    enable_constraint_elimination: bool = false,
    /// Should enable CSE in irtranslator
    enable_cse_in_irtranslator: bool = false,
    /// Should enable CSE in Legalizer
    enable_cse_in_legalizer: bool = false,
    /// Enable the scheduler to generate .cur
    enable_cur_sched: bool = false,
    /// Instead of spilling a variable right away, defer the actual code insertion to the end of the allocation. That way the allocator might still find a suitable coloring for this variable because of other evicted variables.
    enable_deferred_spilling: bool = false,
    /// Enable DFA jump threading
    enable_dfa_jump_thread: bool = false,
    /// Enable unsafe double to float shrinking for math lib calls
    enable_double_float_shrink: bool = false,
    /// Enable partial-overwrite tracking in DSE
    enable_dse_partial_overwrite_tracking: bool = false,
    /// Enable partial store merging in DSE
    enable_dse_partial_store_merging: bool = false,
    /// WebAssembly Emscripten-style exception handling
    enable_emscripten_cxx_exceptions: bool = false,
    /// WebAssembly Emscripten-style setjmp/longjmp handling
    enable_emscripten_sjlj: bool = false,
    /// Enable vectorization of epilogue loops.
    enable_epilogue_vectorization: bool = false,
    /// Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.
    enable_ext_tsp_block_placement: bool = false,
    enable_falkor_hwpf_unroll_fix: bool = false,
    enable_fixedwidth_autovec_in_streaming_mode: bool = false,
    /// Enable adding flow sensitive discriminators
    enable_fs_discriminator: bool = false,
    /// Generate all instruction with TC
    enable_gen_insn: bool = false,
    /// Enable inter-procedural analyses
    enable_global_analyses: bool = false,
    /// Enable the global merge pass
    enable_global_merge: bool = false,
    /// Enable the GVN hoisting pass (default = off)
    enable_gvn_hoist: bool = false,
    enable_gvn_memdep: bool = false,
    /// Enable the GVN sinking pass (default = off)
    enable_gvn_sink: bool = false,
    enable_heap_to_stack_conversion: bool = false,
    /// Enable branch probability info
    enable_hexagon_br_prob: bool = false,
    /// Enable Hexagon SDNode scheduling
    enable_hexagon_sdnode_sched: bool = false,
    /// Enable Hexagon Vector print instr pass
    enable_hexagon_vector_print: bool = false,
    /// Enable if-conversion during vectorization.
    enable_if_conversion: bool = false,
    /// Fold null checks into faulting memory operations
    enable_implicit_null_checks: bool = false,
    /// Enable import metadata like 'thinlto_src_module'
    enable_import_metadata: bool = false,
    /// Count the induction variable only once when interleaving
    enable_ind_var_reg_heur: bool = false,
    /// Enable vectorization on interleaved memory accesses in a loop
    enable_interleaved_mem_accesses: bool = false,
    /// Enable interprocedural register allocation to reduce load/store at procedure calls.
    enable_ipra: bool = false,
    /// Instrument functions with a call to __CheckForDebuggerJustMyCode
    enable_jmc_instrument: bool = false,
    /// enable preservation of attributes throughout code transformation
    enable_knowledge_retention: bool = false,
    enable_legalize_types_checking: bool = false,
    /// Enable the IR outliner on linkonceodr functions
    enable_linkonceodr_ir_outlining: bool = false,
    /// Enable the machine outliner on linkonceodr functions
    enable_linkonceodr_outlining: bool = false,
    enable_load_in_loop_pre: bool = false,
    enable_load_pre: bool = false,
    /// Enable runtime interleaving until load/store ports are saturated
    enable_loadstore_runtime_interleave: bool = false,
    /// Local reassignment can yield better allocation decisions, but may be compile time intensive
    enable_local_reassign: bool = false,
    /// Enable the new, experimental LoopDistribution Pass
    enable_loop_distribute: bool = false,
    /// Enable the LoopFlatten Pass
    enable_loop_flatten: bool = false,
    enable_loop_simplifycfg_term_folding: bool = false,
    /// Enable the experimental LoopInterchange Pass
    enable_loopinterchange: bool = false,
    /// Enable LSR phi elimination
    enable_lsr_phielim: bool = false,
    /// Enable global value internalization in LTO
    enable_lto_internalization: bool = false,
    /// Enable the machine outliner
    enable_machine_outliner: ?enum(u1) {
        always = 0,
        never = 1,
    } = null,
    /// Enable vectorization on masked interleaved memory accesses in a loop
    enable_masked_interleaved_mem_accesses: bool = false,
    /// Enable lowering of the matrix intrinsics
    enable_matrix: bool = false,
    /// Enable symbolic stride memory access versioning
    enable_mem_access_versioning: bool = false,
    /// Enable memory profiler
    enable_mem_prof: bool = false,
    /// Gang up loads and stores generated by inlining of memcpy
    enable_memcpy_dag_opt: bool = false,
    /// Enable memcpyopt even when libcalls are disabled
    enable_memcpyopt_without_libcalls: bool = false,
    /// Enable function merging as part of the optimization pipeline
    enable_merge_functions: bool = false,
    /// Enable the machine instruction scheduling pass.
    enable_misched: bool = false,
    /// Enable ML policy for inliner. Currently trained for -Oz only
    enable_ml_inliner: ?enum(u2) {
        default = 0,
        development = 1,
        release = 2,
    } = null,
    /// Enable module inliner
    enable_module_inliner: bool = false,
    /// Enable interleave MVE vector operation lowering
    enable_mve_interleave: bool = false,
    /// Enable name/filename string compression
    enable_name_compression: bool = false,
    /// Run the NewGVN pass
    enable_newgvn: bool = false,
    /// Enable FP math optimizations that assume no +-Infs
    enable_no_infs_fp_math: bool = false,
    /// Enable FP math optimizations that assume no NaNs
    enable_no_nans_fp_math: bool = false,
    /// Prevent running the simplification pipeline on a function more than once in the case that SCC mutations cause a function to be visited multiple times as long as the function has not been changed
    enable_no_rerun_simplification_pipeline: bool = false,
    /// Enable FP math optimizations that assume the sign of 0 is insignificant
    enable_no_signed_zeros_fp_math: bool = false,
    /// Enable setting the FP exceptions build attribute not to use exceptions
    enable_no_trapping_fp_math: bool = false,
    /// Convert noalias attributes to metadata during inlining.
    enable_noalias_to_md_conversion: bool = false,
    /// Try to propagate nonnull argument attributes from callsites to caller functions.
    enable_nonnull_arg_prop: bool = false,
    /// Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
    enable_nontrivial_unswitch: bool = false,
    /// Enable non-trivial loop unswitching for -O3
    enable_npm_O3_nontrivial_unswitch: bool = false,
    /// Enable inline deferral during PGO
    enable_npm_pgo_inline_deferral: bool = false,
    /// Run synthetic function entry count generation pass
    enable_npm_synthetic_counts: bool = false,
    /// enable/disable all ARC Optimizations
    enable_objc_arc_opts: bool = false,
    /// Enable order file instrumentation (default = off)
    enable_order_file_instrumentation: bool = false,
    /// Run Partial inlinining pass
    enable_partial_inlining: bool = false,
    /// Enable PatchPoint Liveness Analysis Pass
    enable_patchpoint_liveness: bool = false,
    enable_phi_of_ops: bool = false,
    /// Enable Software Pipelining
    enable_pipeliner: bool = false,
    /// Enable SWP at Os.
    enable_pipeliner_opt_size: bool = false,
    /// Enable the post-ra machine instruction scheduling pass.
    enable_post_misched: bool = false,
    /// Run the loop rotation transformation after PGO instrumentation
    enable_post_pgo_loop_rotation: bool = false,
    /// enable coalescing of duplicate branches for PPC
    enable_ppc_branch_coalesce: bool = false,
    /// Add extra TOC register dependencies
    enable_ppc_extra_toc_reg_deps: bool = false,
    /// Enable lowering math functions to their corresponding MASS (scalar) entries
    enable_ppc_gen_scalar_mass: bool = false,
    /// enable software prefetching on PPC
    enable_ppc_prefetching: bool = false,
    enable_pre: bool = false,
    /// Enable long calls for save-restore stubs.
    enable_save_restore_long: bool = false,
    enable_scalable_autovec_in_streaming_mode: bool = false,
    enable_scc_inline_advisor_printing: bool = false,
    enable_scoped_noalias: bool = false,
    enable_selectiondag_sp: bool = false,
    /// enable the shrink-wrapping pass
    enable_shrink_wrap: bool = false,
    /// Force codegen to assume rounding mode can change dynamically
    enable_sign_dependent_rounding_fp_math: bool = false,
    enable_split_backedge_in_load_pre: bool = false,
    /// Split out cold blocks from machine functions based on profile information.
    enable_split_machine_functions: bool = false,
    /// Enable runtime checks for stack overflow.
    enable_stackovf_sanitizer: bool = false,
    enable_store_refinement: bool = false,
    /// Enable subregister liveness tracking.
    enable_subreg_liveness: bool = false,
    enable_tail_merge: bool = false,
    enable_tbaa: bool = false,
    enable_tc_latency_sched: bool = false,
    /// Enable timing class latency
    enable_timing_class_latency: bool = false,
    /// Enable Unroll And Jam Pass
    enable_unroll_and_jam: bool = false,
    /// Enable optimizations that may decrease FP precision
    enable_unsafe_fp_math: bool = false,
    enable_unsafe_globalsmodref_alias_results: bool = false,
    /// Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.
    enable_unswitch_cost_multiplier: bool = false,
    /// Enable virtual function elimination
    enable_vfe: bool = false,
    /// Enable VPlan-native vectorization path with support for outer loop vectorization.
    enable_vplan_native_path: bool = false,
    /// X86: enable AMX scalarizition.
    enable_x86_scalar_amx: bool = false,
    /// When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.
    epilogue_vectorization_force_VF: ?usize = null,
    /// Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.
    epilogue_vectorization_minimum_VF: ?usize = null,
    /// exception model
    exception_model: ?enum(u3) {
        default = 0,
        dwarf = 1,
        sjlj = 2,
        arm = 3,
        wineh = 4,
        wasm = 5,
    } = null,
    /// exe called with module IR after each pass that changes it
    exec_on_ir_change: ?[]const u8 = null,
    /// Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring
    exhaustive_register_search: bool = false,
    expand_all_fp_mlx: bool = false,
    /// Max number of segment coalescings
    expand_condsets_coa_limit: ?usize = null,
    /// Max number of mux expansions
    expand_condsets_tfr_limit: ?usize = null,
    /// Expand constant expressions to instructions for testing purposes
    expand_constant_exprs: bool = false,
    /// div and rem instructions on integers with more than <N> bits are expanded.
    expand_div_rem_bits: ?usize = null,
    /// fp convert instructions on integers with more than <N> bits are expanded.
    expand_fp_convert_bits: ?usize = null,
    expand_limit: ?usize = null,
    /// Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).
    expandvp_override_evl_transform: ?[]const u8 = null,
    /// Options: <empty>|Legal|Discard|Convert. If non-empty, Ignore TargetTransformInfo and always use this transformation for the %mask parameter (Used in testing).
    expandvp_override_mask_transform: ?[]const u8 = null,
    /// Use experimental new value-tracking variable locations
    experimental_debug_variable_locations: bool = false,
    /// expose the ANDI glue bug on PPC
    expose_ppc_andi_glue_bug: bool = false,
    /// Whether to apply ext-tsp placement for instances w/o profile
    ext_tsp_apply_without_profile: bool = false,
    /// Run cleanup optimization passes after vectorization
    extra_vectorizer_passes: bool = false,
    /// Erase the existing functions
    extract_blocks_erase_funcs: bool = false,
    /// A file containing list of basic blocks to extract
    extract_blocks_file: ?[]const u8 = null,
    /// Cutoff for generating "extract" instructions
    extract_cutoff: ?usize = null,
    /// Require & in extract patterns
    extract_needand: bool = false,
    /// No extract instruction with offset 0
    extract_nosr0: bool = false,
    /// The threshold for fast cluster
    fast_cluster_threshold: ?usize = null,
    /// Enable the "fast" instruction selector
    fast_isel: bool = false,
    /// Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.
    fast_isel_abort: ?usize = null,
    /// Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.
    fast_isel_report_on_fallback: bool = false,
    /// Treat warnings as errors
    fatal_warnings: bool = false,
    /// Enable Fast Math processing
    ffast_math: bool = false,
    /// Choose a file type (not all types are supported by all targets):
    filetype: ?enum(u2) {
        @"asm" = 0,
        obj = 1,
        null = 2,
    } = null,
    /// Only consider IR changes for passes whose names match the specified value. No-op without -print-changed
    filter_passes: ?[]const u8 = null,
    /// Only print IR for functions whose name match this for all print-[before|after][-all] options
    filter_print_funcs: ?[]const []const u8 = null,
    /// Allow passing GC Pointer arguments in callee saved registers
    fixup_allow_gcptr_in_csr: bool = false,
    /// Change byte and word instructions to larger sizes
    fixup_byte_word_insts: bool = false,
    /// Max number of statepoints allowed to pass GC Ptrs in registers
    fixup_max_csr_statepoints: ?usize = null,
    /// Enable simple copy propagation during register reloading
    fixup_scs_enable_copy_propagation: bool = false,
    /// Allow spill in spill slot of greater size than register size
    fixup_scs_extend_slot_size: bool = false,
    /// If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
    flat_loop_tripcount_threshold: ?usize = null,
    /// Indicate the sample profile being used is flattened, i.e., no inline hierachy exists in the profile
    flattened_profile_used: bool = false,
    /// Choose float ABI type
    float_abi: ?enum(u2) {
        default = 0,
        soft = 1,
        hard = 2,
    } = null,
    /// Max integer bitwidth to consider in float2int(default=64)
    float2int_max_integer_bw: ?usize = null,
    /// Add an attribute to a function. This should be a pair of 'function-name:attribute-name', for example -force-attribute=foo:noinline. This option can be specified multiple times.
    force_attribute: ?[]const u8 = null,
    /// Apply CHR for all functions
    force_chr: bool = false,
    /// Always emit a debug frame section.
    force_dwarf_frame_section: bool = false,
    /// Switch to fast cluster algorithm with the lost of some fusion opportunities
    force_fast_cluster: bool = false,
    /// Force function specialization for every call site with a constant argument
    force_function_specialization: bool = false,
    /// Force matrix instruction fusion even if not profitable.
    force_fuse_matrix: bool = false,
    /// Force generation of loop guard intrinsic
    force_hardware_loop_guard: bool = false,
    /// Force hardware loop counter to be updated through a phi
    force_hardware_loop_phi: bool = false,
    /// Force hardware loops intrinsics to be inserted
    force_hardware_loops: bool = false,
    /// Enable auto-vectorization of floatint point types on v68.
    force_hvx_float: bool = false,
    /// Import functions with noinline attribute
    force_import_all: bool = false,
    /// Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs
    force_instr_ref_livedebugvalues: bool = false,
    /// Force all indexed operations to be legal for the GlobalISel combiner
    force_legal_indexing: bool = false,
    /// Force outlining cold blocks from loops.
    force_loop_cold_block: bool = false,
    /// MIPS: Expand all branches to long format.
    force_mips_long_branch: bool = false,
    /// Force allowance of nested hardware loops
    force_nested_hardware_loop: bool = false,
    /// Enable the vectorisation of loops with in-order (strict) FP reductions
    force_ordered_reductions: bool = false,
    /// Force the (profiled-guided) size optimizations.
    force_pgso: bool = false,
    /// Force the use of precise cost loop rotation strategy.
    force_precise_rotation_cost: bool = false,
    /// Remove an attribute from a function. This should be a pair of 'function-name:attribute-name', for example -force-remove-attribute=foo:noinline. This option can be specified multiple times.
    force_remove_attribute: ?[]const u8 = null,
    /// Force store splitting no matter what the target query says.
    force_split_store: bool = false,
    force_streaming_compatible_sve: bool = false,
    /// Force all edges in the function summary to cold
    force_summary_edges_cold: ?enum(u2) {
        none = 0,
        @"all-non-critical" = 1,
        all = 2,
    } = null,
    /// A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing.
    force_target_instruction_cost: ?usize = null,
    /// A flag that overrides the target's max interleave factor for scalar loops.
    force_target_max_scalar_interleave: ?usize = null,
    /// A flag that overrides the target's max interleave factor for vectorized loops.
    force_target_max_vector_interleave: ?usize = null,
    /// A flag that overrides the target's number of scalar registers.
    force_target_num_scalar_regs: ?usize = null,
    /// A flag that overrides the target's number of vector registers.
    force_target_num_vector_regs: ?usize = null,
    /// Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.
    force_target_supports_scalable_vectors: bool = false,
    /// Sets the vectorization interleave count. Zero is autoselect.
    force_vector_interleave: ?usize = null,
    /// Sets the SIMD width. Zero is autoselect.
    force_vector_width: ?usize = null,
    /// Override cost based safe divisor widening for div/rem instructions
    force_widen_divrem_via_safe_divisor: bool = false,
    /// Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.
    forget_scev_loop_unroll: bool = false,
    /// Forward switch condition to phi ops (default = false)
    forward_switch_cond: bool = false,
    /// Enable aggressive formation of fused FP ops
    fp_contract: ?enum(u2) {
        fast = 0,
        on = 1,
        off = 2,
    } = null,
    /// The minimum number of instructions that are outlined in a frame helper (default = 2)
    frame_helper_size_threshold: ?usize = null,
    /// Specify frame pointer elimination optimization
    frame_pointer: ?enum(u2) {
        all = 0,
        @"non-leaf" = 1,
        none = 2,
    } = null,
    /// If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.
    freeze_loop_unswitch_cond: bool = false,
    /// Do not insert FS-AFDO discriminators before emit.
    fs_no_final_discrim: bool = false,
    /// Only show debug message if the source branch weight is greater  than this value.
    fs_profile_debug_bw_threshold: ?usize = null,
    /// Only show debug message if the branch probility is greater than this value (in percentage).
    fs_profile_debug_prob_diff_threshold: ?usize = null,
    /// Flow Sensitive profile file name.
    fs_profile_file: ?[]const u8 = null,
    /// Flow Sensitive profile remapping file name.
    fs_remapping_file: ?[]const u8 = null,
    /// View BFI after MIR loader
    fs_viewbfi_after: bool = false,
    /// View BFI before MIR loader
    fs_viewbfi_before: bool = false,
    /// Average loop iteration count cost
    func_specialization_avg_iters_cost: ?usize = null,
    /// The maximum number of clones allowed for a single function specialization
    func_specialization_max_clones: ?usize = null,
    /// The maximum number of iterations function specialization is run
    func_specialization_max_iters: ?usize = null,
    /// Enable function specialization on the address of global values
    func_specialization_on_address: bool = false,
    /// Don't specialize functions that have less than this theshold number of instructions
    func_specialization_size_threshold: ?usize = null,
    /// Emit functions into separate sections
    function_sections: bool = false,
    /// Enable specialization of functions that take a literal constant as an argument.
    function_specialization_for_literal_constant: bool = false,
    /// Enable/disable fusing matrix instructions.
    fuse_matrix: bool = false,
    /// Tile size for matrix instruction fusion using square-shaped tiles.
    fuse_matrix_tile_size: ?usize = null,
    /// Generate loop nest for tiling.
    fuse_matrix_use_loops: bool = false,
    /// Make counter updates atomic
    gcov_atomic_counter: bool = false,
    /// Generate dwarf aranges
    generate_arange_section: bool = false,
    /// When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.
    generate_merged_base_profiles: bool = false,
    /// Generate DWARF4 type units.
    generate_type_units: bool = false,
    /// Enable the "global" instruction selector
    global_isel: bool = false,
    /// Enable abort calls when "global" instruction selection fails to lower/select an instruction
    global_isel_abort: ?enum(u2) {
        @"0" = 0,
        @"1" = 1,
        @"2" = 2,
    } = null,
    /// Improve global merge pass to look at uses
    global_merge_group_by_use: bool = false,
    /// Improve global merge pass to ignore globals only used alone
    global_merge_ignore_single_use: bool = false,
    /// Set maximum offset for global merge pass
    global_merge_max_offset: ?usize = null,
    /// Enable global merge pass on constants
    global_merge_on_const: bool = false,
    /// Enable global merge pass on external linkage
    global_merge_on_external: bool = false,
    /// Global Pointer Addressing Size.  The default size is 8.
    gpsize: ?usize = null,
    /// Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global
    greedy_regclass_priority_trumps_globalness: bool = false,
    /// Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first
    greedy_reverse_local_assignment: bool = false,
    /// growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.
    grow_region_complexity_budget: ?usize = null,
    /// Whether or not we should widen guards  expressed as branches by widenable conditions
    guard_widening_widen_branch_guards: bool = false,
    /// The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
    guards_predicate_pass_branch_weight: ?usize = null,
    /// Enable phi-translation of add instructions
    gvn_add_phi_translation: bool = false,
    /// Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
    gvn_hoist_max_bbs: ?usize = null,
    /// Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
    gvn_hoist_max_chain_length: ?usize = null,
    /// Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
    gvn_hoist_max_depth: ?usize = null,
    /// Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)
    gvn_max_block_speculations: ?usize = null,
    /// Max number of instructions to hoist (default unlimited = -1)
    gvn_max_hoisted: ?usize = null,
    /// Max number of dependences to attempt Load PRE (default = 100)
    gvn_max_num_deps: ?usize = null,
    /// Max number of visited instructions when trying to find dominating value of select dependency (default = 100)
    gvn_max_num_visited_insts: ?usize = null,
    /// Set the loop counter bitwidth
    hardware_loop_counter_bitwidth: ?usize = null,
    /// Set the loop decrement value
    hardware_loop_decrement: ?usize = null,
    /// Rename counter variable of a comdat function based on cfg hash
    hash_based_counter_split: bool = false,
    /// Display available options (--help-hidden for more)
    help: bool = false,
    /// Display all available options
    help_hidden: bool = false,
    /// Display list of available options (--help-list-hidden for more)
    help_list: bool = false,
    /// Display list of all available options
    help_list_hidden: bool = false,
    /// Rewrite unaligned loads as a pair of aligned loads
    hexagon_align_loads: bool = false,
    /// Code growth limit for address mode optimization
    hexagon_amode_growth_limit: ?usize = null,
    /// Enable loop vectorizer for HVX
    hexagon_autohvx: bool = false,
    /// Bit simplification
    hexagon_bit: bool = false,
    /// Enable Hexagon constant-extender optimization
    hexagon_cext: bool = false,
    /// Maximum number of replacements
    hexagon_cext_limit: ?usize = null,
    /// Minimum number of extenders to trigger replacement
    hexagon_cext_threshold: ?usize = null,
    /// Enable checking for cache bank conflicts
    hexagon_check_bank_conflict: bool = false,
    /// Enable commoning of GEP instructions
    hexagon_commgep: bool = false,
    /// Disable minimum alignment of 1 for arguments passed by value on stack
    hexagon_disable_args_min_alignment: bool = false,
    /// Enable early if-conversion
    hexagon_eif: bool = false,
    /// Emit hexagon jump tables in function section
    hexagon_emit_jt_text: bool = false,
    /// Control jump table emission on Hexagon target
    hexagon_emit_jump_tables: bool = false,
    /// Control lookup table emission on Hexagon target
    hexagon_emit_lookup_tables: bool = false,
    /// Emit hexagon lookup tables in function section
    hexagon_emit_lut_text: bool = false,
    /// Enable branch prediction
    hexagon_enable_branch_prediction: bool = false,
    /// Early expansion of MUX
    hexagon_expand_condsets: bool = false,
    /// Generate "extract" instructions
    hexagon_extract: bool = false,
    /// Refrain from using FP whenever possible
    hexagon_fp_elim: bool = false,
    /// Limit on the number of reused registers in frame index elimination
    hexagon_frame_index_reuse_limit: ?usize = null,
    /// Limit on instruction search range in frame index elimination
    hexagon_frame_index_search_range: ?usize = null,
    /// Minimum distance between predicate definition and farther of the two predicated uses
    hexagon_gen_mux_threshold: ?usize = null,
    /// Enable conversion of arithmetic operations to predicate instructions
    hexagon_gen_pred: bool = false,
    /// Lower threshold (in bytes) for widening to HVX vectors
    hexagon_hvx_widen: ?usize = null,
    /// Add a preheader to a hardware loop if one doesn't exist
    hexagon_hwloop_preheader: bool = false,
    /// Simplify the CFG after atomic expansion pass
    hexagon_initial_cfg_cleanup: bool = false,
    /// Generate "insert" instructions
    hexagon_insert: bool = false,
    /// Enable instsimplify
    hexagon_instsimplify: bool = false,
    /// Enable checking of SDNode's single-use status
    hexagon_isel_su: bool = false,
    /// If present, forces/disables the use of long calls
    hexagon_long_calls: bool = false,
    /// Enable loop data prefetch on Hexagon
    hexagon_loop_prefetch: bool = false,
    /// Restrict range of loopN instructions (testing only)
    hexagon_loop_range: ?usize = null,
    /// Loop rescheduling
    hexagon_loop_resched: bool = false,
    /// Enable masked loads/stores for HVX
    hexagon_masked_vmem: bool = false,
    /// Enable converting conditional transfers into MUX instructions
    hexagon_mux: bool = false,
    /// Disable backend optimizations
    hexagon_noopt: bool = false,
    /// Optimize spill slots
    hexagon_opt_spill: bool = false,
    /// Enable vextract optimization
    hexagon_opt_vextract: bool = false,
    /// Allow non-solo packetization of volatile memory references
    hexagon_packetize_volatiles: bool = false,
    /// Consider calls to be predicable
    hexagon_pred_calls: bool = false,
    /// Do not consider inline-asm a scheduling/packetization boundary.
    hexagon_sched_inline_asm: bool = false,
    /// Enable stack frame shrink wrapping
    hexagon_shrink_frame: bool = false,
    /// The maximum size of an object in the sdata section
    hexagon_small_data_threshold: ?usize = null,
    /// Allow static variables in .sdata
    hexagon_statics_in_small_data: bool = false,
    /// Enable subregister liveness tracking for Hexagon
    hexagon_subreg_liveness: bool = false,
    /// Enable HVX vector combining
    hexagon_vector_combine: bool = false,
    /// Threshold for triggering vextract replacement
    hexagon_vextract_threshold: ?usize = null,
    /// Maximum distance of loop carried dependences that are handled
    hexagon_vlcr_iteration_lim: ?usize = null,
    /// Generate bitsplit instructions
    hexbit_bitsplit: bool = false,
    /// Generate extract instructions
    hexbit_extract: bool = false,
    /// Preserve subregisters in tied operands
    hexbit_keep_tied: bool = false,
    hexbit_max_bitsplit: ?usize = null,
    hexbit_max_extract: ?usize = null,
    hexbit_registerset_limit: ?usize = null,
    /// Allow enabling loop hints to reorder FP operations during vectorization.
    hints_allow_reordering: bool = false,
    /// Maximum number of simplification steps in HLIR
    hlir_simplify_limit: ?usize = null,
    /// MachineLICM should hoist even cheap instructions
    hoist_cheap_insts: bool = false,
    /// hoist common instructions (default = false)
    hoist_common_insts: bool = false,
    /// Hoist invariant stores
    hoist_const_stores: bool = false,
    /// Emit homogeneous prologue and epilogue for the size optimization (default = off)
    homogeneous_prolog_epilog: bool = false,
    /// Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
    hot_callsite_rel_freq: ?usize = null,
    /// Threshold for hot callsites
    hot_callsite_threshold: ?usize = null,
    /// Enable hot-cold splitting pass
    hot_cold_split: bool = false,
    hot_cold_static_analysis: bool = false,
    /// Name for the section containing cold functions extracted by hot-cold splitting.
    hotcoldsplit_cold_section_name: ?[]const u8 = null,
    /// Maximum number of parameters for a split function
    hotcoldsplit_max_params: ?usize = null,
    /// Base penalty for splitting cold code (as a multiple of TCC_Basic)
    hotcoldsplit_threshold: ?usize = null,
    /// Do not split loads or stores
    hsdr_no_mem: bool = false,
    /// Split all partitions
    hsdr_split_all: bool = false,
    /// A threshold of live range size which may cause high compile time cost in global splitting.
    huge_size_for_split: ?usize = null,
    /// Use page aliasing in HWASan
    hwasan_experimental_use_page_aliases: bool = false,
    /// generate new tags with runtime library calls
    hwasan_generate_tags_with_calls: bool = false,
    /// Instrument globals
    hwasan_globals: bool = false,
    /// inline all checks
    hwasan_inline_all_checks: bool = false,
    /// instrument atomic instructions (rmw, cmpxchg)
    hwasan_instrument_atomics: bool = false,
    /// instrument byval arguments
    hwasan_instrument_byval: bool = false,
    /// instrument landing pads
    hwasan_instrument_landing_pads: bool = false,
    /// instrument memory intrinsics
    hwasan_instrument_mem_intrinsics: bool = false,
    /// instrument personality functions
    hwasan_instrument_personality_functions: bool = false,
    /// instrument read instructions
    hwasan_instrument_reads: bool = false,
    /// instrument stack (allocas)
    hwasan_instrument_stack: bool = false,
    /// instrument reads and writes with callbacks
    hwasan_instrument_with_calls: bool = false,
    /// instrument write instructions
    hwasan_instrument_writes: bool = false,
    /// Enable KernelHWAddressSanitizer instrumentation
    hwasan_kernel: bool = false,
    /// Use prefix for memory intrinsics in KASAN mode
    hwasan_kernel_mem_intrinsic_prefix: bool = false,
    /// HWASan shadow mapping offset [EXPERIMENTAL]
    hwasan_mapping_offset: ?usize = null,
    /// don't report bad accesses via pointers with this tag
    hwasan_match_all_tag: ?usize = null,
    /// Prefix for memory access callbacks
    hwasan_memory_access_callback_prefix: ?[]const u8 = null,
    /// Record stack frames with tagged allocations in a thread-local ring buffer
    hwasan_record_stack_history: ?enum(u2) {
        none = 0,
        instr = 1,
        libcall = 2,
    } = null,
    /// Enable recovery mode (continue-after-error).
    hwasan_recover: bool = false,
    /// Clear alloca tags before returning from the function to allow non-instrumented and instrumented function calls mix. When set to false, allocas are retagged before returning from the function to detect use after return.
    hwasan_uar_retag_to_zero: bool = false,
    /// detect use after scope within function
    hwasan_use_after_scope: bool = false,
    /// use short granules in allocas and outlined checks
    hwasan_use_short_granules: bool = false,
    /// Use Stack Safety analysis results
    hwasan_use_stack_safety: bool = false,
    /// Access dynamic shadow through an ifunc global on platforms that support this
    hwasan_with_ifunc: bool = false,
    /// Access dynamic shadow through an thread-local pointer on platforms that support this
    hwasan_with_tls: bool = false,
    /// Allow speculation of preheader instructions
    hwloop_spec_preheader: bool = false,
    /// Run indirect-call promotion for call instructions only
    icp_call_only: bool = false,
    /// Skip Callsite up to this number for this compilation
    icp_csskip: ?usize = null,
    /// Max number of promotions for this compilation
    icp_cutoff: ?usize = null,
    /// Dump IR after transformation happens
    icp_dumpafter: bool = false,
    /// Run indirect-call promotion for invoke instruction only
    icp_invoke_only: bool = false,
    /// Run indirect-call promotion in LTO mode
    icp_lto: bool = false,
    /// Max number of annotations for a single indirect call callsite
    icp_max_annotations: ?usize = null,
    /// Max number of promotions for a single indirect call callsite
    icp_max_prom: ?usize = null,
    /// The percentage threshold against remaining unpromoted indirect call count for the promotion
    icp_remaining_percent_threshold: ?usize = null,
    /// Run indirect-call promotion in SamplePGO mode
    icp_samplepgo: bool = false,
    /// The percentage threshold against total count for the promotion
    icp_total_percent_threshold: ?usize = null,
    ifcvt_branch_fold: bool = false,
    ifcvt_fn_start: ?usize = null,
    ifcvt_fn_stop: ?usize = null,
    ifcvt_limit: ?usize = null,
    ignore_bb_reg_pressure: bool = false,
    /// Ignore TTI attributes compatibility check between callee/caller during inline cost calculation
    ignore_tti_inline_compatible: bool = false,
    /// Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file
    ignore_xcoff_visibility: bool = false,
    /// The page size of the target in bytes
    imp_null_check_page_size: ?usize = null,
    /// The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)
    imp_null_max_insts_to_consider: ?usize = null,
    /// Import all external functions in index.
    import_all_index: bool = false,
    /// Multiply the `import-instr-limit` threshold for cold callsites
    import_cold_multiplier: ?usize = null,
    /// Import constant global variables with references
    import_constants_with_refs: bool = false,
    /// Multiply the `import-instr-limit` threshold for critical callsites
    import_critical_multiplier: ?usize = null,
    /// Only import first N functions if N>=0 (default -1)
    import_cutoff: ?usize = null,
    /// Import full type definitions for ThinLTO.
    import_full_type_definitions: bool = false,
    /// As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions
    import_hot_evolution_factor: ?usize = null,
    /// Multiply the `import-instr-limit` threshold for hot callsites
    import_hot_multiplier: ?usize = null,
    /// As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions
    import_instr_evolution_factor: ?usize = null,
    /// Only import functions with less than N instructions
    import_instr_limit: ?usize = null,
    /// When used with filetype=obj, emit an object file which can be used with an incremental linker
    incremental_linker_compatible: bool = false,
    /// Use post increment control-dependent ranges in IndVarSimplify
    indvars_post_increment_ranges: bool = false,
    /// Predicate conditions in read only loops
    indvars_predicate_loops: bool = false,
    /// Allow widening of indvars to eliminate s/zext
    indvars_widen_indvars: bool = false,
    /// File to append -stats and -timer output to
    info_output_file: ?[]const u8 = null,
    /// Initial value of synthetic entry count
    initial_synthetic_count: ?usize = null,
    /// Call penalty that is applied per callsite when inlining
    inline_call_penalty: ?usize = null,
    /// Allow inlining when caller has a superset of callee's nobuiltin attributes.
    inline_caller_superset_nobuiltin: bool = false,
    /// Threshold for inlining cold callsites
    inline_cold_callsite_threshold: ?usize = null,
    /// Compute the full inline cost of a call site even when the cost exceeds the threshold.
    inline_cost_full: bool = false,
    /// Enable deferred inlining
    inline_deferral: bool = false,
    /// Scale to limit the cost of inline deferral
    inline_deferral_scale: ?usize = null,
    /// Enable the cost-benefit analysis for the inliner
    inline_enable_cost_benefit_analysis: bool = false,
    /// Cost of a single instruction when inlining
    inline_instr_cost: ?usize = null,
    /// Do not inline functions with a stack size that exceeds the specified limit
    inline_max_stacksize: ?usize = null,
    /// Cost of load/store instruction when inlining
    inline_memaccess_cost: ?usize = null,
    /// Choose the priority mode to use in module inline
    inline_priority_mode: ?enum(u2) {
        size = 0,
        cost = 1,
        @"cost-benefit" = 2,
        ml = 3,
    } = null,
    /// Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined
    inline_remark_attribute: bool = false,
    /// Multiplier to multiply cycle savings by during inlining
    inline_savings_multiplier: ?usize = null,
    /// The maximum size of a callee that get's inlined without sufficient cycle savings
    inline_size_allowance: ?usize = null,
    /// Initial synthetic entry count for inline functions.
    inline_synthetic_count: ?usize = null,
    /// Control the amount of inlining to perform (default = 225)
    inline_threshold: ?usize = null,
    /// Threshold for inlining functions with cold attribute
    inlinecold_threshold: ?usize = null,
    /// Default amount of inlining to perform
    inlinedefault_threshold: ?usize = null,
    /// Threshold for inlining functions with inline hint
    inlinehint_threshold: ?usize = null,
    /// Enable inliner stats for imported functions
    inliner_function_import_stats: ?enum(u1) {
        basic = 0,
        verbose = 1,
    } = null,
    insert_all0: bool = false,
    insert_const: bool = false,
    /// Vreg distance cutoff for insert generation.
    insert_dist_cutoff: ?usize = null,
    insert_has0: bool = false,
    /// Maximum size of IFMap
    insert_max_ifmap: ?usize = null,
    /// Maximum size of OrderedRegisterList
    insert_max_orl: ?usize = null,
    /// Enable timing of insert generation
    insert_timing: bool = false,
    /// Enable detailed timing of insert generation
    insert_timing_detail: bool = false,
    /// Vreg# cutoff for insert generation.
    insert_vreg_cutoff: ?usize = null,
    /// Enable code sinking
    instcombine_code_sinking: bool = false,
    /// How wide an instruction window to bypass looking for another guard
    instcombine_guard_widening_window: ?usize = null,
    /// Number of instruction combining iterations considered an infinite loop
    instcombine_infinite_loop_threshold: ?usize = null,
    instcombine_lower_dbg_declare: ?usize = null,
    /// Maximum users to visit in copy from constant transform
    instcombine_max_copied_from_constant_users: ?usize = null,
    /// Limit the maximum number of instruction combining iterations
    instcombine_max_iterations: ?usize = null,
    /// Maximum number phis to handle in intptr/ptrint folding
    instcombine_max_num_phis: ?usize = null,
    /// Maximum number of undroppable users for instruction sinking
    instcombine_max_sink_users: ?usize = null,
    /// Maximum array size considered when doing a combine
    instcombine_maxarray_size: ?usize = null,
    /// Should we attempt to sink negations?
    instcombine_negator_enabled: bool = false,
    /// What is the maximal lookup depth when trying to check for viability of negation sinking.
    instcombine_negator_max_depth: ?usize = null,
    /// Make all profile counter updates atomic (for testing only)
    instrprof_atomic_counter_update_all: bool = false,
    /// Enable loop interleaving in Loop vectorization passes
    interleave_loops: bool = false,
    /// Enable interleaving for loops with small iteration counts that contain scalar reductions to expose ILP.
    interleave_small_loop_scalar_reduction: bool = false,
    /// A file containing list of symbol names to preserve
    internalize_public_api_file: ?[]const u8 = null,
    /// A list of symbol names to preserve
    internalize_public_api_list: bool = false,
    /// make the interpreter print every volatile load and store
    interpreter_print_volatile: bool = false,
    /// Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times
    intra_scc_cost_multiplier: ?usize = null,
    /// Enable ir outliner pass
    ir_outliner: bool = false,
    /// If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.
    irce_allow_narrow_latch: bool = false,
    irce_allow_unsigned_latch: bool = false,
    irce_loop_size_cutoff: ?usize = null,
    irce_min_runtime_iterations: ?usize = null,
    irce_print_changed_loops: bool = false,
    irce_print_range_checks: bool = false,
    irce_skip_profitability_checks: bool = false,
    /// Rebalance address calculation trees to improve instruction selection
    isel_rebalance_addr: bool = false,
    /// Iterative inference: maximum number of update iterations per block
    iterative_bfi_max_iterations_per_block: ?usize = null,
    /// Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime
    iterative_bfi_precision: ?usize = null,
    /// Allow counter promotion across the whole loop nest.
    iterative_counter_promotion: bool = false,
    /// Coalesce copies that span blocks (default=subtarget)
    join_globalcopies: bool = false,
    /// Coalesce copies (default=true)
    join_liveintervals: bool = false,
    /// Coalesce copies on split edges (default=subtarget)
    join_splitedges: bool = false,
    /// Cost of jump instructions.
    jump_inst_cost: ?usize = null,
    /// Do not create extra branches to split comparison logic.
    jump_is_expensive: bool = false,
    /// Minimum density for building a jump table in a normal function
    jump_table_density: ?usize = null,
    /// Allow JumpThreading to thread across loop headers, for testing
    jump_threading_across_loop_headers: bool = false,
    /// The number of predecessors to search for a stronger condition to use to thread over a weaker condition
    jump_threading_implication_search_threshold: ?usize = null,
    /// Max PHIs in BB to duplicate for jump threading
    jump_threading_phi_threshold: ?usize = null,
    /// Max block size to duplicate for jump threading
    jump_threading_threshold: ?usize = null,
    keep_inline_advisor_for_printing: bool = false,
    /// Preserve canonical loop structure (default = true)
    keep_loops: bool = false,
    /// Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]
    lanai_constant_mul_threshold: ?usize = null,
    /// Fill Lanai delay slots with NOPs.
    lanai_nop_delay_filler: bool = false,
    /// Small data and bss section threshold size (default=0)
    lanai_ssection_threshold: ?usize = null,
    /// For a large interval, if it is coalesed with other live intervals many times more than the threshold, stop its coalescing to control the compile time.
    large_interval_freq_threshold: ?usize = null,
    /// If the valnos size of an interval is larger than the threshold, it is regarded as a large interval.
    large_interval_size_threshold: ?usize = null,
    /// During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work.
    late_remat_update_threshold: ?usize = null,
    /// Last chance recoloring max depth
    lcr_max_depth: ?usize = null,
    /// Last chance recoloring maximum number of considered interference at a time
    lcr_max_interf: ?usize = null,
    /// Number limit for gluing ld/st of memcpy.
    ldstmemcpy_glue_max: ?usize = null,
    /// Enable control flow (and PHI) hoisting in LICM
    licm_control_flow_hoisting: bool = false,
    /// Force thread model single in LICM pass
    licm_force_thread_model_single: bool = false,
    /// Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
    licm_max_num_uses_traversed: ?usize = null,
    /// [LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.
    licm_mssa_max_acc_promotion: ?usize = null,
    /// Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.
    licm_mssa_optimization_cap: ?usize = null,
    /// LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
    licm_versioning_invariant_threshold: ?usize = null,
    /// LoopVersioningLICM's threshold for maximum allowed loop nest/depth
    licm_versioning_max_depth_threshold: ?usize = null,
    /// Weight of the branch likely to be taken (default = 2000)
    likely_branch_weight: ?usize = null,
    /// Generate low-precision inline sequences for some float libcalls
    limit_float_precision: ?usize = null,
    /// Enable the live debug variables pass
    live_debug_variables: bool = false,
    /// Maximum input basic blocks before DBG_VALUE limit applies
    livedebugvalues_input_bb_limit: ?usize = null,
    /// Maximum input DBG_VALUE insts supported by debug range extension
    livedebugvalues_input_dbg_value_limit: ?usize = null,
    /// livedebugvalues-stack-ws-limit
    livedebugvalues_max_stack_slots: ?usize = null,
    /// Load the specified plugin
    load: ?[]const u8 = null,
    /// Threshold for locally hot callsites
    locally_hot_callsite_threshold: ?usize = null,
    /// Trap on integer division by zero.
    loongarch_check_zero_division: bool = false,
    /// Print numeric register names rather than the ABI names (such as $r0 instead of $zero)
    loongarch_numeric_reg: bool = false,
    /// Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken
    loop_deletion_enable_symbolic_execution: bool = false,
    /// Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
    loop_distribute_non_if_convertible: bool = false,
    /// The maximum number of SCEV checks allowed for Loop Distribution
    loop_distribute_scev_check_threshold: ?usize = null,
    /// The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
    loop_distribute_scev_check_threshold_with_pragma: ?usize = null,
    /// Turn on DominatorTree and LoopInfo verification after Loop Distribution
    loop_distribute_verify: bool = false,
    /// Assume that the product of the two iteration trip counts will never overflow
    loop_flatten_assume_no_overflow: bool = false,
    /// Limit on the cost of instructions that can be repeated due to loop flattening
    loop_flatten_cost_threshold: ?usize = null,
    /// Widen the loop induction variables, if possible, so overflow checks won't reject flattening
    loop_flatten_widen_iv: bool = false,
    /// Which dependence analysis should loop fusion use?
    loop_fusion_dependence_analysis: ?enum(u2) {
        scev = 0,
        da = 1,
        all = 2,
    } = null,
    /// Max number of iterations to be peeled from a loop, such that fusion can take place
    loop_fusion_peel_max_count: ?usize = null,
    /// Interchange if you gain more than this number
    loop_interchange_threshold: ?usize = null,
    /// The maximum number of SCEV checks allowed for Loop Load Elimination
    loop_load_elimination_scev_check_threshold: ?usize = null,
    loop_predication_enable_count_down_loop: bool = false,
    loop_predication_enable_iv_truncation: bool = false,
    /// Whether or not we should insert assumes of conditions of predicated guards
    loop_predication_insert_assumes_of_predicated_guards_conditions: bool = false,
    /// scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
    loop_predication_latch_probability_scale: ?usize = null,
    /// Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks
    loop_predication_predicate_widenable_branches_to_deopt: bool = false,
    loop_predication_skip_profitability_checks: bool = false,
    /// Prefetch write addresses
    loop_prefetch_writes: bool = false,
    /// Allow loop rotation multiple times in order to reach a better latch exit
    loop_rotate_multi: bool = false,
    /// Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio
    loop_to_cold_block_ratio: ?usize = null,
    /// Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.
    loop_vectorize_with_block_frequency: bool = false,
    /// Add no-alias annotation for instructions that are disambiguated by memchecks
    loop_version_annotate_no_alias: bool = false,
    /// Lower llvm.global_dtors (global destructors) via __cxa_atexit
    lower_global_dtors_via_cxa_atexit: bool = false,
    /// Enable lowering interleaved accesses to intrinsics
    lower_interleaved_accesses: bool = false,
    /// Try to avoid reuse of byte array addresses using aliases
    lowertypetests_avoid_reuse: bool = false,
    /// Simply drop type test assume sequences
    lowertypetests_drop_type_tests: bool = false,
    /// Read summary from given YAML file before running pass
    lowertypetests_read_summary: ?[]const u8 = null,
    /// What to do with the summary when running this pass
    lowertypetests_summary_action: ?enum(u2) {
        none = 0,
        import = 1,
        @"export" = 2,
    } = null,
    /// Write summary to given YAML file after running pass
    lowertypetests_write_summary: ?[]const u8 = null,
    /// LSR search space complexity limit
    lsr_complexity_limit: ?usize = null,
    /// Attempt to drop solution if it is less profitable
    lsr_drop_solution: bool = false,
    /// Narrow LSR complex solution using expectation of registers number
    lsr_exp_narrow: bool = false,
    /// Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
    lsr_filter_same_scaled_reg: bool = false,
    /// Add instruction count to a LSR cost model
    lsr_insns_cost: bool = false,
    /// A flag that overrides the target's preferred addressing mode.
    lsr_preferred_addressing_mode: ?enum(u2) {
        none = 0,
        preindexed = 1,
        postindexed = 2,
    } = null,
    /// The limit on recursion depth for LSRs setup cost
    lsr_setupcost_depth_limit: ?usize = null,
    /// Attempt to replace primary IV with other IV.
    lsr_term_fold: bool = false,
    /// Path to a system assembler, picked up on AIX only
    lto_aix_system_assembler: ?[]const u8 = null,
    /// Strip names from Value during LTO (other than GlobalValue).
    lto_discard_value_names: bool = false,
    /// Embed LLVM bitcode in object files produced by LTO
    lto_embed_bitcode: ?enum(u2) {
        none = 0,
        optimized = 1,
        @"post-merge-pre-opt" = 2,
    } = null,
    /// Only record optimization remarks from passes whose names match the given regular expression
    lto_pass_remarks_filter: ?[]const u8 = null,
    /// The format used for serializing remarks (default: YAML)
    lto_pass_remarks_format: ?[]const u8 = null,
    /// Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary.
    lto_pass_remarks_hotness_threshold: bool = false,
    /// Output filename for pass remarks
    lto_pass_remarks_output: ?[]const u8 = null,
    /// With PGO, include profile count in optimization remarks
    lto_pass_remarks_with_hotness: bool = false,
    /// Save statistics to the specified file
    lto_stats_file: ?[]const u8 = null,
    /// Dump all substituted intrs
    machine_combiner_dump_subst_intrs: bool = false,
    /// Incremental depth computation will be used for basic blocks with more instructions.
    machine_combiner_inc_threshold: ?usize = null,
    /// Verify that the generated patterns are ordered by increasing latency
    machine_combiner_verify_pattern_order: bool = false,
    /// Number of times to rerun the outliner after the initial outline
    machine_outliner_reruns: ?usize = null,
    /// Use block frequency info to find successors to sink
    machine_sink_bfi: bool = false,
    /// The maximum number of instructions considered for cycle sinking.
    machine_sink_cycle_limit: ?usize = null,
    /// Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.
    machine_sink_load_blocks_threshold: ?usize = null,
    /// Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.
    machine_sink_load_instrs_threshold: ?usize = null,
    /// Split critical edges during machine sinking
    machine_sink_split: bool = false,
    /// Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge
    machine_sink_split_probability_threshold: ?usize = null,
    /// Perform mandatory inlinings module-wide, before performing inlining
    mandatory_inlining_first: bool = false,
    /// Architecture to generate code for (see --version)
    march: ?[]const u8 = null,
    /// Mark code section jump table data regions.
    mark_data_regions: bool = false,
    /// Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.
    matrix_allow_contract: bool = false,
    /// Sets the default matrix layout
    matrix_default_layout: ?enum(u1) {
        @"column-major" = 0,
        @"row-major" = 1,
    } = null,
    matrix_print_after_transpose_opt: bool = false,
    /// Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in CreateControlFlowHub.
    max_booleans_in_control_flow_hub: ?usize = null,
    /// Forces the maximum bytes allowed to be emitted when padding for alignment
    max_bytes_for_alignment: ?usize = null,
    /// Max number of allowed counter promotions
    max_counter_promotions: ?usize = null,
    /// Max number counter promotions per loop to avoid increasing register pressure too much
    max_counter_promotions_per_loop: ?usize = null,
    /// Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable
    max_deopt_or_unreachable_succ_check_depth: ?usize = null,
    /// Maximum number of dependences collected by loop-access analysis (default = 100)
    max_dependences: ?usize = null,
    /// Maximum recursion depth when finding forked SCEVs (default = 5)
    max_forked_scev_depth: ?usize = null,
    max_heap_to_stack_size: ?usize = null,
    /// Maximum number of split partitions
    max_hsdr: ?usize = null,
    /// the maximum number of instructions analyzed for may throw during attribute inference in inlined body
    max_inst_checked_for_throw_during_inlining: ?usize = null,
    /// Maximum factor for an interleaved access group (default = 8)
    max_interleave_group_factor: ?usize = null,
    /// Set maximum size of jump tables.
    max_jump_table_size: ?usize = null,
    /// Set maximum number of loads used in expanded memcmp
    max_loads_per_memcmp: ?usize = null,
    /// Set maximum number of loads used in expanded memcmp for -Os/Oz
    max_loads_per_memcmp_opt_size: ?usize = null,
    /// The maximum interleave count to use when interleaving a scalar reduction in a nested loop.
    max_nested_scalar_reduction_interleave: ?usize = null,
    /// Max number of blocks to be partially inlined
    max_num_inline_blocks: ?usize = null,
    /// Maximum distance between a tfr feeding a store we consider the store still to be newifiable
    max_num_inst_between_tfr_and_nv_store: ?usize = null,
    /// Max number of partial inlining. The default is unlimited
    max_partial_inlining: ?usize = null,
    /// Max number of iterations to prefetch ahead
    max_prefetch_iters_ahead: ?usize = null,
    /// Max number of VRegs allowed to pass GC pointer meta args in
    max_registers_for_gc_values: ?usize = null,
    /// Number of instructions to allow ahead of the critical path in sched=list-ilp
    max_sched_reorder: ?usize = null,
    /// Limit maximum recursion depth when calculating costs of speculatively executed instructions
    max_speculation_depth: ?usize = null,
    /// Max #stores to inline memcpy
    max_store_memcpy: ?usize = null,
    /// Max #stores to inline memcpy
    max_store_memcpy_Os: ?usize = null,
    /// Max #stores to inline memmove
    max_store_memmove: ?usize = null,
    /// Max #stores to inline memmove
    max_store_memmove_Os: ?usize = null,
    /// Max #stores to inline memset
    max_store_memset: ?usize = null,
    /// Max #stores to inline memset
    max_store_memset_Os: ?usize = null,
    /// Limit cases to analyze when converting a switch to select
    max_switch_cases_per_result: ?usize = null,
    /// Do not sink instructions that have too many uses.
    max_uses_for_sinking: ?usize = null,
    /// When used with filetype=obj, relax all fixups in the emitted object file
    mc_relax_all: bool = false,
    /// tbd
    mcabac: bool = false,
    /// The prefix used for the Machine CFG dot file names.
    mcfg_dot_filename_prefix: ?[]const u8 = null,
    /// The name of a function (or its substring) whose CFG is viewed/printed.
    mcfg_func_name: ?[]const u8 = null,
    mcp_use_is_copy_instr: bool = false,
    /// Target a specific cpu type (-mcpu=help for details)
    mcpu: ?[]const u8 = null,
    /// Set EABI type (default depends on triple):
    meabi: ?enum(u2) {
        default = 0,
        @"4" = 1,
        @"5" = 2,
        gnu = 3,
    } = null,
    mem_loc_frag_fill: bool = false,
    /// MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .
    membedded_data: bool = false,
    /// The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.
    memcmp_num_loads_per_block: ?usize = null,
    /// The number of blocks to scan during memory dependency analysis (default = 200)
    memdep_block_number_limit: ?usize = null,
    /// The number of instructions to scan in a block in memory dependency analysis (default = 100)
    memdep_block_scan_limit: ?usize = null,
    /// Max number of preicise value annotations for a single memopintrinsic
    memop_max_annotations: ?usize = null,
    /// Optimize the memop size <= this value
    memop_value_prof_max_opt_size: ?usize = null,
    /// Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
    memory_check_merge_threshold: ?usize = null,
    /// The threshold the accesses per byte must be under to consider an allocation cold
    memprof_accesses_per_byte_cold_threshold: ?usize = null,
    /// debug
    memprof_debug: ?usize = null,
    /// Debug func
    memprof_debug_func: ?[]const u8 = null,
    /// Debug max inst
    memprof_debug_max: ?usize = null,
    /// Debug min inst
    memprof_debug_min: ?usize = null,
    /// Guard against compiler/runtime version mismatch.
    memprof_guard_against_version_mismatch: bool = false,
    /// instrument atomic instructions (rmw, cmpxchg)
    memprof_instrument_atomics: bool = false,
    /// instrument read instructions
    memprof_instrument_reads: bool = false,
    /// Instrument scalar stack variables
    memprof_instrument_stack: bool = false,
    /// instrument write instructions
    memprof_instrument_writes: bool = false,
    /// granularity of memprof shadow mapping
    memprof_mapping_granularity: ?usize = null,
    /// scale of memprof shadow mapping
    memprof_mapping_scale: ?usize = null,
    /// Prefix for memory access callbacks
    memprof_memory_access_callback_prefix: ?[]const u8 = null,
    /// The minimum lifetime (s) for an allocation to be considered cold
    memprof_min_lifetime_cold_threshold: ?usize = null,
    /// Use callbacks instead of inline instrumentation sequences.
    memprof_use_callbacks: bool = false,
    /// The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
    memssa_check_limit: ?usize = null,
    /// Preserve debug info in thunk when mergefunc transformations are made.
    mergefunc_preserve_debug_info: bool = false,
    /// Allow mergefunc to create aliases
    mergefunc_use_aliases: bool = false,
    /// How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key.
    mergefunc_verify: ?usize = null,
    /// Error for missing parenthesis around predicate registers
    merror_missing_parenthesis: bool = false,
    /// Error for register names that aren't contigious
    merror_noncontigious_register: bool = false,
    /// MIPS: Use gp_rel for data that is not defined by the current object.
    mextern_sdata: bool = false,
    /// Enable the VR4300 mulmul bug fix.
    mfix4300: bool = false,
    /// Minimum number of times a block must be executed to be retained.
    mfs_count_threshold: ?usize = null,
    /// Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.
    mfs_psi_cutoff: ?usize = null,
    /// Splits all EH code and it's descendants by default.
    mfs_split_ehcode: bool = false,
    /// Enable gp-relative addressing of mips small data items
    mgpopt: bool = false,
    /// Enable Hexagon Vector eXtensions
    mhvx: ?enum(u4) {
        v60 = 0,
        v62 = 1,
        v65 = 2,
        v66 = 3,
        v67 = 4,
        v68 = 5,
        v69 = 6,
        v71 = 7,
        v73 = 8,
    } = null,
    /// Enable HVX IEEE floating point extensions
    mhvx_ieee_fp: bool = false,
    /// Hardware multiplier use mode for MSP430
    mhwmult: ?enum(u2) {
        none = 0,
        @"16bit" = 1,
        @"32bit" = 2,
        f5series = 3,
    } = null,
    /// Minimum block executions to consider its BranchProbabilityInfo valid
    min_block_execution: ?usize = null,
    /// Loops with a constant trip count smaller than this value will not use the count register.
    min_ctr_loop_threshold: ?usize = null,
    /// Set minimum number of entries to use a jump table.
    min_jump_table_entries: ?usize = null,
    /// Min stride to add prefetches
    min_prefetch_stride: ?usize = null,
    /// Minimum ratio comparing relative sizes of each outline candidate and original function
    min_region_size_ratio: ?usize = null,
    /// Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size
    minimize_addr_in_v5: ?enum(u3) {
        Default = 0,
        Ranges = 1,
        Expressions = 2,
        Form = 3,
        Disabled = 4,
    } = null,
    /// Set minimum jump tables
    minimum_jump_tables: ?usize = null,
    /// Align constant islands in code
    mips_align_constant_islands: bool = false,
    /// MIPS Specific: Compact branch policy.
    mips_compact_branches: ?enum(u2) {
        never = 0,
        optimal = 1,
        always = 2,
    } = null,
    /// Don't relax loads to long loads - for testing purposes
    mips_constant_islands_no_load_relaxation: bool = false,
    /// Make small offsets be this amount for testing purposes
    mips_constant_islands_small_offset: ?usize = null,
    /// Erase GP Operand
    mips_erase_gp_opnd: bool = false,
    /// Always use $gp as the global base register.
    mips_fix_global_base_reg: bool = false,
    /// MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr
    mips_jalr_reloc: bool = false,
    /// Load target address from GOT
    mips_load_target_from_got: bool = false,
    /// Allow for a mixture of Mips16 and Mips32 code in a single output file
    mips_mixed_16_32: bool = false,
    /// Compile all functions that don't use floating point as Mips 16
    mips_os16: bool = false,
    /// Round section sizes up to the section alignment
    mips_round_section_sizes: bool = false,
    /// Small data and bss section threshold size (default=8)
    mips_ssection_threshold: ?usize = null,
    /// MIPS: permit tail calls.
    mips_tail_calls: bool = false,
    /// Enable mips16 constant islands.
    mips16_constant_islands: bool = false,
    /// Don't expand conditional move related pseudos for Mips 16
    mips16_dont_expand_cond_pseudo: bool = false,
    /// Enable mips16 hard float.
    mips16_hard_float: bool = false,
    /// Force function to be mips32
    mips32_function_mask: ?[]const u8 = null,
    /// Disable one or more combiner rules temporarily in the MipsPostLegalizerCombinerHelper pass
    mipspostlegalizercombinerhelper_disable_rule: ?[]const u8 = null,
    /// Disable all rules in the MipsPostLegalizerCombinerHelper pass then re-enable the specified ones
    mipspostlegalizercombinerhelper_only_enable_rule: ?[]const u8 = null,
    /// Print MIR debug-locations
    mir_debug_loc: bool = false,
    /// Should mir-strip-debug only strip debug info from debugified modules by default
    mir_strip_debugify_only: bool = false,
    /// Use Stable Hashing for MIR VReg Renaming
    mir_vreg_namer_use_stable_hash: bool = false,
    /// Machine instruction scheduler to use
    misched: ?enum(u4) {
        default = 0,
        converge = 1,
        ilpmax = 2,
        ilpmin = 3,
        si = 4,
        @"gcn-max-occupancy" = 5,
        @"gcn-max-ilp" = 6,
        @"gcn-iterative-max-occupancy-experimental" = 7,
        @"gcn-iterative-minreg" = 8,
        @"gcn-iterative-ilp" = 9,
        r600 = 10,
        hexagon = 11,
        @"ppc-prera" = 12,
        @"ppc-postra" = 13,
    } = null,
    /// Force bottom-up list scheduling
    misched_bottomup: bool = false,
    /// Enable memop clustering.
    misched_cluster: bool = false,
    /// Enable cyclic critical path analysis.
    misched_cyclicpath: bool = false,
    /// Print critical path length to stdout
    misched_dcpl: bool = false,
    /// Enable scheduling for macro fusion.
    misched_fusion: bool = false,
    /// Limit ready list to N instructions
    misched_limit: ?usize = null,
    /// Run MachineScheduler post regalloc (independent of preRA sched)
    misched_postra: bool = false,
    /// Enable register pressure scheduling.
    misched_regpressure: bool = false,
    /// Force top-down list scheduling
    misched_topdown: bool = false,
    misched_verbose_level: ?usize = null,
    /// Prevents emiting diagnostics when profile counts are within N% of the threshold..
    misexpect_tolerance: ?usize = null,
    /// Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.
    misfetch_cost: ?usize = null,
    /// Default mispredict rate (initialized to 25%).
    mispredict_default_rate: ?usize = null,
    /// For test - keep the ML Inline advisor's FunctionPropertiesInfo cache
    ml_advisor_keep_fpi_cache: bool = false,
    /// Maximum factor by which expected native size may increase before blocking any further inlining.
    ml_advisor_size_increase_threshold: ?usize = null,
    /// MIPS: Use gp_rel for object-local data.
    mlocal_sdata: bool = false,
    /// MIPS: Don't trap on integer division by zero.
    mno_check_zero_division: bool = false,
    /// Disable looking for compound instructions for Hexagon
    mno_compound: bool = false,
    /// Disable fixing up resolved relocations for Hexagon
    mno_fixup: bool = false,
    /// Disable Hexagon Vector eXtensions
    mno_hvx: bool = false,
    /// Expand double precision loads and stores to their single precision counterparts
    mno_ldc1_sdc1: bool = false,
    /// Disable looking for duplex instructions for Hexagon
    mno_pairing: bool = false,
    /// Disable small data sections sorting
    mno_sort_sda: bool = false,
    /// File to emit dot graph of new summary into
    module_summary_dot_file: ?[]const u8 = null,
    /// The cost threshold for call sites that get inlined without the cost-benefit analysis
    moudle_inliner_top_priority_threshold: ?usize = null,
    /// Define custom MSan AndMask
    msan_and_mask: ?usize = null,
    /// report accesses through a pointer which has poisoned shadow
    msan_check_access_address: bool = false,
    /// Insert checks for constant shadow values
    msan_check_constant_shadow: bool = false,
    /// Apply no_sanitize to the whole file
    msan_disable_checks: bool = false,
    /// Define threshold for number of checks per debug location to force origin update.
    msan_disambiguate_warning_threshold: ?usize = null,
    /// print out instructions with default strict semantics
    msan_dump_strict_instructions: bool = false,
    /// check arguments and return values at function call boundaries
    msan_eager_checks: bool = false,
    /// conservative handling of inline assembly
    msan_handle_asm_conservative: bool = false,
    /// propagate shadow through ICmpEQ and ICmpNE
    msan_handle_icmp: bool = false,
    /// exact handling of relational integer ICmp
    msan_handle_icmp_exact: bool = false,
    /// when possible, poison scoped variables at the beginning of the scope (slower, but more precise)
    msan_handle_lifetime_intrinsics: bool = false,
    /// If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).
    msan_instrumentation_with_call_threshold: ?usize = null,
    /// keep going after reporting a UMR
    msan_keep_going: bool = false,
    /// Enable KernelMemorySanitizer instrumentation
    msan_kernel: bool = false,
    /// Define custom MSan OriginBase
    msan_origin_base: ?usize = null,
    /// poison uninitialized stack variables
    msan_poison_stack: bool = false,
    /// poison uninitialized stack variables with the given pattern
    msan_poison_stack_pattern: ?usize = null,
    /// poison uninitialized stack variables with a call
    msan_poison_stack_with_call: bool = false,
    /// poison undef temps
    msan_poison_undef: bool = false,
    /// Print name of local stack variable
    msan_print_stack_names: bool = false,
    /// Define custom MSan ShadowBase
    msan_shadow_base: ?usize = null,
    /// Track origins (allocation sites) of poisoned memory
    msan_track_origins: ?usize = null,
    /// Place MSan constructors in comdat sections
    msan_with_comdat: bool = false,
    /// Define custom MSan XorMask
    msan_xor_mask: ?usize = null,
    /// Expand out of range branches
    msp430_branch_select: bool = false,
    /// Enable non legal immediates (for testing purposes only)
    msp430_no_legal_immediate: bool = false,
    /// Override target triple for module
    mtriple: ?[]const u8 = null,
    /// Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc.
    mul_constant_optimization: bool = false,
    /// Build for Hexagon V5
    mv5: bool = false,
    /// Build for Hexagon V55
    mv55: bool = false,
    /// Build for Hexagon V60
    mv60: bool = false,
    /// Build for Hexagon V62
    mv62: bool = false,
    /// Build for Hexagon V65
    mv65: bool = false,
    /// Build for Hexagon V66
    mv66: bool = false,
    /// Build for Hexagon V67
    mv67: bool = false,
    /// Build for Hexagon V67T
    mv67t: bool = false,
    /// Build for Hexagon V68
    mv68: bool = false,
    /// Build for Hexagon V69
    mv69: bool = false,
    /// Build for Hexagon V71
    mv71: bool = false,
    /// Build for Hexagon V71T
    mv71t: bool = false,
    /// Build for Hexagon V73
    mv73: bool = false,
    /// Maximum interleave factor for MVE VLDn to generate.
    mve_max_interleave_factor: ?usize = null,
    /// Warn for missing parenthesis around predicate registers
    mwarn_missing_parenthesis: bool = false,
    /// Warn for register names that arent contigious
    mwarn_noncontigious_register: bool = false,
    /// Warn for mismatching a signed and unsigned value
    mwarn_sign_mismatch: bool = false,
    /// Suppress all deprecated warnings
    no_deprecated_warn: bool = false,
    /// Disable generation of discriminator information.
    no_discriminators: bool = false,
    /// Disable emission .debug_ranges section.
    no_dwarf_ranges_section: bool = false,
    /// Disable integrated assembler
    no_integrated_as: bool = false,
    /// Use this option to turn off/on warnings about profile cfg mismatch.
    no_pgo_warn_mismatch: bool = false,
    /// The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.
    no_pgo_warn_mismatch_comdat_weak: bool = false,
    /// Do not use an early exit if isLiveOutPastPHIs returns true.
    no_phi_elim_live_out_early_exit: bool = false,
    /// Disable stack coloring
    no_stack_coloring: bool = false,
    /// Suppress slot sharing during stack coloring
    no_stack_slot_sharing: bool = false,
    /// Suppress type errors (Wasm)
    no_type_check: bool = false,
    /// Suppress all warnings
    no_warn: bool = false,
    /// Use this option to turn off/on warnings about function with samples but without debug information to use those samples.
    no_warn_sample_unused: bool = false,
    /// Avoid optimizing x86 call frames for size
    no_x86_call_frame_opt: bool = false,
    /// Don't emit xray_fn_idx section
    no_xray_index: bool = false,
    /// Maximum size for the name of non-global values.
    non_global_value_max_name_size: ?usize = null,
    /// Don't place zero-initialized symbols into bss section
    nozero_initialized_in_bss: bool = false,
    /// Set the number of scavenger slots
    number_scavenger_slots: ?usize = null,
    /// Maximum number of predicated jumps to be converted to New Value Jump
    nvj_count: ?usize = null,
    /// NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively
    nvptx_fma_level: ?usize = null,
    /// NVPTX Specific: Disable generation of f16 math ops.
    nvptx_no_f16_math: bool = false,
    /// NVPTX Specifies: 0 use div.approx, 1 use div.full, 2 use IEEE Compliant F32 div.rnd if available.
    nvptx_prec_divf32: ?usize = null,
    /// NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.
    nvptx_prec_sqrtf32: bool = false,
    /// NVPTX Specific: schedule for register pressue
    nvptx_sched4reg: bool = false,
    /// Use 32-bit pointers for accessing const/local/shared address spaces.
    nvptx_short_ptr: bool = false,
    /// SM variant
    nvvm_intr_range_sm: ?usize = null,
    /// NVVM reflection, enabled by default
    nvvm_reflect_enable: bool = false,
    /// Use old-style Thumb2 if-conversion heuristics
    old_thumb2_ifcvt: bool = false,
    /// Only enable generating memmove in non-nested loops
    only_nonnested_memmove_idiom: bool = false,
    /// Show only simple regions in the graphviz viewer
    only_simple_regions: bool = false,
    /// Use opaque pointers
    opaque_pointers: bool = false,
    openmp_deduce_icv_values: bool = false,
    /// [WIP] Tries to hide the latency of host to device memory transfers
    openmp_hide_memory_transfer_latency: bool = false,
    /// Use optimistic attributes describing 'as-if' properties of runtime calls.
    openmp_ir_builder_optimistic_attributes: bool = false,
    /// Factor for the unroll threshold to account for code simplifications still taking place
    openmp_ir_builder_unroll_threshold_factor: ?usize = null,
    /// Disable OpenMP specific optimizations.
    openmp_opt_disable: bool = false,
    /// Disable OpenMP optimizations that eliminate barriers.
    openmp_opt_disable_barrier_elimination: bool = false,
    /// Disable OpenMP optimizations involving deglobalization.
    openmp_opt_disable_deglobalization: bool = false,
    /// Disable OpenMP optimizations involving folding.
    openmp_opt_disable_folding: bool = false,
    /// Disable function internalization.
    openmp_opt_disable_internalization: bool = false,
    /// Disable OpenMP optimizations involving SPMD-ization.
    openmp_opt_disable_spmdization: bool = false,
    /// Disable OpenMP optimizations that replace the state machine.
    openmp_opt_disable_state_machine_rewrite: bool = false,
    /// Enable the OpenMP region merging optimization.
    openmp_opt_enable_merging: bool = false,
    /// Inline all applicible functions on the device.
    openmp_opt_inline_device: bool = false,
    /// Maximal number of attributor iterations.
    openmp_opt_max_iterations: ?usize = null,
    /// Print the current module after OpenMP optimizations.
    openmp_opt_print_module_after: bool = false,
    /// Print the current module before OpenMP optimizations.
    openmp_opt_print_module_before: bool = false,
    /// Maximum amount of shared memory to use.
    openmp_opt_shared_limit: ?usize = null,
    /// Enables more verbose remarks.
    openmp_opt_verbose_remarks: bool = false,
    openmp_print_gpu_kernels: bool = false,
    openmp_print_icv_values: bool = false,
    /// Maximum optimization to perform
    opt_bisect_limit: ?usize = null,
    /// Print IR to path when opt-bisect-limit is reached
    opt_bisect_print_ir_path: ?[]const u8 = null,
    /// Enable optimized register allocation compilation path.
    optimize_regalloc: bool = false,
    /// Minimum density for building a jump table in an optsize function
    optsize_jump_table_density: ?usize = null,
    /// Dump functions and their MD5 hash to deobfuscate profile data
    orderfile_write_mapping: ?[]const u8 = null,
    /// Relative frequency of outline region to the entry block
    outline_region_freq_percent: ?usize = null,
    /// Ignore existing branch weights on IR and always overwrite.
    overwrite_existing_weights: bool = false,
    /// A debug option to add additional penalty to the computed one.
    partial_inlining_extra_penalty: ?usize = null,
    /// Specify the current profile is used as a partial profile.
    partial_profile: bool = false,
    /// Clearance between two register writes for inserting XOR to avoid partial register update
    partial_reg_update_clearance: ?usize = null,
    /// The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.
    partial_sample_profile_working_set_size_scale_factor: ?usize = null,
    /// Threshold for partial unrolling
    partial_unrolling_threshold: ?usize = null,
    /// Enable optimization remarks from passes whose name match the given regular expression
    pass_remarks: ?[]const u8 = null,
    /// Enable optimization analysis remarks from passes whose name match the given regular expression
    pass_remarks_analysis: ?[]const u8 = null,
    /// Only record optimization remarks from passes whose names match the given regular expression
    pass_remarks_filter: ?[]const u8 = null,
    /// The format used for serializing remarks (default: YAML)
    pass_remarks_format: ?[]const u8 = null,
    /// Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary.
    pass_remarks_hotness_threshold: bool = false,
    /// Enable missed optimization remarks from passes whose name match the given regular expression
    pass_remarks_missed: ?[]const u8 = null,
    /// Output filename for pass remarks
    pass_remarks_output: ?[]const u8 = null,
    /// With PGO, include profile count in optimization remarks
    pass_remarks_with_hotness: bool = false,
    /// Attempt coalescing during PBQP register allocation.
    pbqp_coalescing: bool = false,
    /// Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).
    persist_profile_staleness: bool = false,
    /// Do not instrument functions with the number of critical edges  greater than this threshold.
    pgo_critical_edge_threshold: ?usize = null,
    /// When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation
    pgo_emit_branch_prob: bool = false,
    /// Fix function entry count in profile use.
    pgo_fix_entry_count: bool = false,
    /// Use this option to enable function entry coverage instrumentation.
    pgo_function_entry_coverage: bool = false,
    /// Do not instrument functions smaller than this threshold.
    pgo_function_size_threshold: ?usize = null,
    /// Use this option to turn on/off memory intrinsic size profiling.
    pgo_instr_memop: bool = false,
    /// Use the old CFG function hashing
    pgo_instr_old_cfg_hashing: bool = false,
    /// Use this option to turn on/off SELECT instruction instrumentation.
    pgo_instr_select: bool = false,
    /// Force to instrument function entry basicblock.
    pgo_instrument_entry: bool = false,
    /// Perform matching and annotation of memprof profiles.
    pgo_match_memprof: bool = false,
    /// The minimum count to optimize memory intrinsic calls
    pgo_memop_count_threshold: ?usize = null,
    /// The max version for the optimized memory  intrinsic calls
    pgo_memop_max_version: ?usize = null,
    /// Size-specialize memcmp and bcmp calls
    pgo_memop_optimize_memcmp_bcmp: bool = false,
    /// The percentage threshold for the memory intrinsic calls optimization
    pgo_memop_percent_threshold: ?usize = null,
    /// Scale the memop size counts using the basic  block count value
    pgo_memop_scale_count: bool = false,
    /// Specify the path of profile data file. This ismainly for test purpose.
    pgo_test_profile_file: ?[]const u8 = null,
    /// Specify the path of profile remapping file. This is mainly for test purpose.
    pgo_test_profile_remapping_file: ?[]const u8 = null,
    /// Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remakrs-analysis=pgo.
    pgo_verify_bfi: bool = false,
    /// Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.
    pgo_verify_bfi_cutoff: ?usize = null,
    /// Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).
    pgo_verify_bfi_ratio: ?usize = null,
    /// Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remakrs-analysis=pgo.
    pgo_verify_hot_bfi: bool = false,
    /// A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
    pgo_view_counts: ?enum(u2) {
        none = 0,
        graph = 1,
        text = 2,
    } = null,
    /// A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.
    pgo_view_raw_counts: ?enum(u2) {
        none = 0,
        graph = 1,
        text = 2,
    } = null,
    /// Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.
    pgo_warn_misexpect: bool = false,
    /// Use this option to turn on/off warnings about missing profile data for functions.
    pgo_warn_missing_function: bool = false,
    /// Enable the profile guided size optimizations.
    pgso: bool = false,
    /// Apply the profile guided size optimizations only to cold code.
    pgso_cold_code_only: bool = false,
    /// Apply the profile guided size optimizations only to cold code under instrumentation PGO.
    pgso_cold_code_only_for_instr_pgo: bool = false,
    /// Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.
    pgso_cold_code_only_for_partial_sample_pgo: bool = false,
    /// Apply the profile guided size optimizations only to cold code under sample PGO.
    pgso_cold_code_only_for_sample_pgo: bool = false,
    /// The profile guided size optimization profile summary cutoff for instrumentation profile.
    pgso_cutoff_instr_prof: ?usize = null,
    /// The profile guided size optimization profile summary cutoff for sample profile.
    pgso_cutoff_sample_prof: ?usize = null,
    /// Apply the profile guided size optimizations only if the working set size is large (except for cold code.)
    pgso_lwss_only: bool = false,
    /// Split all critical edges during PHI elimination
    phi_elim_split_all_critical_edges: bool = false,
    /// Control the amount of phi node folding to perform (default = 2)
    phi_node_folding_threshold: ?usize = null,
    /// Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate
    phicse_debug_hash: bool = false,
    /// When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.
    phicse_num_phi_smallsize: ?usize = null,
    /// Force outline regions with live exits
    pi_force_live_exit_outline: bool = false,
    /// Mark outline function calls with ColdCC
    pi_mark_coldcc: bool = false,
    /// Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass
    pipeliner_annotate_for_testing: bool = false,
    pipeliner_dbg_res: bool = false,
    /// Use the experimental peeling code generator for software pipelining
    pipeliner_experimental_cg: bool = false,
    /// Force pipeliner to use specified II.
    pipeliner_force_ii: ?usize = null,
    /// Force pipeliner to use specified issue width.
    pipeliner_force_issue_width: ?usize = null,
    /// Size limit for the MII.
    pipeliner_max_mii: ?usize = null,
    /// Maximum stages allowed in the generated scheduled.
    pipeliner_max_stages: ?usize = null,
    /// Prune dependences between unrelated Phi nodes.
    pipeliner_prune_deps: bool = false,
    /// Prune loop carried order dependences.
    pipeliner_prune_loop_carried: bool = false,
    pipeliner_show_mask: bool = false,
    /// Check that returns are non-poison (for testing)
    poison_checking_function_local: bool = false,
    /// Enable scheduling after register allocation
    post_RA_scheduler: bool = false,
    /// Debug control MBBs that are scheduled
    postra_sched_debugdiv: ?usize = null,
    /// Debug control MBBs that are scheduled
    postra_sched_debugmod: ?usize = null,
    /// Force the use of a base pointer in every function
    ppc_always_use_base_pointer: bool = false,
    /// Use full register names when printing assembly
    ppc_asm_full_reg_names: bool = false,
    /// stress rotate selection in aggressive ppc isel for bit permutations
    ppc_bit_perm_rewriter_stress_rotates: bool = false,
    /// Bucket number per loop for PPC loop chain common
    ppc_chaincommon_max_vars: ?usize = null,
    /// Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4
    ppc_chaincommon_min_threshold: ?usize = null,
    /// Convert eligible reg+reg instructions to reg+imm
    ppc_convert_rr_to_ri: bool = false,
    /// Disable the use of non-volatile CR register fields
    ppc_disable_non_volatile_cr: bool = false,
    /// disable vector permute decomposition
    ppc_disable_perfect_shuffle: bool = false,
    /// Minimal common base load/store instructions triggering DS/DQ form preparation
    ppc_dispprep_min_threshold: ?usize = null,
    /// Potential PHI threshold per loop for PPC loop prep of DQ form
    ppc_dqprep_max_vars: ?usize = null,
    /// Potential PHI threshold per loop for PPC loop prep of DS form
    ppc_dsprep_max_vars: ?usize = null,
    /// enable elimination of sign-extensions
    ppc_eliminate_signext: bool = false,
    /// enable elimination of zero-extensions
    ppc_eliminate_zeroext: bool = false,
    /// Enable using coldcc calling conv for cold internal functions
    ppc_enable_coldcc: bool = false,
    /// Enable spills from gpr to vsr rather than stack
    ppc_enable_gpr_to_vsr_spills: bool = false,
    /// Enable spills in prologue to vector registers.
    ppc_enable_pe_vector_spills: bool = false,
    /// Enable Machine Pipeliner for PPC
    ppc_enable_pipeliner: bool = false,
    /// register pressure factor for the transformations.
    ppc_fma_rp_factor: ?usize = null,
    /// enable register pressure reduce in machine combiner pass.
    ppc_fma_rp_reduction: bool = false,
    /// Enable chain commoning in PPC loop prepare pass.
    ppc_formprep_chain_commoning: bool = false,
    /// Potential common base number threshold per function for PPC loop prep
    ppc_formprep_max_vars: ?usize = null,
    /// prefer update form when ds form is also a update form
    ppc_formprep_prefer_update: bool = false,
    /// prepare update form when the load/store increment is a loop invariant non-const value.
    ppc_formprep_update_nonconst_inc: bool = false,
    /// Enable generating the ISEL instruction.
    ppc_gen_isel: bool = false,
    /// Enable optimizations on complex GEPs
    ppc_gep_opt: bool = false,
    /// Specify the types of comparisons to emit GPR-only code for.
    ppc_gpr_icmps: ?enum(u4) {
        none = 0,
        all = 1,
        i32 = 2,
        i64 = 3,
        nonextin = 4,
        zext = 5,
        zexti32 = 6,
        zexti64 = 7,
        sext = 8,
        sexti32 = 9,
        sexti64 = 10,
    } = null,
    /// Run pre-emit peephole optimizations.
    ppc_late_peephole: bool = false,
    /// Do not add instruction count to lsr cost model
    ppc_lsr_no_insns_cost: bool = false,
    /// Enable the machine combiner pass
    ppc_machine_combiner: bool = false,
    /// Maximum search distance for definition of CR bit spill on ppc
    ppc_max_crbit_spill_dist: ?usize = null,
    /// Use the old (incorrect) instruction latency calculation
    ppc_old_latency_calc: bool = false,
    /// enable optimization of conditional traps
    ppc_opt_conditional_trap: bool = false,
    /// enable PC Relative linker optimization
    ppc_pcrel_linker_opt: bool = false,
    /// Enable scheduling addi instruction as earlyas possible post ra
    ppc_postra_bias_addi: bool = false,
    /// Potential PHI threshold per loop for PPC loop prep of update form
    ppc_preinc_prep_max_vars: ?usize = null,
    /// enable quadword lock-free atomic operations
    ppc_quadword_atomics: bool = false,
    /// Expand eligible cr-logical binary ops to branches
    ppc_reduce_cr_logicals: bool = false,
    /// Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm
    ppc_reg_to_imm_fixed_point: bool = false,
    /// Prints full register names with percent
    ppc_reg_with_percent_prefix: bool = false,
    /// Set the Data Stream Control Register.
    ppc_set_dscr: ?usize = null,
    /// Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates
    ppc_stack_ptr_caller_preserved: bool = false,
    /// Enable tls optimization peephole
    ppc_tls_opt: bool = false,
    /// Enable subregister liveness tracking for PPC
    ppc_track_subreg_liveness: bool = false,
    /// use absolute jump tables on ppc
    ppc_use_absolute_jumptables: bool = false,
    /// Enable use of a base pointer for complex stack frames
    ppc_use_base_pointer: bool = false,
    /// use aggressive ppc isel for bit permutations
    ppc_use_bit_perm_rewriter: bool = false,
    /// Enable static hinting of branches on ppc
    ppc_use_branch_hint: bool = false,
    /// Prints full register names with vs{31-63} as v{0-31}
    ppc_vsr_nums_as_vr: bool = false,
    /// Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
    pragma_unroll_and_jam_threshold: ?usize = null,
    /// Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
    pragma_unroll_threshold: ?usize = null,
    /// The maximum number of SCEV checks allowed with a vectorize(enable) pragma
    pragma_vectorize_scev_check_threshold: ?usize = null,
    /// Instruction schedulers available (before register allocation):
    pre_RA_sched: ?enum(u3) {
        @"vliw-td" = 0,
        @"list-ilp" = 1,
        @"list-hybrid" = 2,
        source = 3,
        @"list-burr" = 4,
        linearize = 5,
        fast = 6,
        default = 7,
    } = null,
    /// Model the cost of loop rotation more precisely by using profile data.
    precise_rotation_cost: bool = false,
    /// Prefer in-loop vector reductions, overriding the targets preference.
    prefer_inloop_reductions: bool = false,
    /// Prefer predicated Move to CSEL
    prefer_no_csel: bool = false,
    /// Tail-folding and predication preferences over creating a scalar epilogue loop.
    prefer_predicate_over_epilogue: ?enum(u2) {
        @"scalar-epilogue" = 0,
        @"predicate-else-scalar-epilogue" = 1,
        @"predicate-dont-vectorize" = 2,
    } = null,
    /// Prefer predicating a reduction operation over an after loop select.
    prefer_predicated_reduction_select: bool = false,
    /// Number of instructions to prefetch ahead
    prefetch_distance: ?usize = null,
    /// Path to the prefetch hints profile. See also -x86-discriminate-memops
    prefetch_hints_file: ?[]const u8 = null,
    /// Control the amount of inlining in pre-instrumentation inliner (default = 75)
    preinline_threshold: ?usize = null,
    /// Convert align attributes to assumptions during inlining.
    preserve_alignment_assumptions_during_inlining: bool = false,
    /// Preserve Comments in outputted assembly
    preserve_as_comments: bool = false,
    /// Print IR after specified passes
    print_after: ?[]const u8 = null,
    /// Print IR after each pass
    print_after_all: bool = false,
    /// Print machine instrs after ISel
    print_after_isel: bool = false,
    /// Print all option values after command line parsing
    print_all_options: bool = false,
    /// Print IR before specified passes
    print_before: ?[]const u8 = null,
    /// Print IR before each pass
    print_before_all: bool = false,
    /// Print before passes that change them
    print_before_changed: bool = false,
    /// Print the block frequency info.
    print_bfi: bool = false,
    /// The option to specify the name of the function whose block frequency info is printed.
    print_bfi_func_name: ?[]const u8 = null,
    /// Print the branch probability info.
    print_bpi: bool = false,
    /// The option to specify the name of the function whose branch probability info is printed.
    print_bpi_func_name: ?[]const u8 = null,
    /// Print changed IRs
    print_changed: ?enum(u3) {
        quiet = 0,
        diff = 1,
        @"diff-quiet" = 2,
        cdiff = 3,
        @"cdiff-quiet" = 4,
        @"dot-cfg" = 5,
        @"dot-cfg-quiet" = 6,
    } = null,
    /// system dot used by change reporters
    print_changed_dot_path: ?[]const u8 = null,
    print_debug_ata: bool = false,
    /// Print out debug counter info after all counters accumulated
    print_debug_counter: bool = false,
    /// Print instructions that the allocator wants to fuse, but the X86 backend currently can't
    print_failed_fuse_candidates: bool = false,
    /// Dump garbage collector data
    print_gc: bool = false,
    /// Print information for functions rejected for importing
    print_import_failures: bool = false,
    /// Print imported functions
    print_imports: bool = false,
    /// Prints comments for instruction based on inline cost analysis
    print_instruction_comments: bool = false,
    /// Print LLVM IR input to isel pass
    print_isel_input: bool = false,
    /// Print LLVM IR produced by the loop-reduce pass
    print_lsr_output: bool = false,
    /// Print the LazyValueInfo cache after JumpThreading
    print_lvi_after_jump_threading: bool = false,
    /// Print the machine block frequency info.
    print_machine_bfi: bool = false,
    /// When printing IR for print-[before|after]{-all} always print a module IR
    print_module_scope: bool = false,
    /// Print the last form of the IR before crash
    print_on_crash: bool = false,
    /// Print non-default options after command line parsing
    print_options: bool = false,
    /// Print a '-passes' compatible string describing the pipeline (best-effort only).
    print_pipeline_passes: bool = false,
    /// style of printing regions
    print_region_style: ?enum(u2) {
        none = 0,
        bb = 1,
        rn = 2,
    } = null,
    /// Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
    print_regmask_num_regs: ?usize = null,
    /// print register usage details collected for analysis.
    print_regusage: bool = false,
    /// When printing machine IR, annotate instructions and blocks with SlotIndexes when available
    print_slotindexes: bool = false,
    /// Print the global id for each value when reading the module summary
    print_summary_global_ids: bool = false,
    /// The OOO window for processor resources during scheduling.
    procres_cost_lim: ?usize = null,
    /// For symbols in profile symbol list, regard their profiles to be accurate. It may be overriden by profile-sample-accurate.
    profile_accurate_for_symsinlist: bool = false,
    /// Use profile info to add section prefix for hot/cold functions
    profile_guided_section_prefix: bool = false,
    /// Profile uses flow sensitive discriminators
    profile_isfs: bool = false,
    /// branch probability threshold in percentage to be considered very likely when profile is available
    profile_likely_prob: ?usize = null,
    /// If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown.
    profile_sample_accurate: bool = false,
    /// If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown.
    profile_sample_block_accurate: bool = false,
    /// Merge context profiles before calculating thresholds.
    profile_summary_contextless: bool = false,
    /// A count is cold if it is below the minimum count to reach this percentile of total counts.
    profile_summary_cutoff_cold: ?usize = null,
    /// A count is hot if it exceeds the minimum count to reach this percentile of total counts.
    profile_summary_cutoff_hot: ?usize = null,
    /// The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
    profile_summary_huge_working_set_size_threshold: ?usize = null,
    /// The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
    profile_summary_large_working_set_size_threshold: ?usize = null,
    /// Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging
    profile_symbol_list_cutoff: ?usize = null,
    /// In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example.
    profile_unknown_in_special_section: bool = false,
    /// Propagate attributes in index
    propagate_attrs: bool = false,
    /// Do not optimize lifetime zones that are broken
    protect_from_escaped_allocas: bool = false,
    /// Use StructurizeCFG IR pass
    r600_ir_structurize: bool = false,
    rafast_ignore_missing_defs: bool = false,
    rdf_dump: bool = false,
    rdf_limit: ?usize = null,
    /// Maximum recursion level
    rdf_liveness_max_rec: ?usize = null,
    /// Enable RDF-based optimizations
    rdf_opt: bool = false,
    /// Verify this pass produces no dead code
    reassociate_geps_verify_no_dead_code: bool = false,
    /// Rebalance address tree only if it is imbalanced
    rebalance_only_imbal: bool = false,
    /// Rebalance address tree only if this allows optimizations
    rebalance_only_opt: bool = false,
    /// Maximum length of recurrence chain when evaluating the benefit of commuting operands
    recurrence_chain_limit: ?usize = null,
    /// Do not inline recursive functions with a stack size that exceeds the specified limit
    recursive_inline_max_stacksize: ?usize = null,
    /// Register allocator to use
    regalloc: ?enum(u3) {
        pbqp = 0,
        greedy = 1,
        fast = 2,
        basic = 3,
        default = 4,
    } = null,
    regalloc_cheap_remat_weight: ?usize = null,
    regalloc_copy_weight: ?usize = null,
    /// Cost for first time use of callee-saved register.
    regalloc_csr_first_time_cost: ?usize = null,
    /// Enable regalloc advisor mode
    regalloc_enable_advisor: ?enum(u2) {
        default = 0,
        release = 1,
        development = 2,
    } = null,
    /// Enable regalloc advisor mode
    regalloc_enable_priority_advisor: ?enum(u2) {
        default = 0,
        release = 1,
        development = 2,
    } = null,
    /// Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.
    regalloc_eviction_max_interference_cutoff: ?usize = null,
    regalloc_expensive_remat_weight: ?usize = null,
    regalloc_load_weight: ?usize = null,
    regalloc_store_weight: ?usize = null,
    /// Run the Fast mode (default mapping)
    regbankselect_fast: bool = false,
    /// Use the Greedy mode (best local mapping)
    regbankselect_greedy: bool = false,
    /// Emit GOTPCRELX/REX_GOTPCRELX instead of GOTPCREL on x86-64 ELF
    relax_elf_relocations: bool = false,
    /// Relax checks of new-value validity
    relax_nv_checks: bool = false,
    /// Choose relocation model
    relocation_model: ?enum(u3) {
        static = 0,
        pic = 1,
        @"dynamic-no-pic" = 2,
        ropi = 3,
        rwpi = 4,
        @"ropi-rwpi" = 5,
    } = null,
    /// Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.
    remarks_section: bool = false,
    /// Re-materialize load from stub in PIC mode
    remat_pic_stub_load: bool = false,
    /// Prefixes for aliases that don't need to be renamed, separated by a comma
    rename_exclude_alias_prefixes: ?[]const u8 = null,
    /// Prefixes for functions that don't need to be renamed, separated by a comma
    rename_exclude_function_prefixes: ?[]const u8 = null,
    /// Prefixes for global values that don't need to be renamed, separated by a comma
    rename_exclude_global_prefixes: ?[]const u8 = null,
    /// Prefixes for structs that don't need to be renamed, separated by a comma
    rename_exclude_struct_prefixes: ?[]const u8 = null,
    /// If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.
    renumber_blocks_before_view: bool = false,
    /// Choose the strategy to replace exit value in IndVarSimplify
    replexitval: ?enum(u3) {
        never = 0,
        cheap = 1,
        unusedindvarinloop = 2,
        noharduse = 3,
        always = 4,
    } = null,
    /// Compute and report stale profile statistical metrics.
    report_profile_staleness: bool = false,
    /// The maximum number of failures to tolerate during fuzzy matching. (default: 400)
    reroll_num_tolerated_failed_matches: ?usize = null,
    /// Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator.
    reserve_regs_for_regalloc: ?[]const u8 = null,
    /// Restrict remat for statepoint operands
    restrict_statepoint_remat: bool = false,
    /// reverse the CSR restore sequence
    reverse_csr_restore_seq: bool = false,
    /// Symbol Rewrite Map
    rewrite_map_file: ?[]const u8 = null,
    /// Limit the length of PHI chains to lookup
    rewrite_phi_limit: ?usize = null,
    /// Disable looking through phis when inserting vsetvlis.
    riscv_disable_insert_vsetvl_phi_opt: bool = false,
    /// Disable two address hints for register allocation
    riscv_disable_regalloc_hints: bool = false,
    /// Disable removal of sext.w
    riscv_disable_sextw_removal: bool = false,
    /// Disable strip W suffix
    riscv_disable_strip_w_suffix: bool = false,
    /// Disable using constant pool for large integers.
    riscv_disable_using_constant_pool_for_large_ints: bool = false,
    /// Enable the redundant copy elimination pass
    riscv_enable_copyelim: bool = false,
    /// Enable the global merge pass
    riscv_enable_global_merge: bool = false,
    /// Enable the machine combiner pass
    riscv_enable_machine_combiner: bool = false,
    riscv_enable_subreg_liveness: bool = false,
    /// Enable strict assertion checking for the dataflow algorithm
    riscv_insert_vsetvl_strict_asserts: bool = false,
    /// Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion
    riscv_lower_ext_max_web_size: ?usize = null,
    /// Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants
    riscv_lower_form_vw_w_with_splat: bool = false,
    /// Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal
    riscv_lower_fp_repeated_divisors: ?usize = null,
    /// The maximum cost used for building integers.
    riscv_max_build_ints_cost: ?usize = null,
    /// Disable the emission of assembler pseudo instructions
    riscv_no_aliases: bool = false,
    /// Prefer whole register move for vector registers.
    riscv_prefer_whole_register_move: bool = false,
    /// The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.
    riscv_v_fixed_length_vector_lmul_max: ?usize = null,
    /// The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.
    riscv_v_register_bit_width_lmul: ?usize = null,
    /// Result used for getMaximumVF query which is used exclusively by SLP vectorizer.  Defaults to 1 which disables SLP.
    riscv_v_slp_max_vf: ?usize = null,
    /// Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.
    riscv_v_vector_bits_max: ?usize = null,
    /// Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.
    riscv_v_vector_bits_min: ?usize = null,
    /// The default maximum header size for automatic loop rotation
    rotation_max_header_size: ?usize = null,
    /// Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.
    rotation_prepare_for_lto: bool = false,
    rs4gc_allow_statepoint_with_no_deopt_info: bool = false,
    rs4gc_clobber_non_live: bool = false,
    rs4gc_remat_derived_at_uses: bool = false,
    /// Run compiler only for specified passes (comma separated list)
    run_pass: ?[]const u8 = null,
    /// Max number of memchecks allowed per eliminated load on average
    runtime_check_per_loop_load_elim: ?usize = null,
    /// Enable relocating counters at runtime.
    runtime_counter_relocation: bool = false,
    /// Threshold (in bytes) for the runtime check guarding the memmove.
    runtime_mem_idiom_threshold: ?usize = null,
    /// When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
    runtime_memory_check_threshold: ?usize = null,
    /// enable safe stack coloring
    safe_stack_coloring: bool = false,
    /// enable safe stack layout
    safe_stack_layout: bool = false,
    safepoint_ir_verifier_print_only: bool = false,
    safestack_use_pointer_address: bool = false,
    /// Emit a warning if less than N% of records in the input profile are matched to the IR.
    sample_profile_check_record_coverage: ?usize = null,
    /// Emit a warning if less than N% of samples in the input profile are matched to the IR.
    sample_profile_check_sample_coverage: ?usize = null,
    /// Threshold for inlining cold callsites
    sample_profile_cold_inline_threshold: ?usize = null,
    /// Try to evenly distribute flow when there are multiple equally likely options.
    sample_profile_even_flow_distribution: bool = false,
    /// Profile file loaded by -sample-profile
    sample_profile_file: ?[]const u8 = null,
    /// Hot callsite threshold for proirity-based sample profile loader inlining.
    sample_profile_hot_inline_threshold: ?usize = null,
    /// Max number of promotions for a single indirect call callsite in sample profile loader
    sample_profile_icp_max_prom: ?usize = null,
    /// Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.
    sample_profile_icp_relative_hotness: ?usize = null,
    /// Skip relative hotness check for ICP up to given number of targets.
    sample_profile_icp_relative_hotness_skip: ?usize = null,
    /// The size growth ratio limit for proirity-based sample profile loader inlining.
    sample_profile_inline_growth_limit: ?usize = null,
    /// The upper bound of size growth limit for proirity-based sample profile loader inlining.
    sample_profile_inline_limit_max: ?usize = null,
    /// The lower bound of size growth limit for proirity-based sample profile loader inlining.
    sample_profile_inline_limit_min: ?usize = null,
    /// Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.
    sample_profile_inline_replay: ?[]const u8 = null,
    /// How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay
    sample_profile_inline_replay_fallback: ?enum(u2) {
        Original = 0,
        AlwaysInline = 1,
        NeverInline = 2,
    } = null,
    /// How sample profile inline replay file is formatted
    sample_profile_inline_replay_format: ?enum(u2) {
        Line = 0,
        LineColumn = 1,
        LineDiscriminator = 2,
        LineColumnDiscriminator = 3,
    } = null,
    /// Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.
    sample_profile_inline_replay_scope: ?enum(u1) {
        Function = 0,
        Module = 1,
    } = null,
    /// Inline cold call sites in profile loader if it's beneficial for code size.
    sample_profile_inline_size: bool = false,
    /// Join isolated components having positive flow.
    sample_profile_join_islands: bool = false,
    /// Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.
    sample_profile_max_propagate_iterations: ?usize = null,
    /// Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled.
    sample_profile_merge_inlinee: bool = false,
    /// Use call site prioritized inlining for sample profile loader.Currently only CSSPGO is supported.
    sample_profile_prioritized_inline: bool = false,
    /// The cost of decreasing a block's count by one.
    sample_profile_profi_cost_block_dec: ?usize = null,
    /// The cost of decreasing the entry block's count by one.
    sample_profile_profi_cost_block_entry_dec: ?usize = null,
    /// The cost of increasing the entry block's count by one.
    sample_profile_profi_cost_block_entry_inc: ?usize = null,
    /// The cost of increasing a block's count by one.
    sample_profile_profi_cost_block_inc: ?usize = null,
    /// The cost of increasing an unknown block's count by one.
    sample_profile_profi_cost_block_unknown_inc: ?usize = null,
    /// The cost of increasing a count of zero-weight block by one.
    sample_profile_profi_cost_block_zero_inc: ?usize = null,
    /// Evenly re-distribute flow among unknown subgraphs.
    sample_profile_rebalance_unknown: bool = false,
    /// Allow sample loader inliner to inline recursive calls.
    sample_profile_recursive_inline: bool = false,
    /// Profile remapping file loaded by -sample-profile
    sample_profile_remapping_file: ?[]const u8 = null,
    /// Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager.
    sample_profile_top_down_load: bool = false,
    /// Use the preinliner decisions stored in profile context.
    sample_profile_use_preinliner: bool = false,
    /// Use profi to infer block and edge counts.
    sample_profile_use_profi: bool = false,
    /// collect control flow for each function
    sanitizer_coverage_control_flow: bool = false,
    /// increments 8-bit counter for every edge
    sanitizer_coverage_inline_8bit_counters: bool = false,
    /// sets a boolean flag for every edge
    sanitizer_coverage_inline_bool_flag: bool = false,
    /// Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges
    sanitizer_coverage_level: ?usize = null,
    /// create a static PC table
    sanitizer_coverage_pc_table: bool = false,
    /// Reduce the number of instrumented blocks
    sanitizer_coverage_prune_blocks: bool = false,
    /// max stack depth tracing
    sanitizer_coverage_stack_depth: bool = false,
    /// Tracing of CMP and similar instructions
    sanitizer_coverage_trace_compares: bool = false,
    /// Tracing of DIV instructions
    sanitizer_coverage_trace_divs: bool = false,
    /// Tracing of GEP instructions
    sanitizer_coverage_trace_geps: bool = false,
    /// Tracing of load instructions
    sanitizer_coverage_trace_loads: bool = false,
    /// Experimental pc tracing
    sanitizer_coverage_trace_pc: bool = false,
    /// pc tracing with a guard
    sanitizer_coverage_trace_pc_guard: bool = false,
    /// Tracing of store instructions
    sanitizer_coverage_trace_stores: bool = false,
    /// Emit PCs for atomic operations.
    sanitizer_metadata_atomics: bool = false,
    /// Emit PCs for covered functions.
    sanitizer_metadata_covered: bool = false,
    /// Emit PCs for start of functions that are subject for use-after-return checking
    sanitizer_metadata_uar: bool = false,
    /// Declare callbacks extern weak, and only call if non-null.
    sanitizer_metadata_weak_callbacks: bool = false,
    /// Control whether the compiler can use scalable vectors to vectorize a loop
    scalable_vectorization: ?enum(u2) {
        off = 0,
        preferred = 1,
        on = 2,
    } = null,
    /// When printing analysis, include information on every instruction
    scalar_evolution_classify_expressions: bool = false,
    /// Handle <= and >= in finite loops
    scalar_evolution_finite_loop: bool = false,
    /// Size of the expression which is considered huge
    scalar_evolution_huge_expr_threshold: ?usize = null,
    /// Max coefficients in AddRec during evolving
    scalar_evolution_max_add_rec_size: ?usize = null,
    /// Maximum depth of recursive arithmetics
    scalar_evolution_max_arith_depth: ?usize = null,
    /// Maximum depth of recursive SExt/ZExt/Trunc
    scalar_evolution_max_cast_depth: ?usize = null,
    /// Maximum depth of recursive constant evolving
    scalar_evolution_max_constant_evolving_depth: ?usize = null,
    /// Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components
    scalar_evolution_max_scc_analysis_depth: ?usize = null,
    /// Maximum depth of recursive SCEV complexity comparisons
    scalar_evolution_max_scev_compare_depth: ?usize = null,
    /// Maximum depth of recursive SCEV operations implication analysis
    scalar_evolution_max_scev_operations_implication_depth: ?usize = null,
    /// Maximum depth of recursive value complexity comparisons
    scalar_evolution_max_value_compare_depth: ?usize = null,
    /// Infer nuw/nsw flags using context where suitable
    scalar_evolution_use_context_for_no_wrap_flag_strenghening: bool = false,
    /// Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time
    scalar_evolution_use_expensive_range_sharpening: bool = false,
    /// Allow the scalarizer pass to scalarize loads and store
    scalarize_load_store: bool = false,
    /// Allow the scalarizer pass to scalarize insertelement/extractelement with variable index
    scalarize_variable_insert_extract: bool = false,
    /// If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.
    scale_partial_sample_profile_working_set_size: bool = false,
    /// Threshold for inlining addition operands into a SCEV
    scev_addops_inline_threshold: ?usize = null,
    /// When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)
    scev_cheap_expansion_budget: ?usize = null,
    /// Threshold for inlining multiplication operands into a SCEV
    scev_mulops_inline_threshold: ?usize = null,
    /// Threshold for switching to iteratively computing SCEV ranges
    scev_range_iter_threshold: ?usize = null,
    /// Verify IR correctness when making sensitive SCEV queries (slow)
    scev_verify_ir: bool = false,
    /// Average inst/cycle whan no target itinerary exists.
    sched_avg_ipc: ?usize = null,
    /// Roughly estimate the number of cycles that 'long latency'instructions take for targets with no itinerary
    sched_high_latency_cycles: ?usize = null,
    sched_preds_closer: bool = false,
    sched_retval_optimization: bool = false,
    /// Use InstrItineraryData for latency lookup
    scheditins: bool = false,
    /// Use TargetSchedModel for latency lookup
    schedmodel: bool = false,
    /// Schedule VSX FMA instruction mutation early
    schedule_ppc_vsx_fma_mutation_early: bool = false,
    /// Minimum gain per loop (in cycles) threshold.
    select_opti_loop_cycle_gain_threshold: ?usize = null,
    /// Gradient gain threshold (%).
    select_opti_loop_gradient_gain_threshold: ?usize = null,
    /// Minimum relative gain per loop threshold (1/X). Defaults to 12.5%
    select_opti_loop_relative_gain_threshold: ?usize = null,
    /// Register allocator to use for SGPRs
    sgpr_regalloc: ?enum(u2) {
        default = 0,
        basic = 1,
        greedy = 2,
        fast = 3,
    } = null,
    /// Print setting flow sensitive branch probabilities
    show_fs_branchprob: bool = false,
    /// Show encoding in .s output
    show_mc_encoding: bool = false,
    /// Max count of stack frame shrink-wraps
    shrink_frame_limit: ?usize = null,
    /// If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.
    simple_loop_unswitch_drop_non_trivial_implicit_null_checks: bool = false,
    /// If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.
    simple_loop_unswitch_guards: bool = false,
    /// Max number of memory uses to explore during partial unswitching analysis
    simple_loop_unswitch_memoryssa_threshold: ?usize = null,
    /// Leave out unnecessary information when printing MIR
    simplify_mir: bool = false,
    /// Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present
    simplifycfg_branch_fold_common_dest_vector_multiplier: ?usize = null,
    /// Maximum cost of combining conditions when folding branches
    simplifycfg_branch_fold_threshold: ?usize = null,
    /// Hoist common instructions up to the parent block
    simplifycfg_hoist_common: bool = false,
    /// Allow reordering across at most this many instructions when hoisting
    simplifycfg_hoist_common_skip_limit: ?usize = null,
    /// Hoist conditional stores if an unconditional store precedes
    simplifycfg_hoist_cond_stores: bool = false,
    /// Max size of a block which is still considered small enough to thread through
    simplifycfg_max_small_block_size: ?usize = null,
    /// Allow SimplifyCFG to merge invokes together when appropriate
    simplifycfg_merge_compatible_invokes: bool = false,
    /// Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
    simplifycfg_merge_cond_stores: bool = false,
    /// When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
    simplifycfg_merge_cond_stores_aggressively: bool = false,
    /// Temorary development switch used to gradually uplift SimplifyCFG into preserving DomTree,
    simplifycfg_require_and_preserve_domtree: bool = false,
    /// Sink common instructions down to the end block
    simplifycfg_sink_common: bool = false,
    /// Sink common instructions (default = false)
    sink_common_insts: bool = false,
    /// Do not sink instructions that require cloning unless they execute less than this percent of the time.
    sink_freq_percent_threshold: ?usize = null,
    /// Sink instructions into cycles to avoid register spills
    sink_insts_to_avoid_spills: bool = false,
    /// MIPS: Skip branch expansion pass.
    skip_mips_long_branch: bool = false,
    /// Suppress counter promotion if exit blocks contain ret.
    skip_ret_exit_block: bool = false,
    /// Allow slot1 store and slot0 load
    slot1_store_slot0_load: bool = false,
    /// The maximum look-ahead depth for operand reordering scores
    slp_max_look_ahead_depth: ?usize = null,
    /// Attempt to vectorize for this register size in bits
    slp_max_reg_size: ?usize = null,
    /// The maximum look-ahead depth for searching best rooting option
    slp_max_root_look_ahead_depth: ?usize = null,
    /// Maximum depth of the lookup for consecutive stores.
    slp_max_store_lookup: ?usize = null,
    /// Maximum SLP vectorization factor (0=unlimited)
    slp_max_vf: ?usize = null,
    /// Attempt to vectorize for this register size in bits
    slp_min_reg_size: ?usize = null,
    /// Only vectorize small trees if they are fully vectorizable
    slp_min_tree_size: ?usize = null,
    /// Limit the recursion depth when building a vectorizable tree
    slp_recursion_max_depth: ?usize = null,
    /// Limit the size of the SLP scheduling region per block
    slp_schedule_budget: ?usize = null,
    /// Only vectorize if you gain more than this number
    slp_threshold: ?usize = null,
    /// Attempt to vectorize horizontal reductions
    slp_vectorize_hor: bool = false,
    /// Attempt to vectorize horizontal reductions feeding into a store
    slp_vectorize_hor_store: bool = false,
    /// The cost of a loop that is considered 'small' by the interleaver.
    small_loop_cost: ?usize = null,
    /// Sort profiled recursion by edge weights.
    sort_profiled_scc_member: bool = false,
    /// In the report, sort the timers in each group in wall clock time order
    sort_timers: bool = false,
    /// Restrict range of BPcc/FBPfcc instructions (DEBUG)
    sparc_bpcc_offset_bits: ?usize = null,
    /// Relax out of range conditional branches
    sparc_enable_branch_relax: bool = false,
    /// Reserve application registers (%g2-%g4)
    sparc_reserve_app_registers: bool = false,
    /// Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
    spec_exec_max_not_hoisted: ?usize = null,
    /// Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
    spec_exec_max_speculation_cost: ?usize = null,
    /// Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
    spec_exec_only_if_divergent_target: bool = false,
    /// Allow exactly one expensive instruction to be speculatively executed
    speculate_one_expensive_inst: bool = false,
    /// The max number of exiting blocks of a loop to allow  speculative counter promotion
    speculative_counter_promotion_max_exiting: ?usize = null,
    /// When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.
    speculative_counter_promotion_to_loop: bool = false,
    /// Specify O2(not Os) spill func threshold
    spill_func_threshold: ?usize = null,
    /// Specify Os spill func threshold
    spill_func_threshold_Os: ?usize = null,
    /// Enable cross-cu references in DWO files
    split_dwarf_cross_cu_references: bool = false,
    /// Specify the name of the .dwo file to encode in the DWARF output
    split_dwarf_file: ?[]const u8 = null,
    /// .dwo output filename
    split_dwarf_output: ?[]const u8 = null,
    /// Split out cold basic blocks from machine functions based on profile information
    split_machine_functions: bool = false,
    /// Spill mode for splitting live ranges
    split_spill_mode: ?enum(u2) {
        default = 0,
        size = 1,
        speed = 2,
    } = null,
    spp_all_backedges: bool = false,
    spp_counted_loop_trip_width: ?usize = null,
    spp_no_backedge: bool = false,
    spp_no_call: bool = false,
    spp_no_entry: bool = false,
    spp_print_base_pointers: bool = false,
    spp_print_liveset: bool = false,
    spp_print_liveset_size: bool = false,
    spp_rematerialization_threshold: ?usize = null,
    spp_split_backedge: bool = false,
    sroa_strict_inbounds: bool = false,
    ssc_dce_limit: ?usize = null,
    stack_safety_max_iterations: ?usize = null,
    stack_safety_print: bool = false,
    stack_safety_run: bool = false,
    /// Emit a section containing stack size metadata
    stack_size_section: bool = false,
    /// Order local stack symbols.
    stack_symbol_ordering: bool = false,
    /// Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).
    stack_tagging_first_slot_opt: bool = false,
    /// merge stack variable initializers with tagging when possible
    stack_tagging_merge_init: bool = false,
    stack_tagging_merge_init_scan_limit: ?usize = null,
    stack_tagging_merge_init_size_limit: ?usize = null,
    /// merge settag instruction in function epilog
    stack_tagging_merge_settag: bool = false,
    /// Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).
    stack_tagging_unchecked_ld_st: ?enum(u2) {
        never = 0,
        safe = 1,
        always = 2,
    } = null,
    /// Use Stack Safety analysis results
    stack_tagging_use_stack_safety: bool = false,
    /// Treat stack lifetimes as starting on first use, not on START marker.
    stackcoloring_lifetime_start_on_first_use: bool = false,
    /// Specify the stackmap encoding version (default = 3)
    stackmap_version: ?usize = null,
    /// Force align the stack to the minimum alignment
    stackrealign: bool = false,
    /// Resume compilation after a specific pass
    start_after: ?[]const u8 = null,
    /// Resume compilation before a specific pass
    start_before: ?[]const u8 = null,
    /// Use full module build paths in the profile counter names for static functions.
    static_func_full_module_prefix: bool = false,
    /// Strip specified level of directory name from source path in the profile counter name for static functions.
    static_func_strip_dirname_prefix: ?usize = null,
    /// branch probability threshold in percentageto be considered very likely
    static_likely_prob: ?usize = null,
    /// Enable statistics output from program (available with Asserts)
    stats: bool = false,
    /// Display statistics as json data
    stats_json: bool = false,
    /// Stop compilation after a specific pass
    stop_after: ?[]const u8 = null,
    /// Stop compilation before a specific pass
    stop_before: ?[]const u8 = null,
    /// Enable conflict detection in loop-access analysis
    store_to_load_forwarding_conflict_detection: bool = false,
    /// Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare
    stress_cgp_ext_ld_promotion: bool = false,
    /// Stress test store(extract) optimizations in CodeGenPrepare
    stress_cgp_store_extract: bool = false,
    /// Turn all knobs to 11
    stress_early_ifcvt: bool = false,
    /// Limit all regclasses to N registers
    stress_regalloc: ?usize = null,
    /// use strict dwarf
    strict_dwarf: bool = false,
    /// Allow relaxed uniform region checks
    structurizecfg_relaxed_uniform_regions: bool = false,
    /// Force whether the StructurizeCFG pass skips uniform regions
    structurizecfg_skip_uniform_regions: bool = false,
    /// The summary file to use for function importing.
    summary_file: ?[]const u8 = null,
    sve_gather_overhead: ?usize = null,
    sve_scatter_overhead: ?usize = null,
    /// Control the use of vectorisation using tail-folding for SVE:
    sve_tail_folding: ?[]const u8 = null,
    /// Determine when the Swift async frame pointer should be set
    swift_async_fp: ?enum(u2) {
        auto = 0,
        always = 1,
        never = 2,
    } = null,
    /// Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization
    switch_peel_threshold: ?usize = null,
    /// Convert switches into an integer range comparison (default = false)
    switch_range_to_icmp: bool = false,
    /// Convert switches to lookup tables (default = false)
    switch_to_lookup: bool = false,
    /// Enable subregister liveness tracking for SystemZ (experimental)
    systemz_subreg_liveness: bool = false,
    t2_reduce_limit: ?usize = null,
    t2_reduce_limit2: ?usize = null,
    t2_reduce_limit3: ?usize = null,
    /// Maximum instructions to consider tail duplicating blocks that end with indirect branches.
    tail_dup_indirect_size: ?usize = null,
    tail_dup_limit: ?usize = null,
    /// Perform tail duplication during placement. Creates more fallthrough opportunites in outline branches.
    tail_dup_placement: bool = false,
    /// Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict.
    tail_dup_placement_aggressive_threshold: ?usize = null,
    /// Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.
    tail_dup_placement_penalty: ?usize = null,
    /// Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict.
    tail_dup_placement_threshold: ?usize = null,
    /// If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.
    tail_dup_profile_percent_threshold: ?usize = null,
    /// Maximum instructions to consider tail duplicating
    tail_dup_size: ?usize = null,
    /// Verify sanity of PHI instructions during taildup
    tail_dup_verify: bool = false,
    /// Min number of instructions to consider tail merging
    tail_merge_size: ?usize = null,
    /// Max number of predecessors to consider tail merging
    tail_merge_threshold: ?usize = null,
    /// MVE tail-predication pass options
    tail_predication: ?enum(u3) {
        disabled = 0,
        @"enabled-no-reductions" = 1,
        enabled = 2,
        @"force-enabled-no-reductions" = 3,
        @"force-enabled" = 4,
    } = null,
    /// Turn fastcc calls into tail calls by (potentially) changing ABI.
    tailcallopt: bool = false,
    /// The name of the ABI to be targeted from the backend.
    target_abi: ?[]const u8 = null,
    /// Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse
    temporal_reuse_threshold: ?usize = null,
    /// Apply the terminal rule
    terminal_rule: bool = false,
    /// Output simple (non-protobuf) log.
    tfutils_use_simplelogger: bool = false,
    /// Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.
    thinlto_assume_merged: bool = false,
    /// Synthesize entry counts based on the summary
    thinlto_synthesize_entry_counts: bool = false,
    /// Choose threading model
    thread_model: ?enum(u1) {
        posix = 0,
        single = 1,
    } = null,
    threads: ?usize = null,
    /// Repeat compilation N times for timing
    time_compilations: ?usize = null,
    /// Time each pass, printing elapsed time for each on exit
    time_passes: bool = false,
    /// Time each pass run, printing elapsed time for each run on exit
    time_passes_per_run: bool = false,
    /// Record time trace
    time_trace: bool = false,
    /// Specify time trace file destination
    time_trace_file: ?[]const u8 = null,
    /// Minimum time granularity (in microseconds) traced by time profiler
    time_trace_granularity: ?usize = null,
    /// We don't interleave loops with a estimated constant trip count below this number
    tiny_trip_count_interleave_threshold: ?usize = null,
    /// hoist the TLS loads in PIC model to eliminate redundant TLS address calculation.
    tls_load_hoist: bool = false,
    /// Bit size of immediate TLS offsets
    tls_size: ?usize = null,
    /// Trace global value placement
    trace_gv_placement: bool = false,
    /// Enables tracing of vector stores
    trace_hex_vector_stores_only: bool = false,
    /// Enable -time-passes memory tracking (this may be slow)
    track_memory: bool = false,
    /// Emit a call to trap function rather than a trap instruction
    trap_func: ?[]const u8 = null,
    /// Enable generating trap for unreachable
    trap_unreachable: bool = false,
    /// Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error
    treat_scalable_fixed_error_as_warning: bool = false,
    /// Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable.
    triangle_chain_count: ?usize = null,
    trim_var_locs: bool = false,
    /// Emit special compound instrumentation for reads-before-writes
    tsan_compound_read_before_write: bool = false,
    /// Emit special instrumentation for accesses to volatiles
    tsan_distinguish_volatile: bool = false,
    /// Handle C++ exceptions (insert cleanup blocks for unwinding)
    tsan_handle_cxx_exceptions: bool = false,
    /// Instrument atomics
    tsan_instrument_atomics: bool = false,
    /// Instrument function entry and exit
    tsan_instrument_func_entry_exit: bool = false,
    /// Instrument memintrinsics (memset/memcpy/memmove)
    tsan_instrument_memintrinsics: bool = false,
    /// Instrument memory accesses
    tsan_instrument_memory_accesses: bool = false,
    /// Do not eliminate read instrumentation for read-before-writes
    tsan_instrument_read_before_write: bool = false,
    /// Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)
    two_entry_phi_node_folding_threshold: ?usize = null,
    /// Coalesce copies by rescheduling (default=true)
    twoaddr_reschedule: bool = false,
    /// Calculate intrinsics cost based only on argument types
    type_based_intrinsic_cost: bool = false,
    /// How many idle instructions we would like before certain undef register reads
    undef_reg_clearance: ?usize = null,
    /// Give unique names to every basic block section
    unique_basic_block_section_names: bool = false,
    /// Give unique names to every section
    unique_section_names: bool = false,
    /// Weight of the branch unlikely to be taken (default = 1)
    unlikely_branch_weight: ?usize = null,
    /// Allows loop nests to be peeled.
    unroll_allow_loop_nests_peeling: bool = false,
    /// Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
    unroll_allow_partial: bool = false,
    /// Allows loops to be peeled when the dynamic trip count is known to be low.
    unroll_allow_peeling: bool = false,
    /// Allow generation of a loop remainder (extra iterations) when unrolling a loop.
    unroll_allow_remainder: bool = false,
    /// Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
    unroll_and_jam_count: ?usize = null,
    /// Threshold to use for inner loop when doing unroll and jam.
    unroll_and_jam_threshold: ?usize = null,
    /// Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
    unroll_count: ?usize = null,
    /// Force a peel count regardless of profiling information.
    unroll_force_peel_count: ?usize = null,
    /// Set the max unroll count for full unrolling, for testing purposes
    unroll_full_max_count: ?usize = null,
    /// Set the max unroll count for partial and runtime unrolling, fortesting purposes
    unroll_max_count: ?usize = null,
    /// Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
    unroll_max_iteration_count_to_analyze: ?usize = null,
    /// The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
    unroll_max_percent_threshold_boost: ?usize = null,
    /// The max of trip count upper bound that is considered in unrolling
    unroll_max_upperbound: ?usize = null,
    /// The cost threshold for loop unrolling when optimizing for size
    unroll_optsize_threshold: ?usize = null,
    /// The cost threshold for partial loop unrolling
    unroll_partial_threshold: ?usize = null,
    /// Set the unroll peeling count, for testing purposes
    unroll_peel_count: ?usize = null,
    /// Max average trip count which will cause loop peeling.
    unroll_peel_max_count: ?usize = null,
    /// Allow the loop remainder to be unrolled.
    unroll_remainder: bool = false,
    /// Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
    unroll_revisit_child_loops: bool = false,
    /// Unroll loops with run-time trip counts
    unroll_runtime: bool = false,
    /// Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
    unroll_runtime_epilog: bool = false,
    /// Allow runtime unrolling for loops with multiple exits, when epilog is generated
    unroll_runtime_multi_exit: bool = false,
    /// Assume the non latch exit block to be predictable
    unroll_runtime_other_exit_predictable: bool = false,
    /// The cost threshold for loop unrolling
    unroll_threshold: ?usize = null,
    /// Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations
    unroll_threshold_aggressive: ?usize = null,
    /// Default threshold (max size of unrolled loop), used in all but O3 optimizations
    unroll_threshold_default: ?usize = null,
    /// Verify domtree after unrolling
    unroll_verify_domtree: bool = false,
    /// Verify loopinfo after unrolling
    unroll_verify_loopinfo: bool = false,
    /// Number of unswitch candidates that are ignored when calculating cost multiplier.
    unswitch_num_initial_unscaled_candidates: ?usize = null,
    /// Toplevel siblings divisor for cost multiplier.
    unswitch_siblings_toplevel_div: ?usize = null,
    /// The cost threshold for unswitching a loop.
    unswitch_threshold: ?usize = null,
    /// Update pseudo probe distribution factor
    update_pseudo_probe: bool = false,
    /// Update return attributes on calls within inlined body
    update_return_attrs: bool = false,
    /// Use .ctors instead of .init_array.
    use_ctors: bool = false,
    /// Use llvm.dbg.addr for all local variables
    use_dbg_addr: bool = false,
    /// Deref attributes and metadata infer facts at definition only
    use_dereferenceable_at_point_semantics: ?usize = null,
    /// Use base address specifiers in debug_ranges
    use_dwarf_ranges_base_address_specifier: bool = false,
    /// Emit the GNU .debug_macro format with DWARF <5
    use_gnu_debug_macro: bool = false,
    /// turn the LegacyDivergenceAnalysis into a wrapper for GPUDivergenceAnalysis
    use_gpu_divergence_analysis: bool = false,
    /// Apply an iterative post-processing to infer correct BFI counts
    use_iterative_bfi_inference: bool = false,
    /// Disable the usage of LEB128 directives, and generate .byte instead.
    use_leb128_directives: bool = false,
    /// Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
    use_lir_code_size_heurs: bool = false,
    /// use Machine Branch Probability Info
    use_mbpi: bool = false,
    use_newer_candidate: bool = false,
    /// Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.
    use_noalias_intrinsic_during_inlining: bool = false,
    /// Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.
    use_profiled_call_graph: bool = false,
    /// Allow using registers for non pointer deopt args
    use_registers_for_deopt_values: bool = false,
    /// Allow using registers for gc pointer in landing pad
    use_registers_for_gc_values_in_landing_pad: bool = false,
    /// Use segment set for the computation of the live ranges of physregs.
    use_segment_set_for_physregs: bool = false,
    /// Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.
    use_source_filename_for_promoted_locals: bool = false,
    /// Enable use of TBAA during MI DAG construction
    use_tbaa_in_sched_mi: bool = false,
    /// Make an absence of debug location information explicit.
    use_unknown_locations: ?enum(u2) {
        Default = 0,
        Enable = 1,
        Disable = 2,
    } = null,
    /// Enable the AIX Extended Altivec ABI.
    vec_extabi: bool = false,
    /// Max number of instructions to scan for vector combining.
    vector_combine_max_scan_instrs: ?usize = null,
    /// Vector functions library
    vector_library: ?enum(u3) {
        none = 0,
        Accelerate = 1,
        Darwin_libsystem_m = 2,
        @"LIBMVEC-X86" = 3,
        MASSV = 4,
        SVML = 5,
        sleefgnuabi = 6,
    } = null,
    /// Run the Loop vectorization passes
    vectorize_loops: bool = false,
    /// The maximum allowed number of runtime memory checks
    vectorize_memory_check_threshold: ?usize = null,
    /// Max number of stores to be predicated behind an if.
    vectorize_num_stores_pred: ?usize = null,
    /// The maximum number of SCEV checks allowed.
    vectorize_scev_check_threshold: ?usize = null,
    /// Run the SLP vectorization passes
    vectorize_slp: bool = false,
    /// Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.
    vectorizer_maximize_bandwidth: bool = false,
    /// Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.
    vectorizer_min_trip_count: ?usize = null,
    /// Verify machine code after expanding ARM pseudos
    verify_arm_pseudo_expand: bool = false,
    /// Enable verification of assumption cache
    verify_assumption_cache: bool = false,
    verify_cfg_preserved: bool = false,
    /// Verify Call Frame Information instructions
    verify_cfiinstrs: bool = false,
    /// Verify machine instrs before and after register coalescing
    verify_coalescing: bool = false,
    /// Verify dominator info (time consuming)
    verify_dom_info: bool = false,
    /// Verify the ScalarEvolution result after running indvars. Has no effect in release builds. (Note: this adds additional SCEV queries potentially changing the analysis result)
    verify_indvars: bool = false,
    /// Verify loop info (time consuming)
    verify_loop_info: bool = false,
    /// Verify loop lcssa form (time consuming)
    verify_loop_lcssa: bool = false,
    /// Verify machine dominator info (time consuming)
    verify_machine_dom_info: bool = false,
    /// Verify generated machine code
    verify_machineinstrs: bool = false,
    /// Enable verification of MemorySSA.
    verify_memoryssa: bool = false,
    /// Verify machine instrs before and after machine scheduling
    verify_misched: bool = false,
    /// Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating
    verify_noalias_scope_decl_dom: bool = false,
    /// Verify PredicateInfo in legacy printer pass.
    verify_predicateinfo: bool = false,
    /// Do pseudo probe verification
    verify_pseudo_probe: bool = false,
    /// The option to specify the name of the functions to verify.
    verify_pseudo_probe_funcs: ?[]const u8 = null,
    /// Verify during register allocation
    verify_regalloc: bool = false,
    /// Verify region info (time consuming)
    verify_region_info: bool = false,
    /// Verify ScalarEvolution's backedge taken counts (slow)
    verify_scev: bool = false,
    /// Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
    verify_scev_maps: bool = false,
    /// Enable stricter verification with -verify-scev is passed
    verify_scev_strict: bool = false,
    /// Display the version of this program
    version: bool = false,
    /// Register allocator to use for VGPRs
    vgpr_regalloc: ?enum(u2) {
        basic = 0,
        greedy = 1,
        fast = 2,
    } = null,
    /// The option to specify the name of the function whose CFG will be displayed.
    view_bfi_func_name: ?[]const u8 = null,
    /// Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
    view_block_freq_propagation_dags: ?enum(u2) {
        none = 0,
        fraction = 1,
        integer = 2,
        count = 3,
    } = null,
    /// Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
    view_block_layout_with_bfi: ?enum(u2) {
        none = 0,
        fraction = 1,
        integer = 2,
        count = 3,
    } = null,
    /// Pop up a window to show edge bundle graphs
    view_edge_bundles: bool = false,
    /// An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
    view_hot_freq_percent: ?usize = null,
    /// Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
    view_machine_block_freq_propagation_dags: ?enum(u2) {
        none = 0,
        fraction = 1,
        integer = 2,
        count = 3,
    } = null,
    /// Display the SLP trees with Graphviz
    view_slp_tree: bool = false,
    /// High register pressure threhold.
    vliw_misched_reg_pressure: ?usize = null,
    /// The average number of profile counters allocated per value profiling site.
    vp_counters_per_site: ?usize = null,
    /// Do static counter allocation for value profiler
    vp_static_alloc: bool = false,
    /// Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).
    vplan_build_stress_test: bool = false,
    /// Use dot format instead of plain text when dumping VPlans
    vplan_print_in_dot_format: bool = false,
    /// Verify VPlan H-CFG.
    vplan_verify_hcfg: bool = false,
    /// WebAssembly: output implicit locals in instruction output for test purposes only.
    wasm_disable_explicit_locals: bool = false,
    /// WebAssembly exception handling
    wasm_enable_eh: bool = false,
    /// WebAssembly setjmp/longjmp handling
    wasm_enable_sjlj: bool = false,
    /// WebAssembly: output stack registers in instruction output for test purposes only.
    wasm_keep_registers: bool = false,
    /// Enable whole program visibility
    whole_program_visibility: bool = false,
    /// Maximum number of call targets per call site to enable branch funnels
    wholeprogramdevirt_branch_funnel_threshold: ?usize = null,
    /// Type of checking for incorrect devirtualizations
    wholeprogramdevirt_check: ?enum(u2) {
        none = 0,
        trap = 1,
        fallback = 2,
    } = null,
    /// Print index-based devirtualization messages
    wholeprogramdevirt_print_index_based: bool = false,
    /// Read summary from given bitcode or YAML file before running pass
    wholeprogramdevirt_read_summary: ?[]const u8 = null,
    /// Prevent function(s) from being devirtualized
    wholeprogramdevirt_skip: ?[]const u8 = null,
    /// What to do with the summary when running this pass
    wholeprogramdevirt_summary_action: ?enum(u2) {
        none = 0,
        import = 1,
        @"export" = 2,
    } = null,
    /// Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML
    wholeprogramdevirt_write_summary: ?[]const u8 = null,
    /// Write relative block frequency to function summary
    write_relbf_to_summary: bool = false,
    /// Specify types of branches to align (plus separated list of types):
    x86_align_branch: ?[]const u8 = null,
    /// Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches.
    x86_align_branch_boundary: ?usize = null,
    /// Enable setting constant bits to reduce size of mask immediates
    x86_and_imm_shrink: bool = false,
    /// Choose style of code to emit from X86 backend:
    x86_asm_syntax: ?enum(u1) {
        att = 0,
        intel = 1,
    } = null,
    /// Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution.
    x86_branches_within_32B_boundaries: bool = false,
    /// When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.
    x86_bypass_prefetch_instructions: bool = false,
    /// Enable the X86 cmov-to-branch optimization.
    x86_cmov_converter: bool = false,
    /// Convert all cmovs to branches.
    x86_cmov_converter_force_all: bool = false,
    /// Convert cmovs to branches whenever they have memory operands.
    x86_cmov_converter_force_mem_operand: bool = false,
    /// Minimum gain per loop (in cycles) threshold.
    x86_cmov_converter_threshold: ?usize = null,
    /// X86: Disable Store Forwarding Blocks fixup.
    x86_disable_avoid_SFB: bool = false,
    /// Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.
    x86_discriminate_memops: bool = false,
    /// Enable early if-conversion on X86
    x86_early_ifcvt: bool = false,
    /// Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.
    x86_experimental_lvi_inline_asm_hardening: bool = false,
    /// Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.
    x86_experimental_pref_innermost_loop_alignment: ?usize = null,
    /// Use LoadSDNode and StoreSDNode instead of AtomicSDNode for unordered atomic loads and stores respectively.
    x86_experimental_unordered_atomic_isel: bool = false,
    /// Enable X86 indirect branch tracking pass.
    x86_indirect_branch_tracking: bool = false,
    /// For each function, emit a dot graph depicting potential LVI gadgets
    x86_lvi_load_dot: bool = false,
    /// For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences
    x86_lvi_load_dot_only: bool = false,
    /// For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only
    x86_lvi_load_dot_verify: bool = false,
    /// Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security.
    x86_lvi_load_no_cbranch: bool = false,
    /// Specify a plugin to optimize LFENCE insertion
    x86_lvi_load_opt_plugin: ?[]const u8 = null,
    /// Enable the machine combiner pass
    x86_machine_combiner: bool = false,
    /// Pad previous instructions to implement align directives
    x86_pad_for_align: bool = false,
    /// Pad previous instructions to implement branch alignment
    x86_pad_for_branch_align: bool = false,
    /// Maximum number of prefixes to use for padding
    x86_pad_max_prefix_size: ?usize = null,
    /// Enable promoting aligned anyext load to wider load
    x86_promote_anyext_load: bool = false,
    /// Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)
    x86_seses_enable_without_lvi_cfi: bool = false,
    /// Omit all lfences before branch instructions.
    x86_seses_omit_branch_lfences: bool = false,
    /// Omit all lfences other than the first to be placed in a basic block.
    x86_seses_one_lfence_per_bb: bool = false,
    /// Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.
    x86_seses_only_lfence_non_const: bool = false,
    /// X86: Number of instructions backward to inspect for store forwarding blocks.
    x86_sfb_inspection_limit: ?usize = null,
    /// Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.
    x86_slh_fence_call_and_ret: bool = false,
    /// Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.
    x86_slh_indirect: bool = false,
    /// Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.
    x86_slh_ip: bool = false,
    /// Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.
    x86_slh_lfence: bool = false,
    /// Sanitize loads from memory. When disable, no significant security is provided.
    x86_slh_loads: bool = false,
    /// Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.
    x86_slh_post_load: bool = false,
    /// Force enable speculative load hardening
    x86_speculative_load_hardening: bool = false,
    /// Enable the tile register allocation pass
    x86_tile_ra: bool = false,
    /// Enable use of a base pointer for complex stack frames
    x86_use_base_pointer: bool = false,
    /// Use fast short rep mov in memcpy lowering
    x86_use_fsrm_for_memcpy: bool = false,
    /// Minimize AVX to SSE transition penalty
    x86_use_vzeroupper: bool = false,
    /// Emit the XCOFF traceback table
    xcoff_traceback_table: bool = false,
    /// Maximum number of threads (for emulation thread-local storage)
    xcore_max_threads: ?usize = null,
    pub const size_of: comptime_int = @sizeOf(@This());
    pub const align_of: comptime_int = @alignOf(@This());
    pub fn formatWriteBuf(cmd: *LLCCommand, llc_exe: []const u8, buf: [*]u8) usize {
        @setRuntimeSafety(false);
        var ptr: [*]u8 = buf;
        ptr = fmt.strcpyEqu(ptr, llc_exe);
        ptr[0] = 0;
        ptr += 1;
        if (cmd.aarch64_a57_fp_load_balancing_force_all) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-a57-fp-load-balancing-force-all\x00");
        }
        if (cmd.aarch64_a57_fp_load_balancing_override) |aarch64_a57_fp_load_balancing_override| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-a57-fp-load-balancing-override\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_a57_fp_load_balancing_override);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_bcc_offset_bits) |aarch64_bcc_offset_bits| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-bcc-offset-bits\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_bcc_offset_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_cbz_offset_bits) |aarch64_cbz_offset_bits| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-cbz-offset-bits\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_cbz_offset_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_ccmp_limit) |aarch64_ccmp_limit| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-ccmp-limit\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_ccmp_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-early-ifcvt\x00");
        }
        if (cmd.aarch64_elf_ldtls_generation) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-elf-ldtls-generation\x00");
        }
        if (cmd.aarch64_enable_atomic_cfg_tidy) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-atomic-cfg-tidy\x00");
        }
        if (cmd.aarch64_enable_branch_relax) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-branch-relax\x00");
        }
        if (cmd.aarch64_enable_branch_targets) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-branch-targets\x00");
        }
        if (cmd.aarch64_enable_ccmp) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-ccmp\x00");
        }
        if (cmd.aarch64_enable_collect_loh) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-collect-loh\x00");
        }
        if (cmd.aarch64_enable_compress_jump_tables) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-compress-jump-tables\x00");
        }
        if (cmd.aarch64_enable_cond_br_tune) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-cond-br-tune\x00");
        }
        if (cmd.aarch64_enable_condopt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-condopt\x00");
        }
        if (cmd.aarch64_enable_copy_propagation) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-copy-propagation\x00");
        }
        if (cmd.aarch64_enable_copyelim) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-copyelim\x00");
        }
        if (cmd.aarch64_enable_dead_defs) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-dead-defs\x00");
        }
        if (cmd.aarch64_enable_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-early-ifcvt\x00");
        }
        if (cmd.aarch64_enable_falkor_hwpf_fix) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-falkor-hwpf-fix\x00");
        }
        if (cmd.aarch64_enable_gep_opt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-gep-opt\x00");
        }
        if (cmd.aarch64_enable_gisel_ldst_postlegal) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-gisel-ldst-postlegal\x00");
        }
        if (cmd.aarch64_enable_gisel_ldst_prelegal) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-gisel-ldst-prelegal\x00");
        }
        if (cmd.aarch64_enable_global_isel_at_O) |aarch64_enable_global_isel_at_O| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-global-isel-at-O\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_enable_global_isel_at_O);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_enable_global_merge) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-global-merge\x00");
        }
        if (cmd.aarch64_enable_ldst_opt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-ldst-opt\x00");
        }
        if (cmd.aarch64_enable_logical_imm) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-logical-imm\x00");
        }
        if (cmd.aarch64_enable_loop_data_prefetch) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-loop-data-prefetch\x00");
        }
        if (cmd.aarch64_enable_mcr) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-mcr\x00");
        }
        if (cmd.aarch64_enable_mgather_combine) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-mgather-combine\x00");
        }
        if (cmd.aarch64_enable_nonlazybind) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-nonlazybind\x00");
        }
        if (cmd.aarch64_enable_promote_const) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-promote-const\x00");
        }
        if (cmd.aarch64_enable_simd_scalar) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-simd-scalar\x00");
        }
        if (cmd.aarch64_enable_stp_suppress) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-stp-suppress\x00");
        }
        if (cmd.aarch64_enable_sve_intrinsic_opts) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-enable-sve-intrinsic-opts\x00");
        }
        if (cmd.aarch64_insert_extract_base_cost) |aarch64_insert_extract_base_cost| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-insert-extract-base-cost\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_insert_extract_base_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_load_store_renaming) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-load-store-renaming\x00");
        }
        if (cmd.aarch64_load_store_scan_limit) |aarch64_load_store_scan_limit| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-load-store-scan-limit\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_load_store_scan_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_mark_bti_property) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-mark-bti-property\x00");
        }
        if (cmd.aarch64_max_xors) |aarch64_max_xors| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-max-xors\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_max_xors);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_neon_syntax) |aarch64_neon_syntax| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-neon-syntax\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(aarch64_neon_syntax));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_order_frame_objects) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-order-frame-objects\x00");
        }
        if (cmd.aarch64_redzone) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-redzone\x00");
        }
        if (cmd.aarch64_select_opt) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-select-opt\x00");
        }
        if (cmd.aarch64_simd_scalar_force_all) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-simd-scalar-force-all\x00");
        }
        if (cmd.aarch64_slh_loads) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-slh-loads\x00");
        }
        if (cmd.aarch64_stress_ccmp) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-stress-ccmp\x00");
        }
        if (cmd.aarch64_stress_promote_const) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-stress-promote-const\x00");
        }
        if (cmd.aarch64_sve_vector_bits_max) |aarch64_sve_vector_bits_max| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-sve-vector-bits-max\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_sve_vector_bits_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_sve_vector_bits_min) |aarch64_sve_vector_bits_min| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-sve-vector-bits-min\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_sve_vector_bits_min);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_tbz_offset_bits) |aarch64_tbz_offset_bits| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-tbz-offset-bits\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_tbz_offset_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_update_scan_limit) |aarch64_update_scan_limit| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-update-scan-limit\x00");
            ptr = fmt.Ud64.write(ptr, aarch64_update_scan_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64_use_aa) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-use-aa\x00");
        }
        if (cmd.aarch64_use_tbi) {
            ptr = fmt.strcpyEqu(ptr, "--aarch64-use-tbi\x00");
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_disable_rule) |aarch64o0prelegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64o0prelegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64o0prelegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_only_enable_rule) |aarch64o0prelegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64o0prelegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64o0prelegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64postlegalizercombinerhelper_disable_rule) |aarch64postlegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64postlegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64postlegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64postlegalizercombinerhelper_only_enable_rule) |aarch64postlegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64postlegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64postlegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64postlegalizerloweringhelper_disable_rule) |aarch64postlegalizerloweringhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64postlegalizerloweringhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64postlegalizerloweringhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64postlegalizerloweringhelper_only_enable_rule) |aarch64postlegalizerloweringhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64postlegalizerloweringhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64postlegalizerloweringhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64prelegalizercombinerhelper_disable_rule) |aarch64prelegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64prelegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64prelegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aarch64prelegalizercombinerhelper_only_enable_rule) |aarch64prelegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--aarch64prelegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, aarch64prelegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.abort_on_max_devirt_iterations_reached) {
            ptr = fmt.strcpyEqu(ptr, "--abort-on-max-devirt-iterations-reached\x00");
        }
        if (cmd.accel_tables) |accel_tables| {
            ptr = fmt.strcpyEqu(ptr, "--accel-tables\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(accel_tables));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.adce_remove_control_flow) {
            ptr = fmt.strcpyEqu(ptr, "--adce-remove-control-flow\x00");
        }
        if (cmd.adce_remove_loops) {
            ptr = fmt.strcpyEqu(ptr, "--adce-remove-loops\x00");
        }
        if (cmd.addr_sink_combine_base_gv) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-combine-base-gv\x00");
        }
        if (cmd.addr_sink_combine_base_offs) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-combine-base-offs\x00");
        }
        if (cmd.addr_sink_combine_base_reg) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-combine-base-reg\x00");
        }
        if (cmd.addr_sink_combine_scaled_reg) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-combine-scaled-reg\x00");
        }
        if (cmd.addr_sink_new_phis) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-new-phis\x00");
        }
        if (cmd.addr_sink_new_select) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-new-select\x00");
        }
        if (cmd.addr_sink_using_gep) {
            ptr = fmt.strcpyEqu(ptr, "--addr-sink-using-gep\x00");
        }
        if (cmd.addrsig) {
            ptr = fmt.strcpyEqu(ptr, "--addrsig\x00");
        }
        if (cmd.agg_antidep_debugdiv) |agg_antidep_debugdiv| {
            ptr = fmt.strcpyEqu(ptr, "--agg-antidep-debugdiv\x00");
            ptr = fmt.Ud64.write(ptr, agg_antidep_debugdiv);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.agg_antidep_debugmod) |agg_antidep_debugmod| {
            ptr = fmt.strcpyEqu(ptr, "--agg-antidep-debugmod\x00");
            ptr = fmt.Ud64.write(ptr, agg_antidep_debugmod);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aggregate_extracted_args) {
            ptr = fmt.strcpyEqu(ptr, "--aggregate-extracted-args\x00");
        }
        if (cmd.aggressive_ext_opt) {
            ptr = fmt.strcpyEqu(ptr, "--aggressive-ext-opt\x00");
        }
        if (cmd.aggressive_instcombine_max_scan_instrs) |aggressive_instcombine_max_scan_instrs| {
            ptr = fmt.strcpyEqu(ptr, "--aggressive-instcombine-max-scan-instrs\x00");
            ptr = fmt.Ud64.write(ptr, aggressive_instcombine_max_scan_instrs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.aix_ssp_tb_bit) {
            ptr = fmt.strcpyEqu(ptr, "--aix-ssp-tb-bit\x00");
        }
        if (cmd.alias_set_saturation_threshold) |alias_set_saturation_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--alias-set-saturation-threshold\x00");
            ptr = fmt.Ud64.write(ptr, alias_set_saturation_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.align_all_blocks) |align_all_blocks| {
            ptr = fmt.strcpyEqu(ptr, "--align-all-blocks\x00");
            ptr = fmt.Ud64.write(ptr, align_all_blocks);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.align_all_functions) |align_all_functions| {
            ptr = fmt.strcpyEqu(ptr, "--align-all-functions\x00");
            ptr = fmt.Ud64.write(ptr, align_all_functions);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.align_all_nofallthru_blocks) |align_all_nofallthru_blocks| {
            ptr = fmt.strcpyEqu(ptr, "--align-all-nofallthru-blocks\x00");
            ptr = fmt.Ud64.write(ptr, align_all_nofallthru_blocks);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.align_loops) |align_loops| {
            ptr = fmt.strcpyEqu(ptr, "--align-loops\x00");
            ptr = fmt.Ud64.write(ptr, align_loops);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.align_neon_spills) {
            ptr = fmt.strcpyEqu(ptr, "--align-neon-spills\x00");
        }
        if (cmd.allow_arm_wlsloops) {
            ptr = fmt.strcpyEqu(ptr, "--allow-arm-wlsloops\x00");
        }
        if (cmd.allow_ginsert_as_artifact) {
            ptr = fmt.strcpyEqu(ptr, "--allow-ginsert-as-artifact\x00");
        }
        if (cmd.allow_unroll_and_jam) {
            ptr = fmt.strcpyEqu(ptr, "--allow-unroll-and-jam\x00");
        }
        if (cmd.amdgcn_skip_cache_invalidations) {
            ptr = fmt.strcpyEqu(ptr, "--amdgcn-skip-cache-invalidations\x00");
        }
        if (cmd.amdgpu_any_address_space_out_arguments) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-any-address-space-out-arguments\x00");
        }
        if (cmd.amdgpu_assume_dynamic_stack_object_size) |amdgpu_assume_dynamic_stack_object_size| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-assume-dynamic-stack-object-size\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_assume_dynamic_stack_object_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_assume_external_call_stack_size) |amdgpu_assume_external_call_stack_size| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-assume-external-call-stack-size\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_assume_external_call_stack_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_atomic_optimizations) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-atomic-optimizations\x00");
        }
        if (cmd.amdgpu_bypass_slow_div) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-bypass-slow-div\x00");
        }
        if (cmd.amdgpu_dce_in_ra) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-dce-in-ra\x00");
        }
        if (cmd.amdgpu_disable_loop_alignment) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-disable-loop-alignment\x00");
        }
        if (cmd.amdgpu_disable_unclustred_high_rp_reschedule) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-disable-unclustred-high-rp-reschedule\x00");
        }
        if (cmd.amdgpu_dpp_combine) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-dpp-combine\x00");
        }
        if (cmd.amdgpu_dump_hsa_metadata) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-dump-hsa-metadata\x00");
        }
        if (cmd.amdgpu_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-early-ifcvt\x00");
        }
        if (cmd.amdgpu_early_inline_all) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-early-inline-all\x00");
        }
        if (cmd.amdgpu_enable_delay_alu) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-delay-alu\x00");
        }
        if (cmd.amdgpu_enable_lds_replace_with_pointer) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-lds-replace-with-pointer\x00");
        }
        if (cmd.amdgpu_enable_lower_module_lds) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-lower-module-lds\x00");
        }
        if (cmd.amdgpu_enable_max_ilp_scheduling_strategy) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-max-ilp-scheduling-strategy\x00");
        }
        if (cmd.amdgpu_enable_merge_m0) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-merge-m0\x00");
        }
        if (cmd.amdgpu_enable_power_sched) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-power-sched\x00");
        }
        if (cmd.amdgpu_enable_pre_ra_optimizations) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-pre-ra-optimizations\x00");
        }
        if (cmd.amdgpu_enable_promote_kernel_arguments) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-promote-kernel-arguments\x00");
        }
        if (cmd.amdgpu_enable_structurizer_workarounds) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-structurizer-workarounds\x00");
        }
        if (cmd.amdgpu_enable_vopd) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-enable-vopd\x00");
        }
        if (cmd.amdgpu_function_calls) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-function-calls\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-igrouplp-exact-solver\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cost_heur) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-igrouplp-exact-solver-cost-heur\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cutoff) |amdgpu_igrouplp_exact_solver_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-igrouplp-exact-solver-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_igrouplp_exact_solver_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_igrouplp_exact_solver_max_branches) |amdgpu_igrouplp_exact_solver_max_branches| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-igrouplp-exact-solver-max-branches\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_igrouplp_exact_solver_max_branches);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_indirect_access_weight) |amdgpu_indirect_access_weight| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-indirect-access-weight\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_indirect_access_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_inline_arg_alloca_cost) |amdgpu_inline_arg_alloca_cost| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-inline-arg-alloca-cost\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_inline_arg_alloca_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_inline_arg_alloca_cutoff) |amdgpu_inline_arg_alloca_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-inline-arg-alloca-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_inline_arg_alloca_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_inline_max_bb) |amdgpu_inline_max_bb| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-inline-max-bb\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_inline_max_bb);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_internalize_symbols) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-internalize-symbols\x00");
        }
        if (cmd.amdgpu_ir_lower_kernel_arguments) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-ir-lower-kernel-arguments\x00");
        }
        if (cmd.amdgpu_large_stride_threshold) |amdgpu_large_stride_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-large-stride-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_large_stride_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_large_stride_weight) |amdgpu_large_stride_weight| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-large-stride-weight\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_large_stride_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_late_structurize) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-late-structurize\x00");
        }
        if (cmd.amdgpu_limit_wave_threshold) |amdgpu_limit_wave_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-limit-wave-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_limit_wave_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_load_store_vectorizer) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-load-store-vectorizer\x00");
        }
        if (cmd.amdgpu_lower_module_lds_strategy) |amdgpu_lower_module_lds_strategy| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-lower-module-lds-strategy\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(amdgpu_lower_module_lds_strategy));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_max_memory_clause) |amdgpu_max_memory_clause| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-max-memory-clause\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_max_memory_clause);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_max_return_arg_num_regs) |amdgpu_max_return_arg_num_regs| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-max-return-arg-num-regs\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_max_return_arg_num_regs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_mem_intrinsic_expand_size) |amdgpu_mem_intrinsic_expand_size| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-mem-intrinsic-expand-size\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_mem_intrinsic_expand_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_membound_threshold) |amdgpu_membound_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-membound-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_membound_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_mfma_padding_ratio) |amdgpu_mfma_padding_ratio| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-mfma-padding-ratio\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_mfma_padding_ratio);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_mode_register) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-mode-register\x00");
        }
        if (cmd.amdgpu_nsa_threshold) |amdgpu_nsa_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-nsa-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_nsa_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_opt_exec_mask_pre_ra) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-opt-exec-mask-pre-ra\x00");
        }
        if (cmd.amdgpu_opt_vgpr_liverange) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-opt-vgpr-liverange\x00");
        }
        if (cmd.amdgpu_prelink) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-prelink\x00");
        }
        if (cmd.amdgpu_promote_alloca_to_vector_limit) |amdgpu_promote_alloca_to_vector_limit| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-promote-alloca-to-vector-limit\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_promote_alloca_to_vector_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_reassign_regs) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-reassign-regs\x00");
        }
        if (cmd.amdgpu_scalar_ir_passes) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-scalar-ir-passes\x00");
        }
        if (cmd.amdgpu_scalarize_global_loads) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-scalarize-global-loads\x00");
        }
        if (cmd.amdgpu_schedule_metric_bias) |amdgpu_schedule_metric_bias| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-schedule-metric-bias\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_schedule_metric_bias);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_sdwa_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-sdwa-peephole\x00");
        }
        if (cmd.amdgpu_set_wave_priority) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-set-wave-priority\x00");
        }
        if (cmd.amdgpu_set_wave_priority_valu_insts_threshold) |amdgpu_set_wave_priority_valu_insts_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-set-wave-priority-valu-insts-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_set_wave_priority_valu_insts_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_simplify_libcall) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-simplify-libcall\x00");
        }
        if (cmd.amdgpu_skip_threshold) |amdgpu_skip_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-skip-threshold\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_skip_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_stress_function_calls) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-stress-function-calls\x00");
        }
        if (cmd.amdgpu_super_align_lds_globals) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-super-align-lds-globals\x00");
        }
        if (cmd.amdgpu_unroll_max_block_to_analyze) |amdgpu_unroll_max_block_to_analyze| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-unroll-max-block-to-analyze\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_unroll_max_block_to_analyze);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_unroll_runtime_local) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-unroll-runtime-local\x00");
        }
        if (cmd.amdgpu_unroll_threshold_if) |amdgpu_unroll_threshold_if| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-unroll-threshold-if\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_unroll_threshold_if);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_unroll_threshold_local) |amdgpu_unroll_threshold_local| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-unroll-threshold-local\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_unroll_threshold_local);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_unroll_threshold_private) |amdgpu_unroll_threshold_private| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-unroll-threshold-private\x00");
            ptr = fmt.Ud64.write(ptr, amdgpu_unroll_threshold_private);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_use_aa_in_codegen) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-use-aa-in-codegen\x00");
        }
        if (cmd.amdgpu_use_divergent_register_indexing) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-use-divergent-register-indexing\x00");
        }
        if (cmd.amdgpu_use_legacy_divergence_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-use-legacy-divergence-analysis\x00");
        }
        if (cmd.amdgpu_use_native) |amdgpu_use_native| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-use-native\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpu_use_native);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpu_verify_hsa_metadata) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-verify-hsa-metadata\x00");
        }
        if (cmd.amdgpu_vgpr_index_mode) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-vgpr-index-mode\x00");
        }
        if (cmd.amdgpu_waitcnt_forcezero) {
            ptr = fmt.strcpyEqu(ptr, "--amdgpu-waitcnt-forcezero\x00");
        }
        if (cmd.amdgpupostlegalizercombinerhelper_disable_rule) |amdgpupostlegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpupostlegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpupostlegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpupostlegalizercombinerhelper_only_enable_rule) |amdgpupostlegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpupostlegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpupostlegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpuprelegalizercombinerhelper_disable_rule) |amdgpuprelegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpuprelegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpuprelegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpuprelegalizercombinerhelper_only_enable_rule) |amdgpuprelegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpuprelegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpuprelegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpuregbankcombinerhelper_disable_rule) |amdgpuregbankcombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpuregbankcombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpuregbankcombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdgpuregbankcombinerhelper_only_enable_rule) |amdgpuregbankcombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--amdgpuregbankcombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, amdgpuregbankcombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.amdhsa_code_object_version) |amdhsa_code_object_version| {
            ptr = fmt.strcpyEqu(ptr, "--amdhsa-code-object-version\x00");
            ptr = fmt.Ud64.write(ptr, amdhsa_code_object_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.annotate_inline_phase) {
            ptr = fmt.strcpyEqu(ptr, "--annotate-inline-phase\x00");
        }
        if (cmd.annotate_sample_profile_inline_phase) {
            ptr = fmt.strcpyEqu(ptr, "--annotate-sample-profile-inline-phase\x00");
        }
        if (cmd.arc_opt_max_ptr_states) |arc_opt_max_ptr_states| {
            ptr = fmt.strcpyEqu(ptr, "--arc-opt-max-ptr-states\x00");
            ptr = fmt.Ud64.write(ptr, arc_opt_max_ptr_states);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_add_build_attributes) {
            ptr = fmt.strcpyEqu(ptr, "--arm-add-build-attributes\x00");
        }
        if (cmd.arm_adjust_jump_tables) {
            ptr = fmt.strcpyEqu(ptr, "--arm-adjust-jump-tables\x00");
        }
        if (cmd.arm_assume_itcm_bankconflict) {
            ptr = fmt.strcpyEqu(ptr, "--arm-assume-itcm-bankconflict\x00");
        }
        if (cmd.arm_assume_misaligned_load_store) {
            ptr = fmt.strcpyEqu(ptr, "--arm-assume-misaligned-load-store\x00");
        }
        if (cmd.arm_atomic_cfg_tidy) {
            ptr = fmt.strcpyEqu(ptr, "--arm-atomic-cfg-tidy\x00");
        }
        if (cmd.arm_constant_island_max_iteration) |arm_constant_island_max_iteration| {
            ptr = fmt.strcpyEqu(ptr, "--arm-constant-island-max-iteration\x00");
            ptr = fmt.Ud64.write(ptr, arm_constant_island_max_iteration);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_data_bank_mask) |arm_data_bank_mask| {
            ptr = fmt.strcpyEqu(ptr, "--arm-data-bank-mask\x00");
            ptr = fmt.Ud64.write(ptr, arm_data_bank_mask);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_disable_omit_dls) {
            ptr = fmt.strcpyEqu(ptr, "--arm-disable-omit-dls\x00");
        }
        if (cmd.arm_enable_merge_loopenddec) {
            ptr = fmt.strcpyEqu(ptr, "--arm-enable-merge-loopenddec\x00");
        }
        if (cmd.arm_enable_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--arm-enable-subreg-liveness\x00");
        }
        if (cmd.arm_force_fast_isel) {
            ptr = fmt.strcpyEqu(ptr, "--arm-force-fast-isel\x00");
        }
        if (cmd.arm_global_merge) {
            ptr = fmt.strcpyEqu(ptr, "--arm-global-merge\x00");
        }
        if (cmd.arm_implicit_it) |arm_implicit_it| {
            ptr = fmt.strcpyEqu(ptr, "--arm-implicit-it\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(arm_implicit_it));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_interworking) {
            ptr = fmt.strcpyEqu(ptr, "--arm-interworking\x00");
        }
        if (cmd.arm_load_store_opt) {
            ptr = fmt.strcpyEqu(ptr, "--arm-load-store-opt\x00");
        }
        if (cmd.arm_loloops_disable_tailpred) {
            ptr = fmt.strcpyEqu(ptr, "--arm-loloops-disable-tailpred\x00");
        }
        if (cmd.arm_memtransfer_tploop) |arm_memtransfer_tploop| {
            ptr = fmt.strcpyEqu(ptr, "--arm-memtransfer-tploop\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(arm_memtransfer_tploop));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_parallel_dsp_load_limit) |arm_parallel_dsp_load_limit| {
            ptr = fmt.strcpyEqu(ptr, "--arm-parallel-dsp-load-limit\x00");
            ptr = fmt.Ud64.write(ptr, arm_parallel_dsp_load_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_prera_ldst_opt_reorder_limit) |arm_prera_ldst_opt_reorder_limit| {
            ptr = fmt.strcpyEqu(ptr, "--arm-prera-ldst-opt-reorder-limit\x00");
            ptr = fmt.Ud64.write(ptr, arm_prera_ldst_opt_reorder_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_promote_constant) {
            ptr = fmt.strcpyEqu(ptr, "--arm-promote-constant\x00");
        }
        if (cmd.arm_promote_constant_max_size) |arm_promote_constant_max_size| {
            ptr = fmt.strcpyEqu(ptr, "--arm-promote-constant-max-size\x00");
            ptr = fmt.Ud64.write(ptr, arm_promote_constant_max_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_promote_constant_max_total) |arm_promote_constant_max_total| {
            ptr = fmt.strcpyEqu(ptr, "--arm-promote-constant-max-total\x00");
            ptr = fmt.Ud64.write(ptr, arm_promote_constant_max_total);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.arm_default_it) {
            ptr = fmt.strcpyEqu(ptr, "--arm-default-it\x00");
        }
        if (cmd.arm_restrict_it) {
            ptr = fmt.strcpyEqu(ptr, "--arm-restrict-it\x00");
        }
        if (cmd.arm_set_lr_predicate) {
            ptr = fmt.strcpyEqu(ptr, "--arm-set-lr-predicate\x00");
        }
        if (cmd.arm_synthesize_thumb_1_tbb) {
            ptr = fmt.strcpyEqu(ptr, "--arm-synthesize-thumb-1-tbb\x00");
        }
        if (cmd.arm_use_mulops) {
            ptr = fmt.strcpyEqu(ptr, "--arm-use-mulops\x00");
        }
        if (cmd.as_secure_log_file) |as_secure_log_file| {
            ptr = fmt.strcpyEqu(ptr, "--as-secure-log-file\x00");
            ptr = fmt.strcpyEqu(ptr, as_secure_log_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_always_slow_path) {
            ptr = fmt.strcpyEqu(ptr, "--asan-always-slow-path\x00");
        }
        if (cmd.asan_constructor_kind) |asan_constructor_kind| {
            ptr = fmt.strcpyEqu(ptr, "--asan-constructor-kind\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(asan_constructor_kind));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_debug) |asan_debug| {
            ptr = fmt.strcpyEqu(ptr, "--asan-debug\x00");
            ptr = fmt.Ud64.write(ptr, asan_debug);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_debug_func) |asan_debug_func| {
            ptr = fmt.strcpyEqu(ptr, "--asan-debug-func\x00");
            ptr = fmt.strcpyEqu(ptr, asan_debug_func);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_debug_max) |asan_debug_max| {
            ptr = fmt.strcpyEqu(ptr, "--asan-debug-max\x00");
            ptr = fmt.Ud64.write(ptr, asan_debug_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_debug_min) |asan_debug_min| {
            ptr = fmt.strcpyEqu(ptr, "--asan-debug-min\x00");
            ptr = fmt.Ud64.write(ptr, asan_debug_min);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_debug_stack) |asan_debug_stack| {
            ptr = fmt.strcpyEqu(ptr, "--asan-debug-stack\x00");
            ptr = fmt.Ud64.write(ptr, asan_debug_stack);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_destructor_kind) |asan_destructor_kind| {
            ptr = fmt.strcpyEqu(ptr, "--asan-destructor-kind\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(asan_destructor_kind));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_detect_invalid_pointer_cmp) {
            ptr = fmt.strcpyEqu(ptr, "--asan-detect-invalid-pointer-cmp\x00");
        }
        if (cmd.asan_detect_invalid_pointer_pair) {
            ptr = fmt.strcpyEqu(ptr, "--asan-detect-invalid-pointer-pair\x00");
        }
        if (cmd.asan_detect_invalid_pointer_sub) {
            ptr = fmt.strcpyEqu(ptr, "--asan-detect-invalid-pointer-sub\x00");
        }
        if (cmd.asan_force_dynamic_shadow) {
            ptr = fmt.strcpyEqu(ptr, "--asan-force-dynamic-shadow\x00");
        }
        if (cmd.asan_force_experiment) |asan_force_experiment| {
            ptr = fmt.strcpyEqu(ptr, "--asan-force-experiment\x00");
            ptr = fmt.Ud64.write(ptr, asan_force_experiment);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_globals) {
            ptr = fmt.strcpyEqu(ptr, "--asan-globals\x00");
        }
        if (cmd.asan_globals_live_support) {
            ptr = fmt.strcpyEqu(ptr, "--asan-globals-live-support\x00");
        }
        if (cmd.asan_guard_against_version_mismatch) {
            ptr = fmt.strcpyEqu(ptr, "--asan-guard-against-version-mismatch\x00");
        }
        if (cmd.asan_initialization_order) {
            ptr = fmt.strcpyEqu(ptr, "--asan-initialization-order\x00");
        }
        if (cmd.asan_instrument_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrument-atomics\x00");
        }
        if (cmd.asan_instrument_byval) {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrument-byval\x00");
        }
        if (cmd.asan_instrument_dynamic_allocas) {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrument-dynamic-allocas\x00");
        }
        if (cmd.asan_instrument_reads) {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrument-reads\x00");
        }
        if (cmd.asan_instrument_writes) {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrument-writes\x00");
        }
        if (cmd.asan_instrumentation_with_call_threshold) |asan_instrumentation_with_call_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--asan-instrumentation-with-call-threshold\x00");
            ptr = fmt.Ud64.write(ptr, asan_instrumentation_with_call_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_kernel) {
            ptr = fmt.strcpyEqu(ptr, "--asan-kernel\x00");
        }
        if (cmd.asan_kernel_mem_intrinsic_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--asan-kernel-mem-intrinsic-prefix\x00");
        }
        if (cmd.asan_mapping_offset) |asan_mapping_offset| {
            ptr = fmt.strcpyEqu(ptr, "--asan-mapping-offset\x00");
            ptr = fmt.Ud64.write(ptr, asan_mapping_offset);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_mapping_scale) |asan_mapping_scale| {
            ptr = fmt.strcpyEqu(ptr, "--asan-mapping-scale\x00");
            ptr = fmt.Ud64.write(ptr, asan_mapping_scale);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_max_inline_poisoning_size) |asan_max_inline_poisoning_size| {
            ptr = fmt.strcpyEqu(ptr, "--asan-max-inline-poisoning-size\x00");
            ptr = fmt.Ud64.write(ptr, asan_max_inline_poisoning_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_max_ins_per_bb) |asan_max_ins_per_bb| {
            ptr = fmt.strcpyEqu(ptr, "--asan-max-ins-per-bb\x00");
            ptr = fmt.Ud64.write(ptr, asan_max_ins_per_bb);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_memory_access_callback_prefix) |asan_memory_access_callback_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--asan-memory-access-callback-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, asan_memory_access_callback_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_opt) {
            ptr = fmt.strcpyEqu(ptr, "--asan-opt\x00");
        }
        if (cmd.asan_opt_globals) {
            ptr = fmt.strcpyEqu(ptr, "--asan-opt-globals\x00");
        }
        if (cmd.asan_opt_same_temp) {
            ptr = fmt.strcpyEqu(ptr, "--asan-opt-same-temp\x00");
        }
        if (cmd.asan_opt_stack) {
            ptr = fmt.strcpyEqu(ptr, "--asan-opt-stack\x00");
        }
        if (cmd.asan_optimize_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--asan-optimize-callbacks\x00");
        }
        if (cmd.asan_realign_stack) |asan_realign_stack| {
            ptr = fmt.strcpyEqu(ptr, "--asan-realign-stack\x00");
            ptr = fmt.Ud64.write(ptr, asan_realign_stack);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_recover) {
            ptr = fmt.strcpyEqu(ptr, "--asan-recover\x00");
        }
        if (cmd.asan_redzone_byval_args) {
            ptr = fmt.strcpyEqu(ptr, "--asan-redzone-byval-args\x00");
        }
        if (cmd.asan_skip_promotable_allocas) {
            ptr = fmt.strcpyEqu(ptr, "--asan-skip-promotable-allocas\x00");
        }
        if (cmd.asan_stack) {
            ptr = fmt.strcpyEqu(ptr, "--asan-stack\x00");
        }
        if (cmd.asan_stack_dynamic_alloca) {
            ptr = fmt.strcpyEqu(ptr, "--asan-stack-dynamic-alloca\x00");
        }
        if (cmd.asan_use_after_return) |asan_use_after_return| {
            ptr = fmt.strcpyEqu(ptr, "--asan-use-after-return\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(asan_use_after_return));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asan_use_after_scope) {
            ptr = fmt.strcpyEqu(ptr, "--asan-use-after-scope\x00");
        }
        if (cmd.asan_use_odr_indicator) {
            ptr = fmt.strcpyEqu(ptr, "--asan-use-odr-indicator\x00");
        }
        if (cmd.asan_use_private_alias) {
            ptr = fmt.strcpyEqu(ptr, "--asan-use-private-alias\x00");
        }
        if (cmd.asan_use_stack_safety) {
            ptr = fmt.strcpyEqu(ptr, "--asan-use-stack-safety\x00");
        }
        if (cmd.asan_with_comdat) {
            ptr = fmt.strcpyEqu(ptr, "--asan-with-comdat\x00");
        }
        if (cmd.asan_with_ifunc) {
            ptr = fmt.strcpyEqu(ptr, "--asan-with-ifunc\x00");
        }
        if (cmd.asan_with_ifunc_suppress_remat) {
            ptr = fmt.strcpyEqu(ptr, "--asan-with-ifunc-suppress-remat\x00");
        }
        if (cmd.asm_macro_max_nesting_depth) |asm_macro_max_nesting_depth| {
            ptr = fmt.strcpyEqu(ptr, "--asm-macro-max-nesting-depth\x00");
            ptr = fmt.Ud64.write(ptr, asm_macro_max_nesting_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.asm_show_inst) {
            ptr = fmt.strcpyEqu(ptr, "--asm-show-inst\x00");
        }
        if (cmd.asm_verbose) {
            ptr = fmt.strcpyEqu(ptr, "--asm-verbose\x00");
        }
        if (cmd.assume_preserve_all) {
            ptr = fmt.strcpyEqu(ptr, "--assume-preserve-all\x00");
        }
        if (cmd.atomic_counter_update_promoted) {
            ptr = fmt.strcpyEqu(ptr, "--atomic-counter-update-promoted\x00");
        }
        if (cmd.atomic_first_counter) {
            ptr = fmt.strcpyEqu(ptr, "--atomic-first-counter\x00");
        }
        if (cmd.attributor_allow_deep_wrappers) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-allow-deep-wrappers\x00");
        }
        if (cmd.attributor_allow_shallow_wrappers) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-allow-shallow-wrappers\x00");
        }
        if (cmd.attributor_annotate_decl_cs) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-annotate-decl-cs\x00");
        }
        if (cmd.attributor_depgraph_dot_filename_prefix) |attributor_depgraph_dot_filename_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-depgraph-dot-filename-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, attributor_depgraph_dot_filename_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_dump_dep_graph) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-dump-dep-graph\x00");
        }
        if (cmd.attributor_enable) |attributor_enable| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-enable\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(attributor_enable));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_enable_call_site_specific_deduction) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-enable-call-site-specific-deduction\x00");
        }
        if (cmd.attributor_manifest_internal) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-manifest-internal\x00");
        }
        if (cmd.attributor_max_initialization_chain_length) |attributor_max_initialization_chain_length| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-max-initialization-chain-length\x00");
            ptr = fmt.Ud64.write(ptr, attributor_max_initialization_chain_length);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_max_iterations) |attributor_max_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-max-iterations\x00");
            ptr = fmt.Ud64.write(ptr, attributor_max_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_max_iterations_verify) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-max-iterations-verify\x00");
        }
        if (cmd.attributor_max_potential_values) |attributor_max_potential_values| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-max-potential-values\x00");
            ptr = fmt.Ud64.write(ptr, attributor_max_potential_values);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_max_potential_values_iterations) |attributor_max_potential_values_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--attributor-max-potential-values-iterations\x00");
            ptr = fmt.Ud64.write(ptr, attributor_max_potential_values_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.attributor_print_call_graph) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-print-call-graph\x00");
        }
        if (cmd.attributor_print_dep) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-print-dep\x00");
        }
        if (cmd.attributor_simplify_all_loads) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-simplify-all-loads\x00");
        }
        if (cmd.attributor_view_dep_graph) {
            ptr = fmt.strcpyEqu(ptr, "--attributor-view-dep-graph\x00");
        }
        if (cmd.available_load_scan_limit) |available_load_scan_limit| {
            ptr = fmt.strcpyEqu(ptr, "--available-load-scan-limit\x00");
            ptr = fmt.Ud64.write(ptr, available_load_scan_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.avoid_speculation) {
            ptr = fmt.strcpyEqu(ptr, "--avoid-speculation\x00");
        }
        if (cmd.basic_aa_recphi) {
            ptr = fmt.strcpyEqu(ptr, "--basic-aa-recphi\x00");
        }
        if (cmd.basic_aa_separate_storage) {
            ptr = fmt.strcpyEqu(ptr, "--basic-aa-separate-storage\x00");
        }
        if (cmd.bbsections_cold_text_prefix) |bbsections_cold_text_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--bbsections-cold-text-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, bbsections_cold_text_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.bbsections_detect_source_drift) {
            ptr = fmt.strcpyEqu(ptr, "--bbsections-detect-source-drift\x00");
        }
        if (cmd.bbsections_guided_section_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--bbsections-guided-section-prefix\x00");
        }
        if (cmd.binutils_version) |binutils_version| {
            ptr = fmt.strcpyEqu(ptr, "--binutils-version\x00");
            ptr = fmt.strcpyEqu(ptr, binutils_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.bitcode_flush_threshold) |bitcode_flush_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--bitcode-flush-threshold\x00");
            ptr = fmt.Ud64.write(ptr, bitcode_flush_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.bitcode_mdindex_threshold) |bitcode_mdindex_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--bitcode-mdindex-threshold\x00");
            ptr = fmt.Ud64.write(ptr, bitcode_mdindex_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.block_freq_ratio_threshold) |block_freq_ratio_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--block-freq-ratio-threshold\x00");
            ptr = fmt.Ud64.write(ptr, block_freq_ratio_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.block_placement_exit_block_bias) |block_placement_exit_block_bias| {
            ptr = fmt.strcpyEqu(ptr, "--block-placement-exit-block-bias\x00");
            ptr = fmt.Ud64.write(ptr, block_placement_exit_block_bias);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.bonus_inst_threshold) |bonus_inst_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--bonus-inst-threshold\x00");
            ptr = fmt.Ud64.write(ptr, bonus_inst_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.bounds_checking_single_trap) {
            ptr = fmt.strcpyEqu(ptr, "--bounds-checking-single-trap\x00");
        }
        if (cmd.bpf_disable_avoid_speculation) {
            ptr = fmt.strcpyEqu(ptr, "--bpf-disable-avoid-speculation\x00");
        }
        if (cmd.bpf_disable_serialize_icmp) {
            ptr = fmt.strcpyEqu(ptr, "--bpf-disable-serialize-icmp\x00");
        }
        if (cmd.bpf_expand_memcpy_in_order) {
            ptr = fmt.strcpyEqu(ptr, "--bpf-expand-memcpy-in-order\x00");
        }
        if (cmd.branch_fold_placement) {
            ptr = fmt.strcpyEqu(ptr, "--branch-fold-placement\x00");
        }
        if (cmd.branch_relax_asm_large) {
            ptr = fmt.strcpyEqu(ptr, "--branch-relax-asm-large\x00");
        }
        if (cmd.branch_relax_safety_buffer) |branch_relax_safety_buffer| {
            ptr = fmt.strcpyEqu(ptr, "--branch-relax-safety-buffer\x00");
            ptr = fmt.Ud64.write(ptr, branch_relax_safety_buffer);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.break_anti_dependencies) |break_anti_dependencies| {
            ptr = fmt.strcpyEqu(ptr, "--break-anti-dependencies\x00");
            ptr = fmt.strcpyEqu(ptr, break_anti_dependencies);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cache_line_size) |cache_line_size| {
            ptr = fmt.strcpyEqu(ptr, "--cache-line-size\x00");
            ptr = fmt.Ud64.write(ptr, cache_line_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.callgraph_dot_filename_prefix) |callgraph_dot_filename_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--callgraph-dot-filename-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, callgraph_dot_filename_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.callgraph_heat_colors) {
            ptr = fmt.strcpyEqu(ptr, "--callgraph-heat-colors\x00");
        }
        if (cmd.callgraph_multigraph) {
            ptr = fmt.strcpyEqu(ptr, "--callgraph-multigraph\x00");
        }
        if (cmd.callgraph_show_weights) {
            ptr = fmt.strcpyEqu(ptr, "--callgraph-show-weights\x00");
        }
        if (cmd.callsite_splitting_duplication_threshold) |callsite_splitting_duplication_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--callsite-splitting-duplication-threshold\x00");
            ptr = fmt.Ud64.write(ptr, callsite_splitting_duplication_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.canon_nth_function) |canon_nth_function| {
            ptr = fmt.strcpyEqu(ptr, "--canon-nth-function\x00");
            ptr = fmt.Ud64.write(ptr, canon_nth_function);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.canonicalize_icmp_predicates_to_unsigned) {
            ptr = fmt.strcpyEqu(ptr, "--canonicalize-icmp-predicates-to-unsigned\x00");
        }
        if (cmd.capture_tracking_max_uses_to_explore) |capture_tracking_max_uses_to_explore| {
            ptr = fmt.strcpyEqu(ptr, "--capture-tracking-max-uses-to-explore\x00");
            ptr = fmt.Ud64.write(ptr, capture_tracking_max_uses_to_explore);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cfg_dot_filename_prefix) |cfg_dot_filename_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--cfg-dot-filename-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, cfg_dot_filename_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cfg_func_name) |cfg_func_name| {
            ptr = fmt.strcpyEqu(ptr, "--cfg-func-name\x00");
            ptr = fmt.strcpyEqu(ptr, cfg_func_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cfg_heat_colors) {
            ptr = fmt.strcpyEqu(ptr, "--cfg-heat-colors\x00");
        }
        if (cmd.cfg_hide_cold_paths) |cfg_hide_cold_paths| {
            ptr = fmt.strcpyEqu(ptr, "--cfg-hide-cold-paths\x00");
            ptr = fmt.Ud64.write(ptr, cfg_hide_cold_paths);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cfg_hide_deoptimize_paths) {
            ptr = fmt.strcpyEqu(ptr, "--cfg-hide-deoptimize-paths\x00");
        }
        if (cmd.cfg_hide_unreachable_paths) {
            ptr = fmt.strcpyEqu(ptr, "--cfg-hide-unreachable-paths\x00");
        }
        if (cmd.cfg_raw_weights) {
            ptr = fmt.strcpyEqu(ptr, "--cfg-raw-weights\x00");
        }
        if (cmd.cfg_weights) {
            ptr = fmt.strcpyEqu(ptr, "--cfg-weights\x00");
        }
        if (cmd.cgp_freq_ratio_to_skip_merge) |cgp_freq_ratio_to_skip_merge| {
            ptr = fmt.strcpyEqu(ptr, "--cgp-freq-ratio-to-skip-merge\x00");
            ptr = fmt.Ud64.write(ptr, cgp_freq_ratio_to_skip_merge);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cgp_icmp_eq2icmp_st) {
            ptr = fmt.strcpyEqu(ptr, "--cgp-icmp-eq2icmp-st\x00");
        }
        if (cmd.cgp_optimize_phi_types) {
            ptr = fmt.strcpyEqu(ptr, "--cgp-optimize-phi-types\x00");
        }
        if (cmd.cgp_split_large_offset_gep) {
            ptr = fmt.strcpyEqu(ptr, "--cgp-split-large-offset-gep\x00");
        }
        if (cmd.cgp_type_promotion_merge) {
            ptr = fmt.strcpyEqu(ptr, "--cgp-type-promotion-merge\x00");
        }
        if (cmd.cgp_verify_bfi_updates) {
            ptr = fmt.strcpyEqu(ptr, "--cgp-verify-bfi-updates\x00");
        }
        if (cmd.cgpp_huge_func) |cgpp_huge_func| {
            ptr = fmt.strcpyEqu(ptr, "--cgpp-huge-func\x00");
            ptr = fmt.Ud64.write(ptr, cgpp_huge_func);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cgscc_inline_replay) {
            ptr = fmt.strcpyEqu(ptr, "--cgscc-inline-replay\x00");
        }
        if (cmd.cgscc_inline_replay_fallback) |cgscc_inline_replay_fallback| {
            ptr = fmt.strcpyEqu(ptr, "--cgscc-inline-replay-fallback\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(cgscc_inline_replay_fallback));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cgscc_inline_replay_format) |cgscc_inline_replay_format| {
            ptr = fmt.strcpyEqu(ptr, "--cgscc-inline-replay-format\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(cgscc_inline_replay_format));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cgscc_inline_replay_scope) |cgscc_inline_replay_scope| {
            ptr = fmt.strcpyEqu(ptr, "--cgscc-inline-replay-scope\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(cgscc_inline_replay_scope));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.check_bfi_unknown_block_queries) {
            ptr = fmt.strcpyEqu(ptr, "--check-bfi-unknown-block-queries\x00");
        }
        if (cmd.check_early_avail) {
            ptr = fmt.strcpyEqu(ptr, "--check-early-avail\x00");
        }
        if (cmd.chr_bias_threshold) |chr_bias_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--chr-bias-threshold\x00");
            ptr = fmt.Ud64.write(ptr, chr_bias_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.chr_dup_threshold) |chr_dup_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--chr-dup-threshold\x00");
            ptr = fmt.Ud64.write(ptr, chr_dup_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.chr_function_list) |chr_function_list| {
            ptr = fmt.strcpyEqu(ptr, "--chr-function-list\x00");
            ptr = fmt.strcpyEqu(ptr, chr_function_list);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.chr_merge_threshold) |chr_merge_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--chr-merge-threshold\x00");
            ptr = fmt.Ud64.write(ptr, chr_merge_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.chr_module_list) |chr_module_list| {
            ptr = fmt.strcpyEqu(ptr, "--chr-module-list\x00");
            ptr = fmt.strcpyEqu(ptr, chr_module_list);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.code_model) |code_model| {
            ptr = fmt.strcpyEqu(ptr, "--code-model\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(code_model));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cold_branch_ratio) |cold_branch_ratio| {
            ptr = fmt.strcpyEqu(ptr, "--cold-branch-ratio\x00");
            ptr = fmt.Ud64.write(ptr, cold_branch_ratio);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cold_callsite_rel_freq) |cold_callsite_rel_freq| {
            ptr = fmt.strcpyEqu(ptr, "--cold-callsite-rel-freq\x00");
            ptr = fmt.Ud64.write(ptr, cold_callsite_rel_freq);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cold_operand_max_cost_multiplier) |cold_operand_max_cost_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--cold-operand-max-cost-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, cold_operand_max_cost_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cold_operand_threshold) |cold_operand_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--cold-operand-threshold\x00");
            ptr = fmt.Ud64.write(ptr, cold_operand_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cold_synthetic_count) |cold_synthetic_count| {
            ptr = fmt.strcpyEqu(ptr, "--cold-synthetic-count\x00");
            ptr = fmt.Ud64.write(ptr, cold_synthetic_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.coldcc_rel_freq) |coldcc_rel_freq| {
            ptr = fmt.strcpyEqu(ptr, "--coldcc-rel-freq\x00");
            ptr = fmt.Ud64.write(ptr, coldcc_rel_freq);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.color) {
            ptr[0..8].* = "--color\x00".*;
            ptr += 8;
        }
        if (cmd.combiner_global_alias_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-global-alias-analysis\x00");
        }
        if (cmd.combiner_reduce_load_op_store_width) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-reduce-load-op-store-width\x00");
        }
        if (cmd.combiner_shrink_load_replace_store_with_store) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-shrink-load-replace-store-with-store\x00");
        }
        if (cmd.combiner_split_load_index) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-split-load-index\x00");
        }
        if (cmd.combiner_store_merge_dependence_limit) |combiner_store_merge_dependence_limit| {
            ptr = fmt.strcpyEqu(ptr, "--combiner-store-merge-dependence-limit\x00");
            ptr = fmt.Ud64.write(ptr, combiner_store_merge_dependence_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.combiner_store_merging) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-store-merging\x00");
        }
        if (cmd.combiner_stress_load_slicing) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-stress-load-slicing\x00");
        }
        if (cmd.combiner_tokenfactor_inline_limit) |combiner_tokenfactor_inline_limit| {
            ptr = fmt.strcpyEqu(ptr, "--combiner-tokenfactor-inline-limit\x00");
            ptr = fmt.Ud64.write(ptr, combiner_tokenfactor_inline_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.combiner_use_tbaa) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-use-tbaa\x00");
        }
        if (cmd.combiner_vector_fcopysign_extend_round) {
            ptr = fmt.strcpyEqu(ptr, "--combiner-vector-fcopysign-extend-round\x00");
        }
        if (cmd.commgep_const) {
            ptr = fmt.strcpyEqu(ptr, "--commgep-const\x00");
        }
        if (cmd.commgep_inv) {
            ptr = fmt.strcpyEqu(ptr, "--commgep-inv\x00");
        }
        if (cmd.commgep_speculate) {
            ptr = fmt.strcpyEqu(ptr, "--commgep-speculate\x00");
        }
        if (cmd.compile_time_mem_idiom_threshold) |compile_time_mem_idiom_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--compile-time-mem-idiom-threshold\x00");
            ptr = fmt.Ud64.write(ptr, compile_time_mem_idiom_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.compile_twice) {
            ptr = fmt.strcpyEqu(ptr, "--compile-twice\x00");
        }
        if (cmd.compute_dead) {
            ptr = fmt.strcpyEqu(ptr, "--compute-dead\x00");
        }
        if (cmd.consthoist_gep) {
            ptr = fmt.strcpyEqu(ptr, "--consthoist-gep\x00");
        }
        if (cmd.consthoist_min_num_to_rebase) |consthoist_min_num_to_rebase| {
            ptr = fmt.strcpyEqu(ptr, "--consthoist-min-num-to-rebase\x00");
            ptr = fmt.Ud64.write(ptr, consthoist_min_num_to_rebase);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.consthoist_with_block_frequency) {
            ptr = fmt.strcpyEqu(ptr, "--consthoist-with-block-frequency\x00");
        }
        if (cmd.constraint_elimination_max_rows) |constraint_elimination_max_rows| {
            ptr = fmt.strcpyEqu(ptr, "--constraint-elimination-max-rows\x00");
            ptr = fmt.Ud64.write(ptr, constraint_elimination_max_rows);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cost_kind) |cost_kind| {
            ptr = fmt.strcpyEqu(ptr, "--cost-kind\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(cost_kind));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.costmodel_reduxcost) {
            ptr = fmt.strcpyEqu(ptr, "--costmodel-reduxcost\x00");
        }
        if (cmd.crash_diagnostics_dir) |crash_diagnostics_dir| {
            ptr = fmt.strcpyEqu(ptr, "--crash-diagnostics-dir\x00");
            ptr = fmt.strcpyEqu(ptr, crash_diagnostics_dir);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.crash_on_ppc_vsx_self_copy) {
            ptr = fmt.strcpyEqu(ptr, "--crash-on-ppc-vsx-self-copy\x00");
        }
        if (cmd.cs_profile_generate) {
            ptr = fmt.strcpyEqu(ptr, "--cs-profile-generate\x00");
        }
        if (cmd.cs_profile_path) |cs_profile_path| {
            ptr = fmt.strcpyEqu(ptr, "--cs-profile-path\x00");
            ptr = fmt.strcpyEqu(ptr, cs_profile_path);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.csuses_threshold) |csuses_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--csuses-threshold\x00");
            ptr = fmt.Ud64.write(ptr, csuses_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.cvp_max_functions_per_value) |cvp_max_functions_per_value| {
            ptr = fmt.strcpyEqu(ptr, "--cvp-max-functions-per-value\x00");
            ptr = fmt.Ud64.write(ptr, cvp_max_functions_per_value);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.da_delinearize) {
            ptr = fmt.strcpyEqu(ptr, "--da-delinearize\x00");
        }
        if (cmd.da_disable_delinearization_checks) {
            ptr = fmt.strcpyEqu(ptr, "--da-disable-delinearization-checks\x00");
        }
        if (cmd.da_miv_max_level_threshold) |da_miv_max_level_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--da-miv-max-level-threshold\x00");
            ptr = fmt.Ud64.write(ptr, da_miv_max_level_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dag_dump_verbose) {
            ptr = fmt.strcpyEqu(ptr, "--dag-dump-verbose\x00");
        }
        if (cmd.dag_maps_huge_region) |dag_maps_huge_region| {
            ptr = fmt.strcpyEqu(ptr, "--dag-maps-huge-region\x00");
            ptr = fmt.Ud64.write(ptr, dag_maps_huge_region);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dag_maps_reduction_size) |dag_maps_reduction_size| {
            ptr = fmt.strcpyEqu(ptr, "--dag-maps-reduction-size\x00");
            ptr = fmt.Ud64.write(ptr, dag_maps_reduction_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.data_sections) {
            ptr = fmt.strcpyEqu(ptr, "--data-sections\x00");
        }
        if (cmd.dataflow_edge_limit) |dataflow_edge_limit| {
            ptr = fmt.strcpyEqu(ptr, "--dataflow-edge-limit\x00");
            ptr = fmt.Ud64.write(ptr, dataflow_edge_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ddg_pi_blocks) {
            ptr = fmt.strcpyEqu(ptr, "--ddg-pi-blocks\x00");
        }
        if (cmd.ddg_simplify) {
            ptr = fmt.strcpyEqu(ptr, "--ddg-simplify\x00");
        }
        if (cmd.debug_ata_max_blocks) |debug_ata_max_blocks| {
            ptr = fmt.strcpyEqu(ptr, "--debug-ata-max-blocks\x00");
            ptr = fmt.Ud64.write(ptr, debug_ata_max_blocks);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.debug_counter) {
            ptr = fmt.strcpyEqu(ptr, "-debug-counter\x00");
        }
        if (cmd.debug_entry_values) {
            ptr = fmt.strcpyEqu(ptr, "--debug-entry-values\x00");
        }
        if (cmd.debug_info_correlate) {
            ptr = fmt.strcpyEqu(ptr, "--debug-info-correlate\x00");
        }
        if (cmd.debug_pass) |debug_pass| {
            ptr = fmt.strcpyEqu(ptr, "--debug-pass\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(debug_pass));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.debugger_tune) |debugger_tune| {
            ptr = fmt.strcpyEqu(ptr, "--debugger-tune\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(debugger_tune));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.debugify_and_strip_all_safe) {
            ptr = fmt.strcpyEqu(ptr, "--debugify-and-strip-all-safe\x00");
        }
        if (cmd.debugify_check_and_strip_all_safe) {
            ptr = fmt.strcpyEqu(ptr, "--debugify-check-and-strip-all-safe\x00");
        }
        if (cmd.debugify_func_limit) |debugify_func_limit| {
            ptr = fmt.strcpyEqu(ptr, "--debugify-func-limit\x00");
            ptr = fmt.Ud64.write(ptr, debugify_func_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.debugify_level) |debugify_level| {
            ptr = fmt.strcpyEqu(ptr, "--debugify-level\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(debugify_level));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.debugify_quiet) {
            ptr = fmt.strcpyEqu(ptr, "--debugify-quiet\x00");
        }
        if (cmd.default_gcov_version) |default_gcov_version| {
            ptr = fmt.strcpyEqu(ptr, "--default-gcov-version\x00");
            ptr = fmt.strcpyEqu(ptr, default_gcov_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.default_trip_count) |default_trip_count| {
            ptr = fmt.strcpyEqu(ptr, "--default-trip-count\x00");
            ptr = fmt.Ud64.write(ptr, default_trip_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.demote_catchswitch_only) {
            ptr = fmt.strcpyEqu(ptr, "--demote-catchswitch-only\x00");
        }
        if (cmd.denormal_fp_math) |denormal_fp_math| {
            ptr = fmt.strcpyEqu(ptr, "--denormal-fp-math\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(denormal_fp_math));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.denormal_fp_math_f32) |denormal_fp_math_f32| {
            ptr = fmt.strcpyEqu(ptr, "--denormal-fp-math-f32\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(denormal_fp_math_f32));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfa_cost_threshold) |dfa_cost_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--dfa-cost-threshold\x00");
            ptr = fmt.Ud64.write(ptr, dfa_cost_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfa_hazard_rec) {
            ptr = fmt.strcpyEqu(ptr, "--dfa-hazard-rec\x00");
        }
        if (cmd.dfa_instr_limit) |dfa_instr_limit| {
            ptr = fmt.strcpyEqu(ptr, "--dfa-instr-limit\x00");
            ptr = fmt.Ud64.write(ptr, dfa_instr_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfa_jump_view_cfg_before) {
            ptr = fmt.strcpyEqu(ptr, "--dfa-jump-view-cfg-before\x00");
        }
        if (cmd.dfa_max_num_paths) |dfa_max_num_paths| {
            ptr = fmt.strcpyEqu(ptr, "--dfa-max-num-paths\x00");
            ptr = fmt.Ud64.write(ptr, dfa_max_num_paths);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfa_max_path_length) |dfa_max_path_length| {
            ptr = fmt.strcpyEqu(ptr, "--dfa-max-path-length\x00");
            ptr = fmt.Ud64.write(ptr, dfa_max_path_length);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfa_sched_reg_pressure_threshold) |dfa_sched_reg_pressure_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--dfa-sched-reg-pressure-threshold\x00");
            ptr = fmt.Ud64.write(ptr, dfa_sched_reg_pressure_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfsan_abilist) |dfsan_abilist| {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-abilist\x00");
            ptr = fmt.strcpyEqu(ptr, dfsan_abilist);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfsan_combine_offset_labels_on_gep) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-combine-offset-labels-on-gep\x00");
        }
        if (cmd.dfsan_combine_pointer_labels_on_load) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-combine-pointer-labels-on-load\x00");
        }
        if (cmd.dfsan_combine_pointer_labels_on_store) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-combine-pointer-labels-on-store\x00");
        }
        if (cmd.dfsan_combine_taint_lookup_table) |dfsan_combine_taint_lookup_table| {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-combine-taint-lookup-table\x00");
            ptr = fmt.strcpyEqu(ptr, dfsan_combine_taint_lookup_table);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfsan_conditional_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-conditional-callbacks\x00");
        }
        if (cmd.dfsan_debug_nonzero_labels) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-debug-nonzero-labels\x00");
        }
        if (cmd.dfsan_event_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-event-callbacks\x00");
        }
        if (cmd.dfsan_ignore_personality_routine) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-ignore-personality-routine\x00");
        }
        if (cmd.dfsan_instrument_with_call_threshold) |dfsan_instrument_with_call_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-instrument-with-call-threshold\x00");
            ptr = fmt.Ud64.write(ptr, dfsan_instrument_with_call_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfsan_preserve_alignment) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-preserve-alignment\x00");
        }
        if (cmd.dfsan_reaches_function_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-reaches-function-callbacks\x00");
        }
        if (cmd.dfsan_track_origins) |dfsan_track_origins| {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-track-origins\x00");
            ptr = fmt.Ud64.write(ptr, dfsan_track_origins);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dfsan_track_select_control_flow) {
            ptr = fmt.strcpyEqu(ptr, "--dfsan-track-select-control-flow\x00");
        }
        if (cmd.disable_2addr_hack) {
            ptr = fmt.strcpyEqu(ptr, "--disable-2addr-hack\x00");
        }
        if (cmd.disable_a15_sd_optimization) {
            ptr = fmt.strcpyEqu(ptr, "--disable-a15-sd-optimization\x00");
        }
        if (cmd.disable_adv_copy_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-adv-copy-opt\x00");
        }
        if (cmd.disable_advanced_peeling) {
            ptr = fmt.strcpyEqu(ptr, "--disable-advanced-peeling\x00");
        }
        if (cmd.disable_arm_loloops) {
            ptr = fmt.strcpyEqu(ptr, "--disable-arm-loloops\x00");
        }
        if (cmd.disable_arm_parallel_dsp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-arm-parallel-dsp\x00");
        }
        if (cmd.disable_auto_paired_vec_st) {
            ptr = fmt.strcpyEqu(ptr, "--disable-auto-paired-vec-st\x00");
        }
        if (cmd.disable_basic_aa) {
            ptr = fmt.strcpyEqu(ptr, "--disable-basic-aa\x00");
        }
        if (cmd.disable_binop_extract_shuffle) {
            ptr = fmt.strcpyEqu(ptr, "--disable-binop-extract-shuffle\x00");
        }
        if (cmd.disable_bitcode_version_upgrade) {
            ptr = fmt.strcpyEqu(ptr, "--disable-bitcode-version-upgrade\x00");
        }
        if (cmd.disable_block_placement) {
            ptr = fmt.strcpyEqu(ptr, "--disable-block-placement\x00");
        }
        if (cmd.disable_bpf_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--disable-bpf-peephole\x00");
        }
        if (cmd.disable_branch_fold) {
            ptr = fmt.strcpyEqu(ptr, "--disable-branch-fold\x00");
        }
        if (cmd.disable_cfi_fixup) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cfi-fixup\x00");
        }
        if (cmd.disable_cgp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp\x00");
        }
        if (cmd.disable_cgp_branch_opts) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp-branch-opts\x00");
        }
        if (cmd.disable_cgp_ext_ld_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp-ext-ld-promotion\x00");
        }
        if (cmd.disable_cgp_gc_opts) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp-gc-opts\x00");
        }
        if (cmd.disable_cgp_select2branch) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp-select2branch\x00");
        }
        if (cmd.disable_cgp_store_extract) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cgp-store-extract\x00");
        }
        if (cmd.disable_check_noreturn_call) {
            ptr = fmt.strcpyEqu(ptr, "--disable-check-noreturn-call\x00");
        }
        if (cmd.disable_chr) {
            ptr = fmt.strcpyEqu(ptr, "--disable-chr\x00");
        }
        if (cmd.disable_cleanups) {
            ptr = fmt.strcpyEqu(ptr, "--disable-cleanups\x00");
        }
        if (cmd.disable_complex_addr_modes) {
            ptr = fmt.strcpyEqu(ptr, "--disable-complex-addr-modes\x00");
        }
        if (cmd.disable_const64) {
            ptr = fmt.strcpyEqu(ptr, "--disable-const64\x00");
        }
        if (cmd.disable_constant_hoisting) {
            ptr = fmt.strcpyEqu(ptr, "--disable-constant-hoisting\x00");
        }
        if (cmd.disable_copyprop) {
            ptr = fmt.strcpyEqu(ptr, "--disable-copyprop\x00");
        }
        if (cmd.disable_debug_info_print) {
            ptr = fmt.strcpyEqu(ptr, "--disable-debug-info-print\x00");
        }
        if (cmd.disable_demotion) {
            ptr = fmt.strcpyEqu(ptr, "--disable-demotion\x00");
        }
        if (cmd.disable_dfa_sched) {
            ptr = fmt.strcpyEqu(ptr, "--disable-dfa-sched\x00");
        }
        if (cmd.disable_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-early-ifcvt\x00");
        }
        if (cmd.disable_early_taildup) {
            ptr = fmt.strcpyEqu(ptr, "--disable-early-taildup\x00");
        }
        if (cmd.disable_expand_reductions) {
            ptr = fmt.strcpyEqu(ptr, "--disable-expand-reductions\x00");
        }
        if (cmd.disable_gep_const_evaluation) {
            ptr = fmt.strcpyEqu(ptr, "--disable-gep-const-evaluation\x00");
        }
        if (cmd.disable_gisel_legality_check) {
            ptr = fmt.strcpyEqu(ptr, "--disable-gisel-legality-check\x00");
        }
        if (cmd.disable_hcp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hcp\x00");
        }
        if (cmd.disable_hexagon_amodeopt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-amodeopt\x00");
        }
        if (cmd.disable_hexagon_cfgopt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-cfgopt\x00");
        }
        if (cmd.disable_hexagon_dealloc_ret) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-dealloc-ret\x00");
        }
        if (cmd.disable_hexagon_hwloops) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-hwloops\x00");
        }
        if (cmd.disable_hexagon_misched) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-misched\x00");
        }
        if (cmd.disable_hexagon_nv_schedule) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-nv-schedule\x00");
        }
        if (cmd.disable_hexagon_opt_ext_to_64) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-opt-ext-to-64\x00");
        }
        if (cmd.disable_hexagon_optszext) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-optszext\x00");
        }
        if (cmd.disable_hexagon_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-peephole\x00");
        }
        if (cmd.disable_hexagon_pnotp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-pnotp\x00");
        }
        if (cmd.disable_hexagon_shuffle) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-shuffle\x00");
        }
        if (cmd.disable_hexagon_volatile_memcpy) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hexagon-volatile-memcpy\x00");
        }
        if (cmd.disable_hoisting_to_hotter_blocks) |disable_hoisting_to_hotter_blocks| {
            ptr = fmt.strcpyEqu(ptr, "--disable-hoisting-to-hotter-blocks\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(disable_hoisting_to_hotter_blocks));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.disable_hsdr) {
            ptr = fmt.strcpyEqu(ptr, "--disable-hsdr\x00");
        }
        if (cmd.disable_i2p_p2i_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-i2p-p2i-opt\x00");
        }
        if (cmd.disable_icp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-icp\x00");
        }
        if (cmd.disable_ifcvt_diamond) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-diamond\x00");
        }
        if (cmd.disable_ifcvt_forked_diamond) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-forked-diamond\x00");
        }
        if (cmd.disable_ifcvt_simple) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-simple\x00");
        }
        if (cmd.disable_ifcvt_simple_false) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-simple-false\x00");
        }
        if (cmd.disable_ifcvt_triangle) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-triangle\x00");
        }
        if (cmd.disable_ifcvt_triangle_false) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-triangle-false\x00");
        }
        if (cmd.disable_ifcvt_triangle_false_rev) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-triangle-false-rev\x00");
        }
        if (cmd.disable_ifcvt_triangle_rev) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ifcvt-triangle-rev\x00");
        }
        if (cmd.disable_inlined_alloca_merging) {
            ptr = fmt.strcpyEqu(ptr, "--disable-inlined-alloca-merging\x00");
        }
        if (cmd.disable_interleaved_load_combine) {
            ptr = fmt.strcpyEqu(ptr, "--disable-interleaved-load-combine\x00");
        }
        if (cmd.disable_lanai_mem_alu_combiner) {
            ptr = fmt.strcpyEqu(ptr, "--disable-lanai-mem-alu-combiner\x00");
        }
        if (cmd.disable_layout_fsprofile_loader) {
            ptr = fmt.strcpyEqu(ptr, "--disable-layout-fsprofile-loader\x00");
        }
        if (cmd.disable_lftr) {
            ptr = fmt.strcpyEqu(ptr, "--disable-lftr\x00");
        }
        if (cmd.disable_licm_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--disable-licm-promotion\x00");
        }
        if (cmd.disable_loop_level_heuristics) {
            ptr = fmt.strcpyEqu(ptr, "--disable-loop-level-heuristics\x00");
        }
        if (cmd.disable_lsr) {
            ptr = fmt.strcpyEqu(ptr, "--disable-lsr\x00");
        }
        if (cmd.disable_machine_cse) {
            ptr = fmt.strcpyEqu(ptr, "--disable-machine-cse\x00");
        }
        if (cmd.disable_machine_dce) {
            ptr = fmt.strcpyEqu(ptr, "--disable-machine-dce\x00");
        }
        if (cmd.disable_machine_licm) {
            ptr = fmt.strcpyEqu(ptr, "--disable-machine-licm\x00");
        }
        if (cmd.disable_machine_sink) {
            ptr = fmt.strcpyEqu(ptr, "--disable-machine-sink\x00");
        }
        if (cmd.disable_memcpy_idiom) {
            ptr = fmt.strcpyEqu(ptr, "--disable-memcpy-idiom\x00");
        }
        if (cmd.disable_memmove_idiom) {
            ptr = fmt.strcpyEqu(ptr, "--disable-memmove-idiom\x00");
        }
        if (cmd.disable_memop_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-memop-opt\x00");
        }
        if (cmd.disable_merge_into_combines) {
            ptr = fmt.strcpyEqu(ptr, "--disable-merge-into-combines\x00");
        }
        if (cmd.disable_mergeicmps) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mergeicmps\x00");
        }
        if (cmd.disable_mips_delay_filler) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mips-delay-filler\x00");
        }
        if (cmd.disable_mips_df_backward_search) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mips-df-backward-search\x00");
        }
        if (cmd.disable_mips_df_forward_search) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mips-df-forward-search\x00");
        }
        if (cmd.disable_mips_df_succbb_search) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mips-df-succbb-search\x00");
        }
        if (cmd.disable_mr_partial_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--disable-mr-partial-inlining\x00");
        }
        if (cmd.disable_nofree_inference) {
            ptr = fmt.strcpyEqu(ptr, "--disable-nofree-inference\x00");
        }
        if (cmd.disable_non_allocatable_phys_copy_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-non-allocatable-phys-copy-opt\x00");
        }
        if (cmd.disable_nounwind_inference) {
            ptr = fmt.strcpyEqu(ptr, "--disable-nounwind-inference\x00");
        }
        if (cmd.disable_nvjump) {
            ptr = fmt.strcpyEqu(ptr, "--disable-nvjump\x00");
        }
        if (cmd.disable_nvptx_load_store_vectorizer) {
            ptr = fmt.strcpyEqu(ptr, "--disable-nvptx-load-store-vectorizer\x00");
        }
        if (cmd.disable_nvptx_require_structured_cfg) {
            ptr = fmt.strcpyEqu(ptr, "--disable-nvptx-require-structured-cfg\x00");
        }
        if (cmd.disable_ondemand_mds_loading) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ondemand-mds-loading\x00");
        }
        if (cmd.disable_packetizer) {
            ptr = fmt.strcpyEqu(ptr, "--disable-packetizer\x00");
        }
        if (cmd.disable_partial_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--disable-partial-inlining\x00");
        }
        if (cmd.disable_partial_libcall_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--disable-partial-libcall-inlining\x00");
        }
        if (cmd.disable_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--disable-peephole\x00");
        }
        if (cmd.disable_phi_elim_edge_splitting) {
            ptr = fmt.strcpyEqu(ptr, "--disable-phi-elim-edge-splitting\x00");
        }
        if (cmd.disable_post_ra) {
            ptr = fmt.strcpyEqu(ptr, "--disable-post-ra\x00");
        }
        if (cmd.disable_postra_machine_licm) {
            ptr = fmt.strcpyEqu(ptr, "--disable-postra-machine-licm\x00");
        }
        if (cmd.disable_postra_machine_sink) {
            ptr = fmt.strcpyEqu(ptr, "--disable-postra-machine-sink\x00");
        }
        if (cmd.disable_ppc_cmp_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-cmp-opt\x00");
        }
        if (cmd.disable_ppc_constant_hoisting) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-constant-hoisting\x00");
        }
        if (cmd.disable_ppc_ctrloop_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-ctrloop-analysis\x00");
        }
        if (cmd.disable_ppc_ctrloops) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-ctrloops\x00");
        }
        if (cmd.disable_ppc_ilp_pref) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-ilp-pref\x00");
        }
        if (cmd.disable_ppc_innermost_loop_align32) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-innermost-loop-align32\x00");
        }
        if (cmd.disable_ppc_instr_form_prep) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-instr-form-prep\x00");
        }
        if (cmd.disable_ppc_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-peephole\x00");
        }
        if (cmd.disable_ppc_preinc) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-preinc\x00");
        }
        if (cmd.disable_ppc_sched_addi_load) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-sched-addi-load\x00");
        }
        if (cmd.disable_ppc_sco) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-sco\x00");
        }
        if (cmd.disable_ppc_unaligned) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-unaligned\x00");
        }
        if (cmd.disable_ppc_vsx_fma_mutation) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-vsx-fma-mutation\x00");
        }
        if (cmd.disable_ppc_vsx_swap_removal) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ppc-vsx-swap-removal\x00");
        }
        if (cmd.disable_preheader_prot) {
            ptr = fmt.strcpyEqu(ptr, "--disable-preheader-prot\x00");
        }
        if (cmd.disable_preinline) {
            ptr = fmt.strcpyEqu(ptr, "--disable-preinline\x00");
        }
        if (cmd.disable_promote_alloca_to_lds) {
            ptr = fmt.strcpyEqu(ptr, "--disable-promote-alloca-to-lds\x00");
        }
        if (cmd.disable_promote_alloca_to_vector) {
            ptr = fmt.strcpyEqu(ptr, "--disable-promote-alloca-to-vector\x00");
        }
        if (cmd.disable_ra_fsprofile_loader) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ra-fsprofile-loader\x00");
        }
        if (cmd.disable_sample_loader_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sample-loader-inlining\x00");
        }
        if (cmd.disable_sched_critical_path) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-critical-path\x00");
        }
        if (cmd.disable_sched_cycles) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-cycles\x00");
        }
        if (cmd.disable_sched_hazard) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-hazard\x00");
        }
        if (cmd.disable_sched_height) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-height\x00");
        }
        if (cmd.disable_sched_live_uses) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-live-uses\x00");
        }
        if (cmd.disable_sched_physreg_join) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-physreg-join\x00");
        }
        if (cmd.disable_sched_reg_pressure) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-reg-pressure\x00");
        }
        if (cmd.disable_sched_stalls) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-stalls\x00");
        }
        if (cmd.disable_sched_vrcycle) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sched-vrcycle\x00");
        }
        if (cmd.disable_select_optimize) {
            ptr = fmt.strcpyEqu(ptr, "--disable-select-optimize\x00");
        }
        if (cmd.disable_separate_const_offset_from_gep) {
            ptr = fmt.strcpyEqu(ptr, "--disable-separate-const-offset-from-gep\x00");
        }
        if (cmd.disable_shifter_op) {
            ptr = fmt.strcpyEqu(ptr, "--disable-shifter-op\x00");
        }
        if (cmd.disable_simplify_libcalls) {
            ptr = fmt.strcpyEqu(ptr, "--disable-simplify-libcalls\x00");
        }
        if (cmd.disable_sparc_delay_filler) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sparc-delay-filler\x00");
        }
        if (cmd.disable_sparc_leaf_proc) {
            ptr = fmt.strcpyEqu(ptr, "--disable-sparc-leaf-proc\x00");
        }
        if (cmd.disable_spill_fusing) {
            ptr = fmt.strcpyEqu(ptr, "--disable-spill-fusing\x00");
        }
        if (cmd.disable_spill_hoist) {
            ptr = fmt.strcpyEqu(ptr, "--disable-spill-hoist\x00");
        }
        if (cmd.disable_ssc) {
            ptr = fmt.strcpyEqu(ptr, "--disable-ssc\x00");
        }
        if (cmd.disable_store_widen) {
            ptr = fmt.strcpyEqu(ptr, "--disable-store-widen\x00");
        }
        if (cmd.disable_strictnode_mutation) {
            ptr = fmt.strcpyEqu(ptr, "--disable-strictnode-mutation\x00");
        }
        if (cmd.disable_symbolication) {
            ptr = fmt.strcpyEqu(ptr, "--disable-symbolication\x00");
        }
        if (cmd.disable_tail_calls) {
            ptr = fmt.strcpyEqu(ptr, "--disable-tail-calls\x00");
        }
        if (cmd.disable_tail_duplicate) {
            ptr = fmt.strcpyEqu(ptr, "--disable-tail-duplicate\x00");
        }
        if (cmd.disable_thinlto_funcattrs) {
            ptr = fmt.strcpyEqu(ptr, "--disable-thinlto-funcattrs\x00");
        }
        if (cmd.disable_type_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--disable-type-promotion\x00");
        }
        if (cmd.disable_vecdbl_nv_stores) {
            ptr = fmt.strcpyEqu(ptr, "--disable-vecdbl-nv-stores\x00");
        }
        if (cmd.disable_vector_combine) {
            ptr = fmt.strcpyEqu(ptr, "--disable-vector-combine\x00");
        }
        if (cmd.disable_verify) {
            ptr = fmt.strcpyEqu(ptr, "--disable-verify\x00");
        }
        if (cmd.disable_vp) {
            ptr = fmt.strcpyEqu(ptr, "--disable-vp\x00");
        }
        if (cmd.disable_wasm_fallthrough_return_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-wasm-fallthrough-return-opt\x00");
        }
        if (cmd.disable_whole_program_visibility) {
            ptr = fmt.strcpyEqu(ptr, "--disable-whole-program-visibility\x00");
        }
        if (cmd.disable_x86_domain_reassignment) {
            ptr = fmt.strcpyEqu(ptr, "--disable-x86-domain-reassignment\x00");
        }
        if (cmd.disable_x86_lea_opt) {
            ptr = fmt.strcpyEqu(ptr, "--disable-x86-lea-opt\x00");
        }
        if (cmd.discard_value_names) {
            ptr = fmt.strcpyEqu(ptr, "--discard-value-names\x00");
        }
        if (cmd.do_comdat_renaming) {
            ptr = fmt.strcpyEqu(ptr, "--do-comdat-renaming\x00");
        }
        if (cmd.do_counter_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--do-counter-promotion\x00");
        }
        if (cmd.dom_conditions_max_uses) |dom_conditions_max_uses| {
            ptr = fmt.strcpyEqu(ptr, "--dom-conditions-max-uses\x00");
            ptr = fmt.Ud64.write(ptr, dom_conditions_max_uses);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dom_tree_reachability_max_bbs_to_explore) |dom_tree_reachability_max_bbs_to_explore| {
            ptr = fmt.strcpyEqu(ptr, "--dom-tree-reachability-max-bbs-to-explore\x00");
            ptr = fmt.Ud64.write(ptr, dom_tree_reachability_max_bbs_to_explore);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_cfg_after_color) |dot_cfg_after_color| {
            ptr = fmt.strcpyEqu(ptr, "--dot-cfg-after-color\x00");
            ptr = fmt.strcpyEqu(ptr, dot_cfg_after_color);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_cfg_before_color) |dot_cfg_before_color| {
            ptr = fmt.strcpyEqu(ptr, "--dot-cfg-before-color\x00");
            ptr = fmt.strcpyEqu(ptr, dot_cfg_before_color);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_cfg_common_color) |dot_cfg_common_color| {
            ptr = fmt.strcpyEqu(ptr, "--dot-cfg-common-color\x00");
            ptr = fmt.strcpyEqu(ptr, dot_cfg_common_color);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_cfg_dir) |dot_cfg_dir| {
            ptr = fmt.strcpyEqu(ptr, "--dot-cfg-dir\x00");
            ptr = fmt.strcpyEqu(ptr, dot_cfg_dir);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_ddg_filename_prefix) |dot_ddg_filename_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--dot-ddg-filename-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, dot_ddg_filename_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dot_ddg_only) {
            ptr = fmt.strcpyEqu(ptr, "--dot-ddg-only\x00");
        }
        if (cmd.dot_mcfg_only) {
            ptr = fmt.strcpyEqu(ptr, "--dot-mcfg-only\x00");
        }
        if (cmd.dse_memoryssa_defs_per_block_limit) |dse_memoryssa_defs_per_block_limit| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-defs-per-block-limit\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_defs_per_block_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_otherbb_cost) |dse_memoryssa_otherbb_cost| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-otherbb-cost\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_otherbb_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_partial_store_limit) |dse_memoryssa_partial_store_limit| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-partial-store-limit\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_partial_store_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_path_check_limit) |dse_memoryssa_path_check_limit| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-path-check-limit\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_path_check_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_samebb_cost) |dse_memoryssa_samebb_cost| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-samebb-cost\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_samebb_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_scanlimit) |dse_memoryssa_scanlimit| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-scanlimit\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_scanlimit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_memoryssa_walklimit) |dse_memoryssa_walklimit| {
            ptr = fmt.strcpyEqu(ptr, "--dse-memoryssa-walklimit\x00");
            ptr = fmt.Ud64.write(ptr, dse_memoryssa_walklimit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dse_optimize_memoryssa) {
            ptr = fmt.strcpyEqu(ptr, "--dse-optimize-memoryssa\x00");
        }
        if (cmd.dump_thin_cg_sccs) {
            ptr = fmt.strcpyEqu(ptr, "--dump-thin-cg-sccs\x00");
        }
        if (cmd.dwarf_directory) {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-directory\x00");
        }
        if (cmd.dwarf_extended_loc) |dwarf_extended_loc| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-extended-loc\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(dwarf_extended_loc));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf_inlined_strings) |dwarf_inlined_strings| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-inlined-strings\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(dwarf_inlined_strings));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf_linkage_names) |dwarf_linkage_names| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-linkage-names\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(dwarf_linkage_names));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf_op_convert) |dwarf_op_convert| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-op-convert\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(dwarf_op_convert));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf_sections_as_references) |dwarf_sections_as_references| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-sections-as-references\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(dwarf_sections_as_references));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf_version) |dwarf_version| {
            ptr = fmt.strcpyEqu(ptr, "--dwarf-version\x00");
            ptr = fmt.Ud64.write(ptr, dwarf_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.dwarf64) {
            ptr = fmt.strcpyEqu(ptr, "--dwarf64\x00");
        }
        if (cmd.eagerly_invalidate_analyses) {
            ptr = fmt.strcpyEqu(ptr, "--eagerly-invalidate-analyses\x00");
        }
        if (cmd.early_ifcvt_limit) |early_ifcvt_limit| {
            ptr = fmt.strcpyEqu(ptr, "--early-ifcvt-limit\x00");
            ptr = fmt.Ud64.write(ptr, early_ifcvt_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.early_live_intervals) {
            ptr = fmt.strcpyEqu(ptr, "--early-live-intervals\x00");
        }
        if (cmd.earlycse_debug_hash) {
            ptr = fmt.strcpyEqu(ptr, "--earlycse-debug-hash\x00");
        }
        if (cmd.earlycse_mssa_optimization_cap) |earlycse_mssa_optimization_cap| {
            ptr = fmt.strcpyEqu(ptr, "--earlycse-mssa-optimization-cap\x00");
            ptr = fmt.Ud64.write(ptr, earlycse_mssa_optimization_cap);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.eif_limit) |eif_limit| {
            ptr = fmt.strcpyEqu(ptr, "--eif-limit\x00");
            ptr = fmt.Ud64.write(ptr, eif_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.eif_no_loop_exit) {
            ptr = fmt.strcpyEqu(ptr, "--eif-no-loop-exit\x00");
        }
        if (cmd.emit_call_site_info) {
            ptr = fmt.strcpyEqu(ptr, "--emit-call-site-info\x00");
        }
        if (cmd.emit_dwarf_unwind) |emit_dwarf_unwind| {
            ptr = fmt.strcpyEqu(ptr, "--emit-dwarf-unwind\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(emit_dwarf_unwind));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.emscripten_cxx_exceptions_allowed) |emscripten_cxx_exceptions_allowed| {
            ptr = fmt.strcpyEqu(ptr, "--emscripten-cxx-exceptions-allowed\x00");
            ptr = fmt.strcpyEqu(ptr, emscripten_cxx_exceptions_allowed);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.emulate_old_livedebugvalues) {
            ptr = fmt.strcpyEqu(ptr, "--emulate-old-livedebugvalues\x00");
        }
        if (cmd.emulated_tls) {
            ptr = fmt.strcpyEqu(ptr, "--emulated-tls\x00");
        }
        if (cmd.enable_aa_sched_mi) {
            ptr = fmt.strcpyEqu(ptr, "--enable-aa-sched-mi\x00");
        }
        if (cmd.enable_acc_forwarding) {
            ptr = fmt.strcpyEqu(ptr, "--enable-acc-forwarding\x00");
        }
        if (cmd.enable_alu_forwarding) {
            ptr = fmt.strcpyEqu(ptr, "--enable-alu-forwarding\x00");
        }
        if (cmd.enable_amdgpu_aa) {
            ptr = fmt.strcpyEqu(ptr, "--enable-amdgpu-aa\x00");
        }
        if (cmd.enable_andcmp_sinking) {
            ptr = fmt.strcpyEqu(ptr, "--enable-andcmp-sinking\x00");
        }
        if (cmd.enable_approx_func_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-approx-func-fp-math\x00");
        }
        if (cmd.enable_arm_3_addr_conv) {
            ptr = fmt.strcpyEqu(ptr, "--enable-arm-3-addr-conv\x00");
        }
        if (cmd.enable_arm_maskedgatscat) {
            ptr = fmt.strcpyEqu(ptr, "--enable-arm-maskedgatscat\x00");
        }
        if (cmd.enable_arm_maskedldst) {
            ptr = fmt.strcpyEqu(ptr, "--enable-arm-maskedldst\x00");
        }
        if (cmd.enable_block_placement_stats) {
            ptr = fmt.strcpyEqu(ptr, "--enable-block-placement-stats\x00");
        }
        if (cmd.enable_bsb_sched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-bsb-sched\x00");
        }
        if (cmd.enable_chr) {
            ptr = fmt.strcpyEqu(ptr, "--enable-chr\x00");
        }
        if (cmd.enable_cold_section) {
            ptr = fmt.strcpyEqu(ptr, "--enable-cold-section\x00");
        }
        if (cmd.enable_coldcc_stress_test) {
            ptr = fmt.strcpyEqu(ptr, "--enable-coldcc-stress-test\x00");
        }
        if (cmd.enable_complex_deinterleaving) {
            ptr = fmt.strcpyEqu(ptr, "--enable-complex-deinterleaving\x00");
        }
        if (cmd.enable_cond_stores_vec) {
            ptr = fmt.strcpyEqu(ptr, "--enable-cond-stores-vec\x00");
        }
        if (cmd.enable_constraint_elimination) {
            ptr = fmt.strcpyEqu(ptr, "--enable-constraint-elimination\x00");
        }
        if (cmd.enable_cse_in_irtranslator) {
            ptr = fmt.strcpyEqu(ptr, "--enable-cse-in-irtranslator\x00");
        }
        if (cmd.enable_cse_in_legalizer) {
            ptr = fmt.strcpyEqu(ptr, "--enable-cse-in-legalizer\x00");
        }
        if (cmd.enable_cur_sched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-cur-sched\x00");
        }
        if (cmd.enable_deferred_spilling) {
            ptr = fmt.strcpyEqu(ptr, "--enable-deferred-spilling\x00");
        }
        if (cmd.enable_dfa_jump_thread) {
            ptr = fmt.strcpyEqu(ptr, "--enable-dfa-jump-thread\x00");
        }
        if (cmd.enable_double_float_shrink) {
            ptr = fmt.strcpyEqu(ptr, "--enable-double-float-shrink\x00");
        }
        if (cmd.enable_dse_partial_overwrite_tracking) {
            ptr = fmt.strcpyEqu(ptr, "--enable-dse-partial-overwrite-tracking\x00");
        }
        if (cmd.enable_dse_partial_store_merging) {
            ptr = fmt.strcpyEqu(ptr, "--enable-dse-partial-store-merging\x00");
        }
        if (cmd.enable_emscripten_cxx_exceptions) {
            ptr = fmt.strcpyEqu(ptr, "--enable-emscripten-cxx-exceptions\x00");
        }
        if (cmd.enable_emscripten_sjlj) {
            ptr = fmt.strcpyEqu(ptr, "--enable-emscripten-sjlj\x00");
        }
        if (cmd.enable_epilogue_vectorization) {
            ptr = fmt.strcpyEqu(ptr, "--enable-epilogue-vectorization\x00");
        }
        if (cmd.enable_ext_tsp_block_placement) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ext-tsp-block-placement\x00");
        }
        if (cmd.enable_falkor_hwpf_unroll_fix) {
            ptr = fmt.strcpyEqu(ptr, "--enable-falkor-hwpf-unroll-fix\x00");
        }
        if (cmd.enable_fixedwidth_autovec_in_streaming_mode) {
            ptr = fmt.strcpyEqu(ptr, "--enable-fixedwidth-autovec-in-streaming-mode\x00");
        }
        if (cmd.enable_fs_discriminator) {
            ptr = fmt.strcpyEqu(ptr, "--enable-fs-discriminator\x00");
        }
        if (cmd.enable_gen_insn) {
            ptr = fmt.strcpyEqu(ptr, "--enable-gen-insn\x00");
        }
        if (cmd.enable_global_analyses) {
            ptr = fmt.strcpyEqu(ptr, "--enable-global-analyses\x00");
        }
        if (cmd.enable_global_merge) {
            ptr = fmt.strcpyEqu(ptr, "--enable-global-merge\x00");
        }
        if (cmd.enable_gvn_hoist) {
            ptr = fmt.strcpyEqu(ptr, "--enable-gvn-hoist\x00");
        }
        if (cmd.enable_gvn_memdep) {
            ptr = fmt.strcpyEqu(ptr, "--enable-gvn-memdep\x00");
        }
        if (cmd.enable_gvn_sink) {
            ptr = fmt.strcpyEqu(ptr, "--enable-gvn-sink\x00");
        }
        if (cmd.enable_heap_to_stack_conversion) {
            ptr = fmt.strcpyEqu(ptr, "--enable-heap-to-stack-conversion\x00");
        }
        if (cmd.enable_hexagon_br_prob) {
            ptr = fmt.strcpyEqu(ptr, "--enable-hexagon-br-prob\x00");
        }
        if (cmd.enable_hexagon_sdnode_sched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-hexagon-sdnode-sched\x00");
        }
        if (cmd.enable_hexagon_vector_print) {
            ptr = fmt.strcpyEqu(ptr, "--enable-hexagon-vector-print\x00");
        }
        if (cmd.enable_if_conversion) {
            ptr = fmt.strcpyEqu(ptr, "--enable-if-conversion\x00");
        }
        if (cmd.enable_implicit_null_checks) {
            ptr = fmt.strcpyEqu(ptr, "--enable-implicit-null-checks\x00");
        }
        if (cmd.enable_import_metadata) {
            ptr = fmt.strcpyEqu(ptr, "--enable-import-metadata\x00");
        }
        if (cmd.enable_ind_var_reg_heur) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ind-var-reg-heur\x00");
        }
        if (cmd.enable_interleaved_mem_accesses) {
            ptr = fmt.strcpyEqu(ptr, "--enable-interleaved-mem-accesses\x00");
        }
        if (cmd.enable_ipra) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ipra\x00");
        }
        if (cmd.enable_jmc_instrument) {
            ptr = fmt.strcpyEqu(ptr, "--enable-jmc-instrument\x00");
        }
        if (cmd.enable_knowledge_retention) {
            ptr = fmt.strcpyEqu(ptr, "--enable-knowledge-retention\x00");
        }
        if (cmd.enable_legalize_types_checking) {
            ptr = fmt.strcpyEqu(ptr, "--enable-legalize-types-checking\x00");
        }
        if (cmd.enable_linkonceodr_ir_outlining) {
            ptr = fmt.strcpyEqu(ptr, "--enable-linkonceodr-ir-outlining\x00");
        }
        if (cmd.enable_linkonceodr_outlining) {
            ptr = fmt.strcpyEqu(ptr, "--enable-linkonceodr-outlining\x00");
        }
        if (cmd.enable_load_in_loop_pre) {
            ptr = fmt.strcpyEqu(ptr, "--enable-load-in-loop-pre\x00");
        }
        if (cmd.enable_load_pre) {
            ptr = fmt.strcpyEqu(ptr, "--enable-load-pre\x00");
        }
        if (cmd.enable_loadstore_runtime_interleave) {
            ptr = fmt.strcpyEqu(ptr, "--enable-loadstore-runtime-interleave\x00");
        }
        if (cmd.enable_local_reassign) {
            ptr = fmt.strcpyEqu(ptr, "--enable-local-reassign\x00");
        }
        if (cmd.enable_loop_distribute) {
            ptr = fmt.strcpyEqu(ptr, "--enable-loop-distribute\x00");
        }
        if (cmd.enable_loop_flatten) {
            ptr = fmt.strcpyEqu(ptr, "--enable-loop-flatten\x00");
        }
        if (cmd.enable_loop_simplifycfg_term_folding) {
            ptr = fmt.strcpyEqu(ptr, "--enable-loop-simplifycfg-term-folding\x00");
        }
        if (cmd.enable_loopinterchange) {
            ptr = fmt.strcpyEqu(ptr, "--enable-loopinterchange\x00");
        }
        if (cmd.enable_lsr_phielim) {
            ptr = fmt.strcpyEqu(ptr, "--enable-lsr-phielim\x00");
        }
        if (cmd.enable_lto_internalization) {
            ptr = fmt.strcpyEqu(ptr, "--enable-lto-internalization\x00");
        }
        if (cmd.enable_machine_outliner) |enable_machine_outliner| {
            ptr = fmt.strcpyEqu(ptr, "--enable-machine-outliner\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(enable_machine_outliner));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.enable_masked_interleaved_mem_accesses) {
            ptr = fmt.strcpyEqu(ptr, "--enable-masked-interleaved-mem-accesses\x00");
        }
        if (cmd.enable_matrix) {
            ptr = fmt.strcpyEqu(ptr, "--enable-matrix\x00");
        }
        if (cmd.enable_mem_access_versioning) {
            ptr = fmt.strcpyEqu(ptr, "--enable-mem-access-versioning\x00");
        }
        if (cmd.enable_mem_prof) {
            ptr = fmt.strcpyEqu(ptr, "--enable-mem-prof\x00");
        }
        if (cmd.enable_memcpy_dag_opt) {
            ptr = fmt.strcpyEqu(ptr, "--enable-memcpy-dag-opt\x00");
        }
        if (cmd.enable_memcpyopt_without_libcalls) {
            ptr = fmt.strcpyEqu(ptr, "--enable-memcpyopt-without-libcalls\x00");
        }
        if (cmd.enable_merge_functions) {
            ptr = fmt.strcpyEqu(ptr, "--enable-merge-functions\x00");
        }
        if (cmd.enable_misched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-misched\x00");
        }
        if (cmd.enable_ml_inliner) |enable_ml_inliner| {
            ptr = fmt.strcpyEqu(ptr, "--enable-ml-inliner\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(enable_ml_inliner));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.enable_module_inliner) {
            ptr = fmt.strcpyEqu(ptr, "--enable-module-inliner\x00");
        }
        if (cmd.enable_mve_interleave) {
            ptr = fmt.strcpyEqu(ptr, "--enable-mve-interleave\x00");
        }
        if (cmd.enable_name_compression) {
            ptr = fmt.strcpyEqu(ptr, "--enable-name-compression\x00");
        }
        if (cmd.enable_newgvn) {
            ptr = fmt.strcpyEqu(ptr, "--enable-newgvn\x00");
        }
        if (cmd.enable_no_infs_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-no-infs-fp-math\x00");
        }
        if (cmd.enable_no_nans_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-no-nans-fp-math\x00");
        }
        if (cmd.enable_no_rerun_simplification_pipeline) {
            ptr = fmt.strcpyEqu(ptr, "--enable-no-rerun-simplification-pipeline\x00");
        }
        if (cmd.enable_no_signed_zeros_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-no-signed-zeros-fp-math\x00");
        }
        if (cmd.enable_no_trapping_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-no-trapping-fp-math\x00");
        }
        if (cmd.enable_noalias_to_md_conversion) {
            ptr = fmt.strcpyEqu(ptr, "--enable-noalias-to-md-conversion\x00");
        }
        if (cmd.enable_nonnull_arg_prop) {
            ptr = fmt.strcpyEqu(ptr, "--enable-nonnull-arg-prop\x00");
        }
        if (cmd.enable_nontrivial_unswitch) {
            ptr = fmt.strcpyEqu(ptr, "--enable-nontrivial-unswitch\x00");
        }
        if (cmd.enable_npm_O3_nontrivial_unswitch) {
            ptr = fmt.strcpyEqu(ptr, "--enable-npm-O3-nontrivial-unswitch\x00");
        }
        if (cmd.enable_npm_pgo_inline_deferral) {
            ptr = fmt.strcpyEqu(ptr, "--enable-npm-pgo-inline-deferral\x00");
        }
        if (cmd.enable_npm_synthetic_counts) {
            ptr = fmt.strcpyEqu(ptr, "--enable-npm-synthetic-counts\x00");
        }
        if (cmd.enable_objc_arc_opts) {
            ptr = fmt.strcpyEqu(ptr, "--enable-objc-arc-opts\x00");
        }
        if (cmd.enable_order_file_instrumentation) {
            ptr = fmt.strcpyEqu(ptr, "--enable-order-file-instrumentation\x00");
        }
        if (cmd.enable_partial_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--enable-partial-inlining\x00");
        }
        if (cmd.enable_patchpoint_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--enable-patchpoint-liveness\x00");
        }
        if (cmd.enable_phi_of_ops) {
            ptr = fmt.strcpyEqu(ptr, "--enable-phi-of-ops\x00");
        }
        if (cmd.enable_pipeliner) {
            ptr = fmt.strcpyEqu(ptr, "--enable-pipeliner\x00");
        }
        if (cmd.enable_pipeliner_opt_size) {
            ptr = fmt.strcpyEqu(ptr, "--enable-pipeliner-opt-size\x00");
        }
        if (cmd.enable_post_misched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-post-misched\x00");
        }
        if (cmd.enable_post_pgo_loop_rotation) {
            ptr = fmt.strcpyEqu(ptr, "--enable-post-pgo-loop-rotation\x00");
        }
        if (cmd.enable_ppc_branch_coalesce) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ppc-branch-coalesce\x00");
        }
        if (cmd.enable_ppc_extra_toc_reg_deps) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ppc-extra-toc-reg-deps\x00");
        }
        if (cmd.enable_ppc_gen_scalar_mass) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ppc-gen-scalar-mass\x00");
        }
        if (cmd.enable_ppc_prefetching) {
            ptr = fmt.strcpyEqu(ptr, "--enable-ppc-prefetching\x00");
        }
        if (cmd.enable_pre) {
            ptr = fmt.strcpyEqu(ptr, "--enable-pre\x00");
        }
        if (cmd.enable_save_restore_long) {
            ptr = fmt.strcpyEqu(ptr, "--enable-save-restore-long\x00");
        }
        if (cmd.enable_scalable_autovec_in_streaming_mode) {
            ptr = fmt.strcpyEqu(ptr, "--enable-scalable-autovec-in-streaming-mode\x00");
        }
        if (cmd.enable_scc_inline_advisor_printing) {
            ptr = fmt.strcpyEqu(ptr, "--enable-scc-inline-advisor-printing\x00");
        }
        if (cmd.enable_scoped_noalias) {
            ptr = fmt.strcpyEqu(ptr, "--enable-scoped-noalias\x00");
        }
        if (cmd.enable_selectiondag_sp) {
            ptr = fmt.strcpyEqu(ptr, "--enable-selectiondag-sp\x00");
        }
        if (cmd.enable_shrink_wrap) {
            ptr = fmt.strcpyEqu(ptr, "--enable-shrink-wrap\x00");
        }
        if (cmd.enable_sign_dependent_rounding_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-sign-dependent-rounding-fp-math\x00");
        }
        if (cmd.enable_split_backedge_in_load_pre) {
            ptr = fmt.strcpyEqu(ptr, "--enable-split-backedge-in-load-pre\x00");
        }
        if (cmd.enable_split_machine_functions) {
            ptr = fmt.strcpyEqu(ptr, "--enable-split-machine-functions\x00");
        }
        if (cmd.enable_stackovf_sanitizer) {
            ptr = fmt.strcpyEqu(ptr, "--enable-stackovf-sanitizer\x00");
        }
        if (cmd.enable_store_refinement) {
            ptr = fmt.strcpyEqu(ptr, "--enable-store-refinement\x00");
        }
        if (cmd.enable_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--enable-subreg-liveness\x00");
        }
        if (cmd.enable_tail_merge) {
            ptr = fmt.strcpyEqu(ptr, "--enable-tail-merge\x00");
        }
        if (cmd.enable_tbaa) {
            ptr = fmt.strcpyEqu(ptr, "--enable-tbaa\x00");
        }
        if (cmd.enable_tc_latency_sched) {
            ptr = fmt.strcpyEqu(ptr, "--enable-tc-latency-sched\x00");
        }
        if (cmd.enable_timing_class_latency) {
            ptr = fmt.strcpyEqu(ptr, "--enable-timing-class-latency\x00");
        }
        if (cmd.enable_unroll_and_jam) {
            ptr = fmt.strcpyEqu(ptr, "--enable-unroll-and-jam\x00");
        }
        if (cmd.enable_unsafe_fp_math) {
            ptr = fmt.strcpyEqu(ptr, "--enable-unsafe-fp-math\x00");
        }
        if (cmd.enable_unsafe_globalsmodref_alias_results) {
            ptr = fmt.strcpyEqu(ptr, "--enable-unsafe-globalsmodref-alias-results\x00");
        }
        if (cmd.enable_unswitch_cost_multiplier) {
            ptr = fmt.strcpyEqu(ptr, "--enable-unswitch-cost-multiplier\x00");
        }
        if (cmd.enable_vfe) {
            ptr = fmt.strcpyEqu(ptr, "--enable-vfe\x00");
        }
        if (cmd.enable_vplan_native_path) {
            ptr = fmt.strcpyEqu(ptr, "--enable-vplan-native-path\x00");
        }
        if (cmd.enable_x86_scalar_amx) {
            ptr = fmt.strcpyEqu(ptr, "--enable-x86-scalar-amx\x00");
        }
        if (cmd.epilogue_vectorization_force_VF) |epilogue_vectorization_force_VF| {
            ptr = fmt.strcpyEqu(ptr, "--epilogue-vectorization-force-VF\x00");
            ptr = fmt.Ud64.write(ptr, epilogue_vectorization_force_VF);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.epilogue_vectorization_minimum_VF) |epilogue_vectorization_minimum_VF| {
            ptr = fmt.strcpyEqu(ptr, "--epilogue-vectorization-minimum-VF\x00");
            ptr = fmt.Ud64.write(ptr, epilogue_vectorization_minimum_VF);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.exception_model) |exception_model| {
            ptr = fmt.strcpyEqu(ptr, "--exception-model\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(exception_model));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.exec_on_ir_change) |exec_on_ir_change| {
            ptr = fmt.strcpyEqu(ptr, "--exec-on-ir-change\x00");
            ptr = fmt.strcpyEqu(ptr, exec_on_ir_change);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.exhaustive_register_search) {
            ptr = fmt.strcpyEqu(ptr, "--exhaustive-register-search\x00");
        }
        if (cmd.expand_all_fp_mlx) {
            ptr = fmt.strcpyEqu(ptr, "--expand-all-fp-mlx\x00");
        }
        if (cmd.expand_condsets_coa_limit) |expand_condsets_coa_limit| {
            ptr = fmt.strcpyEqu(ptr, "--expand-condsets-coa-limit\x00");
            ptr = fmt.Ud64.write(ptr, expand_condsets_coa_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expand_condsets_tfr_limit) |expand_condsets_tfr_limit| {
            ptr = fmt.strcpyEqu(ptr, "--expand-condsets-tfr-limit\x00");
            ptr = fmt.Ud64.write(ptr, expand_condsets_tfr_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expand_constant_exprs) {
            ptr = fmt.strcpyEqu(ptr, "--expand-constant-exprs\x00");
        }
        if (cmd.expand_div_rem_bits) |expand_div_rem_bits| {
            ptr = fmt.strcpyEqu(ptr, "--expand-div-rem-bits\x00");
            ptr = fmt.Ud64.write(ptr, expand_div_rem_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expand_fp_convert_bits) |expand_fp_convert_bits| {
            ptr = fmt.strcpyEqu(ptr, "--expand-fp-convert-bits\x00");
            ptr = fmt.Ud64.write(ptr, expand_fp_convert_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expand_limit) |expand_limit| {
            ptr = fmt.strcpyEqu(ptr, "--expand-limit\x00");
            ptr = fmt.Ud64.write(ptr, expand_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expandvp_override_evl_transform) |expandvp_override_evl_transform| {
            ptr = fmt.strcpyEqu(ptr, "--expandvp-override-evl-transform\x00");
            ptr = fmt.strcpyEqu(ptr, expandvp_override_evl_transform);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.expandvp_override_mask_transform) |expandvp_override_mask_transform| {
            ptr = fmt.strcpyEqu(ptr, "--expandvp-override-mask-transform\x00");
            ptr = fmt.strcpyEqu(ptr, expandvp_override_mask_transform);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.experimental_debug_variable_locations) {
            ptr = fmt.strcpyEqu(ptr, "--experimental-debug-variable-locations\x00");
        }
        if (cmd.expose_ppc_andi_glue_bug) {
            ptr = fmt.strcpyEqu(ptr, "--expose-ppc-andi-glue-bug\x00");
        }
        if (cmd.ext_tsp_apply_without_profile) {
            ptr = fmt.strcpyEqu(ptr, "--ext-tsp-apply-without-profile\x00");
        }
        if (cmd.extra_vectorizer_passes) {
            ptr = fmt.strcpyEqu(ptr, "--extra-vectorizer-passes\x00");
        }
        if (cmd.extract_blocks_erase_funcs) {
            ptr = fmt.strcpyEqu(ptr, "--extract-blocks-erase-funcs\x00");
        }
        if (cmd.extract_blocks_file) |extract_blocks_file| {
            ptr = fmt.strcpyEqu(ptr, "--extract-blocks-file\x00");
            ptr = fmt.strcpyEqu(ptr, extract_blocks_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.extract_cutoff) |extract_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--extract-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, extract_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.extract_needand) {
            ptr = fmt.strcpyEqu(ptr, "--extract-needand\x00");
        }
        if (cmd.extract_nosr0) {
            ptr = fmt.strcpyEqu(ptr, "--extract-nosr0\x00");
        }
        if (cmd.fast_cluster_threshold) |fast_cluster_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--fast-cluster-threshold\x00");
            ptr = fmt.Ud64.write(ptr, fast_cluster_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fast_isel) {
            ptr = fmt.strcpyEqu(ptr, "--fast-isel\x00");
        }
        if (cmd.fast_isel_abort) |fast_isel_abort| {
            ptr = fmt.strcpyEqu(ptr, "--fast-isel-abort\x00");
            ptr = fmt.Ud64.write(ptr, fast_isel_abort);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fast_isel_report_on_fallback) {
            ptr = fmt.strcpyEqu(ptr, "--fast-isel-report-on-fallback\x00");
        }
        if (cmd.fatal_warnings) {
            ptr = fmt.strcpyEqu(ptr, "--fatal-warnings\x00");
        }
        if (cmd.ffast_math) {
            ptr = fmt.strcpyEqu(ptr, "--ffast-math\x00");
        }
        if (cmd.filetype) |filetype| {
            ptr = fmt.strcpyEqu(ptr, "--filetype\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(filetype));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.filter_passes) |filter_passes| {
            ptr = fmt.strcpyEqu(ptr, "--filter-passes\x00");
            ptr = fmt.strcpyEqu(ptr, filter_passes);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.filter_print_funcs) |filter_print_funcs| {
            for (filter_print_funcs) |value| {
                ptr = fmt.strcpyEqu(ptr, "--filter-print-funcs\x00");
                ptr = fmt.strcpyEqu(ptr, value);
                ptr[0] = 0;
                ptr += 1;
            }
        }
        if (cmd.fixup_allow_gcptr_in_csr) {
            ptr = fmt.strcpyEqu(ptr, "--fixup-allow-gcptr-in-csr\x00");
        }
        if (cmd.fixup_byte_word_insts) {
            ptr = fmt.strcpyEqu(ptr, "--fixup-byte-word-insts\x00");
        }
        if (cmd.fixup_max_csr_statepoints) |fixup_max_csr_statepoints| {
            ptr = fmt.strcpyEqu(ptr, "--fixup-max-csr-statepoints\x00");
            ptr = fmt.Ud64.write(ptr, fixup_max_csr_statepoints);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fixup_scs_enable_copy_propagation) {
            ptr = fmt.strcpyEqu(ptr, "--fixup-scs-enable-copy-propagation\x00");
        }
        if (cmd.fixup_scs_extend_slot_size) {
            ptr = fmt.strcpyEqu(ptr, "--fixup-scs-extend-slot-size\x00");
        }
        if (cmd.flat_loop_tripcount_threshold) |flat_loop_tripcount_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--flat-loop-tripcount-threshold\x00");
            ptr = fmt.Ud64.write(ptr, flat_loop_tripcount_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.flattened_profile_used) {
            ptr = fmt.strcpyEqu(ptr, "--flattened-profile-used\x00");
        }
        if (cmd.float_abi) |float_abi| {
            ptr = fmt.strcpyEqu(ptr, "--float-abi\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(float_abi));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.float2int_max_integer_bw) |float2int_max_integer_bw| {
            ptr = fmt.strcpyEqu(ptr, "--float2int-max-integer-bw\x00");
            ptr = fmt.Ud64.write(ptr, float2int_max_integer_bw);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_attribute) |force_attribute| {
            ptr = fmt.strcpyEqu(ptr, "--force-attribute\x00");
            ptr = fmt.strcpyEqu(ptr, force_attribute);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_chr) {
            ptr = fmt.strcpyEqu(ptr, "--force-chr\x00");
        }
        if (cmd.force_dwarf_frame_section) {
            ptr = fmt.strcpyEqu(ptr, "--force-dwarf-frame-section\x00");
        }
        if (cmd.force_fast_cluster) {
            ptr = fmt.strcpyEqu(ptr, "--force-fast-cluster\x00");
        }
        if (cmd.force_function_specialization) {
            ptr = fmt.strcpyEqu(ptr, "--force-function-specialization\x00");
        }
        if (cmd.force_fuse_matrix) {
            ptr = fmt.strcpyEqu(ptr, "--force-fuse-matrix\x00");
        }
        if (cmd.force_hardware_loop_guard) {
            ptr = fmt.strcpyEqu(ptr, "--force-hardware-loop-guard\x00");
        }
        if (cmd.force_hardware_loop_phi) {
            ptr = fmt.strcpyEqu(ptr, "--force-hardware-loop-phi\x00");
        }
        if (cmd.force_hardware_loops) {
            ptr = fmt.strcpyEqu(ptr, "--force-hardware-loops\x00");
        }
        if (cmd.force_hvx_float) {
            ptr = fmt.strcpyEqu(ptr, "--force-hvx-float\x00");
        }
        if (cmd.force_import_all) {
            ptr = fmt.strcpyEqu(ptr, "--force-import-all\x00");
        }
        if (cmd.force_instr_ref_livedebugvalues) {
            ptr = fmt.strcpyEqu(ptr, "--force-instr-ref-livedebugvalues\x00");
        }
        if (cmd.force_legal_indexing) {
            ptr = fmt.strcpyEqu(ptr, "--force-legal-indexing\x00");
        }
        if (cmd.force_loop_cold_block) {
            ptr = fmt.strcpyEqu(ptr, "--force-loop-cold-block\x00");
        }
        if (cmd.force_mips_long_branch) {
            ptr = fmt.strcpyEqu(ptr, "--force-mips-long-branch\x00");
        }
        if (cmd.force_nested_hardware_loop) {
            ptr = fmt.strcpyEqu(ptr, "--force-nested-hardware-loop\x00");
        }
        if (cmd.force_ordered_reductions) {
            ptr = fmt.strcpyEqu(ptr, "--force-ordered-reductions\x00");
        }
        if (cmd.force_pgso) {
            ptr = fmt.strcpyEqu(ptr, "--force-pgso\x00");
        }
        if (cmd.force_precise_rotation_cost) {
            ptr = fmt.strcpyEqu(ptr, "--force-precise-rotation-cost\x00");
        }
        if (cmd.force_remove_attribute) |force_remove_attribute| {
            ptr = fmt.strcpyEqu(ptr, "--force-remove-attribute\x00");
            ptr = fmt.strcpyEqu(ptr, force_remove_attribute);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_split_store) {
            ptr = fmt.strcpyEqu(ptr, "--force-split-store\x00");
        }
        if (cmd.force_streaming_compatible_sve) {
            ptr = fmt.strcpyEqu(ptr, "--force-streaming-compatible-sve\x00");
        }
        if (cmd.force_summary_edges_cold) |force_summary_edges_cold| {
            ptr = fmt.strcpyEqu(ptr, "--force-summary-edges-cold\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(force_summary_edges_cold));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_instruction_cost) |force_target_instruction_cost| {
            ptr = fmt.strcpyEqu(ptr, "--force-target-instruction-cost\x00");
            ptr = fmt.Ud64.write(ptr, force_target_instruction_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_max_scalar_interleave) |force_target_max_scalar_interleave| {
            ptr = fmt.strcpyEqu(ptr, "--force-target-max-scalar-interleave\x00");
            ptr = fmt.Ud64.write(ptr, force_target_max_scalar_interleave);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_max_vector_interleave) |force_target_max_vector_interleave| {
            ptr = fmt.strcpyEqu(ptr, "--force-target-max-vector-interleave\x00");
            ptr = fmt.Ud64.write(ptr, force_target_max_vector_interleave);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_num_scalar_regs) |force_target_num_scalar_regs| {
            ptr = fmt.strcpyEqu(ptr, "--force-target-num-scalar-regs\x00");
            ptr = fmt.Ud64.write(ptr, force_target_num_scalar_regs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_num_vector_regs) |force_target_num_vector_regs| {
            ptr = fmt.strcpyEqu(ptr, "--force-target-num-vector-regs\x00");
            ptr = fmt.Ud64.write(ptr, force_target_num_vector_regs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_target_supports_scalable_vectors) {
            ptr = fmt.strcpyEqu(ptr, "--force-target-supports-scalable-vectors\x00");
        }
        if (cmd.force_vector_interleave) |force_vector_interleave| {
            ptr = fmt.strcpyEqu(ptr, "--force-vector-interleave\x00");
            ptr = fmt.Ud64.write(ptr, force_vector_interleave);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_vector_width) |force_vector_width| {
            ptr = fmt.strcpyEqu(ptr, "--force-vector-width\x00");
            ptr = fmt.Ud64.write(ptr, force_vector_width);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.force_widen_divrem_via_safe_divisor) {
            ptr = fmt.strcpyEqu(ptr, "--force-widen-divrem-via-safe-divisor\x00");
        }
        if (cmd.forget_scev_loop_unroll) {
            ptr = fmt.strcpyEqu(ptr, "--forget-scev-loop-unroll\x00");
        }
        if (cmd.forward_switch_cond) {
            ptr = fmt.strcpyEqu(ptr, "--forward-switch-cond\x00");
        }
        if (cmd.fp_contract) |fp_contract| {
            ptr = fmt.strcpyEqu(ptr, "--fp-contract\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(fp_contract));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.frame_helper_size_threshold) |frame_helper_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--frame-helper-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, frame_helper_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.frame_pointer) |frame_pointer| {
            ptr = fmt.strcpyEqu(ptr, "--frame-pointer\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(frame_pointer));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.freeze_loop_unswitch_cond) {
            ptr = fmt.strcpyEqu(ptr, "--freeze-loop-unswitch-cond\x00");
        }
        if (cmd.fs_no_final_discrim) {
            ptr = fmt.strcpyEqu(ptr, "--fs-no-final-discrim\x00");
        }
        if (cmd.fs_profile_debug_bw_threshold) |fs_profile_debug_bw_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--fs-profile-debug-bw-threshold\x00");
            ptr = fmt.Ud64.write(ptr, fs_profile_debug_bw_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fs_profile_debug_prob_diff_threshold) |fs_profile_debug_prob_diff_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--fs-profile-debug-prob-diff-threshold\x00");
            ptr = fmt.Ud64.write(ptr, fs_profile_debug_prob_diff_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fs_profile_file) |fs_profile_file| {
            ptr = fmt.strcpyEqu(ptr, "--fs-profile-file\x00");
            ptr = fmt.strcpyEqu(ptr, fs_profile_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fs_remapping_file) |fs_remapping_file| {
            ptr = fmt.strcpyEqu(ptr, "--fs-remapping-file\x00");
            ptr = fmt.strcpyEqu(ptr, fs_remapping_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fs_viewbfi_after) {
            ptr = fmt.strcpyEqu(ptr, "--fs-viewbfi-after\x00");
        }
        if (cmd.fs_viewbfi_before) {
            ptr = fmt.strcpyEqu(ptr, "--fs-viewbfi-before\x00");
        }
        if (cmd.func_specialization_avg_iters_cost) |func_specialization_avg_iters_cost| {
            ptr = fmt.strcpyEqu(ptr, "--func-specialization-avg-iters-cost\x00");
            ptr = fmt.Ud64.write(ptr, func_specialization_avg_iters_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.func_specialization_max_clones) |func_specialization_max_clones| {
            ptr = fmt.strcpyEqu(ptr, "--func-specialization-max-clones\x00");
            ptr = fmt.Ud64.write(ptr, func_specialization_max_clones);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.func_specialization_max_iters) |func_specialization_max_iters| {
            ptr = fmt.strcpyEqu(ptr, "--func-specialization-max-iters\x00");
            ptr = fmt.Ud64.write(ptr, func_specialization_max_iters);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.func_specialization_on_address) {
            ptr = fmt.strcpyEqu(ptr, "--func-specialization-on-address\x00");
        }
        if (cmd.func_specialization_size_threshold) |func_specialization_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--func-specialization-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, func_specialization_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.function_sections) {
            ptr = fmt.strcpyEqu(ptr, "--function-sections\x00");
        }
        if (cmd.function_specialization_for_literal_constant) {
            ptr = fmt.strcpyEqu(ptr, "--function-specialization-for-literal-constant\x00");
        }
        if (cmd.fuse_matrix) {
            ptr = fmt.strcpyEqu(ptr, "--fuse-matrix\x00");
        }
        if (cmd.fuse_matrix_tile_size) |fuse_matrix_tile_size| {
            ptr = fmt.strcpyEqu(ptr, "--fuse-matrix-tile-size\x00");
            ptr = fmt.Ud64.write(ptr, fuse_matrix_tile_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.fuse_matrix_use_loops) {
            ptr = fmt.strcpyEqu(ptr, "--fuse-matrix-use-loops\x00");
        }
        if (cmd.gcov_atomic_counter) {
            ptr = fmt.strcpyEqu(ptr, "--gcov-atomic-counter\x00");
        }
        if (cmd.generate_arange_section) {
            ptr = fmt.strcpyEqu(ptr, "--generate-arange-section\x00");
        }
        if (cmd.generate_merged_base_profiles) {
            ptr = fmt.strcpyEqu(ptr, "--generate-merged-base-profiles\x00");
        }
        if (cmd.generate_type_units) {
            ptr = fmt.strcpyEqu(ptr, "--generate-type-units\x00");
        }
        if (cmd.global_isel) {
            ptr = fmt.strcpyEqu(ptr, "--global-isel\x00");
        }
        if (cmd.global_isel_abort) |global_isel_abort| {
            ptr = fmt.strcpyEqu(ptr, "--global-isel-abort\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(global_isel_abort));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.global_merge_group_by_use) {
            ptr = fmt.strcpyEqu(ptr, "--global-merge-group-by-use\x00");
        }
        if (cmd.global_merge_ignore_single_use) {
            ptr = fmt.strcpyEqu(ptr, "--global-merge-ignore-single-use\x00");
        }
        if (cmd.global_merge_max_offset) |global_merge_max_offset| {
            ptr = fmt.strcpyEqu(ptr, "--global-merge-max-offset\x00");
            ptr = fmt.Ud64.write(ptr, global_merge_max_offset);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.global_merge_on_const) {
            ptr = fmt.strcpyEqu(ptr, "--global-merge-on-const\x00");
        }
        if (cmd.global_merge_on_external) {
            ptr = fmt.strcpyEqu(ptr, "--global-merge-on-external\x00");
        }
        if (cmd.gpsize) |gpsize| {
            ptr = fmt.strcpyEqu(ptr, "--gpsize\x00");
            ptr = fmt.Ud64.write(ptr, gpsize);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.greedy_regclass_priority_trumps_globalness) {
            ptr = fmt.strcpyEqu(ptr, "--greedy-regclass-priority-trumps-globalness\x00");
        }
        if (cmd.greedy_reverse_local_assignment) {
            ptr = fmt.strcpyEqu(ptr, "--greedy-reverse-local-assignment\x00");
        }
        if (cmd.grow_region_complexity_budget) |grow_region_complexity_budget| {
            ptr = fmt.strcpyEqu(ptr, "--grow-region-complexity-budget\x00");
            ptr = fmt.Ud64.write(ptr, grow_region_complexity_budget);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.guard_widening_widen_branch_guards) {
            ptr = fmt.strcpyEqu(ptr, "--guard-widening-widen-branch-guards\x00");
        }
        if (cmd.guards_predicate_pass_branch_weight) |guards_predicate_pass_branch_weight| {
            ptr = fmt.strcpyEqu(ptr, "--guards-predicate-pass-branch-weight\x00");
            ptr = fmt.Ud64.write(ptr, guards_predicate_pass_branch_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_add_phi_translation) {
            ptr = fmt.strcpyEqu(ptr, "--gvn-add-phi-translation\x00");
        }
        if (cmd.gvn_hoist_max_bbs) |gvn_hoist_max_bbs| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-hoist-max-bbs\x00");
            ptr = fmt.Ud64.write(ptr, gvn_hoist_max_bbs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_hoist_max_chain_length) |gvn_hoist_max_chain_length| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-hoist-max-chain-length\x00");
            ptr = fmt.Ud64.write(ptr, gvn_hoist_max_chain_length);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_hoist_max_depth) |gvn_hoist_max_depth| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-hoist-max-depth\x00");
            ptr = fmt.Ud64.write(ptr, gvn_hoist_max_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_max_block_speculations) |gvn_max_block_speculations| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-max-block-speculations\x00");
            ptr = fmt.Ud64.write(ptr, gvn_max_block_speculations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_max_hoisted) |gvn_max_hoisted| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-max-hoisted\x00");
            ptr = fmt.Ud64.write(ptr, gvn_max_hoisted);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_max_num_deps) |gvn_max_num_deps| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-max-num-deps\x00");
            ptr = fmt.Ud64.write(ptr, gvn_max_num_deps);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.gvn_max_num_visited_insts) |gvn_max_num_visited_insts| {
            ptr = fmt.strcpyEqu(ptr, "--gvn-max-num-visited-insts\x00");
            ptr = fmt.Ud64.write(ptr, gvn_max_num_visited_insts);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hardware_loop_counter_bitwidth) |hardware_loop_counter_bitwidth| {
            ptr = fmt.strcpyEqu(ptr, "--hardware-loop-counter-bitwidth\x00");
            ptr = fmt.Ud64.write(ptr, hardware_loop_counter_bitwidth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hardware_loop_decrement) |hardware_loop_decrement| {
            ptr = fmt.strcpyEqu(ptr, "--hardware-loop-decrement\x00");
            ptr = fmt.Ud64.write(ptr, hardware_loop_decrement);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hash_based_counter_split) {
            ptr = fmt.strcpyEqu(ptr, "--hash-based-counter-split\x00");
        }
        if (cmd.help) {
            ptr[0..7].* = "--help\x00".*;
            ptr += 7;
        }
        if (cmd.help_hidden) {
            ptr = fmt.strcpyEqu(ptr, "--help-hidden\x00");
        }
        if (cmd.help_list) {
            ptr = fmt.strcpyEqu(ptr, "--help-list\x00");
        }
        if (cmd.help_list_hidden) {
            ptr = fmt.strcpyEqu(ptr, "--help-list-hidden\x00");
        }
        if (cmd.hexagon_align_loads) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-align-loads\x00");
        }
        if (cmd.hexagon_amode_growth_limit) |hexagon_amode_growth_limit| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-amode-growth-limit\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_amode_growth_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_autohvx) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-autohvx\x00");
        }
        if (cmd.hexagon_bit) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-bit\x00");
        }
        if (cmd.hexagon_cext) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-cext\x00");
        }
        if (cmd.hexagon_cext_limit) |hexagon_cext_limit| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-cext-limit\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_cext_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_cext_threshold) |hexagon_cext_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-cext-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_cext_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_check_bank_conflict) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-check-bank-conflict\x00");
        }
        if (cmd.hexagon_commgep) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-commgep\x00");
        }
        if (cmd.hexagon_disable_args_min_alignment) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-disable-args-min-alignment\x00");
        }
        if (cmd.hexagon_eif) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-eif\x00");
        }
        if (cmd.hexagon_emit_jt_text) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-emit-jt-text\x00");
        }
        if (cmd.hexagon_emit_jump_tables) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-emit-jump-tables\x00");
        }
        if (cmd.hexagon_emit_lookup_tables) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-emit-lookup-tables\x00");
        }
        if (cmd.hexagon_emit_lut_text) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-emit-lut-text\x00");
        }
        if (cmd.hexagon_enable_branch_prediction) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-enable-branch-prediction\x00");
        }
        if (cmd.hexagon_expand_condsets) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-expand-condsets\x00");
        }
        if (cmd.hexagon_extract) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-extract\x00");
        }
        if (cmd.hexagon_fp_elim) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-fp-elim\x00");
        }
        if (cmd.hexagon_frame_index_reuse_limit) |hexagon_frame_index_reuse_limit| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-frame-index-reuse-limit\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_frame_index_reuse_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_frame_index_search_range) |hexagon_frame_index_search_range| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-frame-index-search-range\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_frame_index_search_range);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_gen_mux_threshold) |hexagon_gen_mux_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-gen-mux-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_gen_mux_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_gen_pred) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-gen-pred\x00");
        }
        if (cmd.hexagon_hvx_widen) |hexagon_hvx_widen| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-hvx-widen\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_hvx_widen);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_hwloop_preheader) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-hwloop-preheader\x00");
        }
        if (cmd.hexagon_initial_cfg_cleanup) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-initial-cfg-cleanup\x00");
        }
        if (cmd.hexagon_insert) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-insert\x00");
        }
        if (cmd.hexagon_instsimplify) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-instsimplify\x00");
        }
        if (cmd.hexagon_isel_su) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-isel-su\x00");
        }
        if (cmd.hexagon_long_calls) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-long-calls\x00");
        }
        if (cmd.hexagon_loop_prefetch) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-loop-prefetch\x00");
        }
        if (cmd.hexagon_loop_range) |hexagon_loop_range| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-loop-range\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_loop_range);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_loop_resched) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-loop-resched\x00");
        }
        if (cmd.hexagon_masked_vmem) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-masked-vmem\x00");
        }
        if (cmd.hexagon_mux) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-mux\x00");
        }
        if (cmd.hexagon_noopt) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-noopt\x00");
        }
        if (cmd.hexagon_opt_spill) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-opt-spill\x00");
        }
        if (cmd.hexagon_opt_vextract) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-opt-vextract\x00");
        }
        if (cmd.hexagon_packetize_volatiles) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-packetize-volatiles\x00");
        }
        if (cmd.hexagon_pred_calls) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-pred-calls\x00");
        }
        if (cmd.hexagon_sched_inline_asm) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-sched-inline-asm\x00");
        }
        if (cmd.hexagon_shrink_frame) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-shrink-frame\x00");
        }
        if (cmd.hexagon_small_data_threshold) |hexagon_small_data_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-small-data-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_small_data_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_statics_in_small_data) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-statics-in-small-data\x00");
        }
        if (cmd.hexagon_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-subreg-liveness\x00");
        }
        if (cmd.hexagon_vector_combine) {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-vector-combine\x00");
        }
        if (cmd.hexagon_vextract_threshold) |hexagon_vextract_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-vextract-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_vextract_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexagon_vlcr_iteration_lim) |hexagon_vlcr_iteration_lim| {
            ptr = fmt.strcpyEqu(ptr, "--hexagon-vlcr-iteration-lim\x00");
            ptr = fmt.Ud64.write(ptr, hexagon_vlcr_iteration_lim);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexbit_bitsplit) {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-bitsplit\x00");
        }
        if (cmd.hexbit_extract) {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-extract\x00");
        }
        if (cmd.hexbit_keep_tied) {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-keep-tied\x00");
        }
        if (cmd.hexbit_max_bitsplit) |hexbit_max_bitsplit| {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-max-bitsplit\x00");
            ptr = fmt.Ud64.write(ptr, hexbit_max_bitsplit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexbit_max_extract) |hexbit_max_extract| {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-max-extract\x00");
            ptr = fmt.Ud64.write(ptr, hexbit_max_extract);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hexbit_registerset_limit) |hexbit_registerset_limit| {
            ptr = fmt.strcpyEqu(ptr, "--hexbit-registerset-limit\x00");
            ptr = fmt.Ud64.write(ptr, hexbit_registerset_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hints_allow_reordering) {
            ptr = fmt.strcpyEqu(ptr, "--hints-allow-reordering\x00");
        }
        if (cmd.hlir_simplify_limit) |hlir_simplify_limit| {
            ptr = fmt.strcpyEqu(ptr, "--hlir-simplify-limit\x00");
            ptr = fmt.Ud64.write(ptr, hlir_simplify_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hoist_cheap_insts) {
            ptr = fmt.strcpyEqu(ptr, "--hoist-cheap-insts\x00");
        }
        if (cmd.hoist_common_insts) {
            ptr = fmt.strcpyEqu(ptr, "--hoist-common-insts\x00");
        }
        if (cmd.hoist_const_stores) {
            ptr = fmt.strcpyEqu(ptr, "--hoist-const-stores\x00");
        }
        if (cmd.homogeneous_prolog_epilog) {
            ptr = fmt.strcpyEqu(ptr, "--homogeneous-prolog-epilog\x00");
        }
        if (cmd.hot_callsite_rel_freq) |hot_callsite_rel_freq| {
            ptr = fmt.strcpyEqu(ptr, "--hot-callsite-rel-freq\x00");
            ptr = fmt.Ud64.write(ptr, hot_callsite_rel_freq);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hot_callsite_threshold) |hot_callsite_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hot-callsite-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hot_callsite_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hot_cold_split) {
            ptr = fmt.strcpyEqu(ptr, "--hot-cold-split\x00");
        }
        if (cmd.hot_cold_static_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--hot-cold-static-analysis\x00");
        }
        if (cmd.hotcoldsplit_cold_section_name) |hotcoldsplit_cold_section_name| {
            ptr = fmt.strcpyEqu(ptr, "--hotcoldsplit-cold-section-name\x00");
            ptr = fmt.strcpyEqu(ptr, hotcoldsplit_cold_section_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hotcoldsplit_max_params) |hotcoldsplit_max_params| {
            ptr = fmt.strcpyEqu(ptr, "--hotcoldsplit-max-params\x00");
            ptr = fmt.Ud64.write(ptr, hotcoldsplit_max_params);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hotcoldsplit_threshold) |hotcoldsplit_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--hotcoldsplit-threshold\x00");
            ptr = fmt.Ud64.write(ptr, hotcoldsplit_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hsdr_no_mem) {
            ptr = fmt.strcpyEqu(ptr, "--hsdr-no-mem\x00");
        }
        if (cmd.hsdr_split_all) {
            ptr = fmt.strcpyEqu(ptr, "--hsdr-split-all\x00");
        }
        if (cmd.huge_size_for_split) |huge_size_for_split| {
            ptr = fmt.strcpyEqu(ptr, "--huge-size-for-split\x00");
            ptr = fmt.Ud64.write(ptr, huge_size_for_split);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hwasan_experimental_use_page_aliases) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-experimental-use-page-aliases\x00");
        }
        if (cmd.hwasan_generate_tags_with_calls) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-generate-tags-with-calls\x00");
        }
        if (cmd.hwasan_globals) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-globals\x00");
        }
        if (cmd.hwasan_inline_all_checks) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-inline-all-checks\x00");
        }
        if (cmd.hwasan_instrument_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-atomics\x00");
        }
        if (cmd.hwasan_instrument_byval) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-byval\x00");
        }
        if (cmd.hwasan_instrument_landing_pads) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-landing-pads\x00");
        }
        if (cmd.hwasan_instrument_mem_intrinsics) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-mem-intrinsics\x00");
        }
        if (cmd.hwasan_instrument_personality_functions) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-personality-functions\x00");
        }
        if (cmd.hwasan_instrument_reads) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-reads\x00");
        }
        if (cmd.hwasan_instrument_stack) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-stack\x00");
        }
        if (cmd.hwasan_instrument_with_calls) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-with-calls\x00");
        }
        if (cmd.hwasan_instrument_writes) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-instrument-writes\x00");
        }
        if (cmd.hwasan_kernel) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-kernel\x00");
        }
        if (cmd.hwasan_kernel_mem_intrinsic_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-kernel-mem-intrinsic-prefix\x00");
        }
        if (cmd.hwasan_mapping_offset) |hwasan_mapping_offset| {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-mapping-offset\x00");
            ptr = fmt.Ud64.write(ptr, hwasan_mapping_offset);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hwasan_match_all_tag) |hwasan_match_all_tag| {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-match-all-tag\x00");
            ptr = fmt.Ud64.write(ptr, hwasan_match_all_tag);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hwasan_memory_access_callback_prefix) |hwasan_memory_access_callback_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-memory-access-callback-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, hwasan_memory_access_callback_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hwasan_record_stack_history) |hwasan_record_stack_history| {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-record-stack-history\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(hwasan_record_stack_history));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.hwasan_recover) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-recover\x00");
        }
        if (cmd.hwasan_uar_retag_to_zero) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-uar-retag-to-zero\x00");
        }
        if (cmd.hwasan_use_after_scope) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-use-after-scope\x00");
        }
        if (cmd.hwasan_use_short_granules) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-use-short-granules\x00");
        }
        if (cmd.hwasan_use_stack_safety) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-use-stack-safety\x00");
        }
        if (cmd.hwasan_with_ifunc) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-with-ifunc\x00");
        }
        if (cmd.hwasan_with_tls) {
            ptr = fmt.strcpyEqu(ptr, "--hwasan-with-tls\x00");
        }
        if (cmd.hwloop_spec_preheader) {
            ptr = fmt.strcpyEqu(ptr, "--hwloop-spec-preheader\x00");
        }
        if (cmd.icp_call_only) {
            ptr = fmt.strcpyEqu(ptr, "--icp-call-only\x00");
        }
        if (cmd.icp_csskip) |icp_csskip| {
            ptr = fmt.strcpyEqu(ptr, "--icp-csskip\x00");
            ptr = fmt.Ud64.write(ptr, icp_csskip);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.icp_cutoff) |icp_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--icp-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, icp_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.icp_dumpafter) {
            ptr = fmt.strcpyEqu(ptr, "--icp-dumpafter\x00");
        }
        if (cmd.icp_invoke_only) {
            ptr = fmt.strcpyEqu(ptr, "--icp-invoke-only\x00");
        }
        if (cmd.icp_lto) {
            ptr = fmt.strcpyEqu(ptr, "--icp-lto\x00");
        }
        if (cmd.icp_max_annotations) |icp_max_annotations| {
            ptr = fmt.strcpyEqu(ptr, "--icp-max-annotations\x00");
            ptr = fmt.Ud64.write(ptr, icp_max_annotations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.icp_max_prom) |icp_max_prom| {
            ptr = fmt.strcpyEqu(ptr, "--icp-max-prom\x00");
            ptr = fmt.Ud64.write(ptr, icp_max_prom);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.icp_remaining_percent_threshold) |icp_remaining_percent_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--icp-remaining-percent-threshold\x00");
            ptr = fmt.Ud64.write(ptr, icp_remaining_percent_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.icp_samplepgo) {
            ptr = fmt.strcpyEqu(ptr, "--icp-samplepgo\x00");
        }
        if (cmd.icp_total_percent_threshold) |icp_total_percent_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--icp-total-percent-threshold\x00");
            ptr = fmt.Ud64.write(ptr, icp_total_percent_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ifcvt_branch_fold) {
            ptr = fmt.strcpyEqu(ptr, "--ifcvt-branch-fold\x00");
        }
        if (cmd.ifcvt_fn_start) |ifcvt_fn_start| {
            ptr = fmt.strcpyEqu(ptr, "--ifcvt-fn-start\x00");
            ptr = fmt.Ud64.write(ptr, ifcvt_fn_start);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ifcvt_fn_stop) |ifcvt_fn_stop| {
            ptr = fmt.strcpyEqu(ptr, "--ifcvt-fn-stop\x00");
            ptr = fmt.Ud64.write(ptr, ifcvt_fn_stop);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ifcvt_limit) |ifcvt_limit| {
            ptr = fmt.strcpyEqu(ptr, "--ifcvt-limit\x00");
            ptr = fmt.Ud64.write(ptr, ifcvt_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ignore_bb_reg_pressure) {
            ptr = fmt.strcpyEqu(ptr, "--ignore-bb-reg-pressure\x00");
        }
        if (cmd.ignore_tti_inline_compatible) {
            ptr = fmt.strcpyEqu(ptr, "--ignore-tti-inline-compatible\x00");
        }
        if (cmd.ignore_xcoff_visibility) {
            ptr = fmt.strcpyEqu(ptr, "--ignore-xcoff-visibility\x00");
        }
        if (cmd.imp_null_check_page_size) |imp_null_check_page_size| {
            ptr = fmt.strcpyEqu(ptr, "--imp-null-check-page-size\x00");
            ptr = fmt.Ud64.write(ptr, imp_null_check_page_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.imp_null_max_insts_to_consider) |imp_null_max_insts_to_consider| {
            ptr = fmt.strcpyEqu(ptr, "--imp-null-max-insts-to-consider\x00");
            ptr = fmt.Ud64.write(ptr, imp_null_max_insts_to_consider);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_all_index) {
            ptr = fmt.strcpyEqu(ptr, "--import-all-index\x00");
        }
        if (cmd.import_cold_multiplier) |import_cold_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--import-cold-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, import_cold_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_constants_with_refs) {
            ptr = fmt.strcpyEqu(ptr, "--import-constants-with-refs\x00");
        }
        if (cmd.import_critical_multiplier) |import_critical_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--import-critical-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, import_critical_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_cutoff) |import_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--import-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, import_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_full_type_definitions) {
            ptr = fmt.strcpyEqu(ptr, "--import-full-type-definitions\x00");
        }
        if (cmd.import_hot_evolution_factor) |import_hot_evolution_factor| {
            ptr = fmt.strcpyEqu(ptr, "--import-hot-evolution-factor\x00");
            ptr = fmt.Ud64.write(ptr, import_hot_evolution_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_hot_multiplier) |import_hot_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--import-hot-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, import_hot_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_instr_evolution_factor) |import_instr_evolution_factor| {
            ptr = fmt.strcpyEqu(ptr, "--import-instr-evolution-factor\x00");
            ptr = fmt.Ud64.write(ptr, import_instr_evolution_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.import_instr_limit) |import_instr_limit| {
            ptr = fmt.strcpyEqu(ptr, "--import-instr-limit\x00");
            ptr = fmt.Ud64.write(ptr, import_instr_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.incremental_linker_compatible) {
            ptr = fmt.strcpyEqu(ptr, "--incremental-linker-compatible\x00");
        }
        if (cmd.indvars_post_increment_ranges) {
            ptr = fmt.strcpyEqu(ptr, "--indvars-post-increment-ranges\x00");
        }
        if (cmd.indvars_predicate_loops) {
            ptr = fmt.strcpyEqu(ptr, "--indvars-predicate-loops\x00");
        }
        if (cmd.indvars_widen_indvars) {
            ptr = fmt.strcpyEqu(ptr, "--indvars-widen-indvars\x00");
        }
        if (cmd.info_output_file) |info_output_file| {
            ptr = fmt.strcpyEqu(ptr, "--info-output-file\x00");
            ptr = fmt.strcpyEqu(ptr, info_output_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.initial_synthetic_count) |initial_synthetic_count| {
            ptr = fmt.strcpyEqu(ptr, "--initial-synthetic-count\x00");
            ptr = fmt.Ud64.write(ptr, initial_synthetic_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_call_penalty) |inline_call_penalty| {
            ptr = fmt.strcpyEqu(ptr, "--inline-call-penalty\x00");
            ptr = fmt.Ud64.write(ptr, inline_call_penalty);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_caller_superset_nobuiltin) {
            ptr = fmt.strcpyEqu(ptr, "--inline-caller-superset-nobuiltin\x00");
        }
        if (cmd.inline_cold_callsite_threshold) |inline_cold_callsite_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--inline-cold-callsite-threshold\x00");
            ptr = fmt.Ud64.write(ptr, inline_cold_callsite_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_cost_full) {
            ptr = fmt.strcpyEqu(ptr, "--inline-cost-full\x00");
        }
        if (cmd.inline_deferral) {
            ptr = fmt.strcpyEqu(ptr, "--inline-deferral\x00");
        }
        if (cmd.inline_deferral_scale) |inline_deferral_scale| {
            ptr = fmt.strcpyEqu(ptr, "--inline-deferral-scale\x00");
            ptr = fmt.Ud64.write(ptr, inline_deferral_scale);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_enable_cost_benefit_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--inline-enable-cost-benefit-analysis\x00");
        }
        if (cmd.inline_instr_cost) |inline_instr_cost| {
            ptr = fmt.strcpyEqu(ptr, "--inline-instr-cost\x00");
            ptr = fmt.Ud64.write(ptr, inline_instr_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_max_stacksize) |inline_max_stacksize| {
            ptr = fmt.strcpyEqu(ptr, "--inline-max-stacksize\x00");
            ptr = fmt.Ud64.write(ptr, inline_max_stacksize);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_memaccess_cost) |inline_memaccess_cost| {
            ptr = fmt.strcpyEqu(ptr, "--inline-memaccess-cost\x00");
            ptr = fmt.Ud64.write(ptr, inline_memaccess_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_priority_mode) |inline_priority_mode| {
            ptr = fmt.strcpyEqu(ptr, "--inline-priority-mode\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(inline_priority_mode));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_remark_attribute) {
            ptr = fmt.strcpyEqu(ptr, "--inline-remark-attribute\x00");
        }
        if (cmd.inline_savings_multiplier) |inline_savings_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--inline-savings-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, inline_savings_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_size_allowance) |inline_size_allowance| {
            ptr = fmt.strcpyEqu(ptr, "--inline-size-allowance\x00");
            ptr = fmt.Ud64.write(ptr, inline_size_allowance);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_synthetic_count) |inline_synthetic_count| {
            ptr = fmt.strcpyEqu(ptr, "--inline-synthetic-count\x00");
            ptr = fmt.Ud64.write(ptr, inline_synthetic_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inline_threshold) |inline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--inline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, inline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inlinecold_threshold) |inlinecold_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--inlinecold-threshold\x00");
            ptr = fmt.Ud64.write(ptr, inlinecold_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inlinedefault_threshold) |inlinedefault_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--inlinedefault-threshold\x00");
            ptr = fmt.Ud64.write(ptr, inlinedefault_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inlinehint_threshold) |inlinehint_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--inlinehint-threshold\x00");
            ptr = fmt.Ud64.write(ptr, inlinehint_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.inliner_function_import_stats) |inliner_function_import_stats| {
            ptr = fmt.strcpyEqu(ptr, "--inliner-function-import-stats\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(inliner_function_import_stats));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.insert_all0) {
            ptr = fmt.strcpyEqu(ptr, "--insert-all0\x00");
        }
        if (cmd.insert_const) {
            ptr = fmt.strcpyEqu(ptr, "--insert-const\x00");
        }
        if (cmd.insert_dist_cutoff) |insert_dist_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--insert-dist-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, insert_dist_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.insert_has0) {
            ptr = fmt.strcpyEqu(ptr, "--insert-has0\x00");
        }
        if (cmd.insert_max_ifmap) |insert_max_ifmap| {
            ptr = fmt.strcpyEqu(ptr, "--insert-max-ifmap\x00");
            ptr = fmt.Ud64.write(ptr, insert_max_ifmap);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.insert_max_orl) |insert_max_orl| {
            ptr = fmt.strcpyEqu(ptr, "--insert-max-orl\x00");
            ptr = fmt.Ud64.write(ptr, insert_max_orl);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.insert_timing) {
            ptr = fmt.strcpyEqu(ptr, "--insert-timing\x00");
        }
        if (cmd.insert_timing_detail) {
            ptr = fmt.strcpyEqu(ptr, "--insert-timing-detail\x00");
        }
        if (cmd.insert_vreg_cutoff) |insert_vreg_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--insert-vreg-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, insert_vreg_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_code_sinking) {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-code-sinking\x00");
        }
        if (cmd.instcombine_guard_widening_window) |instcombine_guard_widening_window| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-guard-widening-window\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_guard_widening_window);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_infinite_loop_threshold) |instcombine_infinite_loop_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-infinite-loop-threshold\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_infinite_loop_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_lower_dbg_declare) |instcombine_lower_dbg_declare| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-lower-dbg-declare\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_lower_dbg_declare);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_max_copied_from_constant_users) |instcombine_max_copied_from_constant_users| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-max-copied-from-constant-users\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_max_copied_from_constant_users);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_max_iterations) |instcombine_max_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-max-iterations\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_max_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_max_num_phis) |instcombine_max_num_phis| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-max-num-phis\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_max_num_phis);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_max_sink_users) |instcombine_max_sink_users| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-max-sink-users\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_max_sink_users);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_maxarray_size) |instcombine_maxarray_size| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-maxarray-size\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_maxarray_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instcombine_negator_enabled) {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-negator-enabled\x00");
        }
        if (cmd.instcombine_negator_max_depth) |instcombine_negator_max_depth| {
            ptr = fmt.strcpyEqu(ptr, "--instcombine-negator-max-depth\x00");
            ptr = fmt.Ud64.write(ptr, instcombine_negator_max_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.instrprof_atomic_counter_update_all) {
            ptr = fmt.strcpyEqu(ptr, "--instrprof-atomic-counter-update-all\x00");
        }
        if (cmd.interleave_loops) {
            ptr = fmt.strcpyEqu(ptr, "--interleave-loops\x00");
        }
        if (cmd.interleave_small_loop_scalar_reduction) {
            ptr = fmt.strcpyEqu(ptr, "--interleave-small-loop-scalar-reduction\x00");
        }
        if (cmd.internalize_public_api_file) |internalize_public_api_file| {
            ptr = fmt.strcpyEqu(ptr, "--internalize-public-api-file\x00");
            ptr = fmt.strcpyEqu(ptr, internalize_public_api_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.internalize_public_api_list) {
            ptr = fmt.strcpyEqu(ptr, "--internalize-public-api-list\x00");
        }
        if (cmd.interpreter_print_volatile) {
            ptr = fmt.strcpyEqu(ptr, "--interpreter-print-volatile\x00");
        }
        if (cmd.intra_scc_cost_multiplier) |intra_scc_cost_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--intra-scc-cost-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, intra_scc_cost_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ir_outliner) {
            ptr = fmt.strcpyEqu(ptr, "--ir-outliner\x00");
        }
        if (cmd.irce_allow_narrow_latch) {
            ptr = fmt.strcpyEqu(ptr, "--irce-allow-narrow-latch\x00");
        }
        if (cmd.irce_allow_unsigned_latch) {
            ptr = fmt.strcpyEqu(ptr, "--irce-allow-unsigned-latch\x00");
        }
        if (cmd.irce_loop_size_cutoff) |irce_loop_size_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--irce-loop-size-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, irce_loop_size_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.irce_min_runtime_iterations) |irce_min_runtime_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--irce-min-runtime-iterations\x00");
            ptr = fmt.Ud64.write(ptr, irce_min_runtime_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.irce_print_changed_loops) {
            ptr = fmt.strcpyEqu(ptr, "--irce-print-changed-loops\x00");
        }
        if (cmd.irce_print_range_checks) {
            ptr = fmt.strcpyEqu(ptr, "--irce-print-range-checks\x00");
        }
        if (cmd.irce_skip_profitability_checks) {
            ptr = fmt.strcpyEqu(ptr, "--irce-skip-profitability-checks\x00");
        }
        if (cmd.isel_rebalance_addr) {
            ptr = fmt.strcpyEqu(ptr, "--isel-rebalance-addr\x00");
        }
        if (cmd.iterative_bfi_max_iterations_per_block) |iterative_bfi_max_iterations_per_block| {
            ptr = fmt.strcpyEqu(ptr, "--iterative-bfi-max-iterations-per-block\x00");
            ptr = fmt.Ud64.write(ptr, iterative_bfi_max_iterations_per_block);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.iterative_bfi_precision) |iterative_bfi_precision| {
            ptr = fmt.strcpyEqu(ptr, "--iterative-bfi-precision\x00");
            ptr = fmt.Ud64.write(ptr, iterative_bfi_precision);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.iterative_counter_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--iterative-counter-promotion\x00");
        }
        if (cmd.join_globalcopies) {
            ptr = fmt.strcpyEqu(ptr, "--join-globalcopies\x00");
        }
        if (cmd.join_liveintervals) {
            ptr = fmt.strcpyEqu(ptr, "--join-liveintervals\x00");
        }
        if (cmd.join_splitedges) {
            ptr = fmt.strcpyEqu(ptr, "--join-splitedges\x00");
        }
        if (cmd.jump_inst_cost) |jump_inst_cost| {
            ptr = fmt.strcpyEqu(ptr, "--jump-inst-cost\x00");
            ptr = fmt.Ud64.write(ptr, jump_inst_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.jump_is_expensive) {
            ptr = fmt.strcpyEqu(ptr, "--jump-is-expensive\x00");
        }
        if (cmd.jump_table_density) |jump_table_density| {
            ptr = fmt.strcpyEqu(ptr, "--jump-table-density\x00");
            ptr = fmt.Ud64.write(ptr, jump_table_density);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.jump_threading_across_loop_headers) {
            ptr = fmt.strcpyEqu(ptr, "--jump-threading-across-loop-headers\x00");
        }
        if (cmd.jump_threading_implication_search_threshold) |jump_threading_implication_search_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--jump-threading-implication-search-threshold\x00");
            ptr = fmt.Ud64.write(ptr, jump_threading_implication_search_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.jump_threading_phi_threshold) |jump_threading_phi_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--jump-threading-phi-threshold\x00");
            ptr = fmt.Ud64.write(ptr, jump_threading_phi_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.jump_threading_threshold) |jump_threading_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--jump-threading-threshold\x00");
            ptr = fmt.Ud64.write(ptr, jump_threading_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.keep_inline_advisor_for_printing) {
            ptr = fmt.strcpyEqu(ptr, "--keep-inline-advisor-for-printing\x00");
        }
        if (cmd.keep_loops) {
            ptr = fmt.strcpyEqu(ptr, "--keep-loops\x00");
        }
        if (cmd.lanai_constant_mul_threshold) |lanai_constant_mul_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--lanai-constant-mul-threshold\x00");
            ptr = fmt.Ud64.write(ptr, lanai_constant_mul_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lanai_nop_delay_filler) {
            ptr = fmt.strcpyEqu(ptr, "--lanai-nop-delay-filler\x00");
        }
        if (cmd.lanai_ssection_threshold) |lanai_ssection_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--lanai-ssection-threshold\x00");
            ptr = fmt.Ud64.write(ptr, lanai_ssection_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.large_interval_freq_threshold) |large_interval_freq_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--large-interval-freq-threshold\x00");
            ptr = fmt.Ud64.write(ptr, large_interval_freq_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.large_interval_size_threshold) |large_interval_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--large-interval-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, large_interval_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.late_remat_update_threshold) |late_remat_update_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--late-remat-update-threshold\x00");
            ptr = fmt.Ud64.write(ptr, late_remat_update_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lcr_max_depth) |lcr_max_depth| {
            ptr = fmt.strcpyEqu(ptr, "--lcr-max-depth\x00");
            ptr = fmt.Ud64.write(ptr, lcr_max_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lcr_max_interf) |lcr_max_interf| {
            ptr = fmt.strcpyEqu(ptr, "--lcr-max-interf\x00");
            ptr = fmt.Ud64.write(ptr, lcr_max_interf);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ldstmemcpy_glue_max) |ldstmemcpy_glue_max| {
            ptr = fmt.strcpyEqu(ptr, "--ldstmemcpy-glue-max\x00");
            ptr = fmt.Ud64.write(ptr, ldstmemcpy_glue_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.licm_control_flow_hoisting) {
            ptr = fmt.strcpyEqu(ptr, "--licm-control-flow-hoisting\x00");
        }
        if (cmd.licm_force_thread_model_single) {
            ptr = fmt.strcpyEqu(ptr, "--licm-force-thread-model-single\x00");
        }
        if (cmd.licm_max_num_uses_traversed) |licm_max_num_uses_traversed| {
            ptr = fmt.strcpyEqu(ptr, "--licm-max-num-uses-traversed\x00");
            ptr = fmt.Ud64.write(ptr, licm_max_num_uses_traversed);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.licm_mssa_max_acc_promotion) |licm_mssa_max_acc_promotion| {
            ptr = fmt.strcpyEqu(ptr, "--licm-mssa-max-acc-promotion\x00");
            ptr = fmt.Ud64.write(ptr, licm_mssa_max_acc_promotion);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.licm_mssa_optimization_cap) |licm_mssa_optimization_cap| {
            ptr = fmt.strcpyEqu(ptr, "--licm-mssa-optimization-cap\x00");
            ptr = fmt.Ud64.write(ptr, licm_mssa_optimization_cap);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.licm_versioning_invariant_threshold) |licm_versioning_invariant_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--licm-versioning-invariant-threshold\x00");
            ptr = fmt.Ud64.write(ptr, licm_versioning_invariant_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.licm_versioning_max_depth_threshold) |licm_versioning_max_depth_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--licm-versioning-max-depth-threshold\x00");
            ptr = fmt.Ud64.write(ptr, licm_versioning_max_depth_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.likely_branch_weight) |likely_branch_weight| {
            ptr = fmt.strcpyEqu(ptr, "--likely-branch-weight\x00");
            ptr = fmt.Ud64.write(ptr, likely_branch_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.limit_float_precision) |limit_float_precision| {
            ptr = fmt.strcpyEqu(ptr, "--limit-float-precision\x00");
            ptr = fmt.Ud64.write(ptr, limit_float_precision);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.live_debug_variables) {
            ptr = fmt.strcpyEqu(ptr, "--live-debug-variables\x00");
        }
        if (cmd.livedebugvalues_input_bb_limit) |livedebugvalues_input_bb_limit| {
            ptr = fmt.strcpyEqu(ptr, "--livedebugvalues-input-bb-limit\x00");
            ptr = fmt.Ud64.write(ptr, livedebugvalues_input_bb_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.livedebugvalues_input_dbg_value_limit) |livedebugvalues_input_dbg_value_limit| {
            ptr = fmt.strcpyEqu(ptr, "--livedebugvalues-input-dbg-value-limit\x00");
            ptr = fmt.Ud64.write(ptr, livedebugvalues_input_dbg_value_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.livedebugvalues_max_stack_slots) |livedebugvalues_max_stack_slots| {
            ptr = fmt.strcpyEqu(ptr, "--livedebugvalues-max-stack-slots\x00");
            ptr = fmt.Ud64.write(ptr, livedebugvalues_max_stack_slots);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.load) |load| {
            ptr[0..7].* = "--load\x00".*;
            ptr += 7;
            ptr = fmt.strcpyEqu(ptr, load);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.locally_hot_callsite_threshold) |locally_hot_callsite_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--locally-hot-callsite-threshold\x00");
            ptr = fmt.Ud64.write(ptr, locally_hot_callsite_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loongarch_check_zero_division) {
            ptr = fmt.strcpyEqu(ptr, "--loongarch-check-zero-division\x00");
        }
        if (cmd.loongarch_numeric_reg) {
            ptr = fmt.strcpyEqu(ptr, "--loongarch-numeric-reg\x00");
        }
        if (cmd.loop_deletion_enable_symbolic_execution) {
            ptr = fmt.strcpyEqu(ptr, "--loop-deletion-enable-symbolic-execution\x00");
        }
        if (cmd.loop_distribute_non_if_convertible) {
            ptr = fmt.strcpyEqu(ptr, "--loop-distribute-non-if-convertible\x00");
        }
        if (cmd.loop_distribute_scev_check_threshold) |loop_distribute_scev_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--loop-distribute-scev-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, loop_distribute_scev_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_distribute_scev_check_threshold_with_pragma) |loop_distribute_scev_check_threshold_with_pragma| {
            ptr = fmt.strcpyEqu(ptr, "--loop-distribute-scev-check-threshold-with-pragma\x00");
            ptr = fmt.Ud64.write(ptr, loop_distribute_scev_check_threshold_with_pragma);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_distribute_verify) {
            ptr = fmt.strcpyEqu(ptr, "--loop-distribute-verify\x00");
        }
        if (cmd.loop_flatten_assume_no_overflow) {
            ptr = fmt.strcpyEqu(ptr, "--loop-flatten-assume-no-overflow\x00");
        }
        if (cmd.loop_flatten_cost_threshold) |loop_flatten_cost_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--loop-flatten-cost-threshold\x00");
            ptr = fmt.Ud64.write(ptr, loop_flatten_cost_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_flatten_widen_iv) {
            ptr = fmt.strcpyEqu(ptr, "--loop-flatten-widen-iv\x00");
        }
        if (cmd.loop_fusion_dependence_analysis) |loop_fusion_dependence_analysis| {
            ptr = fmt.strcpyEqu(ptr, "--loop-fusion-dependence-analysis\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(loop_fusion_dependence_analysis));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_fusion_peel_max_count) |loop_fusion_peel_max_count| {
            ptr = fmt.strcpyEqu(ptr, "--loop-fusion-peel-max-count\x00");
            ptr = fmt.Ud64.write(ptr, loop_fusion_peel_max_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_interchange_threshold) |loop_interchange_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--loop-interchange-threshold\x00");
            ptr = fmt.Ud64.write(ptr, loop_interchange_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_load_elimination_scev_check_threshold) |loop_load_elimination_scev_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--loop-load-elimination-scev-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, loop_load_elimination_scev_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_predication_enable_count_down_loop) {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-enable-count-down-loop\x00");
        }
        if (cmd.loop_predication_enable_iv_truncation) {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-enable-iv-truncation\x00");
        }
        if (cmd.loop_predication_insert_assumes_of_predicated_guards_conditions) {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-insert-assumes-of-predicated-guards-conditions\x00");
        }
        if (cmd.loop_predication_latch_probability_scale) |loop_predication_latch_probability_scale| {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-latch-probability-scale\x00");
            ptr = fmt.Ud64.write(ptr, loop_predication_latch_probability_scale);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_predication_predicate_widenable_branches_to_deopt) {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-predicate-widenable-branches-to-deopt\x00");
        }
        if (cmd.loop_predication_skip_profitability_checks) {
            ptr = fmt.strcpyEqu(ptr, "--loop-predication-skip-profitability-checks\x00");
        }
        if (cmd.loop_prefetch_writes) {
            ptr = fmt.strcpyEqu(ptr, "--loop-prefetch-writes\x00");
        }
        if (cmd.loop_rotate_multi) {
            ptr = fmt.strcpyEqu(ptr, "--loop-rotate-multi\x00");
        }
        if (cmd.loop_to_cold_block_ratio) |loop_to_cold_block_ratio| {
            ptr = fmt.strcpyEqu(ptr, "--loop-to-cold-block-ratio\x00");
            ptr = fmt.Ud64.write(ptr, loop_to_cold_block_ratio);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.loop_vectorize_with_block_frequency) {
            ptr = fmt.strcpyEqu(ptr, "--loop-vectorize-with-block-frequency\x00");
        }
        if (cmd.loop_version_annotate_no_alias) {
            ptr = fmt.strcpyEqu(ptr, "--loop-version-annotate-no-alias\x00");
        }
        if (cmd.lower_global_dtors_via_cxa_atexit) {
            ptr = fmt.strcpyEqu(ptr, "--lower-global-dtors-via-cxa-atexit\x00");
        }
        if (cmd.lower_interleaved_accesses) {
            ptr = fmt.strcpyEqu(ptr, "--lower-interleaved-accesses\x00");
        }
        if (cmd.lowertypetests_avoid_reuse) {
            ptr = fmt.strcpyEqu(ptr, "--lowertypetests-avoid-reuse\x00");
        }
        if (cmd.lowertypetests_drop_type_tests) {
            ptr = fmt.strcpyEqu(ptr, "--lowertypetests-drop-type-tests\x00");
        }
        if (cmd.lowertypetests_read_summary) |lowertypetests_read_summary| {
            ptr = fmt.strcpyEqu(ptr, "--lowertypetests-read-summary\x00");
            ptr = fmt.strcpyEqu(ptr, lowertypetests_read_summary);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lowertypetests_summary_action) |lowertypetests_summary_action| {
            ptr = fmt.strcpyEqu(ptr, "--lowertypetests-summary-action\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(lowertypetests_summary_action));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lowertypetests_write_summary) |lowertypetests_write_summary| {
            ptr = fmt.strcpyEqu(ptr, "--lowertypetests-write-summary\x00");
            ptr = fmt.strcpyEqu(ptr, lowertypetests_write_summary);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lsr_complexity_limit) |lsr_complexity_limit| {
            ptr = fmt.strcpyEqu(ptr, "--lsr-complexity-limit\x00");
            ptr = fmt.Ud64.write(ptr, lsr_complexity_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lsr_drop_solution) {
            ptr = fmt.strcpyEqu(ptr, "--lsr-drop-solution\x00");
        }
        if (cmd.lsr_exp_narrow) {
            ptr = fmt.strcpyEqu(ptr, "--lsr-exp-narrow\x00");
        }
        if (cmd.lsr_filter_same_scaled_reg) {
            ptr = fmt.strcpyEqu(ptr, "--lsr-filter-same-scaled-reg\x00");
        }
        if (cmd.lsr_insns_cost) {
            ptr = fmt.strcpyEqu(ptr, "--lsr-insns-cost\x00");
        }
        if (cmd.lsr_preferred_addressing_mode) |lsr_preferred_addressing_mode| {
            ptr = fmt.strcpyEqu(ptr, "--lsr-preferred-addressing-mode\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(lsr_preferred_addressing_mode));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lsr_setupcost_depth_limit) |lsr_setupcost_depth_limit| {
            ptr = fmt.strcpyEqu(ptr, "--lsr-setupcost-depth-limit\x00");
            ptr = fmt.Ud64.write(ptr, lsr_setupcost_depth_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lsr_term_fold) {
            ptr = fmt.strcpyEqu(ptr, "--lsr-term-fold\x00");
        }
        if (cmd.lto_aix_system_assembler) |lto_aix_system_assembler| {
            ptr = fmt.strcpyEqu(ptr, "--lto-aix-system-assembler\x00");
            ptr = fmt.strcpyEqu(ptr, lto_aix_system_assembler);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lto_discard_value_names) {
            ptr = fmt.strcpyEqu(ptr, "--lto-discard-value-names\x00");
        }
        if (cmd.lto_embed_bitcode) |lto_embed_bitcode| {
            ptr = fmt.strcpyEqu(ptr, "--lto-embed-bitcode\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(lto_embed_bitcode));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lto_pass_remarks_filter) |lto_pass_remarks_filter| {
            ptr = fmt.strcpyEqu(ptr, "--lto-pass-remarks-filter\x00");
            ptr = fmt.strcpyEqu(ptr, lto_pass_remarks_filter);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lto_pass_remarks_format) |lto_pass_remarks_format| {
            ptr = fmt.strcpyEqu(ptr, "--lto-pass-remarks-format\x00");
            ptr = fmt.strcpyEqu(ptr, lto_pass_remarks_format);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lto_pass_remarks_hotness_threshold) {
            ptr = fmt.strcpyEqu(ptr, "--lto-pass-remarks-hotness-threshold\x00");
        }
        if (cmd.lto_pass_remarks_output) |lto_pass_remarks_output| {
            ptr = fmt.strcpyEqu(ptr, "--lto-pass-remarks-output\x00");
            ptr = fmt.strcpyEqu(ptr, lto_pass_remarks_output);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.lto_pass_remarks_with_hotness) {
            ptr = fmt.strcpyEqu(ptr, "--lto-pass-remarks-with-hotness\x00");
        }
        if (cmd.lto_stats_file) |lto_stats_file| {
            ptr = fmt.strcpyEqu(ptr, "--lto-stats-file\x00");
            ptr = fmt.strcpyEqu(ptr, lto_stats_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_combiner_dump_subst_intrs) {
            ptr = fmt.strcpyEqu(ptr, "--machine-combiner-dump-subst-intrs\x00");
        }
        if (cmd.machine_combiner_inc_threshold) |machine_combiner_inc_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--machine-combiner-inc-threshold\x00");
            ptr = fmt.Ud64.write(ptr, machine_combiner_inc_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_combiner_verify_pattern_order) {
            ptr = fmt.strcpyEqu(ptr, "--machine-combiner-verify-pattern-order\x00");
        }
        if (cmd.machine_outliner_reruns) |machine_outliner_reruns| {
            ptr = fmt.strcpyEqu(ptr, "--machine-outliner-reruns\x00");
            ptr = fmt.Ud64.write(ptr, machine_outliner_reruns);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_sink_bfi) {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-bfi\x00");
        }
        if (cmd.machine_sink_cycle_limit) |machine_sink_cycle_limit| {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-cycle-limit\x00");
            ptr = fmt.Ud64.write(ptr, machine_sink_cycle_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_sink_load_blocks_threshold) |machine_sink_load_blocks_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-load-blocks-threshold\x00");
            ptr = fmt.Ud64.write(ptr, machine_sink_load_blocks_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_sink_load_instrs_threshold) |machine_sink_load_instrs_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-load-instrs-threshold\x00");
            ptr = fmt.Ud64.write(ptr, machine_sink_load_instrs_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.machine_sink_split) {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-split\x00");
        }
        if (cmd.machine_sink_split_probability_threshold) |machine_sink_split_probability_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--machine-sink-split-probability-threshold\x00");
            ptr = fmt.Ud64.write(ptr, machine_sink_split_probability_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mandatory_inlining_first) {
            ptr = fmt.strcpyEqu(ptr, "--mandatory-inlining-first\x00");
        }
        if (cmd.march) |march| {
            ptr[0..8].* = "--march\x00".*;
            ptr += 8;
            ptr = fmt.strcpyEqu(ptr, march);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mark_data_regions) {
            ptr = fmt.strcpyEqu(ptr, "--mark-data-regions\x00");
        }
        if (cmd.matrix_allow_contract) {
            ptr = fmt.strcpyEqu(ptr, "--matrix-allow-contract\x00");
        }
        if (cmd.matrix_default_layout) |matrix_default_layout| {
            ptr = fmt.strcpyEqu(ptr, "--matrix-default-layout\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(matrix_default_layout));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.matrix_print_after_transpose_opt) {
            ptr = fmt.strcpyEqu(ptr, "--matrix-print-after-transpose-opt\x00");
        }
        if (cmd.max_booleans_in_control_flow_hub) |max_booleans_in_control_flow_hub| {
            ptr = fmt.strcpyEqu(ptr, "--max-booleans-in-control-flow-hub\x00");
            ptr = fmt.Ud64.write(ptr, max_booleans_in_control_flow_hub);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_bytes_for_alignment) |max_bytes_for_alignment| {
            ptr = fmt.strcpyEqu(ptr, "--max-bytes-for-alignment\x00");
            ptr = fmt.Ud64.write(ptr, max_bytes_for_alignment);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_counter_promotions) |max_counter_promotions| {
            ptr = fmt.strcpyEqu(ptr, "--max-counter-promotions\x00");
            ptr = fmt.Ud64.write(ptr, max_counter_promotions);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_counter_promotions_per_loop) |max_counter_promotions_per_loop| {
            ptr = fmt.strcpyEqu(ptr, "--max-counter-promotions-per-loop\x00");
            ptr = fmt.Ud64.write(ptr, max_counter_promotions_per_loop);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_deopt_or_unreachable_succ_check_depth) |max_deopt_or_unreachable_succ_check_depth| {
            ptr = fmt.strcpyEqu(ptr, "--max-deopt-or-unreachable-succ-check-depth\x00");
            ptr = fmt.Ud64.write(ptr, max_deopt_or_unreachable_succ_check_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_dependences) |max_dependences| {
            ptr = fmt.strcpyEqu(ptr, "--max-dependences\x00");
            ptr = fmt.Ud64.write(ptr, max_dependences);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_forked_scev_depth) |max_forked_scev_depth| {
            ptr = fmt.strcpyEqu(ptr, "--max-forked-scev-depth\x00");
            ptr = fmt.Ud64.write(ptr, max_forked_scev_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_heap_to_stack_size) |max_heap_to_stack_size| {
            ptr = fmt.strcpyEqu(ptr, "--max-heap-to-stack-size\x00");
            ptr = fmt.Ud64.write(ptr, max_heap_to_stack_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_hsdr) |max_hsdr| {
            ptr = fmt.strcpyEqu(ptr, "--max-hsdr\x00");
            ptr = fmt.Ud64.write(ptr, max_hsdr);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_inst_checked_for_throw_during_inlining) |max_inst_checked_for_throw_during_inlining| {
            ptr = fmt.strcpyEqu(ptr, "--max-inst-checked-for-throw-during-inlining\x00");
            ptr = fmt.Ud64.write(ptr, max_inst_checked_for_throw_during_inlining);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_interleave_group_factor) |max_interleave_group_factor| {
            ptr = fmt.strcpyEqu(ptr, "--max-interleave-group-factor\x00");
            ptr = fmt.Ud64.write(ptr, max_interleave_group_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_jump_table_size) |max_jump_table_size| {
            ptr = fmt.strcpyEqu(ptr, "--max-jump-table-size\x00");
            ptr = fmt.Ud64.write(ptr, max_jump_table_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_loads_per_memcmp) |max_loads_per_memcmp| {
            ptr = fmt.strcpyEqu(ptr, "--max-loads-per-memcmp\x00");
            ptr = fmt.Ud64.write(ptr, max_loads_per_memcmp);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_loads_per_memcmp_opt_size) |max_loads_per_memcmp_opt_size| {
            ptr = fmt.strcpyEqu(ptr, "--max-loads-per-memcmp-opt-size\x00");
            ptr = fmt.Ud64.write(ptr, max_loads_per_memcmp_opt_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_nested_scalar_reduction_interleave) |max_nested_scalar_reduction_interleave| {
            ptr = fmt.strcpyEqu(ptr, "--max-nested-scalar-reduction-interleave\x00");
            ptr = fmt.Ud64.write(ptr, max_nested_scalar_reduction_interleave);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_num_inline_blocks) |max_num_inline_blocks| {
            ptr = fmt.strcpyEqu(ptr, "--max-num-inline-blocks\x00");
            ptr = fmt.Ud64.write(ptr, max_num_inline_blocks);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_num_inst_between_tfr_and_nv_store) |max_num_inst_between_tfr_and_nv_store| {
            ptr = fmt.strcpyEqu(ptr, "--max-num-inst-between-tfr-and-nv-store\x00");
            ptr = fmt.Ud64.write(ptr, max_num_inst_between_tfr_and_nv_store);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_partial_inlining) |max_partial_inlining| {
            ptr = fmt.strcpyEqu(ptr, "--max-partial-inlining\x00");
            ptr = fmt.Ud64.write(ptr, max_partial_inlining);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_prefetch_iters_ahead) |max_prefetch_iters_ahead| {
            ptr = fmt.strcpyEqu(ptr, "--max-prefetch-iters-ahead\x00");
            ptr = fmt.Ud64.write(ptr, max_prefetch_iters_ahead);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_registers_for_gc_values) |max_registers_for_gc_values| {
            ptr = fmt.strcpyEqu(ptr, "--max-registers-for-gc-values\x00");
            ptr = fmt.Ud64.write(ptr, max_registers_for_gc_values);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_sched_reorder) |max_sched_reorder| {
            ptr = fmt.strcpyEqu(ptr, "--max-sched-reorder\x00");
            ptr = fmt.Ud64.write(ptr, max_sched_reorder);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_speculation_depth) |max_speculation_depth| {
            ptr = fmt.strcpyEqu(ptr, "--max-speculation-depth\x00");
            ptr = fmt.Ud64.write(ptr, max_speculation_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memcpy) |max_store_memcpy| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memcpy\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memcpy);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memcpy_Os) |max_store_memcpy_Os| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memcpy-Os\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memcpy_Os);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memmove) |max_store_memmove| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memmove\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memmove);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memmove_Os) |max_store_memmove_Os| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memmove-Os\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memmove_Os);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memset) |max_store_memset| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memset\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memset);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_store_memset_Os) |max_store_memset_Os| {
            ptr = fmt.strcpyEqu(ptr, "--max-store-memset-Os\x00");
            ptr = fmt.Ud64.write(ptr, max_store_memset_Os);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_switch_cases_per_result) |max_switch_cases_per_result| {
            ptr = fmt.strcpyEqu(ptr, "--max-switch-cases-per-result\x00");
            ptr = fmt.Ud64.write(ptr, max_switch_cases_per_result);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.max_uses_for_sinking) |max_uses_for_sinking| {
            ptr = fmt.strcpyEqu(ptr, "--max-uses-for-sinking\x00");
            ptr = fmt.Ud64.write(ptr, max_uses_for_sinking);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mc_relax_all) {
            ptr = fmt.strcpyEqu(ptr, "--mc-relax-all\x00");
        }
        if (cmd.mcabac) {
            ptr = fmt.strcpyEqu(ptr, "--mcabac\x00");
        }
        if (cmd.mcfg_dot_filename_prefix) |mcfg_dot_filename_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--mcfg-dot-filename-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, mcfg_dot_filename_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mcfg_func_name) |mcfg_func_name| {
            ptr = fmt.strcpyEqu(ptr, "--mcfg-func-name\x00");
            ptr = fmt.strcpyEqu(ptr, mcfg_func_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mcp_use_is_copy_instr) {
            ptr = fmt.strcpyEqu(ptr, "--mcp-use-is-copy-instr\x00");
        }
        if (cmd.mcpu) |mcpu| {
            ptr[0..7].* = "--mcpu\x00".*;
            ptr += 7;
            ptr = fmt.strcpyEqu(ptr, mcpu);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.meabi) |meabi| {
            ptr[0..8].* = "--meabi\x00".*;
            ptr += 8;
            ptr = fmt.strcpyEqu(ptr, @tagName(meabi));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mem_loc_frag_fill) {
            ptr = fmt.strcpyEqu(ptr, "--mem-loc-frag-fill\x00");
        }
        if (cmd.membedded_data) {
            ptr = fmt.strcpyEqu(ptr, "--membedded-data\x00");
        }
        if (cmd.memcmp_num_loads_per_block) |memcmp_num_loads_per_block| {
            ptr = fmt.strcpyEqu(ptr, "--memcmp-num-loads-per-block\x00");
            ptr = fmt.Ud64.write(ptr, memcmp_num_loads_per_block);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memdep_block_number_limit) |memdep_block_number_limit| {
            ptr = fmt.strcpyEqu(ptr, "--memdep-block-number-limit\x00");
            ptr = fmt.Ud64.write(ptr, memdep_block_number_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memdep_block_scan_limit) |memdep_block_scan_limit| {
            ptr = fmt.strcpyEqu(ptr, "--memdep-block-scan-limit\x00");
            ptr = fmt.Ud64.write(ptr, memdep_block_scan_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memop_max_annotations) |memop_max_annotations| {
            ptr = fmt.strcpyEqu(ptr, "--memop-max-annotations\x00");
            ptr = fmt.Ud64.write(ptr, memop_max_annotations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memop_value_prof_max_opt_size) |memop_value_prof_max_opt_size| {
            ptr = fmt.strcpyEqu(ptr, "--memop-value-prof-max-opt-size\x00");
            ptr = fmt.Ud64.write(ptr, memop_value_prof_max_opt_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memory_check_merge_threshold) |memory_check_merge_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--memory-check-merge-threshold\x00");
            ptr = fmt.Ud64.write(ptr, memory_check_merge_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_accesses_per_byte_cold_threshold) |memprof_accesses_per_byte_cold_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-accesses-per-byte-cold-threshold\x00");
            ptr = fmt.Ud64.write(ptr, memprof_accesses_per_byte_cold_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_debug) |memprof_debug| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-debug\x00");
            ptr = fmt.Ud64.write(ptr, memprof_debug);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_debug_func) |memprof_debug_func| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-debug-func\x00");
            ptr = fmt.strcpyEqu(ptr, memprof_debug_func);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_debug_max) |memprof_debug_max| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-debug-max\x00");
            ptr = fmt.Ud64.write(ptr, memprof_debug_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_debug_min) |memprof_debug_min| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-debug-min\x00");
            ptr = fmt.Ud64.write(ptr, memprof_debug_min);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_guard_against_version_mismatch) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-guard-against-version-mismatch\x00");
        }
        if (cmd.memprof_instrument_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-instrument-atomics\x00");
        }
        if (cmd.memprof_instrument_reads) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-instrument-reads\x00");
        }
        if (cmd.memprof_instrument_stack) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-instrument-stack\x00");
        }
        if (cmd.memprof_instrument_writes) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-instrument-writes\x00");
        }
        if (cmd.memprof_mapping_granularity) |memprof_mapping_granularity| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-mapping-granularity\x00");
            ptr = fmt.Ud64.write(ptr, memprof_mapping_granularity);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_mapping_scale) |memprof_mapping_scale| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-mapping-scale\x00");
            ptr = fmt.Ud64.write(ptr, memprof_mapping_scale);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_memory_access_callback_prefix) |memprof_memory_access_callback_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-memory-access-callback-prefix\x00");
            ptr = fmt.strcpyEqu(ptr, memprof_memory_access_callback_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_min_lifetime_cold_threshold) |memprof_min_lifetime_cold_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--memprof-min-lifetime-cold-threshold\x00");
            ptr = fmt.Ud64.write(ptr, memprof_min_lifetime_cold_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.memprof_use_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--memprof-use-callbacks\x00");
        }
        if (cmd.memssa_check_limit) |memssa_check_limit| {
            ptr = fmt.strcpyEqu(ptr, "--memssa-check-limit\x00");
            ptr = fmt.Ud64.write(ptr, memssa_check_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mergefunc_preserve_debug_info) {
            ptr = fmt.strcpyEqu(ptr, "--mergefunc-preserve-debug-info\x00");
        }
        if (cmd.mergefunc_use_aliases) {
            ptr = fmt.strcpyEqu(ptr, "--mergefunc-use-aliases\x00");
        }
        if (cmd.mergefunc_verify) |mergefunc_verify| {
            ptr = fmt.strcpyEqu(ptr, "--mergefunc-verify\x00");
            ptr = fmt.Ud64.write(ptr, mergefunc_verify);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.merror_missing_parenthesis) {
            ptr = fmt.strcpyEqu(ptr, "--merror-missing-parenthesis\x00");
        }
        if (cmd.merror_noncontigious_register) {
            ptr = fmt.strcpyEqu(ptr, "--merror-noncontigious-register\x00");
        }
        if (cmd.mextern_sdata) {
            ptr = fmt.strcpyEqu(ptr, "--mextern-sdata\x00");
        }
        if (cmd.mfix4300) {
            ptr = fmt.strcpyEqu(ptr, "--mfix4300\x00");
        }
        if (cmd.mfs_count_threshold) |mfs_count_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--mfs-count-threshold\x00");
            ptr = fmt.Ud64.write(ptr, mfs_count_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mfs_psi_cutoff) |mfs_psi_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--mfs-psi-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, mfs_psi_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mfs_split_ehcode) {
            ptr = fmt.strcpyEqu(ptr, "--mfs-split-ehcode\x00");
        }
        if (cmd.mgpopt) {
            ptr = fmt.strcpyEqu(ptr, "--mgpopt\x00");
        }
        if (cmd.mhvx) |mhvx| {
            ptr[0..7].* = "--mhvx\x00".*;
            ptr += 7;
            ptr = fmt.strcpyEqu(ptr, @tagName(mhvx));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mhvx_ieee_fp) {
            ptr = fmt.strcpyEqu(ptr, "--mhvx-ieee-fp\x00");
        }
        if (cmd.mhwmult) |mhwmult| {
            ptr = fmt.strcpyEqu(ptr, "--mhwmult\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(mhwmult));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.min_block_execution) |min_block_execution| {
            ptr = fmt.strcpyEqu(ptr, "--min-block-execution\x00");
            ptr = fmt.Ud64.write(ptr, min_block_execution);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.min_ctr_loop_threshold) |min_ctr_loop_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--min-ctr-loop-threshold\x00");
            ptr = fmt.Ud64.write(ptr, min_ctr_loop_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.min_jump_table_entries) |min_jump_table_entries| {
            ptr = fmt.strcpyEqu(ptr, "--min-jump-table-entries\x00");
            ptr = fmt.Ud64.write(ptr, min_jump_table_entries);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.min_prefetch_stride) |min_prefetch_stride| {
            ptr = fmt.strcpyEqu(ptr, "--min-prefetch-stride\x00");
            ptr = fmt.Ud64.write(ptr, min_prefetch_stride);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.min_region_size_ratio) |min_region_size_ratio| {
            ptr = fmt.strcpyEqu(ptr, "--min-region-size-ratio\x00");
            ptr = fmt.Ud64.write(ptr, min_region_size_ratio);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.minimize_addr_in_v5) |minimize_addr_in_v5| {
            ptr = fmt.strcpyEqu(ptr, "--minimize-addr-in-v5\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(minimize_addr_in_v5));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.minimum_jump_tables) |minimum_jump_tables| {
            ptr = fmt.strcpyEqu(ptr, "--minimum-jump-tables\x00");
            ptr = fmt.Ud64.write(ptr, minimum_jump_tables);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mips_align_constant_islands) {
            ptr = fmt.strcpyEqu(ptr, "--mips-align-constant-islands\x00");
        }
        if (cmd.mips_compact_branches) |mips_compact_branches| {
            ptr = fmt.strcpyEqu(ptr, "--mips-compact-branches\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(mips_compact_branches));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mips_constant_islands_no_load_relaxation) {
            ptr = fmt.strcpyEqu(ptr, "--mips-constant-islands-no-load-relaxation\x00");
        }
        if (cmd.mips_constant_islands_small_offset) |mips_constant_islands_small_offset| {
            ptr = fmt.strcpyEqu(ptr, "--mips-constant-islands-small-offset\x00");
            ptr = fmt.Ud64.write(ptr, mips_constant_islands_small_offset);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mips_erase_gp_opnd) {
            ptr = fmt.strcpyEqu(ptr, "--mips-erase-gp-opnd\x00");
        }
        if (cmd.mips_fix_global_base_reg) {
            ptr = fmt.strcpyEqu(ptr, "--mips-fix-global-base-reg\x00");
        }
        if (cmd.mips_jalr_reloc) {
            ptr = fmt.strcpyEqu(ptr, "--mips-jalr-reloc\x00");
        }
        if (cmd.mips_load_target_from_got) {
            ptr = fmt.strcpyEqu(ptr, "--mips-load-target-from-got\x00");
        }
        if (cmd.mips_mixed_16_32) {
            ptr = fmt.strcpyEqu(ptr, "--mips-mixed-16-32\x00");
        }
        if (cmd.mips_os16) {
            ptr = fmt.strcpyEqu(ptr, "--mips-os16\x00");
        }
        if (cmd.mips_round_section_sizes) {
            ptr = fmt.strcpyEqu(ptr, "--mips-round-section-sizes\x00");
        }
        if (cmd.mips_ssection_threshold) |mips_ssection_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--mips-ssection-threshold\x00");
            ptr = fmt.Ud64.write(ptr, mips_ssection_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mips_tail_calls) {
            ptr = fmt.strcpyEqu(ptr, "--mips-tail-calls\x00");
        }
        if (cmd.mips16_constant_islands) {
            ptr = fmt.strcpyEqu(ptr, "--mips16-constant-islands\x00");
        }
        if (cmd.mips16_dont_expand_cond_pseudo) {
            ptr = fmt.strcpyEqu(ptr, "--mips16-dont-expand-cond-pseudo\x00");
        }
        if (cmd.mips16_hard_float) {
            ptr = fmt.strcpyEqu(ptr, "--mips16-hard-float\x00");
        }
        if (cmd.mips32_function_mask) |mips32_function_mask| {
            ptr = fmt.strcpyEqu(ptr, "--mips32-function-mask\x00");
            ptr = fmt.strcpyEqu(ptr, mips32_function_mask);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mipspostlegalizercombinerhelper_disable_rule) |mipspostlegalizercombinerhelper_disable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--mipspostlegalizercombinerhelper-disable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, mipspostlegalizercombinerhelper_disable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mipspostlegalizercombinerhelper_only_enable_rule) |mipspostlegalizercombinerhelper_only_enable_rule| {
            ptr = fmt.strcpyEqu(ptr, "--mipspostlegalizercombinerhelper-only-enable-rule\x00");
            ptr = fmt.strcpyEqu(ptr, mipspostlegalizercombinerhelper_only_enable_rule);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mir_debug_loc) {
            ptr = fmt.strcpyEqu(ptr, "--mir-debug-loc\x00");
        }
        if (cmd.mir_strip_debugify_only) {
            ptr = fmt.strcpyEqu(ptr, "--mir-strip-debugify-only\x00");
        }
        if (cmd.mir_vreg_namer_use_stable_hash) {
            ptr = fmt.strcpyEqu(ptr, "--mir-vreg-namer-use-stable-hash\x00");
        }
        if (cmd.misched) |misched| {
            ptr = fmt.strcpyEqu(ptr, "--misched\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(misched));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.misched_bottomup) {
            ptr = fmt.strcpyEqu(ptr, "--misched-bottomup\x00");
        }
        if (cmd.misched_cluster) {
            ptr = fmt.strcpyEqu(ptr, "--misched-cluster\x00");
        }
        if (cmd.misched_cyclicpath) {
            ptr = fmt.strcpyEqu(ptr, "--misched-cyclicpath\x00");
        }
        if (cmd.misched_dcpl) {
            ptr = fmt.strcpyEqu(ptr, "--misched-dcpl\x00");
        }
        if (cmd.misched_fusion) {
            ptr = fmt.strcpyEqu(ptr, "--misched-fusion\x00");
        }
        if (cmd.misched_limit) |misched_limit| {
            ptr = fmt.strcpyEqu(ptr, "--misched-limit\x00");
            ptr = fmt.Ud64.write(ptr, misched_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.misched_postra) {
            ptr = fmt.strcpyEqu(ptr, "--misched-postra\x00");
        }
        if (cmd.misched_regpressure) {
            ptr = fmt.strcpyEqu(ptr, "--misched-regpressure\x00");
        }
        if (cmd.misched_topdown) {
            ptr = fmt.strcpyEqu(ptr, "--misched-topdown\x00");
        }
        if (cmd.misched_verbose_level) |misched_verbose_level| {
            ptr = fmt.strcpyEqu(ptr, "--misched-verbose-level\x00");
            ptr = fmt.Ud64.write(ptr, misched_verbose_level);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.misexpect_tolerance) |misexpect_tolerance| {
            ptr = fmt.strcpyEqu(ptr, "--misexpect-tolerance\x00");
            ptr = fmt.Ud64.write(ptr, misexpect_tolerance);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.misfetch_cost) |misfetch_cost| {
            ptr = fmt.strcpyEqu(ptr, "--misfetch-cost\x00");
            ptr = fmt.Ud64.write(ptr, misfetch_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mispredict_default_rate) |mispredict_default_rate| {
            ptr = fmt.strcpyEqu(ptr, "--mispredict-default-rate\x00");
            ptr = fmt.Ud64.write(ptr, mispredict_default_rate);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ml_advisor_keep_fpi_cache) {
            ptr = fmt.strcpyEqu(ptr, "--ml-advisor-keep-fpi-cache\x00");
        }
        if (cmd.ml_advisor_size_increase_threshold) |ml_advisor_size_increase_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--ml-advisor-size-increase-threshold\x00");
            ptr = fmt.Ud64.write(ptr, ml_advisor_size_increase_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mlocal_sdata) {
            ptr = fmt.strcpyEqu(ptr, "--mlocal-sdata\x00");
        }
        if (cmd.mno_check_zero_division) {
            ptr = fmt.strcpyEqu(ptr, "--mno-check-zero-division\x00");
        }
        if (cmd.mno_compound) {
            ptr = fmt.strcpyEqu(ptr, "--mno-compound\x00");
        }
        if (cmd.mno_fixup) {
            ptr = fmt.strcpyEqu(ptr, "--mno-fixup\x00");
        }
        if (cmd.mno_hvx) {
            ptr = fmt.strcpyEqu(ptr, "--mno-hvx\x00");
        }
        if (cmd.mno_ldc1_sdc1) {
            ptr = fmt.strcpyEqu(ptr, "--mno-ldc1-sdc1\x00");
        }
        if (cmd.mno_pairing) {
            ptr = fmt.strcpyEqu(ptr, "--mno-pairing\x00");
        }
        if (cmd.mno_sort_sda) {
            ptr = fmt.strcpyEqu(ptr, "--mno-sort-sda\x00");
        }
        if (cmd.module_summary_dot_file) |module_summary_dot_file| {
            ptr = fmt.strcpyEqu(ptr, "--module-summary-dot-file\x00");
            ptr = fmt.strcpyEqu(ptr, module_summary_dot_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.moudle_inliner_top_priority_threshold) |moudle_inliner_top_priority_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--moudle-inliner-top-priority-threshold\x00");
            ptr = fmt.Ud64.write(ptr, moudle_inliner_top_priority_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_and_mask) |msan_and_mask| {
            ptr = fmt.strcpyEqu(ptr, "--msan-and-mask\x00");
            ptr = fmt.Ud64.write(ptr, msan_and_mask);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_check_access_address) {
            ptr = fmt.strcpyEqu(ptr, "--msan-check-access-address\x00");
        }
        if (cmd.msan_check_constant_shadow) {
            ptr = fmt.strcpyEqu(ptr, "--msan-check-constant-shadow\x00");
        }
        if (cmd.msan_disable_checks) {
            ptr = fmt.strcpyEqu(ptr, "--msan-disable-checks\x00");
        }
        if (cmd.msan_disambiguate_warning_threshold) |msan_disambiguate_warning_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--msan-disambiguate-warning-threshold\x00");
            ptr = fmt.Ud64.write(ptr, msan_disambiguate_warning_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_dump_strict_instructions) {
            ptr = fmt.strcpyEqu(ptr, "--msan-dump-strict-instructions\x00");
        }
        if (cmd.msan_eager_checks) {
            ptr = fmt.strcpyEqu(ptr, "--msan-eager-checks\x00");
        }
        if (cmd.msan_handle_asm_conservative) {
            ptr = fmt.strcpyEqu(ptr, "--msan-handle-asm-conservative\x00");
        }
        if (cmd.msan_handle_icmp) {
            ptr = fmt.strcpyEqu(ptr, "--msan-handle-icmp\x00");
        }
        if (cmd.msan_handle_icmp_exact) {
            ptr = fmt.strcpyEqu(ptr, "--msan-handle-icmp-exact\x00");
        }
        if (cmd.msan_handle_lifetime_intrinsics) {
            ptr = fmt.strcpyEqu(ptr, "--msan-handle-lifetime-intrinsics\x00");
        }
        if (cmd.msan_instrumentation_with_call_threshold) |msan_instrumentation_with_call_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--msan-instrumentation-with-call-threshold\x00");
            ptr = fmt.Ud64.write(ptr, msan_instrumentation_with_call_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_keep_going) {
            ptr = fmt.strcpyEqu(ptr, "--msan-keep-going\x00");
        }
        if (cmd.msan_kernel) {
            ptr = fmt.strcpyEqu(ptr, "--msan-kernel\x00");
        }
        if (cmd.msan_origin_base) |msan_origin_base| {
            ptr = fmt.strcpyEqu(ptr, "--msan-origin-base\x00");
            ptr = fmt.Ud64.write(ptr, msan_origin_base);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_poison_stack) {
            ptr = fmt.strcpyEqu(ptr, "--msan-poison-stack\x00");
        }
        if (cmd.msan_poison_stack_pattern) |msan_poison_stack_pattern| {
            ptr = fmt.strcpyEqu(ptr, "--msan-poison-stack-pattern\x00");
            ptr = fmt.Ud64.write(ptr, msan_poison_stack_pattern);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_poison_stack_with_call) {
            ptr = fmt.strcpyEqu(ptr, "--msan-poison-stack-with-call\x00");
        }
        if (cmd.msan_poison_undef) {
            ptr = fmt.strcpyEqu(ptr, "--msan-poison-undef\x00");
        }
        if (cmd.msan_print_stack_names) {
            ptr = fmt.strcpyEqu(ptr, "--msan-print-stack-names\x00");
        }
        if (cmd.msan_shadow_base) |msan_shadow_base| {
            ptr = fmt.strcpyEqu(ptr, "--msan-shadow-base\x00");
            ptr = fmt.Ud64.write(ptr, msan_shadow_base);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_track_origins) |msan_track_origins| {
            ptr = fmt.strcpyEqu(ptr, "--msan-track-origins\x00");
            ptr = fmt.Ud64.write(ptr, msan_track_origins);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msan_with_comdat) {
            ptr = fmt.strcpyEqu(ptr, "--msan-with-comdat\x00");
        }
        if (cmd.msan_xor_mask) |msan_xor_mask| {
            ptr = fmt.strcpyEqu(ptr, "--msan-xor-mask\x00");
            ptr = fmt.Ud64.write(ptr, msan_xor_mask);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.msp430_branch_select) {
            ptr = fmt.strcpyEqu(ptr, "--msp430-branch-select\x00");
        }
        if (cmd.msp430_no_legal_immediate) {
            ptr = fmt.strcpyEqu(ptr, "--msp430-no-legal-immediate\x00");
        }
        if (cmd.mtriple) |mtriple| {
            ptr = fmt.strcpyEqu(ptr, "--mtriple\x00");
            ptr = fmt.strcpyEqu(ptr, mtriple);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mul_constant_optimization) {
            ptr = fmt.strcpyEqu(ptr, "--mul-constant-optimization\x00");
        }
        if (cmd.mv5) {
            ptr[0..6].* = "--mv5\x00".*;
            ptr += 6;
        }
        if (cmd.mv55) {
            ptr[0..7].* = "--mv55\x00".*;
            ptr += 7;
        }
        if (cmd.mv60) {
            ptr[0..7].* = "--mv60\x00".*;
            ptr += 7;
        }
        if (cmd.mv62) {
            ptr[0..7].* = "--mv62\x00".*;
            ptr += 7;
        }
        if (cmd.mv65) {
            ptr[0..7].* = "--mv65\x00".*;
            ptr += 7;
        }
        if (cmd.mv66) {
            ptr[0..7].* = "--mv66\x00".*;
            ptr += 7;
        }
        if (cmd.mv67) {
            ptr[0..7].* = "--mv67\x00".*;
            ptr += 7;
        }
        if (cmd.mv67t) {
            ptr[0..8].* = "--mv67t\x00".*;
            ptr += 8;
        }
        if (cmd.mv68) {
            ptr[0..7].* = "--mv68\x00".*;
            ptr += 7;
        }
        if (cmd.mv69) {
            ptr[0..7].* = "--mv69\x00".*;
            ptr += 7;
        }
        if (cmd.mv71) {
            ptr[0..7].* = "--mv71\x00".*;
            ptr += 7;
        }
        if (cmd.mv71t) {
            ptr[0..8].* = "--mv71t\x00".*;
            ptr += 8;
        }
        if (cmd.mv73) {
            ptr[0..7].* = "--mv73\x00".*;
            ptr += 7;
        }
        if (cmd.mve_max_interleave_factor) |mve_max_interleave_factor| {
            ptr = fmt.strcpyEqu(ptr, "--mve-max-interleave-factor\x00");
            ptr = fmt.Ud64.write(ptr, mve_max_interleave_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.mwarn_missing_parenthesis) {
            ptr = fmt.strcpyEqu(ptr, "--mwarn-missing-parenthesis\x00");
        }
        if (cmd.mwarn_noncontigious_register) {
            ptr = fmt.strcpyEqu(ptr, "--mwarn-noncontigious-register\x00");
        }
        if (cmd.mwarn_sign_mismatch) {
            ptr = fmt.strcpyEqu(ptr, "--mwarn-sign-mismatch\x00");
        }
        if (cmd.no_deprecated_warn) {
            ptr = fmt.strcpyEqu(ptr, "--no-deprecated-warn\x00");
        }
        if (cmd.no_discriminators) {
            ptr = fmt.strcpyEqu(ptr, "--no-discriminators\x00");
        }
        if (cmd.no_dwarf_ranges_section) {
            ptr = fmt.strcpyEqu(ptr, "--no-dwarf-ranges-section\x00");
        }
        if (cmd.no_integrated_as) {
            ptr = fmt.strcpyEqu(ptr, "--no-integrated-as\x00");
        }
        if (cmd.no_pgo_warn_mismatch) {
            ptr = fmt.strcpyEqu(ptr, "--no-pgo-warn-mismatch\x00");
        }
        if (cmd.no_pgo_warn_mismatch_comdat_weak) {
            ptr = fmt.strcpyEqu(ptr, "--no-pgo-warn-mismatch-comdat-weak\x00");
        }
        if (cmd.no_phi_elim_live_out_early_exit) {
            ptr = fmt.strcpyEqu(ptr, "--no-phi-elim-live-out-early-exit\x00");
        }
        if (cmd.no_stack_coloring) {
            ptr = fmt.strcpyEqu(ptr, "--no-stack-coloring\x00");
        }
        if (cmd.no_stack_slot_sharing) {
            ptr = fmt.strcpyEqu(ptr, "--no-stack-slot-sharing\x00");
        }
        if (cmd.no_type_check) {
            ptr = fmt.strcpyEqu(ptr, "--no-type-check\x00");
        }
        if (cmd.no_warn) {
            ptr = fmt.strcpyEqu(ptr, "--no-warn\x00");
        }
        if (cmd.no_warn_sample_unused) {
            ptr = fmt.strcpyEqu(ptr, "--no-warn-sample-unused\x00");
        }
        if (cmd.no_x86_call_frame_opt) {
            ptr = fmt.strcpyEqu(ptr, "--no-x86-call-frame-opt\x00");
        }
        if (cmd.no_xray_index) {
            ptr = fmt.strcpyEqu(ptr, "--no-xray-index\x00");
        }
        if (cmd.non_global_value_max_name_size) |non_global_value_max_name_size| {
            ptr = fmt.strcpyEqu(ptr, "--non-global-value-max-name-size\x00");
            ptr = fmt.Ud64.write(ptr, non_global_value_max_name_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nozero_initialized_in_bss) {
            ptr = fmt.strcpyEqu(ptr, "--nozero-initialized-in-bss\x00");
        }
        if (cmd.number_scavenger_slots) |number_scavenger_slots| {
            ptr = fmt.strcpyEqu(ptr, "--number-scavenger-slots\x00");
            ptr = fmt.Ud64.write(ptr, number_scavenger_slots);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nvj_count) |nvj_count| {
            ptr = fmt.strcpyEqu(ptr, "--nvj-count\x00");
            ptr = fmt.Ud64.write(ptr, nvj_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nvptx_fma_level) |nvptx_fma_level| {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-fma-level\x00");
            ptr = fmt.Ud64.write(ptr, nvptx_fma_level);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nvptx_no_f16_math) {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-no-f16-math\x00");
        }
        if (cmd.nvptx_prec_divf32) |nvptx_prec_divf32| {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-prec-divf32\x00");
            ptr = fmt.Ud64.write(ptr, nvptx_prec_divf32);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nvptx_prec_sqrtf32) {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-prec-sqrtf32\x00");
        }
        if (cmd.nvptx_sched4reg) {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-sched4reg\x00");
        }
        if (cmd.nvptx_short_ptr) {
            ptr = fmt.strcpyEqu(ptr, "--nvptx-short-ptr\x00");
        }
        if (cmd.nvvm_intr_range_sm) |nvvm_intr_range_sm| {
            ptr = fmt.strcpyEqu(ptr, "--nvvm-intr-range-sm\x00");
            ptr = fmt.Ud64.write(ptr, nvvm_intr_range_sm);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.nvvm_reflect_enable) {
            ptr = fmt.strcpyEqu(ptr, "--nvvm-reflect-enable\x00");
        }
        if (cmd.old_thumb2_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--old-thumb2-ifcvt\x00");
        }
        if (cmd.only_nonnested_memmove_idiom) {
            ptr = fmt.strcpyEqu(ptr, "--only-nonnested-memmove-idiom\x00");
        }
        if (cmd.only_simple_regions) {
            ptr = fmt.strcpyEqu(ptr, "--only-simple-regions\x00");
        }
        if (cmd.opaque_pointers) {
            ptr = fmt.strcpyEqu(ptr, "--opaque-pointers\x00");
        }
        if (cmd.openmp_deduce_icv_values) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-deduce-icv-values\x00");
        }
        if (cmd.openmp_hide_memory_transfer_latency) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-hide-memory-transfer-latency\x00");
        }
        if (cmd.openmp_ir_builder_optimistic_attributes) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-ir-builder-optimistic-attributes\x00");
        }
        if (cmd.openmp_ir_builder_unroll_threshold_factor) |openmp_ir_builder_unroll_threshold_factor| {
            ptr = fmt.strcpyEqu(ptr, "--openmp-ir-builder-unroll-threshold-factor\x00");
            ptr = fmt.Ud64.write(ptr, openmp_ir_builder_unroll_threshold_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.openmp_opt_disable) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable\x00");
        }
        if (cmd.openmp_opt_disable_barrier_elimination) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-barrier-elimination\x00");
        }
        if (cmd.openmp_opt_disable_deglobalization) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-deglobalization\x00");
        }
        if (cmd.openmp_opt_disable_folding) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-folding\x00");
        }
        if (cmd.openmp_opt_disable_internalization) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-internalization\x00");
        }
        if (cmd.openmp_opt_disable_spmdization) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-spmdization\x00");
        }
        if (cmd.openmp_opt_disable_state_machine_rewrite) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-disable-state-machine-rewrite\x00");
        }
        if (cmd.openmp_opt_enable_merging) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-enable-merging\x00");
        }
        if (cmd.openmp_opt_inline_device) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-inline-device\x00");
        }
        if (cmd.openmp_opt_max_iterations) |openmp_opt_max_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-max-iterations\x00");
            ptr = fmt.Ud64.write(ptr, openmp_opt_max_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.openmp_opt_print_module_after) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-print-module-after\x00");
        }
        if (cmd.openmp_opt_print_module_before) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-print-module-before\x00");
        }
        if (cmd.openmp_opt_shared_limit) |openmp_opt_shared_limit| {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-shared-limit\x00");
            ptr = fmt.Ud64.write(ptr, openmp_opt_shared_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.openmp_opt_verbose_remarks) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-opt-verbose-remarks\x00");
        }
        if (cmd.openmp_print_gpu_kernels) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-print-gpu-kernels\x00");
        }
        if (cmd.openmp_print_icv_values) {
            ptr = fmt.strcpyEqu(ptr, "--openmp-print-icv-values\x00");
        }
        if (cmd.opt_bisect_limit) |opt_bisect_limit| {
            ptr = fmt.strcpyEqu(ptr, "--opt-bisect-limit\x00");
            ptr = fmt.Ud64.write(ptr, opt_bisect_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.opt_bisect_print_ir_path) |opt_bisect_print_ir_path| {
            ptr = fmt.strcpyEqu(ptr, "--opt-bisect-print-ir-path\x00");
            ptr = fmt.strcpyEqu(ptr, opt_bisect_print_ir_path);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.optimize_regalloc) {
            ptr = fmt.strcpyEqu(ptr, "--optimize-regalloc\x00");
        }
        if (cmd.optsize_jump_table_density) |optsize_jump_table_density| {
            ptr = fmt.strcpyEqu(ptr, "--optsize-jump-table-density\x00");
            ptr = fmt.Ud64.write(ptr, optsize_jump_table_density);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.orderfile_write_mapping) |orderfile_write_mapping| {
            ptr = fmt.strcpyEqu(ptr, "--orderfile-write-mapping\x00");
            ptr = fmt.strcpyEqu(ptr, orderfile_write_mapping);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.outline_region_freq_percent) |outline_region_freq_percent| {
            ptr = fmt.strcpyEqu(ptr, "--outline-region-freq-percent\x00");
            ptr = fmt.Ud64.write(ptr, outline_region_freq_percent);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.overwrite_existing_weights) {
            ptr = fmt.strcpyEqu(ptr, "--overwrite-existing-weights\x00");
        }
        if (cmd.partial_inlining_extra_penalty) |partial_inlining_extra_penalty| {
            ptr = fmt.strcpyEqu(ptr, "--partial-inlining-extra-penalty\x00");
            ptr = fmt.Ud64.write(ptr, partial_inlining_extra_penalty);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.partial_profile) {
            ptr = fmt.strcpyEqu(ptr, "--partial-profile\x00");
        }
        if (cmd.partial_reg_update_clearance) |partial_reg_update_clearance| {
            ptr = fmt.strcpyEqu(ptr, "--partial-reg-update-clearance\x00");
            ptr = fmt.Ud64.write(ptr, partial_reg_update_clearance);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.partial_sample_profile_working_set_size_scale_factor) |partial_sample_profile_working_set_size_scale_factor| {
            ptr = fmt.strcpyEqu(ptr, "--partial-sample-profile-working-set-size-scale-factor\x00");
            ptr = fmt.Ud64.write(ptr, partial_sample_profile_working_set_size_scale_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.partial_unrolling_threshold) |partial_unrolling_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--partial-unrolling-threshold\x00");
            ptr = fmt.Ud64.write(ptr, partial_unrolling_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks) |pass_remarks| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_analysis) |pass_remarks_analysis| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-analysis\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks_analysis);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_filter) |pass_remarks_filter| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-filter\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks_filter);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_format) |pass_remarks_format| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-format\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks_format);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_hotness_threshold) {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-hotness-threshold\x00");
        }
        if (cmd.pass_remarks_missed) |pass_remarks_missed| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-missed\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks_missed);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_output) |pass_remarks_output| {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-output\x00");
            ptr = fmt.strcpyEqu(ptr, pass_remarks_output);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pass_remarks_with_hotness) {
            ptr = fmt.strcpyEqu(ptr, "--pass-remarks-with-hotness\x00");
        }
        if (cmd.pbqp_coalescing) {
            ptr = fmt.strcpyEqu(ptr, "--pbqp-coalescing\x00");
        }
        if (cmd.persist_profile_staleness) {
            ptr = fmt.strcpyEqu(ptr, "--persist-profile-staleness\x00");
        }
        if (cmd.pgo_critical_edge_threshold) |pgo_critical_edge_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-critical-edge-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pgo_critical_edge_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_emit_branch_prob) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-emit-branch-prob\x00");
        }
        if (cmd.pgo_fix_entry_count) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-fix-entry-count\x00");
        }
        if (cmd.pgo_function_entry_coverage) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-function-entry-coverage\x00");
        }
        if (cmd.pgo_function_size_threshold) |pgo_function_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-function-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pgo_function_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_instr_memop) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-instr-memop\x00");
        }
        if (cmd.pgo_instr_old_cfg_hashing) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-instr-old-cfg-hashing\x00");
        }
        if (cmd.pgo_instr_select) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-instr-select\x00");
        }
        if (cmd.pgo_instrument_entry) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-instrument-entry\x00");
        }
        if (cmd.pgo_match_memprof) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-match-memprof\x00");
        }
        if (cmd.pgo_memop_count_threshold) |pgo_memop_count_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-memop-count-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pgo_memop_count_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_memop_max_version) |pgo_memop_max_version| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-memop-max-version\x00");
            ptr = fmt.Ud64.write(ptr, pgo_memop_max_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_memop_optimize_memcmp_bcmp) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-memop-optimize-memcmp-bcmp\x00");
        }
        if (cmd.pgo_memop_percent_threshold) |pgo_memop_percent_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-memop-percent-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pgo_memop_percent_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_memop_scale_count) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-memop-scale-count\x00");
        }
        if (cmd.pgo_test_profile_file) |pgo_test_profile_file| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-test-profile-file\x00");
            ptr = fmt.strcpyEqu(ptr, pgo_test_profile_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_test_profile_remapping_file) |pgo_test_profile_remapping_file| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-test-profile-remapping-file\x00");
            ptr = fmt.strcpyEqu(ptr, pgo_test_profile_remapping_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_verify_bfi) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-verify-bfi\x00");
        }
        if (cmd.pgo_verify_bfi_cutoff) |pgo_verify_bfi_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-verify-bfi-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, pgo_verify_bfi_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_verify_bfi_ratio) |pgo_verify_bfi_ratio| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-verify-bfi-ratio\x00");
            ptr = fmt.Ud64.write(ptr, pgo_verify_bfi_ratio);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_verify_hot_bfi) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-verify-hot-bfi\x00");
        }
        if (cmd.pgo_view_counts) |pgo_view_counts| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-view-counts\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(pgo_view_counts));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_view_raw_counts) |pgo_view_raw_counts| {
            ptr = fmt.strcpyEqu(ptr, "--pgo-view-raw-counts\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(pgo_view_raw_counts));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgo_warn_misexpect) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-warn-misexpect\x00");
        }
        if (cmd.pgo_warn_missing_function) {
            ptr = fmt.strcpyEqu(ptr, "--pgo-warn-missing-function\x00");
        }
        if (cmd.pgso) {
            ptr[0..7].* = "--pgso\x00".*;
            ptr += 7;
        }
        if (cmd.pgso_cold_code_only) {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cold-code-only\x00");
        }
        if (cmd.pgso_cold_code_only_for_instr_pgo) {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cold-code-only-for-instr-pgo\x00");
        }
        if (cmd.pgso_cold_code_only_for_partial_sample_pgo) {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cold-code-only-for-partial-sample-pgo\x00");
        }
        if (cmd.pgso_cold_code_only_for_sample_pgo) {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cold-code-only-for-sample-pgo\x00");
        }
        if (cmd.pgso_cutoff_instr_prof) |pgso_cutoff_instr_prof| {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cutoff-instr-prof\x00");
            ptr = fmt.Ud64.write(ptr, pgso_cutoff_instr_prof);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgso_cutoff_sample_prof) |pgso_cutoff_sample_prof| {
            ptr = fmt.strcpyEqu(ptr, "--pgso-cutoff-sample-prof\x00");
            ptr = fmt.Ud64.write(ptr, pgso_cutoff_sample_prof);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pgso_lwss_only) {
            ptr = fmt.strcpyEqu(ptr, "--pgso-lwss-only\x00");
        }
        if (cmd.phi_elim_split_all_critical_edges) {
            ptr = fmt.strcpyEqu(ptr, "--phi-elim-split-all-critical-edges\x00");
        }
        if (cmd.phi_node_folding_threshold) |phi_node_folding_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--phi-node-folding-threshold\x00");
            ptr = fmt.Ud64.write(ptr, phi_node_folding_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.phicse_debug_hash) {
            ptr = fmt.strcpyEqu(ptr, "--phicse-debug-hash\x00");
        }
        if (cmd.phicse_num_phi_smallsize) |phicse_num_phi_smallsize| {
            ptr = fmt.strcpyEqu(ptr, "--phicse-num-phi-smallsize\x00");
            ptr = fmt.Ud64.write(ptr, phicse_num_phi_smallsize);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pi_force_live_exit_outline) {
            ptr = fmt.strcpyEqu(ptr, "--pi-force-live-exit-outline\x00");
        }
        if (cmd.pi_mark_coldcc) {
            ptr = fmt.strcpyEqu(ptr, "--pi-mark-coldcc\x00");
        }
        if (cmd.pipeliner_annotate_for_testing) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-annotate-for-testing\x00");
        }
        if (cmd.pipeliner_dbg_res) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-dbg-res\x00");
        }
        if (cmd.pipeliner_experimental_cg) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-experimental-cg\x00");
        }
        if (cmd.pipeliner_force_ii) |pipeliner_force_ii| {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-force-ii\x00");
            ptr = fmt.Ud64.write(ptr, pipeliner_force_ii);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pipeliner_force_issue_width) |pipeliner_force_issue_width| {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-force-issue-width\x00");
            ptr = fmt.Ud64.write(ptr, pipeliner_force_issue_width);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pipeliner_max_mii) |pipeliner_max_mii| {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-max-mii\x00");
            ptr = fmt.Ud64.write(ptr, pipeliner_max_mii);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pipeliner_max_stages) |pipeliner_max_stages| {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-max-stages\x00");
            ptr = fmt.Ud64.write(ptr, pipeliner_max_stages);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pipeliner_prune_deps) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-prune-deps\x00");
        }
        if (cmd.pipeliner_prune_loop_carried) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-prune-loop-carried\x00");
        }
        if (cmd.pipeliner_show_mask) {
            ptr = fmt.strcpyEqu(ptr, "--pipeliner-show-mask\x00");
        }
        if (cmd.poison_checking_function_local) {
            ptr = fmt.strcpyEqu(ptr, "--poison-checking-function-local\x00");
        }
        if (cmd.post_RA_scheduler) {
            ptr = fmt.strcpyEqu(ptr, "--post-RA-scheduler\x00");
        }
        if (cmd.postra_sched_debugdiv) |postra_sched_debugdiv| {
            ptr = fmt.strcpyEqu(ptr, "--postra-sched-debugdiv\x00");
            ptr = fmt.Ud64.write(ptr, postra_sched_debugdiv);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.postra_sched_debugmod) |postra_sched_debugmod| {
            ptr = fmt.strcpyEqu(ptr, "--postra-sched-debugmod\x00");
            ptr = fmt.Ud64.write(ptr, postra_sched_debugmod);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_always_use_base_pointer) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-always-use-base-pointer\x00");
        }
        if (cmd.ppc_asm_full_reg_names) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-asm-full-reg-names\x00");
        }
        if (cmd.ppc_bit_perm_rewriter_stress_rotates) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-bit-perm-rewriter-stress-rotates\x00");
        }
        if (cmd.ppc_chaincommon_max_vars) |ppc_chaincommon_max_vars| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-chaincommon-max-vars\x00");
            ptr = fmt.Ud64.write(ptr, ppc_chaincommon_max_vars);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_chaincommon_min_threshold) |ppc_chaincommon_min_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-chaincommon-min-threshold\x00");
            ptr = fmt.Ud64.write(ptr, ppc_chaincommon_min_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_convert_rr_to_ri) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-convert-rr-to-ri\x00");
        }
        if (cmd.ppc_disable_non_volatile_cr) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-disable-non-volatile-cr\x00");
        }
        if (cmd.ppc_disable_perfect_shuffle) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-disable-perfect-shuffle\x00");
        }
        if (cmd.ppc_dispprep_min_threshold) |ppc_dispprep_min_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-dispprep-min-threshold\x00");
            ptr = fmt.Ud64.write(ptr, ppc_dispprep_min_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_dqprep_max_vars) |ppc_dqprep_max_vars| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-dqprep-max-vars\x00");
            ptr = fmt.Ud64.write(ptr, ppc_dqprep_max_vars);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_dsprep_max_vars) |ppc_dsprep_max_vars| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-dsprep-max-vars\x00");
            ptr = fmt.Ud64.write(ptr, ppc_dsprep_max_vars);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_eliminate_signext) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-eliminate-signext\x00");
        }
        if (cmd.ppc_eliminate_zeroext) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-eliminate-zeroext\x00");
        }
        if (cmd.ppc_enable_coldcc) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-enable-coldcc\x00");
        }
        if (cmd.ppc_enable_gpr_to_vsr_spills) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-enable-gpr-to-vsr-spills\x00");
        }
        if (cmd.ppc_enable_pe_vector_spills) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-enable-pe-vector-spills\x00");
        }
        if (cmd.ppc_enable_pipeliner) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-enable-pipeliner\x00");
        }
        if (cmd.ppc_fma_rp_factor) |ppc_fma_rp_factor| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-fma-rp-factor\x00");
            ptr = fmt.Ud64.write(ptr, ppc_fma_rp_factor);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_fma_rp_reduction) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-fma-rp-reduction\x00");
        }
        if (cmd.ppc_formprep_chain_commoning) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-formprep-chain-commoning\x00");
        }
        if (cmd.ppc_formprep_max_vars) |ppc_formprep_max_vars| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-formprep-max-vars\x00");
            ptr = fmt.Ud64.write(ptr, ppc_formprep_max_vars);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_formprep_prefer_update) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-formprep-prefer-update\x00");
        }
        if (cmd.ppc_formprep_update_nonconst_inc) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-formprep-update-nonconst-inc\x00");
        }
        if (cmd.ppc_gen_isel) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-gen-isel\x00");
        }
        if (cmd.ppc_gep_opt) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-gep-opt\x00");
        }
        if (cmd.ppc_gpr_icmps) |ppc_gpr_icmps| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-gpr-icmps\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(ppc_gpr_icmps));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_late_peephole) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-late-peephole\x00");
        }
        if (cmd.ppc_lsr_no_insns_cost) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-lsr-no-insns-cost\x00");
        }
        if (cmd.ppc_machine_combiner) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-machine-combiner\x00");
        }
        if (cmd.ppc_max_crbit_spill_dist) |ppc_max_crbit_spill_dist| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-max-crbit-spill-dist\x00");
            ptr = fmt.Ud64.write(ptr, ppc_max_crbit_spill_dist);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_old_latency_calc) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-old-latency-calc\x00");
        }
        if (cmd.ppc_opt_conditional_trap) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-opt-conditional-trap\x00");
        }
        if (cmd.ppc_pcrel_linker_opt) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-pcrel-linker-opt\x00");
        }
        if (cmd.ppc_postra_bias_addi) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-postra-bias-addi\x00");
        }
        if (cmd.ppc_preinc_prep_max_vars) |ppc_preinc_prep_max_vars| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-preinc-prep-max-vars\x00");
            ptr = fmt.Ud64.write(ptr, ppc_preinc_prep_max_vars);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_quadword_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-quadword-atomics\x00");
        }
        if (cmd.ppc_reduce_cr_logicals) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-reduce-cr-logicals\x00");
        }
        if (cmd.ppc_reg_to_imm_fixed_point) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-reg-to-imm-fixed-point\x00");
        }
        if (cmd.ppc_reg_with_percent_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-reg-with-percent-prefix\x00");
        }
        if (cmd.ppc_set_dscr) |ppc_set_dscr| {
            ptr = fmt.strcpyEqu(ptr, "--ppc-set-dscr\x00");
            ptr = fmt.Ud64.write(ptr, ppc_set_dscr);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.ppc_stack_ptr_caller_preserved) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-stack-ptr-caller-preserved\x00");
        }
        if (cmd.ppc_tls_opt) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-tls-opt\x00");
        }
        if (cmd.ppc_track_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-track-subreg-liveness\x00");
        }
        if (cmd.ppc_use_absolute_jumptables) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-use-absolute-jumptables\x00");
        }
        if (cmd.ppc_use_base_pointer) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-use-base-pointer\x00");
        }
        if (cmd.ppc_use_bit_perm_rewriter) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-use-bit-perm-rewriter\x00");
        }
        if (cmd.ppc_use_branch_hint) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-use-branch-hint\x00");
        }
        if (cmd.ppc_vsr_nums_as_vr) {
            ptr = fmt.strcpyEqu(ptr, "--ppc-vsr-nums-as-vr\x00");
        }
        if (cmd.pragma_unroll_and_jam_threshold) |pragma_unroll_and_jam_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pragma-unroll-and-jam-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pragma_unroll_and_jam_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pragma_unroll_threshold) |pragma_unroll_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pragma-unroll-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pragma_unroll_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pragma_vectorize_scev_check_threshold) |pragma_vectorize_scev_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--pragma-vectorize-scev-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, pragma_vectorize_scev_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.pre_RA_sched) |pre_RA_sched| {
            ptr = fmt.strcpyEqu(ptr, "--pre-RA-sched\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(pre_RA_sched));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.precise_rotation_cost) {
            ptr = fmt.strcpyEqu(ptr, "--precise-rotation-cost\x00");
        }
        if (cmd.prefer_inloop_reductions) {
            ptr = fmt.strcpyEqu(ptr, "--prefer-inloop-reductions\x00");
        }
        if (cmd.prefer_no_csel) {
            ptr = fmt.strcpyEqu(ptr, "--prefer-no-csel\x00");
        }
        if (cmd.prefer_predicate_over_epilogue) |prefer_predicate_over_epilogue| {
            ptr = fmt.strcpyEqu(ptr, "--prefer-predicate-over-epilogue\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(prefer_predicate_over_epilogue));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.prefer_predicated_reduction_select) {
            ptr = fmt.strcpyEqu(ptr, "--prefer-predicated-reduction-select\x00");
        }
        if (cmd.prefetch_distance) |prefetch_distance| {
            ptr = fmt.strcpyEqu(ptr, "--prefetch-distance\x00");
            ptr = fmt.Ud64.write(ptr, prefetch_distance);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.prefetch_hints_file) |prefetch_hints_file| {
            ptr = fmt.strcpyEqu(ptr, "--prefetch-hints-file\x00");
            ptr = fmt.strcpyEqu(ptr, prefetch_hints_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.preinline_threshold) |preinline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--preinline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, preinline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.preserve_alignment_assumptions_during_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--preserve-alignment-assumptions-during-inlining\x00");
        }
        if (cmd.preserve_as_comments) {
            ptr = fmt.strcpyEqu(ptr, "--preserve-as-comments\x00");
        }
        if (cmd.print_after) |print_after| {
            ptr = fmt.strcpyEqu(ptr, "--print-after\x00");
            ptr = fmt.strcpyEqu(ptr, print_after);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_after_all) {
            ptr = fmt.strcpyEqu(ptr, "--print-after-all\x00");
        }
        if (cmd.print_after_isel) {
            ptr = fmt.strcpyEqu(ptr, "--print-after-isel\x00");
        }
        if (cmd.print_all_options) {
            ptr = fmt.strcpyEqu(ptr, "--print-all-options\x00");
        }
        if (cmd.print_before) |print_before| {
            ptr = fmt.strcpyEqu(ptr, "--print-before\x00");
            ptr = fmt.strcpyEqu(ptr, print_before);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_before_all) {
            ptr = fmt.strcpyEqu(ptr, "--print-before-all\x00");
        }
        if (cmd.print_before_changed) {
            ptr = fmt.strcpyEqu(ptr, "--print-before-changed\x00");
        }
        if (cmd.print_bfi) {
            ptr = fmt.strcpyEqu(ptr, "--print-bfi\x00");
        }
        if (cmd.print_bfi_func_name) |print_bfi_func_name| {
            ptr = fmt.strcpyEqu(ptr, "--print-bfi-func-name\x00");
            ptr = fmt.strcpyEqu(ptr, print_bfi_func_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_bpi) {
            ptr = fmt.strcpyEqu(ptr, "--print-bpi\x00");
        }
        if (cmd.print_bpi_func_name) |print_bpi_func_name| {
            ptr = fmt.strcpyEqu(ptr, "--print-bpi-func-name\x00");
            ptr = fmt.strcpyEqu(ptr, print_bpi_func_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_changed) |print_changed| {
            ptr = fmt.strcpyEqu(ptr, "--print-changed\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(print_changed));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_changed_dot_path) |print_changed_dot_path| {
            ptr = fmt.strcpyEqu(ptr, "--print-changed-dot-path\x00");
            ptr = fmt.strcpyEqu(ptr, print_changed_dot_path);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_debug_ata) {
            ptr = fmt.strcpyEqu(ptr, "--print-debug-ata\x00");
        }
        if (cmd.print_debug_counter) {
            ptr = fmt.strcpyEqu(ptr, "--print-debug-counter\x00");
        }
        if (cmd.print_failed_fuse_candidates) {
            ptr = fmt.strcpyEqu(ptr, "--print-failed-fuse-candidates\x00");
        }
        if (cmd.print_gc) {
            ptr = fmt.strcpyEqu(ptr, "--print-gc\x00");
        }
        if (cmd.print_import_failures) {
            ptr = fmt.strcpyEqu(ptr, "--print-import-failures\x00");
        }
        if (cmd.print_imports) {
            ptr = fmt.strcpyEqu(ptr, "--print-imports\x00");
        }
        if (cmd.print_instruction_comments) {
            ptr = fmt.strcpyEqu(ptr, "--print-instruction-comments\x00");
        }
        if (cmd.print_isel_input) {
            ptr = fmt.strcpyEqu(ptr, "--print-isel-input\x00");
        }
        if (cmd.print_lsr_output) {
            ptr = fmt.strcpyEqu(ptr, "--print-lsr-output\x00");
        }
        if (cmd.print_lvi_after_jump_threading) {
            ptr = fmt.strcpyEqu(ptr, "--print-lvi-after-jump-threading\x00");
        }
        if (cmd.print_machine_bfi) {
            ptr = fmt.strcpyEqu(ptr, "--print-machine-bfi\x00");
        }
        if (cmd.print_module_scope) {
            ptr = fmt.strcpyEqu(ptr, "--print-module-scope\x00");
        }
        if (cmd.print_on_crash) {
            ptr = fmt.strcpyEqu(ptr, "--print-on-crash\x00");
        }
        if (cmd.print_options) {
            ptr = fmt.strcpyEqu(ptr, "--print-options\x00");
        }
        if (cmd.print_pipeline_passes) {
            ptr = fmt.strcpyEqu(ptr, "--print-pipeline-passes\x00");
        }
        if (cmd.print_region_style) |print_region_style| {
            ptr = fmt.strcpyEqu(ptr, "--print-region-style\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(print_region_style));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_regmask_num_regs) |print_regmask_num_regs| {
            ptr = fmt.strcpyEqu(ptr, "--print-regmask-num-regs\x00");
            ptr = fmt.Ud64.write(ptr, print_regmask_num_regs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.print_regusage) {
            ptr = fmt.strcpyEqu(ptr, "--print-regusage\x00");
        }
        if (cmd.print_slotindexes) {
            ptr = fmt.strcpyEqu(ptr, "--print-slotindexes\x00");
        }
        if (cmd.print_summary_global_ids) {
            ptr = fmt.strcpyEqu(ptr, "--print-summary-global-ids\x00");
        }
        if (cmd.procres_cost_lim) |procres_cost_lim| {
            ptr = fmt.strcpyEqu(ptr, "--procres-cost-lim\x00");
            ptr = fmt.Ud64.write(ptr, procres_cost_lim);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_accurate_for_symsinlist) {
            ptr = fmt.strcpyEqu(ptr, "--profile-accurate-for-symsinlist\x00");
        }
        if (cmd.profile_guided_section_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--profile-guided-section-prefix\x00");
        }
        if (cmd.profile_isfs) {
            ptr = fmt.strcpyEqu(ptr, "--profile-isfs\x00");
        }
        if (cmd.profile_likely_prob) |profile_likely_prob| {
            ptr = fmt.strcpyEqu(ptr, "--profile-likely-prob\x00");
            ptr = fmt.Ud64.write(ptr, profile_likely_prob);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_sample_accurate) {
            ptr = fmt.strcpyEqu(ptr, "--profile-sample-accurate\x00");
        }
        if (cmd.profile_sample_block_accurate) {
            ptr = fmt.strcpyEqu(ptr, "--profile-sample-block-accurate\x00");
        }
        if (cmd.profile_summary_contextless) {
            ptr = fmt.strcpyEqu(ptr, "--profile-summary-contextless\x00");
        }
        if (cmd.profile_summary_cutoff_cold) |profile_summary_cutoff_cold| {
            ptr = fmt.strcpyEqu(ptr, "--profile-summary-cutoff-cold\x00");
            ptr = fmt.Ud64.write(ptr, profile_summary_cutoff_cold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_summary_cutoff_hot) |profile_summary_cutoff_hot| {
            ptr = fmt.strcpyEqu(ptr, "--profile-summary-cutoff-hot\x00");
            ptr = fmt.Ud64.write(ptr, profile_summary_cutoff_hot);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_summary_huge_working_set_size_threshold) |profile_summary_huge_working_set_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--profile-summary-huge-working-set-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, profile_summary_huge_working_set_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_summary_large_working_set_size_threshold) |profile_summary_large_working_set_size_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--profile-summary-large-working-set-size-threshold\x00");
            ptr = fmt.Ud64.write(ptr, profile_summary_large_working_set_size_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_symbol_list_cutoff) |profile_symbol_list_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--profile-symbol-list-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, profile_symbol_list_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.profile_unknown_in_special_section) {
            ptr = fmt.strcpyEqu(ptr, "--profile-unknown-in-special-section\x00");
        }
        if (cmd.propagate_attrs) {
            ptr = fmt.strcpyEqu(ptr, "--propagate-attrs\x00");
        }
        if (cmd.protect_from_escaped_allocas) {
            ptr = fmt.strcpyEqu(ptr, "--protect-from-escaped-allocas\x00");
        }
        if (cmd.r600_ir_structurize) {
            ptr = fmt.strcpyEqu(ptr, "--r600-ir-structurize\x00");
        }
        if (cmd.rafast_ignore_missing_defs) {
            ptr = fmt.strcpyEqu(ptr, "--rafast-ignore-missing-defs\x00");
        }
        if (cmd.rdf_dump) {
            ptr = fmt.strcpyEqu(ptr, "--rdf-dump\x00");
        }
        if (cmd.rdf_limit) |rdf_limit| {
            ptr = fmt.strcpyEqu(ptr, "--rdf-limit\x00");
            ptr = fmt.Ud64.write(ptr, rdf_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rdf_liveness_max_rec) |rdf_liveness_max_rec| {
            ptr = fmt.strcpyEqu(ptr, "--rdf-liveness-max-rec\x00");
            ptr = fmt.Ud64.write(ptr, rdf_liveness_max_rec);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rdf_opt) {
            ptr = fmt.strcpyEqu(ptr, "--rdf-opt\x00");
        }
        if (cmd.reassociate_geps_verify_no_dead_code) {
            ptr = fmt.strcpyEqu(ptr, "--reassociate-geps-verify-no-dead-code\x00");
        }
        if (cmd.rebalance_only_imbal) {
            ptr = fmt.strcpyEqu(ptr, "--rebalance-only-imbal\x00");
        }
        if (cmd.rebalance_only_opt) {
            ptr = fmt.strcpyEqu(ptr, "--rebalance-only-opt\x00");
        }
        if (cmd.recurrence_chain_limit) |recurrence_chain_limit| {
            ptr = fmt.strcpyEqu(ptr, "--recurrence-chain-limit\x00");
            ptr = fmt.Ud64.write(ptr, recurrence_chain_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.recursive_inline_max_stacksize) |recursive_inline_max_stacksize| {
            ptr = fmt.strcpyEqu(ptr, "--recursive-inline-max-stacksize\x00");
            ptr = fmt.Ud64.write(ptr, recursive_inline_max_stacksize);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc) |regalloc| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(regalloc));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_cheap_remat_weight) |regalloc_cheap_remat_weight| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-cheap-remat-weight\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_cheap_remat_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_copy_weight) |regalloc_copy_weight| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-copy-weight\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_copy_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_csr_first_time_cost) |regalloc_csr_first_time_cost| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-csr-first-time-cost\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_csr_first_time_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_enable_advisor) |regalloc_enable_advisor| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-enable-advisor\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(regalloc_enable_advisor));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_enable_priority_advisor) |regalloc_enable_priority_advisor| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-enable-priority-advisor\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(regalloc_enable_priority_advisor));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_eviction_max_interference_cutoff) |regalloc_eviction_max_interference_cutoff| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-eviction-max-interference-cutoff\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_eviction_max_interference_cutoff);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_expensive_remat_weight) |regalloc_expensive_remat_weight| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-expensive-remat-weight\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_expensive_remat_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_load_weight) |regalloc_load_weight| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-load-weight\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_load_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regalloc_store_weight) |regalloc_store_weight| {
            ptr = fmt.strcpyEqu(ptr, "--regalloc-store-weight\x00");
            ptr = fmt.Ud64.write(ptr, regalloc_store_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.regbankselect_fast) {
            ptr = fmt.strcpyEqu(ptr, "--regbankselect-fast\x00");
        }
        if (cmd.regbankselect_greedy) {
            ptr = fmt.strcpyEqu(ptr, "--regbankselect-greedy\x00");
        }
        if (cmd.relax_elf_relocations) {
            ptr = fmt.strcpyEqu(ptr, "--relax-elf-relocations\x00");
        }
        if (cmd.relax_nv_checks) {
            ptr = fmt.strcpyEqu(ptr, "--relax-nv-checks\x00");
        }
        if (cmd.relocation_model) |relocation_model| {
            ptr = fmt.strcpyEqu(ptr, "--relocation-model\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(relocation_model));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.remarks_section) {
            ptr = fmt.strcpyEqu(ptr, "--remarks-section\x00");
        }
        if (cmd.remat_pic_stub_load) {
            ptr = fmt.strcpyEqu(ptr, "--remat-pic-stub-load\x00");
        }
        if (cmd.rename_exclude_alias_prefixes) |rename_exclude_alias_prefixes| {
            ptr = fmt.strcpyEqu(ptr, "--rename-exclude-alias-prefixes\x00");
            ptr = fmt.strcpyEqu(ptr, rename_exclude_alias_prefixes);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rename_exclude_function_prefixes) |rename_exclude_function_prefixes| {
            ptr = fmt.strcpyEqu(ptr, "--rename-exclude-function-prefixes\x00");
            ptr = fmt.strcpyEqu(ptr, rename_exclude_function_prefixes);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rename_exclude_global_prefixes) |rename_exclude_global_prefixes| {
            ptr = fmt.strcpyEqu(ptr, "--rename-exclude-global-prefixes\x00");
            ptr = fmt.strcpyEqu(ptr, rename_exclude_global_prefixes);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rename_exclude_struct_prefixes) |rename_exclude_struct_prefixes| {
            ptr = fmt.strcpyEqu(ptr, "--rename-exclude-struct-prefixes\x00");
            ptr = fmt.strcpyEqu(ptr, rename_exclude_struct_prefixes);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.renumber_blocks_before_view) {
            ptr = fmt.strcpyEqu(ptr, "--renumber-blocks-before-view\x00");
        }
        if (cmd.replexitval) |replexitval| {
            ptr = fmt.strcpyEqu(ptr, "--replexitval\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(replexitval));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.report_profile_staleness) {
            ptr = fmt.strcpyEqu(ptr, "--report-profile-staleness\x00");
        }
        if (cmd.reroll_num_tolerated_failed_matches) |reroll_num_tolerated_failed_matches| {
            ptr = fmt.strcpyEqu(ptr, "--reroll-num-tolerated-failed-matches\x00");
            ptr = fmt.Ud64.write(ptr, reroll_num_tolerated_failed_matches);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.reserve_regs_for_regalloc) |reserve_regs_for_regalloc| {
            ptr = fmt.strcpyEqu(ptr, "--reserve-regs-for-regalloc\x00");
            ptr = fmt.strcpyEqu(ptr, reserve_regs_for_regalloc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.restrict_statepoint_remat) {
            ptr = fmt.strcpyEqu(ptr, "--restrict-statepoint-remat\x00");
        }
        if (cmd.reverse_csr_restore_seq) {
            ptr = fmt.strcpyEqu(ptr, "--reverse-csr-restore-seq\x00");
        }
        if (cmd.rewrite_map_file) |rewrite_map_file| {
            ptr = fmt.strcpyEqu(ptr, "--rewrite-map-file\x00");
            ptr = fmt.strcpyEqu(ptr, rewrite_map_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rewrite_phi_limit) |rewrite_phi_limit| {
            ptr = fmt.strcpyEqu(ptr, "--rewrite-phi-limit\x00");
            ptr = fmt.Ud64.write(ptr, rewrite_phi_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_disable_insert_vsetvl_phi_opt) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-disable-insert-vsetvl-phi-opt\x00");
        }
        if (cmd.riscv_disable_regalloc_hints) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-disable-regalloc-hints\x00");
        }
        if (cmd.riscv_disable_sextw_removal) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-disable-sextw-removal\x00");
        }
        if (cmd.riscv_disable_strip_w_suffix) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-disable-strip-w-suffix\x00");
        }
        if (cmd.riscv_disable_using_constant_pool_for_large_ints) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-disable-using-constant-pool-for-large-ints\x00");
        }
        if (cmd.riscv_enable_copyelim) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-enable-copyelim\x00");
        }
        if (cmd.riscv_enable_global_merge) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-enable-global-merge\x00");
        }
        if (cmd.riscv_enable_machine_combiner) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-enable-machine-combiner\x00");
        }
        if (cmd.riscv_enable_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-enable-subreg-liveness\x00");
        }
        if (cmd.riscv_insert_vsetvl_strict_asserts) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-insert-vsetvl-strict-asserts\x00");
        }
        if (cmd.riscv_lower_ext_max_web_size) |riscv_lower_ext_max_web_size| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-lower-ext-max-web-size\x00");
            ptr = fmt.Ud64.write(ptr, riscv_lower_ext_max_web_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_lower_form_vw_w_with_splat) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-lower-form-vw-w-with-splat\x00");
        }
        if (cmd.riscv_lower_fp_repeated_divisors) |riscv_lower_fp_repeated_divisors| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-lower-fp-repeated-divisors\x00");
            ptr = fmt.Ud64.write(ptr, riscv_lower_fp_repeated_divisors);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_max_build_ints_cost) |riscv_max_build_ints_cost| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-max-build-ints-cost\x00");
            ptr = fmt.Ud64.write(ptr, riscv_max_build_ints_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_no_aliases) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-no-aliases\x00");
        }
        if (cmd.riscv_prefer_whole_register_move) {
            ptr = fmt.strcpyEqu(ptr, "--riscv-prefer-whole-register-move\x00");
        }
        if (cmd.riscv_v_fixed_length_vector_lmul_max) |riscv_v_fixed_length_vector_lmul_max| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-v-fixed-length-vector-lmul-max\x00");
            ptr = fmt.Ud64.write(ptr, riscv_v_fixed_length_vector_lmul_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_v_register_bit_width_lmul) |riscv_v_register_bit_width_lmul| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-v-register-bit-width-lmul\x00");
            ptr = fmt.Ud64.write(ptr, riscv_v_register_bit_width_lmul);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_v_slp_max_vf) |riscv_v_slp_max_vf| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-v-slp-max-vf\x00");
            ptr = fmt.Ud64.write(ptr, riscv_v_slp_max_vf);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_v_vector_bits_max) |riscv_v_vector_bits_max| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-v-vector-bits-max\x00");
            ptr = fmt.Ud64.write(ptr, riscv_v_vector_bits_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.riscv_v_vector_bits_min) |riscv_v_vector_bits_min| {
            ptr = fmt.strcpyEqu(ptr, "--riscv-v-vector-bits-min\x00");
            ptr = fmt.Ud64.write(ptr, riscv_v_vector_bits_min);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rotation_max_header_size) |rotation_max_header_size| {
            ptr = fmt.strcpyEqu(ptr, "--rotation-max-header-size\x00");
            ptr = fmt.Ud64.write(ptr, rotation_max_header_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.rotation_prepare_for_lto) {
            ptr = fmt.strcpyEqu(ptr, "--rotation-prepare-for-lto\x00");
        }
        if (cmd.rs4gc_allow_statepoint_with_no_deopt_info) {
            ptr = fmt.strcpyEqu(ptr, "--rs4gc-allow-statepoint-with-no-deopt-info\x00");
        }
        if (cmd.rs4gc_clobber_non_live) {
            ptr = fmt.strcpyEqu(ptr, "--rs4gc-clobber-non-live\x00");
        }
        if (cmd.rs4gc_remat_derived_at_uses) {
            ptr = fmt.strcpyEqu(ptr, "--rs4gc-remat-derived-at-uses\x00");
        }
        if (cmd.run_pass) |run_pass| {
            ptr = fmt.strcpyEqu(ptr, "--run-pass\x00");
            ptr = fmt.strcpyEqu(ptr, run_pass);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.runtime_check_per_loop_load_elim) |runtime_check_per_loop_load_elim| {
            ptr = fmt.strcpyEqu(ptr, "--runtime-check-per-loop-load-elim\x00");
            ptr = fmt.Ud64.write(ptr, runtime_check_per_loop_load_elim);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.runtime_counter_relocation) {
            ptr = fmt.strcpyEqu(ptr, "--runtime-counter-relocation\x00");
        }
        if (cmd.runtime_mem_idiom_threshold) |runtime_mem_idiom_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--runtime-mem-idiom-threshold\x00");
            ptr = fmt.Ud64.write(ptr, runtime_mem_idiom_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.runtime_memory_check_threshold) |runtime_memory_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--runtime-memory-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, runtime_memory_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.safe_stack_coloring) {
            ptr = fmt.strcpyEqu(ptr, "--safe-stack-coloring\x00");
        }
        if (cmd.safe_stack_layout) {
            ptr = fmt.strcpyEqu(ptr, "--safe-stack-layout\x00");
        }
        if (cmd.safepoint_ir_verifier_print_only) {
            ptr = fmt.strcpyEqu(ptr, "--safepoint-ir-verifier-print-only\x00");
        }
        if (cmd.safestack_use_pointer_address) {
            ptr = fmt.strcpyEqu(ptr, "--safestack-use-pointer-address\x00");
        }
        if (cmd.sample_profile_check_record_coverage) |sample_profile_check_record_coverage| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-check-record-coverage\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_check_record_coverage);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_check_sample_coverage) |sample_profile_check_sample_coverage| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-check-sample-coverage\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_check_sample_coverage);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_cold_inline_threshold) |sample_profile_cold_inline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-cold-inline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_cold_inline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_even_flow_distribution) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-even-flow-distribution\x00");
        }
        if (cmd.sample_profile_file) |sample_profile_file| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-file\x00");
            ptr = fmt.strcpyEqu(ptr, sample_profile_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_hot_inline_threshold) |sample_profile_hot_inline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-hot-inline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_hot_inline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_icp_max_prom) |sample_profile_icp_max_prom| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-icp-max-prom\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_icp_max_prom);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_icp_relative_hotness) |sample_profile_icp_relative_hotness| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-icp-relative-hotness\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_icp_relative_hotness);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_icp_relative_hotness_skip) |sample_profile_icp_relative_hotness_skip| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-icp-relative-hotness-skip\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_icp_relative_hotness_skip);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_growth_limit) |sample_profile_inline_growth_limit| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-growth-limit\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_inline_growth_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_limit_max) |sample_profile_inline_limit_max| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-limit-max\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_inline_limit_max);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_limit_min) |sample_profile_inline_limit_min| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-limit-min\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_inline_limit_min);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_replay) |sample_profile_inline_replay| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-replay\x00");
            ptr = fmt.strcpyEqu(ptr, sample_profile_inline_replay);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_replay_fallback) |sample_profile_inline_replay_fallback| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-replay-fallback\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(sample_profile_inline_replay_fallback));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_replay_format) |sample_profile_inline_replay_format| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-replay-format\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(sample_profile_inline_replay_format));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_replay_scope) |sample_profile_inline_replay_scope| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-replay-scope\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(sample_profile_inline_replay_scope));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_inline_size) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-inline-size\x00");
        }
        if (cmd.sample_profile_join_islands) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-join-islands\x00");
        }
        if (cmd.sample_profile_max_propagate_iterations) |sample_profile_max_propagate_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-max-propagate-iterations\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_max_propagate_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_merge_inlinee) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-merge-inlinee\x00");
        }
        if (cmd.sample_profile_prioritized_inline) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-prioritized-inline\x00");
        }
        if (cmd.sample_profile_profi_cost_block_dec) |sample_profile_profi_cost_block_dec| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-dec\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_dec);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_profi_cost_block_entry_dec) |sample_profile_profi_cost_block_entry_dec| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-entry-dec\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_entry_dec);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_profi_cost_block_entry_inc) |sample_profile_profi_cost_block_entry_inc| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-entry-inc\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_entry_inc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_profi_cost_block_inc) |sample_profile_profi_cost_block_inc| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-inc\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_inc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_profi_cost_block_unknown_inc) |sample_profile_profi_cost_block_unknown_inc| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-unknown-inc\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_unknown_inc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_profi_cost_block_zero_inc) |sample_profile_profi_cost_block_zero_inc| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-profi-cost-block-zero-inc\x00");
            ptr = fmt.Ud64.write(ptr, sample_profile_profi_cost_block_zero_inc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_rebalance_unknown) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-rebalance-unknown\x00");
        }
        if (cmd.sample_profile_recursive_inline) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-recursive-inline\x00");
        }
        if (cmd.sample_profile_remapping_file) |sample_profile_remapping_file| {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-remapping-file\x00");
            ptr = fmt.strcpyEqu(ptr, sample_profile_remapping_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sample_profile_top_down_load) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-top-down-load\x00");
        }
        if (cmd.sample_profile_use_preinliner) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-use-preinliner\x00");
        }
        if (cmd.sample_profile_use_profi) {
            ptr = fmt.strcpyEqu(ptr, "--sample-profile-use-profi\x00");
        }
        if (cmd.sanitizer_coverage_control_flow) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-control-flow\x00");
        }
        if (cmd.sanitizer_coverage_inline_8bit_counters) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-inline-8bit-counters\x00");
        }
        if (cmd.sanitizer_coverage_inline_bool_flag) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-inline-bool-flag\x00");
        }
        if (cmd.sanitizer_coverage_level) |sanitizer_coverage_level| {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-level\x00");
            ptr = fmt.Ud64.write(ptr, sanitizer_coverage_level);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sanitizer_coverage_pc_table) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-pc-table\x00");
        }
        if (cmd.sanitizer_coverage_prune_blocks) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-prune-blocks\x00");
        }
        if (cmd.sanitizer_coverage_stack_depth) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-stack-depth\x00");
        }
        if (cmd.sanitizer_coverage_trace_compares) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-compares\x00");
        }
        if (cmd.sanitizer_coverage_trace_divs) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-divs\x00");
        }
        if (cmd.sanitizer_coverage_trace_geps) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-geps\x00");
        }
        if (cmd.sanitizer_coverage_trace_loads) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-loads\x00");
        }
        if (cmd.sanitizer_coverage_trace_pc) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-pc\x00");
        }
        if (cmd.sanitizer_coverage_trace_pc_guard) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-pc-guard\x00");
        }
        if (cmd.sanitizer_coverage_trace_stores) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-coverage-trace-stores\x00");
        }
        if (cmd.sanitizer_metadata_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-metadata-atomics\x00");
        }
        if (cmd.sanitizer_metadata_covered) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-metadata-covered\x00");
        }
        if (cmd.sanitizer_metadata_uar) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-metadata-uar\x00");
        }
        if (cmd.sanitizer_metadata_weak_callbacks) {
            ptr = fmt.strcpyEqu(ptr, "--sanitizer-metadata-weak-callbacks\x00");
        }
        if (cmd.scalable_vectorization) |scalable_vectorization| {
            ptr = fmt.strcpyEqu(ptr, "--scalable-vectorization\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(scalable_vectorization));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_classify_expressions) {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-classify-expressions\x00");
        }
        if (cmd.scalar_evolution_finite_loop) {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-finite-loop\x00");
        }
        if (cmd.scalar_evolution_huge_expr_threshold) |scalar_evolution_huge_expr_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-huge-expr-threshold\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_huge_expr_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_add_rec_size) |scalar_evolution_max_add_rec_size| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-add-rec-size\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_add_rec_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_arith_depth) |scalar_evolution_max_arith_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-arith-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_arith_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_cast_depth) |scalar_evolution_max_cast_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-cast-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_cast_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_constant_evolving_depth) |scalar_evolution_max_constant_evolving_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-constant-evolving-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_constant_evolving_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_scc_analysis_depth) |scalar_evolution_max_scc_analysis_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-scc-analysis-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_scc_analysis_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_scev_compare_depth) |scalar_evolution_max_scev_compare_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-scev-compare-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_scev_compare_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_scev_operations_implication_depth) |scalar_evolution_max_scev_operations_implication_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-scev-operations-implication-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_scev_operations_implication_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_max_value_compare_depth) |scalar_evolution_max_value_compare_depth| {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-max-value-compare-depth\x00");
            ptr = fmt.Ud64.write(ptr, scalar_evolution_max_value_compare_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scalar_evolution_use_context_for_no_wrap_flag_strenghening) {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-use-context-for-no-wrap-flag-strenghening\x00");
        }
        if (cmd.scalar_evolution_use_expensive_range_sharpening) {
            ptr = fmt.strcpyEqu(ptr, "--scalar-evolution-use-expensive-range-sharpening\x00");
        }
        if (cmd.scalarize_load_store) {
            ptr = fmt.strcpyEqu(ptr, "--scalarize-load-store\x00");
        }
        if (cmd.scalarize_variable_insert_extract) {
            ptr = fmt.strcpyEqu(ptr, "--scalarize-variable-insert-extract\x00");
        }
        if (cmd.scale_partial_sample_profile_working_set_size) {
            ptr = fmt.strcpyEqu(ptr, "--scale-partial-sample-profile-working-set-size\x00");
        }
        if (cmd.scev_addops_inline_threshold) |scev_addops_inline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--scev-addops-inline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, scev_addops_inline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scev_cheap_expansion_budget) |scev_cheap_expansion_budget| {
            ptr = fmt.strcpyEqu(ptr, "--scev-cheap-expansion-budget\x00");
            ptr = fmt.Ud64.write(ptr, scev_cheap_expansion_budget);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scev_mulops_inline_threshold) |scev_mulops_inline_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--scev-mulops-inline-threshold\x00");
            ptr = fmt.Ud64.write(ptr, scev_mulops_inline_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scev_range_iter_threshold) |scev_range_iter_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--scev-range-iter-threshold\x00");
            ptr = fmt.Ud64.write(ptr, scev_range_iter_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.scev_verify_ir) {
            ptr = fmt.strcpyEqu(ptr, "--scev-verify-ir\x00");
        }
        if (cmd.sched_avg_ipc) |sched_avg_ipc| {
            ptr = fmt.strcpyEqu(ptr, "--sched-avg-ipc\x00");
            ptr = fmt.Ud64.write(ptr, sched_avg_ipc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sched_high_latency_cycles) |sched_high_latency_cycles| {
            ptr = fmt.strcpyEqu(ptr, "--sched-high-latency-cycles\x00");
            ptr = fmt.Ud64.write(ptr, sched_high_latency_cycles);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sched_preds_closer) {
            ptr = fmt.strcpyEqu(ptr, "--sched-preds-closer\x00");
        }
        if (cmd.sched_retval_optimization) {
            ptr = fmt.strcpyEqu(ptr, "--sched-retval-optimization\x00");
        }
        if (cmd.scheditins) {
            ptr = fmt.strcpyEqu(ptr, "--scheditins\x00");
        }
        if (cmd.schedmodel) {
            ptr = fmt.strcpyEqu(ptr, "--schedmodel\x00");
        }
        if (cmd.schedule_ppc_vsx_fma_mutation_early) {
            ptr = fmt.strcpyEqu(ptr, "--schedule-ppc-vsx-fma-mutation-early\x00");
        }
        if (cmd.select_opti_loop_cycle_gain_threshold) |select_opti_loop_cycle_gain_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--select-opti-loop-cycle-gain-threshold\x00");
            ptr = fmt.Ud64.write(ptr, select_opti_loop_cycle_gain_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.select_opti_loop_gradient_gain_threshold) |select_opti_loop_gradient_gain_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--select-opti-loop-gradient-gain-threshold\x00");
            ptr = fmt.Ud64.write(ptr, select_opti_loop_gradient_gain_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.select_opti_loop_relative_gain_threshold) |select_opti_loop_relative_gain_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--select-opti-loop-relative-gain-threshold\x00");
            ptr = fmt.Ud64.write(ptr, select_opti_loop_relative_gain_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sgpr_regalloc) |sgpr_regalloc| {
            ptr = fmt.strcpyEqu(ptr, "--sgpr-regalloc\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(sgpr_regalloc));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.show_fs_branchprob) {
            ptr = fmt.strcpyEqu(ptr, "--show-fs-branchprob\x00");
        }
        if (cmd.show_mc_encoding) {
            ptr = fmt.strcpyEqu(ptr, "--show-mc-encoding\x00");
        }
        if (cmd.shrink_frame_limit) |shrink_frame_limit| {
            ptr = fmt.strcpyEqu(ptr, "--shrink-frame-limit\x00");
            ptr = fmt.Ud64.write(ptr, shrink_frame_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simple_loop_unswitch_drop_non_trivial_implicit_null_checks) {
            ptr = fmt.strcpyEqu(ptr, "--simple-loop-unswitch-drop-non-trivial-implicit-null-checks\x00");
        }
        if (cmd.simple_loop_unswitch_guards) {
            ptr = fmt.strcpyEqu(ptr, "--simple-loop-unswitch-guards\x00");
        }
        if (cmd.simple_loop_unswitch_memoryssa_threshold) |simple_loop_unswitch_memoryssa_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--simple-loop-unswitch-memoryssa-threshold\x00");
            ptr = fmt.Ud64.write(ptr, simple_loop_unswitch_memoryssa_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simplify_mir) {
            ptr = fmt.strcpyEqu(ptr, "--simplify-mir\x00");
        }
        if (cmd.simplifycfg_branch_fold_common_dest_vector_multiplier) |simplifycfg_branch_fold_common_dest_vector_multiplier| {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-branch-fold-common-dest-vector-multiplier\x00");
            ptr = fmt.Ud64.write(ptr, simplifycfg_branch_fold_common_dest_vector_multiplier);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simplifycfg_branch_fold_threshold) |simplifycfg_branch_fold_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-branch-fold-threshold\x00");
            ptr = fmt.Ud64.write(ptr, simplifycfg_branch_fold_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simplifycfg_hoist_common) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-hoist-common\x00");
        }
        if (cmd.simplifycfg_hoist_common_skip_limit) |simplifycfg_hoist_common_skip_limit| {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-hoist-common-skip-limit\x00");
            ptr = fmt.Ud64.write(ptr, simplifycfg_hoist_common_skip_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simplifycfg_hoist_cond_stores) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-hoist-cond-stores\x00");
        }
        if (cmd.simplifycfg_max_small_block_size) |simplifycfg_max_small_block_size| {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-max-small-block-size\x00");
            ptr = fmt.Ud64.write(ptr, simplifycfg_max_small_block_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.simplifycfg_merge_compatible_invokes) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-merge-compatible-invokes\x00");
        }
        if (cmd.simplifycfg_merge_cond_stores) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-merge-cond-stores\x00");
        }
        if (cmd.simplifycfg_merge_cond_stores_aggressively) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-merge-cond-stores-aggressively\x00");
        }
        if (cmd.simplifycfg_require_and_preserve_domtree) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-require-and-preserve-domtree\x00");
        }
        if (cmd.simplifycfg_sink_common) {
            ptr = fmt.strcpyEqu(ptr, "--simplifycfg-sink-common\x00");
        }
        if (cmd.sink_common_insts) {
            ptr = fmt.strcpyEqu(ptr, "--sink-common-insts\x00");
        }
        if (cmd.sink_freq_percent_threshold) |sink_freq_percent_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--sink-freq-percent-threshold\x00");
            ptr = fmt.Ud64.write(ptr, sink_freq_percent_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sink_insts_to_avoid_spills) {
            ptr = fmt.strcpyEqu(ptr, "--sink-insts-to-avoid-spills\x00");
        }
        if (cmd.skip_mips_long_branch) {
            ptr = fmt.strcpyEqu(ptr, "--skip-mips-long-branch\x00");
        }
        if (cmd.skip_ret_exit_block) {
            ptr = fmt.strcpyEqu(ptr, "--skip-ret-exit-block\x00");
        }
        if (cmd.slot1_store_slot0_load) {
            ptr = fmt.strcpyEqu(ptr, "--slot1-store-slot0-load\x00");
        }
        if (cmd.slp_max_look_ahead_depth) |slp_max_look_ahead_depth| {
            ptr = fmt.strcpyEqu(ptr, "--slp-max-look-ahead-depth\x00");
            ptr = fmt.Ud64.write(ptr, slp_max_look_ahead_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_max_reg_size) |slp_max_reg_size| {
            ptr = fmt.strcpyEqu(ptr, "--slp-max-reg-size\x00");
            ptr = fmt.Ud64.write(ptr, slp_max_reg_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_max_root_look_ahead_depth) |slp_max_root_look_ahead_depth| {
            ptr = fmt.strcpyEqu(ptr, "--slp-max-root-look-ahead-depth\x00");
            ptr = fmt.Ud64.write(ptr, slp_max_root_look_ahead_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_max_store_lookup) |slp_max_store_lookup| {
            ptr = fmt.strcpyEqu(ptr, "--slp-max-store-lookup\x00");
            ptr = fmt.Ud64.write(ptr, slp_max_store_lookup);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_max_vf) |slp_max_vf| {
            ptr = fmt.strcpyEqu(ptr, "--slp-max-vf\x00");
            ptr = fmt.Ud64.write(ptr, slp_max_vf);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_min_reg_size) |slp_min_reg_size| {
            ptr = fmt.strcpyEqu(ptr, "--slp-min-reg-size\x00");
            ptr = fmt.Ud64.write(ptr, slp_min_reg_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_min_tree_size) |slp_min_tree_size| {
            ptr = fmt.strcpyEqu(ptr, "--slp-min-tree-size\x00");
            ptr = fmt.Ud64.write(ptr, slp_min_tree_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_recursion_max_depth) |slp_recursion_max_depth| {
            ptr = fmt.strcpyEqu(ptr, "--slp-recursion-max-depth\x00");
            ptr = fmt.Ud64.write(ptr, slp_recursion_max_depth);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_schedule_budget) |slp_schedule_budget| {
            ptr = fmt.strcpyEqu(ptr, "--slp-schedule-budget\x00");
            ptr = fmt.Ud64.write(ptr, slp_schedule_budget);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_threshold) |slp_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--slp-threshold\x00");
            ptr = fmt.Ud64.write(ptr, slp_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.slp_vectorize_hor) {
            ptr = fmt.strcpyEqu(ptr, "--slp-vectorize-hor\x00");
        }
        if (cmd.slp_vectorize_hor_store) {
            ptr = fmt.strcpyEqu(ptr, "--slp-vectorize-hor-store\x00");
        }
        if (cmd.small_loop_cost) |small_loop_cost| {
            ptr = fmt.strcpyEqu(ptr, "--small-loop-cost\x00");
            ptr = fmt.Ud64.write(ptr, small_loop_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sort_profiled_scc_member) {
            ptr = fmt.strcpyEqu(ptr, "--sort-profiled-scc-member\x00");
        }
        if (cmd.sort_timers) {
            ptr = fmt.strcpyEqu(ptr, "--sort-timers\x00");
        }
        if (cmd.sparc_bpcc_offset_bits) |sparc_bpcc_offset_bits| {
            ptr = fmt.strcpyEqu(ptr, "--sparc-bpcc-offset-bits\x00");
            ptr = fmt.Ud64.write(ptr, sparc_bpcc_offset_bits);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sparc_enable_branch_relax) {
            ptr = fmt.strcpyEqu(ptr, "--sparc-enable-branch-relax\x00");
        }
        if (cmd.sparc_reserve_app_registers) {
            ptr = fmt.strcpyEqu(ptr, "--sparc-reserve-app-registers\x00");
        }
        if (cmd.spec_exec_max_not_hoisted) |spec_exec_max_not_hoisted| {
            ptr = fmt.strcpyEqu(ptr, "--spec-exec-max-not-hoisted\x00");
            ptr = fmt.Ud64.write(ptr, spec_exec_max_not_hoisted);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spec_exec_max_speculation_cost) |spec_exec_max_speculation_cost| {
            ptr = fmt.strcpyEqu(ptr, "--spec-exec-max-speculation-cost\x00");
            ptr = fmt.Ud64.write(ptr, spec_exec_max_speculation_cost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spec_exec_only_if_divergent_target) {
            ptr = fmt.strcpyEqu(ptr, "--spec-exec-only-if-divergent-target\x00");
        }
        if (cmd.speculate_one_expensive_inst) {
            ptr = fmt.strcpyEqu(ptr, "--speculate-one-expensive-inst\x00");
        }
        if (cmd.speculative_counter_promotion_max_exiting) |speculative_counter_promotion_max_exiting| {
            ptr = fmt.strcpyEqu(ptr, "--speculative-counter-promotion-max-exiting\x00");
            ptr = fmt.Ud64.write(ptr, speculative_counter_promotion_max_exiting);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.speculative_counter_promotion_to_loop) {
            ptr = fmt.strcpyEqu(ptr, "--speculative-counter-promotion-to-loop\x00");
        }
        if (cmd.spill_func_threshold) |spill_func_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--spill-func-threshold\x00");
            ptr = fmt.Ud64.write(ptr, spill_func_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spill_func_threshold_Os) |spill_func_threshold_Os| {
            ptr = fmt.strcpyEqu(ptr, "--spill-func-threshold-Os\x00");
            ptr = fmt.Ud64.write(ptr, spill_func_threshold_Os);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.split_dwarf_cross_cu_references) {
            ptr = fmt.strcpyEqu(ptr, "--split-dwarf-cross-cu-references\x00");
        }
        if (cmd.split_dwarf_file) |split_dwarf_file| {
            ptr = fmt.strcpyEqu(ptr, "--split-dwarf-file\x00");
            ptr = fmt.strcpyEqu(ptr, split_dwarf_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.split_dwarf_output) |split_dwarf_output| {
            ptr = fmt.strcpyEqu(ptr, "--split-dwarf-output\x00");
            ptr = fmt.strcpyEqu(ptr, split_dwarf_output);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.split_machine_functions) {
            ptr = fmt.strcpyEqu(ptr, "--split-machine-functions\x00");
        }
        if (cmd.split_spill_mode) |split_spill_mode| {
            ptr = fmt.strcpyEqu(ptr, "--split-spill-mode\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(split_spill_mode));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spp_all_backedges) {
            ptr = fmt.strcpyEqu(ptr, "--spp-all-backedges\x00");
        }
        if (cmd.spp_counted_loop_trip_width) |spp_counted_loop_trip_width| {
            ptr = fmt.strcpyEqu(ptr, "--spp-counted-loop-trip-width\x00");
            ptr = fmt.Ud64.write(ptr, spp_counted_loop_trip_width);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spp_no_backedge) {
            ptr = fmt.strcpyEqu(ptr, "--spp-no-backedge\x00");
        }
        if (cmd.spp_no_call) {
            ptr = fmt.strcpyEqu(ptr, "--spp-no-call\x00");
        }
        if (cmd.spp_no_entry) {
            ptr = fmt.strcpyEqu(ptr, "--spp-no-entry\x00");
        }
        if (cmd.spp_print_base_pointers) {
            ptr = fmt.strcpyEqu(ptr, "--spp-print-base-pointers\x00");
        }
        if (cmd.spp_print_liveset) {
            ptr = fmt.strcpyEqu(ptr, "--spp-print-liveset\x00");
        }
        if (cmd.spp_print_liveset_size) {
            ptr = fmt.strcpyEqu(ptr, "--spp-print-liveset-size\x00");
        }
        if (cmd.spp_rematerialization_threshold) |spp_rematerialization_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--spp-rematerialization-threshold\x00");
            ptr = fmt.Ud64.write(ptr, spp_rematerialization_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.spp_split_backedge) {
            ptr = fmt.strcpyEqu(ptr, "--spp-split-backedge\x00");
        }
        if (cmd.sroa_strict_inbounds) {
            ptr = fmt.strcpyEqu(ptr, "--sroa-strict-inbounds\x00");
        }
        if (cmd.ssc_dce_limit) |ssc_dce_limit| {
            ptr = fmt.strcpyEqu(ptr, "--ssc-dce-limit\x00");
            ptr = fmt.Ud64.write(ptr, ssc_dce_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stack_safety_max_iterations) |stack_safety_max_iterations| {
            ptr = fmt.strcpyEqu(ptr, "--stack-safety-max-iterations\x00");
            ptr = fmt.Ud64.write(ptr, stack_safety_max_iterations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stack_safety_print) {
            ptr = fmt.strcpyEqu(ptr, "--stack-safety-print\x00");
        }
        if (cmd.stack_safety_run) {
            ptr = fmt.strcpyEqu(ptr, "--stack-safety-run\x00");
        }
        if (cmd.stack_size_section) {
            ptr = fmt.strcpyEqu(ptr, "--stack-size-section\x00");
        }
        if (cmd.stack_symbol_ordering) {
            ptr = fmt.strcpyEqu(ptr, "--stack-symbol-ordering\x00");
        }
        if (cmd.stack_tagging_first_slot_opt) {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-first-slot-opt\x00");
        }
        if (cmd.stack_tagging_merge_init) {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-merge-init\x00");
        }
        if (cmd.stack_tagging_merge_init_scan_limit) |stack_tagging_merge_init_scan_limit| {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-merge-init-scan-limit\x00");
            ptr = fmt.Ud64.write(ptr, stack_tagging_merge_init_scan_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stack_tagging_merge_init_size_limit) |stack_tagging_merge_init_size_limit| {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-merge-init-size-limit\x00");
            ptr = fmt.Ud64.write(ptr, stack_tagging_merge_init_size_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stack_tagging_merge_settag) {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-merge-settag\x00");
        }
        if (cmd.stack_tagging_unchecked_ld_st) |stack_tagging_unchecked_ld_st| {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-unchecked-ld-st\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(stack_tagging_unchecked_ld_st));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stack_tagging_use_stack_safety) {
            ptr = fmt.strcpyEqu(ptr, "--stack-tagging-use-stack-safety\x00");
        }
        if (cmd.stackcoloring_lifetime_start_on_first_use) {
            ptr = fmt.strcpyEqu(ptr, "--stackcoloring-lifetime-start-on-first-use\x00");
        }
        if (cmd.stackmap_version) |stackmap_version| {
            ptr = fmt.strcpyEqu(ptr, "--stackmap-version\x00");
            ptr = fmt.Ud64.write(ptr, stackmap_version);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stackrealign) {
            ptr = fmt.strcpyEqu(ptr, "--stackrealign\x00");
        }
        if (cmd.start_after) |start_after| {
            ptr = fmt.strcpyEqu(ptr, "--start-after\x00");
            ptr = fmt.strcpyEqu(ptr, start_after);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.start_before) |start_before| {
            ptr = fmt.strcpyEqu(ptr, "--start-before\x00");
            ptr = fmt.strcpyEqu(ptr, start_before);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.static_func_full_module_prefix) {
            ptr = fmt.strcpyEqu(ptr, "--static-func-full-module-prefix\x00");
        }
        if (cmd.static_func_strip_dirname_prefix) |static_func_strip_dirname_prefix| {
            ptr = fmt.strcpyEqu(ptr, "--static-func-strip-dirname-prefix\x00");
            ptr = fmt.Ud64.write(ptr, static_func_strip_dirname_prefix);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.static_likely_prob) |static_likely_prob| {
            ptr = fmt.strcpyEqu(ptr, "--static-likely-prob\x00");
            ptr = fmt.Ud64.write(ptr, static_likely_prob);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stats) {
            ptr[0..8].* = "--stats\x00".*;
            ptr += 8;
        }
        if (cmd.stats_json) {
            ptr = fmt.strcpyEqu(ptr, "--stats-json\x00");
        }
        if (cmd.stop_after) |stop_after| {
            ptr = fmt.strcpyEqu(ptr, "--stop-after\x00");
            ptr = fmt.strcpyEqu(ptr, stop_after);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.stop_before) |stop_before| {
            ptr = fmt.strcpyEqu(ptr, "--stop-before\x00");
            ptr = fmt.strcpyEqu(ptr, stop_before);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.store_to_load_forwarding_conflict_detection) {
            ptr = fmt.strcpyEqu(ptr, "--store-to-load-forwarding-conflict-detection\x00");
        }
        if (cmd.stress_cgp_ext_ld_promotion) {
            ptr = fmt.strcpyEqu(ptr, "--stress-cgp-ext-ld-promotion\x00");
        }
        if (cmd.stress_cgp_store_extract) {
            ptr = fmt.strcpyEqu(ptr, "--stress-cgp-store-extract\x00");
        }
        if (cmd.stress_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--stress-early-ifcvt\x00");
        }
        if (cmd.stress_regalloc) |stress_regalloc| {
            ptr = fmt.strcpyEqu(ptr, "--stress-regalloc\x00");
            ptr = fmt.Ud64.write(ptr, stress_regalloc);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.strict_dwarf) {
            ptr = fmt.strcpyEqu(ptr, "--strict-dwarf\x00");
        }
        if (cmd.structurizecfg_relaxed_uniform_regions) {
            ptr = fmt.strcpyEqu(ptr, "--structurizecfg-relaxed-uniform-regions\x00");
        }
        if (cmd.structurizecfg_skip_uniform_regions) {
            ptr = fmt.strcpyEqu(ptr, "--structurizecfg-skip-uniform-regions\x00");
        }
        if (cmd.summary_file) |summary_file| {
            ptr = fmt.strcpyEqu(ptr, "--summary-file\x00");
            ptr = fmt.strcpyEqu(ptr, summary_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sve_gather_overhead) |sve_gather_overhead| {
            ptr = fmt.strcpyEqu(ptr, "--sve-gather-overhead\x00");
            ptr = fmt.Ud64.write(ptr, sve_gather_overhead);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sve_scatter_overhead) |sve_scatter_overhead| {
            ptr = fmt.strcpyEqu(ptr, "--sve-scatter-overhead\x00");
            ptr = fmt.Ud64.write(ptr, sve_scatter_overhead);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.sve_tail_folding) |sve_tail_folding| {
            ptr = fmt.strcpyEqu(ptr, "--sve-tail-folding\x00");
            ptr = fmt.strcpyEqu(ptr, sve_tail_folding);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.swift_async_fp) |swift_async_fp| {
            ptr = fmt.strcpyEqu(ptr, "--swift-async-fp\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(swift_async_fp));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.switch_peel_threshold) |switch_peel_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--switch-peel-threshold\x00");
            ptr = fmt.Ud64.write(ptr, switch_peel_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.switch_range_to_icmp) {
            ptr = fmt.strcpyEqu(ptr, "--switch-range-to-icmp\x00");
        }
        if (cmd.switch_to_lookup) {
            ptr = fmt.strcpyEqu(ptr, "--switch-to-lookup\x00");
        }
        if (cmd.systemz_subreg_liveness) {
            ptr = fmt.strcpyEqu(ptr, "--systemz-subreg-liveness\x00");
        }
        if (cmd.t2_reduce_limit) |t2_reduce_limit| {
            ptr = fmt.strcpyEqu(ptr, "--t2-reduce-limit\x00");
            ptr = fmt.Ud64.write(ptr, t2_reduce_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.t2_reduce_limit2) |t2_reduce_limit2| {
            ptr = fmt.strcpyEqu(ptr, "--t2-reduce-limit2\x00");
            ptr = fmt.Ud64.write(ptr, t2_reduce_limit2);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.t2_reduce_limit3) |t2_reduce_limit3| {
            ptr = fmt.strcpyEqu(ptr, "--t2-reduce-limit3\x00");
            ptr = fmt.Ud64.write(ptr, t2_reduce_limit3);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_indirect_size) |tail_dup_indirect_size| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-indirect-size\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_indirect_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_limit) |tail_dup_limit| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-limit\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_placement) {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-placement\x00");
        }
        if (cmd.tail_dup_placement_aggressive_threshold) |tail_dup_placement_aggressive_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-placement-aggressive-threshold\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_placement_aggressive_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_placement_penalty) |tail_dup_placement_penalty| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-placement-penalty\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_placement_penalty);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_placement_threshold) |tail_dup_placement_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-placement-threshold\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_placement_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_profile_percent_threshold) |tail_dup_profile_percent_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-profile-percent-threshold\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_profile_percent_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_size) |tail_dup_size| {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-size\x00");
            ptr = fmt.Ud64.write(ptr, tail_dup_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_dup_verify) {
            ptr = fmt.strcpyEqu(ptr, "--tail-dup-verify\x00");
        }
        if (cmd.tail_merge_size) |tail_merge_size| {
            ptr = fmt.strcpyEqu(ptr, "--tail-merge-size\x00");
            ptr = fmt.Ud64.write(ptr, tail_merge_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_merge_threshold) |tail_merge_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--tail-merge-threshold\x00");
            ptr = fmt.Ud64.write(ptr, tail_merge_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tail_predication) |tail_predication| {
            ptr = fmt.strcpyEqu(ptr, "--tail-predication\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(tail_predication));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tailcallopt) {
            ptr = fmt.strcpyEqu(ptr, "--tailcallopt\x00");
        }
        if (cmd.target_abi) |target_abi| {
            ptr = fmt.strcpyEqu(ptr, "--target-abi\x00");
            ptr = fmt.strcpyEqu(ptr, target_abi);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.temporal_reuse_threshold) |temporal_reuse_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--temporal-reuse-threshold\x00");
            ptr = fmt.Ud64.write(ptr, temporal_reuse_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.terminal_rule) {
            ptr = fmt.strcpyEqu(ptr, "--terminal-rule\x00");
        }
        if (cmd.tfutils_use_simplelogger) {
            ptr = fmt.strcpyEqu(ptr, "--tfutils-use-simplelogger\x00");
        }
        if (cmd.thinlto_assume_merged) {
            ptr = fmt.strcpyEqu(ptr, "--thinlto-assume-merged\x00");
        }
        if (cmd.thinlto_synthesize_entry_counts) {
            ptr = fmt.strcpyEqu(ptr, "--thinlto-synthesize-entry-counts\x00");
        }
        if (cmd.thread_model) |thread_model| {
            ptr = fmt.strcpyEqu(ptr, "--thread-model\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(thread_model));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.threads) |threads| {
            ptr = fmt.strcpyEqu(ptr, "--threads\x00");
            ptr = fmt.Ud64.write(ptr, threads);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.time_compilations) |time_compilations| {
            ptr = fmt.strcpyEqu(ptr, "--time-compilations\x00");
            ptr = fmt.Ud64.write(ptr, time_compilations);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.time_passes) {
            ptr = fmt.strcpyEqu(ptr, "--time-passes\x00");
        }
        if (cmd.time_passes_per_run) {
            ptr = fmt.strcpyEqu(ptr, "--time-passes-per-run\x00");
        }
        if (cmd.time_trace) {
            ptr = fmt.strcpyEqu(ptr, "--time-trace\x00");
        }
        if (cmd.time_trace_file) |time_trace_file| {
            ptr = fmt.strcpyEqu(ptr, "--time-trace-file\x00");
            ptr = fmt.strcpyEqu(ptr, time_trace_file);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.time_trace_granularity) |time_trace_granularity| {
            ptr = fmt.strcpyEqu(ptr, "--time-trace-granularity\x00");
            ptr = fmt.Ud64.write(ptr, time_trace_granularity);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tiny_trip_count_interleave_threshold) |tiny_trip_count_interleave_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--tiny-trip-count-interleave-threshold\x00");
            ptr = fmt.Ud64.write(ptr, tiny_trip_count_interleave_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.tls_load_hoist) {
            ptr = fmt.strcpyEqu(ptr, "--tls-load-hoist\x00");
        }
        if (cmd.tls_size) |tls_size| {
            ptr = fmt.strcpyEqu(ptr, "--tls-size\x00");
            ptr = fmt.Ud64.write(ptr, tls_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.trace_gv_placement) {
            ptr = fmt.strcpyEqu(ptr, "--trace-gv-placement\x00");
        }
        if (cmd.trace_hex_vector_stores_only) {
            ptr = fmt.strcpyEqu(ptr, "--trace-hex-vector-stores-only\x00");
        }
        if (cmd.track_memory) {
            ptr = fmt.strcpyEqu(ptr, "--track-memory\x00");
        }
        if (cmd.trap_func) |trap_func| {
            ptr = fmt.strcpyEqu(ptr, "--trap-func\x00");
            ptr = fmt.strcpyEqu(ptr, trap_func);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.trap_unreachable) {
            ptr = fmt.strcpyEqu(ptr, "--trap-unreachable\x00");
        }
        if (cmd.treat_scalable_fixed_error_as_warning) {
            ptr = fmt.strcpyEqu(ptr, "--treat-scalable-fixed-error-as-warning\x00");
        }
        if (cmd.triangle_chain_count) |triangle_chain_count| {
            ptr = fmt.strcpyEqu(ptr, "--triangle-chain-count\x00");
            ptr = fmt.Ud64.write(ptr, triangle_chain_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.trim_var_locs) {
            ptr = fmt.strcpyEqu(ptr, "--trim-var-locs\x00");
        }
        if (cmd.tsan_compound_read_before_write) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-compound-read-before-write\x00");
        }
        if (cmd.tsan_distinguish_volatile) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-distinguish-volatile\x00");
        }
        if (cmd.tsan_handle_cxx_exceptions) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-handle-cxx-exceptions\x00");
        }
        if (cmd.tsan_instrument_atomics) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-instrument-atomics\x00");
        }
        if (cmd.tsan_instrument_func_entry_exit) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-instrument-func-entry-exit\x00");
        }
        if (cmd.tsan_instrument_memintrinsics) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-instrument-memintrinsics\x00");
        }
        if (cmd.tsan_instrument_memory_accesses) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-instrument-memory-accesses\x00");
        }
        if (cmd.tsan_instrument_read_before_write) {
            ptr = fmt.strcpyEqu(ptr, "--tsan-instrument-read-before-write\x00");
        }
        if (cmd.two_entry_phi_node_folding_threshold) |two_entry_phi_node_folding_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--two-entry-phi-node-folding-threshold\x00");
            ptr = fmt.Ud64.write(ptr, two_entry_phi_node_folding_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.twoaddr_reschedule) {
            ptr = fmt.strcpyEqu(ptr, "--twoaddr-reschedule\x00");
        }
        if (cmd.type_based_intrinsic_cost) {
            ptr = fmt.strcpyEqu(ptr, "--type-based-intrinsic-cost\x00");
        }
        if (cmd.undef_reg_clearance) |undef_reg_clearance| {
            ptr = fmt.strcpyEqu(ptr, "--undef-reg-clearance\x00");
            ptr = fmt.Ud64.write(ptr, undef_reg_clearance);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unique_basic_block_section_names) {
            ptr = fmt.strcpyEqu(ptr, "--unique-basic-block-section-names\x00");
        }
        if (cmd.unique_section_names) {
            ptr = fmt.strcpyEqu(ptr, "--unique-section-names\x00");
        }
        if (cmd.unlikely_branch_weight) |unlikely_branch_weight| {
            ptr = fmt.strcpyEqu(ptr, "--unlikely-branch-weight\x00");
            ptr = fmt.Ud64.write(ptr, unlikely_branch_weight);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_allow_loop_nests_peeling) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-allow-loop-nests-peeling\x00");
        }
        if (cmd.unroll_allow_partial) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-allow-partial\x00");
        }
        if (cmd.unroll_allow_peeling) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-allow-peeling\x00");
        }
        if (cmd.unroll_allow_remainder) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-allow-remainder\x00");
        }
        if (cmd.unroll_and_jam_count) |unroll_and_jam_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-and-jam-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_and_jam_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_and_jam_threshold) |unroll_and_jam_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-and-jam-threshold\x00");
            ptr = fmt.Ud64.write(ptr, unroll_and_jam_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_count) |unroll_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_force_peel_count) |unroll_force_peel_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-force-peel-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_force_peel_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_full_max_count) |unroll_full_max_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-full-max-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_full_max_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_max_count) |unroll_max_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-max-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_max_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_max_iteration_count_to_analyze) |unroll_max_iteration_count_to_analyze| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-max-iteration-count-to-analyze\x00");
            ptr = fmt.Ud64.write(ptr, unroll_max_iteration_count_to_analyze);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_max_percent_threshold_boost) |unroll_max_percent_threshold_boost| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-max-percent-threshold-boost\x00");
            ptr = fmt.Ud64.write(ptr, unroll_max_percent_threshold_boost);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_max_upperbound) |unroll_max_upperbound| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-max-upperbound\x00");
            ptr = fmt.Ud64.write(ptr, unroll_max_upperbound);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_optsize_threshold) |unroll_optsize_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-optsize-threshold\x00");
            ptr = fmt.Ud64.write(ptr, unroll_optsize_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_partial_threshold) |unroll_partial_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-partial-threshold\x00");
            ptr = fmt.Ud64.write(ptr, unroll_partial_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_peel_count) |unroll_peel_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-peel-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_peel_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_peel_max_count) |unroll_peel_max_count| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-peel-max-count\x00");
            ptr = fmt.Ud64.write(ptr, unroll_peel_max_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_remainder) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-remainder\x00");
        }
        if (cmd.unroll_revisit_child_loops) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-revisit-child-loops\x00");
        }
        if (cmd.unroll_runtime) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-runtime\x00");
        }
        if (cmd.unroll_runtime_epilog) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-runtime-epilog\x00");
        }
        if (cmd.unroll_runtime_multi_exit) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-runtime-multi-exit\x00");
        }
        if (cmd.unroll_runtime_other_exit_predictable) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-runtime-other-exit-predictable\x00");
        }
        if (cmd.unroll_threshold) |unroll_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-threshold\x00");
            ptr = fmt.Ud64.write(ptr, unroll_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_threshold_aggressive) |unroll_threshold_aggressive| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-threshold-aggressive\x00");
            ptr = fmt.Ud64.write(ptr, unroll_threshold_aggressive);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_threshold_default) |unroll_threshold_default| {
            ptr = fmt.strcpyEqu(ptr, "--unroll-threshold-default\x00");
            ptr = fmt.Ud64.write(ptr, unroll_threshold_default);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unroll_verify_domtree) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-verify-domtree\x00");
        }
        if (cmd.unroll_verify_loopinfo) {
            ptr = fmt.strcpyEqu(ptr, "--unroll-verify-loopinfo\x00");
        }
        if (cmd.unswitch_num_initial_unscaled_candidates) |unswitch_num_initial_unscaled_candidates| {
            ptr = fmt.strcpyEqu(ptr, "--unswitch-num-initial-unscaled-candidates\x00");
            ptr = fmt.Ud64.write(ptr, unswitch_num_initial_unscaled_candidates);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unswitch_siblings_toplevel_div) |unswitch_siblings_toplevel_div| {
            ptr = fmt.strcpyEqu(ptr, "--unswitch-siblings-toplevel-div\x00");
            ptr = fmt.Ud64.write(ptr, unswitch_siblings_toplevel_div);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.unswitch_threshold) |unswitch_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--unswitch-threshold\x00");
            ptr = fmt.Ud64.write(ptr, unswitch_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.update_pseudo_probe) {
            ptr = fmt.strcpyEqu(ptr, "--update-pseudo-probe\x00");
        }
        if (cmd.update_return_attrs) {
            ptr = fmt.strcpyEqu(ptr, "--update-return-attrs\x00");
        }
        if (cmd.use_ctors) {
            ptr = fmt.strcpyEqu(ptr, "--use-ctors\x00");
        }
        if (cmd.use_dbg_addr) {
            ptr = fmt.strcpyEqu(ptr, "--use-dbg-addr\x00");
        }
        if (cmd.use_dereferenceable_at_point_semantics) |use_dereferenceable_at_point_semantics| {
            ptr = fmt.strcpyEqu(ptr, "--use-dereferenceable-at-point-semantics\x00");
            ptr = fmt.Ud64.write(ptr, use_dereferenceable_at_point_semantics);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.use_dwarf_ranges_base_address_specifier) {
            ptr = fmt.strcpyEqu(ptr, "--use-dwarf-ranges-base-address-specifier\x00");
        }
        if (cmd.use_gnu_debug_macro) {
            ptr = fmt.strcpyEqu(ptr, "--use-gnu-debug-macro\x00");
        }
        if (cmd.use_gpu_divergence_analysis) {
            ptr = fmt.strcpyEqu(ptr, "--use-gpu-divergence-analysis\x00");
        }
        if (cmd.use_iterative_bfi_inference) {
            ptr = fmt.strcpyEqu(ptr, "--use-iterative-bfi-inference\x00");
        }
        if (cmd.use_leb128_directives) {
            ptr = fmt.strcpyEqu(ptr, "--use-leb128-directives\x00");
        }
        if (cmd.use_lir_code_size_heurs) {
            ptr = fmt.strcpyEqu(ptr, "--use-lir-code-size-heurs\x00");
        }
        if (cmd.use_mbpi) {
            ptr = fmt.strcpyEqu(ptr, "--use-mbpi\x00");
        }
        if (cmd.use_newer_candidate) {
            ptr = fmt.strcpyEqu(ptr, "--use-newer-candidate\x00");
        }
        if (cmd.use_noalias_intrinsic_during_inlining) {
            ptr = fmt.strcpyEqu(ptr, "--use-noalias-intrinsic-during-inlining\x00");
        }
        if (cmd.use_profiled_call_graph) {
            ptr = fmt.strcpyEqu(ptr, "--use-profiled-call-graph\x00");
        }
        if (cmd.use_registers_for_deopt_values) {
            ptr = fmt.strcpyEqu(ptr, "--use-registers-for-deopt-values\x00");
        }
        if (cmd.use_registers_for_gc_values_in_landing_pad) {
            ptr = fmt.strcpyEqu(ptr, "--use-registers-for-gc-values-in-landing-pad\x00");
        }
        if (cmd.use_segment_set_for_physregs) {
            ptr = fmt.strcpyEqu(ptr, "--use-segment-set-for-physregs\x00");
        }
        if (cmd.use_source_filename_for_promoted_locals) {
            ptr = fmt.strcpyEqu(ptr, "--use-source-filename-for-promoted-locals\x00");
        }
        if (cmd.use_tbaa_in_sched_mi) {
            ptr = fmt.strcpyEqu(ptr, "--use-tbaa-in-sched-mi\x00");
        }
        if (cmd.use_unknown_locations) |use_unknown_locations| {
            ptr = fmt.strcpyEqu(ptr, "--use-unknown-locations\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(use_unknown_locations));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vec_extabi) {
            ptr = fmt.strcpyEqu(ptr, "--vec-extabi\x00");
        }
        if (cmd.vector_combine_max_scan_instrs) |vector_combine_max_scan_instrs| {
            ptr = fmt.strcpyEqu(ptr, "--vector-combine-max-scan-instrs\x00");
            ptr = fmt.Ud64.write(ptr, vector_combine_max_scan_instrs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vector_library) |vector_library| {
            ptr = fmt.strcpyEqu(ptr, "--vector-library\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(vector_library));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vectorize_loops) {
            ptr = fmt.strcpyEqu(ptr, "--vectorize-loops\x00");
        }
        if (cmd.vectorize_memory_check_threshold) |vectorize_memory_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--vectorize-memory-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, vectorize_memory_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vectorize_num_stores_pred) |vectorize_num_stores_pred| {
            ptr = fmt.strcpyEqu(ptr, "--vectorize-num-stores-pred\x00");
            ptr = fmt.Ud64.write(ptr, vectorize_num_stores_pred);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vectorize_scev_check_threshold) |vectorize_scev_check_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--vectorize-scev-check-threshold\x00");
            ptr = fmt.Ud64.write(ptr, vectorize_scev_check_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vectorize_slp) {
            ptr = fmt.strcpyEqu(ptr, "--vectorize-slp\x00");
        }
        if (cmd.vectorizer_maximize_bandwidth) {
            ptr = fmt.strcpyEqu(ptr, "--vectorizer-maximize-bandwidth\x00");
        }
        if (cmd.vectorizer_min_trip_count) |vectorizer_min_trip_count| {
            ptr = fmt.strcpyEqu(ptr, "--vectorizer-min-trip-count\x00");
            ptr = fmt.Ud64.write(ptr, vectorizer_min_trip_count);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.verify_arm_pseudo_expand) {
            ptr = fmt.strcpyEqu(ptr, "--verify-arm-pseudo-expand\x00");
        }
        if (cmd.verify_assumption_cache) {
            ptr = fmt.strcpyEqu(ptr, "--verify-assumption-cache\x00");
        }
        if (cmd.verify_cfg_preserved) {
            ptr = fmt.strcpyEqu(ptr, "--verify-cfg-preserved\x00");
        }
        if (cmd.verify_cfiinstrs) {
            ptr = fmt.strcpyEqu(ptr, "--verify-cfiinstrs\x00");
        }
        if (cmd.verify_coalescing) {
            ptr = fmt.strcpyEqu(ptr, "--verify-coalescing\x00");
        }
        if (cmd.verify_dom_info) {
            ptr = fmt.strcpyEqu(ptr, "--verify-dom-info\x00");
        }
        if (cmd.verify_indvars) {
            ptr = fmt.strcpyEqu(ptr, "--verify-indvars\x00");
        }
        if (cmd.verify_loop_info) {
            ptr = fmt.strcpyEqu(ptr, "--verify-loop-info\x00");
        }
        if (cmd.verify_loop_lcssa) {
            ptr = fmt.strcpyEqu(ptr, "--verify-loop-lcssa\x00");
        }
        if (cmd.verify_machine_dom_info) {
            ptr = fmt.strcpyEqu(ptr, "--verify-machine-dom-info\x00");
        }
        if (cmd.verify_machineinstrs) {
            ptr = fmt.strcpyEqu(ptr, "--verify-machineinstrs\x00");
        }
        if (cmd.verify_memoryssa) {
            ptr = fmt.strcpyEqu(ptr, "--verify-memoryssa\x00");
        }
        if (cmd.verify_misched) {
            ptr = fmt.strcpyEqu(ptr, "--verify-misched\x00");
        }
        if (cmd.verify_noalias_scope_decl_dom) {
            ptr = fmt.strcpyEqu(ptr, "--verify-noalias-scope-decl-dom\x00");
        }
        if (cmd.verify_predicateinfo) {
            ptr = fmt.strcpyEqu(ptr, "--verify-predicateinfo\x00");
        }
        if (cmd.verify_pseudo_probe) {
            ptr = fmt.strcpyEqu(ptr, "--verify-pseudo-probe\x00");
        }
        if (cmd.verify_pseudo_probe_funcs) |verify_pseudo_probe_funcs| {
            ptr = fmt.strcpyEqu(ptr, "--verify-pseudo-probe-funcs\x00");
            ptr = fmt.strcpyEqu(ptr, verify_pseudo_probe_funcs);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.verify_regalloc) {
            ptr = fmt.strcpyEqu(ptr, "--verify-regalloc\x00");
        }
        if (cmd.verify_region_info) {
            ptr = fmt.strcpyEqu(ptr, "--verify-region-info\x00");
        }
        if (cmd.verify_scev) {
            ptr = fmt.strcpyEqu(ptr, "--verify-scev\x00");
        }
        if (cmd.verify_scev_maps) {
            ptr = fmt.strcpyEqu(ptr, "--verify-scev-maps\x00");
        }
        if (cmd.verify_scev_strict) {
            ptr = fmt.strcpyEqu(ptr, "--verify-scev-strict\x00");
        }
        if (cmd.version) {
            ptr = fmt.strcpyEqu(ptr, "--version\x00");
        }
        if (cmd.vgpr_regalloc) |vgpr_regalloc| {
            ptr = fmt.strcpyEqu(ptr, "--vgpr-regalloc\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(vgpr_regalloc));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_bfi_func_name) |view_bfi_func_name| {
            ptr = fmt.strcpyEqu(ptr, "--view-bfi-func-name\x00");
            ptr = fmt.strcpyEqu(ptr, view_bfi_func_name);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_block_freq_propagation_dags) |view_block_freq_propagation_dags| {
            ptr = fmt.strcpyEqu(ptr, "--view-block-freq-propagation-dags\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(view_block_freq_propagation_dags));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_block_layout_with_bfi) |view_block_layout_with_bfi| {
            ptr = fmt.strcpyEqu(ptr, "--view-block-layout-with-bfi\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(view_block_layout_with_bfi));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_edge_bundles) {
            ptr = fmt.strcpyEqu(ptr, "--view-edge-bundles\x00");
        }
        if (cmd.view_hot_freq_percent) |view_hot_freq_percent| {
            ptr = fmt.strcpyEqu(ptr, "--view-hot-freq-percent\x00");
            ptr = fmt.Ud64.write(ptr, view_hot_freq_percent);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_machine_block_freq_propagation_dags) |view_machine_block_freq_propagation_dags| {
            ptr = fmt.strcpyEqu(ptr, "--view-machine-block-freq-propagation-dags\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(view_machine_block_freq_propagation_dags));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.view_slp_tree) {
            ptr = fmt.strcpyEqu(ptr, "--view-slp-tree\x00");
        }
        if (cmd.vliw_misched_reg_pressure) |vliw_misched_reg_pressure| {
            ptr = fmt.strcpyEqu(ptr, "--vliw-misched-reg-pressure\x00");
            ptr = fmt.Ud64.write(ptr, vliw_misched_reg_pressure);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vp_counters_per_site) |vp_counters_per_site| {
            ptr = fmt.strcpyEqu(ptr, "--vp-counters-per-site\x00");
            ptr = fmt.Ud64.write(ptr, vp_counters_per_site);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.vp_static_alloc) {
            ptr = fmt.strcpyEqu(ptr, "--vp-static-alloc\x00");
        }
        if (cmd.vplan_build_stress_test) {
            ptr = fmt.strcpyEqu(ptr, "--vplan-build-stress-test\x00");
        }
        if (cmd.vplan_print_in_dot_format) {
            ptr = fmt.strcpyEqu(ptr, "--vplan-print-in-dot-format\x00");
        }
        if (cmd.vplan_verify_hcfg) {
            ptr = fmt.strcpyEqu(ptr, "--vplan-verify-hcfg\x00");
        }
        if (cmd.wasm_disable_explicit_locals) {
            ptr = fmt.strcpyEqu(ptr, "--wasm-disable-explicit-locals\x00");
        }
        if (cmd.wasm_enable_eh) {
            ptr = fmt.strcpyEqu(ptr, "--wasm-enable-eh\x00");
        }
        if (cmd.wasm_enable_sjlj) {
            ptr = fmt.strcpyEqu(ptr, "--wasm-enable-sjlj\x00");
        }
        if (cmd.wasm_keep_registers) {
            ptr = fmt.strcpyEqu(ptr, "--wasm-keep-registers\x00");
        }
        if (cmd.whole_program_visibility) {
            ptr = fmt.strcpyEqu(ptr, "--whole-program-visibility\x00");
        }
        if (cmd.wholeprogramdevirt_branch_funnel_threshold) |wholeprogramdevirt_branch_funnel_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-branch-funnel-threshold\x00");
            ptr = fmt.Ud64.write(ptr, wholeprogramdevirt_branch_funnel_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.wholeprogramdevirt_check) |wholeprogramdevirt_check| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-check\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(wholeprogramdevirt_check));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.wholeprogramdevirt_print_index_based) {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-print-index-based\x00");
        }
        if (cmd.wholeprogramdevirt_read_summary) |wholeprogramdevirt_read_summary| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-read-summary\x00");
            ptr = fmt.strcpyEqu(ptr, wholeprogramdevirt_read_summary);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.wholeprogramdevirt_skip) |wholeprogramdevirt_skip| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-skip\x00");
            ptr = fmt.strcpyEqu(ptr, wholeprogramdevirt_skip);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.wholeprogramdevirt_summary_action) |wholeprogramdevirt_summary_action| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-summary-action\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(wholeprogramdevirt_summary_action));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.wholeprogramdevirt_write_summary) |wholeprogramdevirt_write_summary| {
            ptr = fmt.strcpyEqu(ptr, "--wholeprogramdevirt-write-summary\x00");
            ptr = fmt.strcpyEqu(ptr, wholeprogramdevirt_write_summary);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.write_relbf_to_summary) {
            ptr = fmt.strcpyEqu(ptr, "--write-relbf-to-summary\x00");
        }
        if (cmd.x86_align_branch) |x86_align_branch| {
            ptr = fmt.strcpyEqu(ptr, "--x86-align-branch\x00");
            ptr = fmt.strcpyEqu(ptr, x86_align_branch);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_align_branch_boundary) |x86_align_branch_boundary| {
            ptr = fmt.strcpyEqu(ptr, "--x86-align-branch-boundary\x00");
            ptr = fmt.Ud64.write(ptr, x86_align_branch_boundary);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_and_imm_shrink) {
            ptr = fmt.strcpyEqu(ptr, "--x86-and-imm-shrink\x00");
        }
        if (cmd.x86_asm_syntax) |x86_asm_syntax| {
            ptr = fmt.strcpyEqu(ptr, "--x86-asm-syntax\x00");
            ptr = fmt.strcpyEqu(ptr, @tagName(x86_asm_syntax));
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_branches_within_32B_boundaries) {
            ptr = fmt.strcpyEqu(ptr, "--x86-branches-within-32B-boundaries\x00");
        }
        if (cmd.x86_bypass_prefetch_instructions) {
            ptr = fmt.strcpyEqu(ptr, "--x86-bypass-prefetch-instructions\x00");
        }
        if (cmd.x86_cmov_converter) {
            ptr = fmt.strcpyEqu(ptr, "--x86-cmov-converter\x00");
        }
        if (cmd.x86_cmov_converter_force_all) {
            ptr = fmt.strcpyEqu(ptr, "--x86-cmov-converter-force-all\x00");
        }
        if (cmd.x86_cmov_converter_force_mem_operand) {
            ptr = fmt.strcpyEqu(ptr, "--x86-cmov-converter-force-mem-operand\x00");
        }
        if (cmd.x86_cmov_converter_threshold) |x86_cmov_converter_threshold| {
            ptr = fmt.strcpyEqu(ptr, "--x86-cmov-converter-threshold\x00");
            ptr = fmt.Ud64.write(ptr, x86_cmov_converter_threshold);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_disable_avoid_SFB) {
            ptr = fmt.strcpyEqu(ptr, "--x86-disable-avoid-SFB\x00");
        }
        if (cmd.x86_discriminate_memops) {
            ptr = fmt.strcpyEqu(ptr, "--x86-discriminate-memops\x00");
        }
        if (cmd.x86_early_ifcvt) {
            ptr = fmt.strcpyEqu(ptr, "--x86-early-ifcvt\x00");
        }
        if (cmd.x86_experimental_lvi_inline_asm_hardening) {
            ptr = fmt.strcpyEqu(ptr, "--x86-experimental-lvi-inline-asm-hardening\x00");
        }
        if (cmd.x86_experimental_pref_innermost_loop_alignment) |x86_experimental_pref_innermost_loop_alignment| {
            ptr = fmt.strcpyEqu(ptr, "--x86-experimental-pref-innermost-loop-alignment\x00");
            ptr = fmt.Ud64.write(ptr, x86_experimental_pref_innermost_loop_alignment);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_experimental_unordered_atomic_isel) {
            ptr = fmt.strcpyEqu(ptr, "--x86-experimental-unordered-atomic-isel\x00");
        }
        if (cmd.x86_indirect_branch_tracking) {
            ptr = fmt.strcpyEqu(ptr, "--x86-indirect-branch-tracking\x00");
        }
        if (cmd.x86_lvi_load_dot) {
            ptr = fmt.strcpyEqu(ptr, "--x86-lvi-load-dot\x00");
        }
        if (cmd.x86_lvi_load_dot_only) {
            ptr = fmt.strcpyEqu(ptr, "--x86-lvi-load-dot-only\x00");
        }
        if (cmd.x86_lvi_load_dot_verify) {
            ptr = fmt.strcpyEqu(ptr, "--x86-lvi-load-dot-verify\x00");
        }
        if (cmd.x86_lvi_load_no_cbranch) {
            ptr = fmt.strcpyEqu(ptr, "--x86-lvi-load-no-cbranch\x00");
        }
        if (cmd.x86_lvi_load_opt_plugin) |x86_lvi_load_opt_plugin| {
            ptr = fmt.strcpyEqu(ptr, "--x86-lvi-load-opt-plugin\x00");
            ptr = fmt.strcpyEqu(ptr, x86_lvi_load_opt_plugin);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_machine_combiner) {
            ptr = fmt.strcpyEqu(ptr, "--x86-machine-combiner\x00");
        }
        if (cmd.x86_pad_for_align) {
            ptr = fmt.strcpyEqu(ptr, "--x86-pad-for-align\x00");
        }
        if (cmd.x86_pad_for_branch_align) {
            ptr = fmt.strcpyEqu(ptr, "--x86-pad-for-branch-align\x00");
        }
        if (cmd.x86_pad_max_prefix_size) |x86_pad_max_prefix_size| {
            ptr = fmt.strcpyEqu(ptr, "--x86-pad-max-prefix-size\x00");
            ptr = fmt.Ud64.write(ptr, x86_pad_max_prefix_size);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_promote_anyext_load) {
            ptr = fmt.strcpyEqu(ptr, "--x86-promote-anyext-load\x00");
        }
        if (cmd.x86_seses_enable_without_lvi_cfi) {
            ptr = fmt.strcpyEqu(ptr, "--x86-seses-enable-without-lvi-cfi\x00");
        }
        if (cmd.x86_seses_omit_branch_lfences) {
            ptr = fmt.strcpyEqu(ptr, "--x86-seses-omit-branch-lfences\x00");
        }
        if (cmd.x86_seses_one_lfence_per_bb) {
            ptr = fmt.strcpyEqu(ptr, "--x86-seses-one-lfence-per-bb\x00");
        }
        if (cmd.x86_seses_only_lfence_non_const) {
            ptr = fmt.strcpyEqu(ptr, "--x86-seses-only-lfence-non-const\x00");
        }
        if (cmd.x86_sfb_inspection_limit) |x86_sfb_inspection_limit| {
            ptr = fmt.strcpyEqu(ptr, "--x86-sfb-inspection-limit\x00");
            ptr = fmt.Ud64.write(ptr, x86_sfb_inspection_limit);
            ptr[0] = 0;
            ptr += 1;
        }
        if (cmd.x86_slh_fence_call_and_ret) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-fence-call-and-ret\x00");
        }
        if (cmd.x86_slh_indirect) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-indirect\x00");
        }
        if (cmd.x86_slh_ip) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-ip\x00");
        }
        if (cmd.x86_slh_lfence) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-lfence\x00");
        }
        if (cmd.x86_slh_loads) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-loads\x00");
        }
        if (cmd.x86_slh_post_load) {
            ptr = fmt.strcpyEqu(ptr, "--x86-slh-post-load\x00");
        }
        if (cmd.x86_speculative_load_hardening) {
            ptr = fmt.strcpyEqu(ptr, "--x86-speculative-load-hardening\x00");
        }
        if (cmd.x86_tile_ra) {
            ptr = fmt.strcpyEqu(ptr, "--x86-tile-ra\x00");
        }
        if (cmd.x86_use_base_pointer) {
            ptr = fmt.strcpyEqu(ptr, "--x86-use-base-pointer\x00");
        }
        if (cmd.x86_use_fsrm_for_memcpy) {
            ptr = fmt.strcpyEqu(ptr, "--x86-use-fsrm-for-memcpy\x00");
        }
        if (cmd.x86_use_vzeroupper) {
            ptr = fmt.strcpyEqu(ptr, "--x86-use-vzeroupper\x00");
        }
        if (cmd.xcoff_traceback_table) {
            ptr = fmt.strcpyEqu(ptr, "--xcoff-traceback-table\x00");
        }
        if (cmd.xcore_max_threads) |xcore_max_threads| {
            ptr = fmt.strcpyEqu(ptr, "--xcore-max-threads\x00");
            ptr = fmt.Ud64.write(ptr, xcore_max_threads);
            ptr[0] = 0;
            ptr += 1;
        }
        return @intFromPtr(ptr) -% @intFromPtr(buf);
    }
    pub fn formatLength(cmd: *LLCCommand, llc_exe: []const u8) usize {
        @setRuntimeSafety(false);
        var len: usize = 1 +% llc_exe.len;
        if (cmd.aarch64_a57_fp_load_balancing_force_all) {
            len +%= 42;
        }
        if (cmd.aarch64_a57_fp_load_balancing_override) |aarch64_a57_fp_load_balancing_override| {
            len +%= 42 +% fmt.Ud64.length(aarch64_a57_fp_load_balancing_override);
        }
        if (cmd.aarch64_bcc_offset_bits) |aarch64_bcc_offset_bits| {
            len +%= 27 +% fmt.Ud64.length(aarch64_bcc_offset_bits);
        }
        if (cmd.aarch64_cbz_offset_bits) |aarch64_cbz_offset_bits| {
            len +%= 27 +% fmt.Ud64.length(aarch64_cbz_offset_bits);
        }
        if (cmd.aarch64_ccmp_limit) |aarch64_ccmp_limit| {
            len +%= 22 +% fmt.Ud64.length(aarch64_ccmp_limit);
        }
        if (cmd.aarch64_early_ifcvt) {
            len +%= 22;
        }
        if (cmd.aarch64_elf_ldtls_generation) {
            len +%= 31;
        }
        if (cmd.aarch64_enable_atomic_cfg_tidy) {
            len +%= 33;
        }
        if (cmd.aarch64_enable_branch_relax) {
            len +%= 30;
        }
        if (cmd.aarch64_enable_branch_targets) {
            len +%= 32;
        }
        if (cmd.aarch64_enable_ccmp) {
            len +%= 22;
        }
        if (cmd.aarch64_enable_collect_loh) {
            len +%= 29;
        }
        if (cmd.aarch64_enable_compress_jump_tables) {
            len +%= 38;
        }
        if (cmd.aarch64_enable_cond_br_tune) {
            len +%= 30;
        }
        if (cmd.aarch64_enable_condopt) {
            len +%= 25;
        }
        if (cmd.aarch64_enable_copy_propagation) {
            len +%= 34;
        }
        if (cmd.aarch64_enable_copyelim) {
            len +%= 26;
        }
        if (cmd.aarch64_enable_dead_defs) {
            len +%= 27;
        }
        if (cmd.aarch64_enable_early_ifcvt) {
            len +%= 29;
        }
        if (cmd.aarch64_enable_falkor_hwpf_fix) {
            len +%= 33;
        }
        if (cmd.aarch64_enable_gep_opt) {
            len +%= 25;
        }
        if (cmd.aarch64_enable_gisel_ldst_postlegal) {
            len +%= 38;
        }
        if (cmd.aarch64_enable_gisel_ldst_prelegal) {
            len +%= 37;
        }
        if (cmd.aarch64_enable_global_isel_at_O) |aarch64_enable_global_isel_at_O| {
            len +%= 35 +% fmt.Ud64.length(aarch64_enable_global_isel_at_O);
        }
        if (cmd.aarch64_enable_global_merge) {
            len +%= 30;
        }
        if (cmd.aarch64_enable_ldst_opt) {
            len +%= 26;
        }
        if (cmd.aarch64_enable_logical_imm) {
            len +%= 29;
        }
        if (cmd.aarch64_enable_loop_data_prefetch) {
            len +%= 36;
        }
        if (cmd.aarch64_enable_mcr) {
            len +%= 21;
        }
        if (cmd.aarch64_enable_mgather_combine) {
            len +%= 33;
        }
        if (cmd.aarch64_enable_nonlazybind) {
            len +%= 29;
        }
        if (cmd.aarch64_enable_promote_const) {
            len +%= 31;
        }
        if (cmd.aarch64_enable_simd_scalar) {
            len +%= 29;
        }
        if (cmd.aarch64_enable_stp_suppress) {
            len +%= 30;
        }
        if (cmd.aarch64_enable_sve_intrinsic_opts) {
            len +%= 36;
        }
        if (cmd.aarch64_insert_extract_base_cost) |aarch64_insert_extract_base_cost| {
            len +%= 36 +% fmt.Ud64.length(aarch64_insert_extract_base_cost);
        }
        if (cmd.aarch64_load_store_renaming) {
            len +%= 30;
        }
        if (cmd.aarch64_load_store_scan_limit) |aarch64_load_store_scan_limit| {
            len +%= 33 +% fmt.Ud64.length(aarch64_load_store_scan_limit);
        }
        if (cmd.aarch64_mark_bti_property) {
            len +%= 28;
        }
        if (cmd.aarch64_max_xors) |aarch64_max_xors| {
            len +%= 20 +% fmt.Ud64.length(aarch64_max_xors);
        }
        if (cmd.aarch64_neon_syntax) |aarch64_neon_syntax| {
            len +%= 23 +% @tagName(aarch64_neon_syntax).len;
        }
        if (cmd.aarch64_order_frame_objects) {
            len +%= 30;
        }
        if (cmd.aarch64_redzone) {
            len +%= 18;
        }
        if (cmd.aarch64_select_opt) {
            len +%= 21;
        }
        if (cmd.aarch64_simd_scalar_force_all) {
            len +%= 32;
        }
        if (cmd.aarch64_slh_loads) {
            len +%= 20;
        }
        if (cmd.aarch64_stress_ccmp) {
            len +%= 22;
        }
        if (cmd.aarch64_stress_promote_const) {
            len +%= 31;
        }
        if (cmd.aarch64_sve_vector_bits_max) |aarch64_sve_vector_bits_max| {
            len +%= 31 +% fmt.Ud64.length(aarch64_sve_vector_bits_max);
        }
        if (cmd.aarch64_sve_vector_bits_min) |aarch64_sve_vector_bits_min| {
            len +%= 31 +% fmt.Ud64.length(aarch64_sve_vector_bits_min);
        }
        if (cmd.aarch64_tbz_offset_bits) |aarch64_tbz_offset_bits| {
            len +%= 27 +% fmt.Ud64.length(aarch64_tbz_offset_bits);
        }
        if (cmd.aarch64_update_scan_limit) |aarch64_update_scan_limit| {
            len +%= 29 +% fmt.Ud64.length(aarch64_update_scan_limit);
        }
        if (cmd.aarch64_use_aa) {
            len +%= 17;
        }
        if (cmd.aarch64_use_tbi) {
            len +%= 18;
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_disable_rule) |aarch64o0prelegalizercombinerhelper_disable_rule| {
            len +%= 52 +% aarch64o0prelegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_only_enable_rule) |aarch64o0prelegalizercombinerhelper_only_enable_rule| {
            len +%= 56 +% aarch64o0prelegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.aarch64postlegalizercombinerhelper_disable_rule) |aarch64postlegalizercombinerhelper_disable_rule| {
            len +%= 51 +% aarch64postlegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.aarch64postlegalizercombinerhelper_only_enable_rule) |aarch64postlegalizercombinerhelper_only_enable_rule| {
            len +%= 55 +% aarch64postlegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.aarch64postlegalizerloweringhelper_disable_rule) |aarch64postlegalizerloweringhelper_disable_rule| {
            len +%= 51 +% aarch64postlegalizerloweringhelper_disable_rule.len;
        }
        if (cmd.aarch64postlegalizerloweringhelper_only_enable_rule) |aarch64postlegalizerloweringhelper_only_enable_rule| {
            len +%= 55 +% aarch64postlegalizerloweringhelper_only_enable_rule.len;
        }
        if (cmd.aarch64prelegalizercombinerhelper_disable_rule) |aarch64prelegalizercombinerhelper_disable_rule| {
            len +%= 50 +% aarch64prelegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.aarch64prelegalizercombinerhelper_only_enable_rule) |aarch64prelegalizercombinerhelper_only_enable_rule| {
            len +%= 54 +% aarch64prelegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.abort_on_max_devirt_iterations_reached) {
            len +%= 41;
        }
        if (cmd.accel_tables) |accel_tables| {
            len +%= 16 +% @tagName(accel_tables).len;
        }
        if (cmd.adce_remove_control_flow) {
            len +%= 27;
        }
        if (cmd.adce_remove_loops) {
            len +%= 20;
        }
        if (cmd.addr_sink_combine_base_gv) {
            len +%= 28;
        }
        if (cmd.addr_sink_combine_base_offs) {
            len +%= 30;
        }
        if (cmd.addr_sink_combine_base_reg) {
            len +%= 29;
        }
        if (cmd.addr_sink_combine_scaled_reg) {
            len +%= 31;
        }
        if (cmd.addr_sink_new_phis) {
            len +%= 21;
        }
        if (cmd.addr_sink_new_select) {
            len +%= 23;
        }
        if (cmd.addr_sink_using_gep) {
            len +%= 22;
        }
        if (cmd.addrsig) {
            len +%= 10;
        }
        if (cmd.agg_antidep_debugdiv) |agg_antidep_debugdiv| {
            len +%= 24 +% fmt.Ud64.length(agg_antidep_debugdiv);
        }
        if (cmd.agg_antidep_debugmod) |agg_antidep_debugmod| {
            len +%= 24 +% fmt.Ud64.length(agg_antidep_debugmod);
        }
        if (cmd.aggregate_extracted_args) {
            len +%= 27;
        }
        if (cmd.aggressive_ext_opt) {
            len +%= 21;
        }
        if (cmd.aggressive_instcombine_max_scan_instrs) |aggressive_instcombine_max_scan_instrs| {
            len +%= 42 +% fmt.Ud64.length(aggressive_instcombine_max_scan_instrs);
        }
        if (cmd.aix_ssp_tb_bit) {
            len +%= 17;
        }
        if (cmd.alias_set_saturation_threshold) |alias_set_saturation_threshold| {
            len +%= 34 +% fmt.Ud64.length(alias_set_saturation_threshold);
        }
        if (cmd.align_all_blocks) |align_all_blocks| {
            len +%= 20 +% fmt.Ud64.length(align_all_blocks);
        }
        if (cmd.align_all_functions) |align_all_functions| {
            len +%= 23 +% fmt.Ud64.length(align_all_functions);
        }
        if (cmd.align_all_nofallthru_blocks) |align_all_nofallthru_blocks| {
            len +%= 31 +% fmt.Ud64.length(align_all_nofallthru_blocks);
        }
        if (cmd.align_loops) |align_loops| {
            len +%= 15 +% fmt.Ud64.length(align_loops);
        }
        if (cmd.align_neon_spills) {
            len +%= 20;
        }
        if (cmd.allow_arm_wlsloops) {
            len +%= 21;
        }
        if (cmd.allow_ginsert_as_artifact) {
            len +%= 28;
        }
        if (cmd.allow_unroll_and_jam) {
            len +%= 23;
        }
        if (cmd.amdgcn_skip_cache_invalidations) {
            len +%= 34;
        }
        if (cmd.amdgpu_any_address_space_out_arguments) {
            len +%= 41;
        }
        if (cmd.amdgpu_assume_dynamic_stack_object_size) |amdgpu_assume_dynamic_stack_object_size| {
            len +%= 43 +% fmt.Ud64.length(amdgpu_assume_dynamic_stack_object_size);
        }
        if (cmd.amdgpu_assume_external_call_stack_size) |amdgpu_assume_external_call_stack_size| {
            len +%= 42 +% fmt.Ud64.length(amdgpu_assume_external_call_stack_size);
        }
        if (cmd.amdgpu_atomic_optimizations) {
            len +%= 30;
        }
        if (cmd.amdgpu_bypass_slow_div) {
            len +%= 25;
        }
        if (cmd.amdgpu_dce_in_ra) {
            len +%= 19;
        }
        if (cmd.amdgpu_disable_loop_alignment) {
            len +%= 32;
        }
        if (cmd.amdgpu_disable_unclustred_high_rp_reschedule) {
            len +%= 47;
        }
        if (cmd.amdgpu_dpp_combine) {
            len +%= 21;
        }
        if (cmd.amdgpu_dump_hsa_metadata) {
            len +%= 27;
        }
        if (cmd.amdgpu_early_ifcvt) {
            len +%= 21;
        }
        if (cmd.amdgpu_early_inline_all) {
            len +%= 26;
        }
        if (cmd.amdgpu_enable_delay_alu) {
            len +%= 26;
        }
        if (cmd.amdgpu_enable_lds_replace_with_pointer) {
            len +%= 41;
        }
        if (cmd.amdgpu_enable_lower_module_lds) {
            len +%= 33;
        }
        if (cmd.amdgpu_enable_max_ilp_scheduling_strategy) {
            len +%= 44;
        }
        if (cmd.amdgpu_enable_merge_m0) {
            len +%= 25;
        }
        if (cmd.amdgpu_enable_power_sched) {
            len +%= 28;
        }
        if (cmd.amdgpu_enable_pre_ra_optimizations) {
            len +%= 37;
        }
        if (cmd.amdgpu_enable_promote_kernel_arguments) {
            len +%= 41;
        }
        if (cmd.amdgpu_enable_structurizer_workarounds) {
            len +%= 41;
        }
        if (cmd.amdgpu_enable_vopd) {
            len +%= 21;
        }
        if (cmd.amdgpu_function_calls) {
            len +%= 24;
        }
        if (cmd.amdgpu_igrouplp_exact_solver) {
            len +%= 31;
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cost_heur) {
            len +%= 41;
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cutoff) |amdgpu_igrouplp_exact_solver_cutoff| {
            len +%= 39 +% fmt.Ud64.length(amdgpu_igrouplp_exact_solver_cutoff);
        }
        if (cmd.amdgpu_igrouplp_exact_solver_max_branches) |amdgpu_igrouplp_exact_solver_max_branches| {
            len +%= 45 +% fmt.Ud64.length(amdgpu_igrouplp_exact_solver_max_branches);
        }
        if (cmd.amdgpu_indirect_access_weight) |amdgpu_indirect_access_weight| {
            len +%= 33 +% fmt.Ud64.length(amdgpu_indirect_access_weight);
        }
        if (cmd.amdgpu_inline_arg_alloca_cost) |amdgpu_inline_arg_alloca_cost| {
            len +%= 33 +% fmt.Ud64.length(amdgpu_inline_arg_alloca_cost);
        }
        if (cmd.amdgpu_inline_arg_alloca_cutoff) |amdgpu_inline_arg_alloca_cutoff| {
            len +%= 35 +% fmt.Ud64.length(amdgpu_inline_arg_alloca_cutoff);
        }
        if (cmd.amdgpu_inline_max_bb) |amdgpu_inline_max_bb| {
            len +%= 24 +% fmt.Ud64.length(amdgpu_inline_max_bb);
        }
        if (cmd.amdgpu_internalize_symbols) {
            len +%= 29;
        }
        if (cmd.amdgpu_ir_lower_kernel_arguments) {
            len +%= 35;
        }
        if (cmd.amdgpu_large_stride_threshold) |amdgpu_large_stride_threshold| {
            len +%= 33 +% fmt.Ud64.length(amdgpu_large_stride_threshold);
        }
        if (cmd.amdgpu_large_stride_weight) |amdgpu_large_stride_weight| {
            len +%= 30 +% fmt.Ud64.length(amdgpu_large_stride_weight);
        }
        if (cmd.amdgpu_late_structurize) {
            len +%= 26;
        }
        if (cmd.amdgpu_limit_wave_threshold) |amdgpu_limit_wave_threshold| {
            len +%= 31 +% fmt.Ud64.length(amdgpu_limit_wave_threshold);
        }
        if (cmd.amdgpu_load_store_vectorizer) {
            len +%= 31;
        }
        if (cmd.amdgpu_lower_module_lds_strategy) |amdgpu_lower_module_lds_strategy| {
            len +%= 36 +% @tagName(amdgpu_lower_module_lds_strategy).len;
        }
        if (cmd.amdgpu_max_memory_clause) |amdgpu_max_memory_clause| {
            len +%= 28 +% fmt.Ud64.length(amdgpu_max_memory_clause);
        }
        if (cmd.amdgpu_max_return_arg_num_regs) |amdgpu_max_return_arg_num_regs| {
            len +%= 34 +% fmt.Ud64.length(amdgpu_max_return_arg_num_regs);
        }
        if (cmd.amdgpu_mem_intrinsic_expand_size) |amdgpu_mem_intrinsic_expand_size| {
            len +%= 36 +% fmt.Ud64.length(amdgpu_mem_intrinsic_expand_size);
        }
        if (cmd.amdgpu_membound_threshold) |amdgpu_membound_threshold| {
            len +%= 29 +% fmt.Ud64.length(amdgpu_membound_threshold);
        }
        if (cmd.amdgpu_mfma_padding_ratio) |amdgpu_mfma_padding_ratio| {
            len +%= 29 +% fmt.Ud64.length(amdgpu_mfma_padding_ratio);
        }
        if (cmd.amdgpu_mode_register) {
            len +%= 23;
        }
        if (cmd.amdgpu_nsa_threshold) |amdgpu_nsa_threshold| {
            len +%= 24 +% fmt.Ud64.length(amdgpu_nsa_threshold);
        }
        if (cmd.amdgpu_opt_exec_mask_pre_ra) {
            len +%= 30;
        }
        if (cmd.amdgpu_opt_vgpr_liverange) {
            len +%= 28;
        }
        if (cmd.amdgpu_prelink) {
            len +%= 17;
        }
        if (cmd.amdgpu_promote_alloca_to_vector_limit) |amdgpu_promote_alloca_to_vector_limit| {
            len +%= 41 +% fmt.Ud64.length(amdgpu_promote_alloca_to_vector_limit);
        }
        if (cmd.amdgpu_reassign_regs) {
            len +%= 23;
        }
        if (cmd.amdgpu_scalar_ir_passes) {
            len +%= 26;
        }
        if (cmd.amdgpu_scalarize_global_loads) {
            len +%= 32;
        }
        if (cmd.amdgpu_schedule_metric_bias) |amdgpu_schedule_metric_bias| {
            len +%= 31 +% fmt.Ud64.length(amdgpu_schedule_metric_bias);
        }
        if (cmd.amdgpu_sdwa_peephole) {
            len +%= 23;
        }
        if (cmd.amdgpu_set_wave_priority) {
            len +%= 27;
        }
        if (cmd.amdgpu_set_wave_priority_valu_insts_threshold) |amdgpu_set_wave_priority_valu_insts_threshold| {
            len +%= 49 +% fmt.Ud64.length(amdgpu_set_wave_priority_valu_insts_threshold);
        }
        if (cmd.amdgpu_simplify_libcall) {
            len +%= 26;
        }
        if (cmd.amdgpu_skip_threshold) |amdgpu_skip_threshold| {
            len +%= 25 +% fmt.Ud64.length(amdgpu_skip_threshold);
        }
        if (cmd.amdgpu_stress_function_calls) {
            len +%= 31;
        }
        if (cmd.amdgpu_super_align_lds_globals) {
            len +%= 33;
        }
        if (cmd.amdgpu_unroll_max_block_to_analyze) |amdgpu_unroll_max_block_to_analyze| {
            len +%= 38 +% fmt.Ud64.length(amdgpu_unroll_max_block_to_analyze);
        }
        if (cmd.amdgpu_unroll_runtime_local) {
            len +%= 30;
        }
        if (cmd.amdgpu_unroll_threshold_if) |amdgpu_unroll_threshold_if| {
            len +%= 30 +% fmt.Ud64.length(amdgpu_unroll_threshold_if);
        }
        if (cmd.amdgpu_unroll_threshold_local) |amdgpu_unroll_threshold_local| {
            len +%= 33 +% fmt.Ud64.length(amdgpu_unroll_threshold_local);
        }
        if (cmd.amdgpu_unroll_threshold_private) |amdgpu_unroll_threshold_private| {
            len +%= 35 +% fmt.Ud64.length(amdgpu_unroll_threshold_private);
        }
        if (cmd.amdgpu_use_aa_in_codegen) {
            len +%= 27;
        }
        if (cmd.amdgpu_use_divergent_register_indexing) {
            len +%= 41;
        }
        if (cmd.amdgpu_use_legacy_divergence_analysis) {
            len +%= 40;
        }
        if (cmd.amdgpu_use_native) |amdgpu_use_native| {
            len +%= 21 +% amdgpu_use_native.len;
        }
        if (cmd.amdgpu_verify_hsa_metadata) {
            len +%= 29;
        }
        if (cmd.amdgpu_vgpr_index_mode) {
            len +%= 25;
        }
        if (cmd.amdgpu_waitcnt_forcezero) {
            len +%= 27;
        }
        if (cmd.amdgpupostlegalizercombinerhelper_disable_rule) |amdgpupostlegalizercombinerhelper_disable_rule| {
            len +%= 50 +% amdgpupostlegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.amdgpupostlegalizercombinerhelper_only_enable_rule) |amdgpupostlegalizercombinerhelper_only_enable_rule| {
            len +%= 54 +% amdgpupostlegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.amdgpuprelegalizercombinerhelper_disable_rule) |amdgpuprelegalizercombinerhelper_disable_rule| {
            len +%= 49 +% amdgpuprelegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.amdgpuprelegalizercombinerhelper_only_enable_rule) |amdgpuprelegalizercombinerhelper_only_enable_rule| {
            len +%= 53 +% amdgpuprelegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.amdgpuregbankcombinerhelper_disable_rule) |amdgpuregbankcombinerhelper_disable_rule| {
            len +%= 44 +% amdgpuregbankcombinerhelper_disable_rule.len;
        }
        if (cmd.amdgpuregbankcombinerhelper_only_enable_rule) |amdgpuregbankcombinerhelper_only_enable_rule| {
            len +%= 48 +% amdgpuregbankcombinerhelper_only_enable_rule.len;
        }
        if (cmd.amdhsa_code_object_version) |amdhsa_code_object_version| {
            len +%= 30 +% fmt.Ud64.length(amdhsa_code_object_version);
        }
        if (cmd.annotate_inline_phase) {
            len +%= 24;
        }
        if (cmd.annotate_sample_profile_inline_phase) {
            len +%= 39;
        }
        if (cmd.arc_opt_max_ptr_states) |arc_opt_max_ptr_states| {
            len +%= 26 +% fmt.Ud64.length(arc_opt_max_ptr_states);
        }
        if (cmd.arm_add_build_attributes) {
            len +%= 27;
        }
        if (cmd.arm_adjust_jump_tables) {
            len +%= 25;
        }
        if (cmd.arm_assume_itcm_bankconflict) {
            len +%= 31;
        }
        if (cmd.arm_assume_misaligned_load_store) {
            len +%= 35;
        }
        if (cmd.arm_atomic_cfg_tidy) {
            len +%= 22;
        }
        if (cmd.arm_constant_island_max_iteration) |arm_constant_island_max_iteration| {
            len +%= 37 +% fmt.Ud64.length(arm_constant_island_max_iteration);
        }
        if (cmd.arm_data_bank_mask) |arm_data_bank_mask| {
            len +%= 22 +% fmt.Ud64.length(arm_data_bank_mask);
        }
        if (cmd.arm_disable_omit_dls) {
            len +%= 23;
        }
        if (cmd.arm_enable_merge_loopenddec) {
            len +%= 30;
        }
        if (cmd.arm_enable_subreg_liveness) {
            len +%= 29;
        }
        if (cmd.arm_force_fast_isel) {
            len +%= 22;
        }
        if (cmd.arm_global_merge) {
            len +%= 19;
        }
        if (cmd.arm_implicit_it) |arm_implicit_it| {
            len +%= 19 +% @tagName(arm_implicit_it).len;
        }
        if (cmd.arm_interworking) {
            len +%= 19;
        }
        if (cmd.arm_load_store_opt) {
            len +%= 21;
        }
        if (cmd.arm_loloops_disable_tailpred) {
            len +%= 31;
        }
        if (cmd.arm_memtransfer_tploop) |arm_memtransfer_tploop| {
            len +%= 26 +% @tagName(arm_memtransfer_tploop).len;
        }
        if (cmd.arm_parallel_dsp_load_limit) |arm_parallel_dsp_load_limit| {
            len +%= 31 +% fmt.Ud64.length(arm_parallel_dsp_load_limit);
        }
        if (cmd.arm_prera_ldst_opt_reorder_limit) |arm_prera_ldst_opt_reorder_limit| {
            len +%= 36 +% fmt.Ud64.length(arm_prera_ldst_opt_reorder_limit);
        }
        if (cmd.arm_promote_constant) {
            len +%= 23;
        }
        if (cmd.arm_promote_constant_max_size) |arm_promote_constant_max_size| {
            len +%= 33 +% fmt.Ud64.length(arm_promote_constant_max_size);
        }
        if (cmd.arm_promote_constant_max_total) |arm_promote_constant_max_total| {
            len +%= 34 +% fmt.Ud64.length(arm_promote_constant_max_total);
        }
        if (cmd.arm_default_it) {
            len +%= 17;
        }
        if (cmd.arm_restrict_it) {
            len +%= 18;
        }
        if (cmd.arm_set_lr_predicate) {
            len +%= 23;
        }
        if (cmd.arm_synthesize_thumb_1_tbb) {
            len +%= 29;
        }
        if (cmd.arm_use_mulops) {
            len +%= 17;
        }
        if (cmd.as_secure_log_file) |as_secure_log_file| {
            len +%= 22 +% as_secure_log_file.len;
        }
        if (cmd.asan_always_slow_path) {
            len +%= 24;
        }
        if (cmd.asan_constructor_kind) |asan_constructor_kind| {
            len +%= 25 +% @tagName(asan_constructor_kind).len;
        }
        if (cmd.asan_debug) |asan_debug| {
            len +%= 14 +% fmt.Ud64.length(asan_debug);
        }
        if (cmd.asan_debug_func) |asan_debug_func| {
            len +%= 19 +% asan_debug_func.len;
        }
        if (cmd.asan_debug_max) |asan_debug_max| {
            len +%= 18 +% fmt.Ud64.length(asan_debug_max);
        }
        if (cmd.asan_debug_min) |asan_debug_min| {
            len +%= 18 +% fmt.Ud64.length(asan_debug_min);
        }
        if (cmd.asan_debug_stack) |asan_debug_stack| {
            len +%= 20 +% fmt.Ud64.length(asan_debug_stack);
        }
        if (cmd.asan_destructor_kind) |asan_destructor_kind| {
            len +%= 24 +% @tagName(asan_destructor_kind).len;
        }
        if (cmd.asan_detect_invalid_pointer_cmp) {
            len +%= 34;
        }
        if (cmd.asan_detect_invalid_pointer_pair) {
            len +%= 35;
        }
        if (cmd.asan_detect_invalid_pointer_sub) {
            len +%= 34;
        }
        if (cmd.asan_force_dynamic_shadow) {
            len +%= 28;
        }
        if (cmd.asan_force_experiment) |asan_force_experiment| {
            len +%= 25 +% fmt.Ud64.length(asan_force_experiment);
        }
        if (cmd.asan_globals) {
            len +%= 15;
        }
        if (cmd.asan_globals_live_support) {
            len +%= 28;
        }
        if (cmd.asan_guard_against_version_mismatch) {
            len +%= 38;
        }
        if (cmd.asan_initialization_order) {
            len +%= 28;
        }
        if (cmd.asan_instrument_atomics) {
            len +%= 26;
        }
        if (cmd.asan_instrument_byval) {
            len +%= 24;
        }
        if (cmd.asan_instrument_dynamic_allocas) {
            len +%= 34;
        }
        if (cmd.asan_instrument_reads) {
            len +%= 24;
        }
        if (cmd.asan_instrument_writes) {
            len +%= 25;
        }
        if (cmd.asan_instrumentation_with_call_threshold) |asan_instrumentation_with_call_threshold| {
            len +%= 44 +% fmt.Ud64.length(asan_instrumentation_with_call_threshold);
        }
        if (cmd.asan_kernel) {
            len +%= 14;
        }
        if (cmd.asan_kernel_mem_intrinsic_prefix) {
            len +%= 35;
        }
        if (cmd.asan_mapping_offset) |asan_mapping_offset| {
            len +%= 23 +% fmt.Ud64.length(asan_mapping_offset);
        }
        if (cmd.asan_mapping_scale) |asan_mapping_scale| {
            len +%= 22 +% fmt.Ud64.length(asan_mapping_scale);
        }
        if (cmd.asan_max_inline_poisoning_size) |asan_max_inline_poisoning_size| {
            len +%= 34 +% fmt.Ud64.length(asan_max_inline_poisoning_size);
        }
        if (cmd.asan_max_ins_per_bb) |asan_max_ins_per_bb| {
            len +%= 23 +% fmt.Ud64.length(asan_max_ins_per_bb);
        }
        if (cmd.asan_memory_access_callback_prefix) |asan_memory_access_callback_prefix| {
            len +%= 38 +% asan_memory_access_callback_prefix.len;
        }
        if (cmd.asan_opt) {
            len +%= 11;
        }
        if (cmd.asan_opt_globals) {
            len +%= 19;
        }
        if (cmd.asan_opt_same_temp) {
            len +%= 21;
        }
        if (cmd.asan_opt_stack) {
            len +%= 17;
        }
        if (cmd.asan_optimize_callbacks) {
            len +%= 26;
        }
        if (cmd.asan_realign_stack) |asan_realign_stack| {
            len +%= 22 +% fmt.Ud64.length(asan_realign_stack);
        }
        if (cmd.asan_recover) {
            len +%= 15;
        }
        if (cmd.asan_redzone_byval_args) {
            len +%= 26;
        }
        if (cmd.asan_skip_promotable_allocas) {
            len +%= 31;
        }
        if (cmd.asan_stack) {
            len +%= 13;
        }
        if (cmd.asan_stack_dynamic_alloca) {
            len +%= 28;
        }
        if (cmd.asan_use_after_return) |asan_use_after_return| {
            len +%= 25 +% @tagName(asan_use_after_return).len;
        }
        if (cmd.asan_use_after_scope) {
            len +%= 23;
        }
        if (cmd.asan_use_odr_indicator) {
            len +%= 25;
        }
        if (cmd.asan_use_private_alias) {
            len +%= 25;
        }
        if (cmd.asan_use_stack_safety) {
            len +%= 24;
        }
        if (cmd.asan_with_comdat) {
            len +%= 19;
        }
        if (cmd.asan_with_ifunc) {
            len +%= 18;
        }
        if (cmd.asan_with_ifunc_suppress_remat) {
            len +%= 33;
        }
        if (cmd.asm_macro_max_nesting_depth) |asm_macro_max_nesting_depth| {
            len +%= 31 +% fmt.Ud64.length(asm_macro_max_nesting_depth);
        }
        if (cmd.asm_show_inst) {
            len +%= 16;
        }
        if (cmd.asm_verbose) {
            len +%= 14;
        }
        if (cmd.assume_preserve_all) {
            len +%= 22;
        }
        if (cmd.atomic_counter_update_promoted) {
            len +%= 33;
        }
        if (cmd.atomic_first_counter) {
            len +%= 23;
        }
        if (cmd.attributor_allow_deep_wrappers) {
            len +%= 33;
        }
        if (cmd.attributor_allow_shallow_wrappers) {
            len +%= 36;
        }
        if (cmd.attributor_annotate_decl_cs) {
            len +%= 30;
        }
        if (cmd.attributor_depgraph_dot_filename_prefix) |attributor_depgraph_dot_filename_prefix| {
            len +%= 43 +% attributor_depgraph_dot_filename_prefix.len;
        }
        if (cmd.attributor_dump_dep_graph) {
            len +%= 28;
        }
        if (cmd.attributor_enable) |attributor_enable| {
            len +%= 21 +% @tagName(attributor_enable).len;
        }
        if (cmd.attributor_enable_call_site_specific_deduction) {
            len +%= 49;
        }
        if (cmd.attributor_manifest_internal) {
            len +%= 31;
        }
        if (cmd.attributor_max_initialization_chain_length) |attributor_max_initialization_chain_length| {
            len +%= 46 +% fmt.Ud64.length(attributor_max_initialization_chain_length);
        }
        if (cmd.attributor_max_iterations) |attributor_max_iterations| {
            len +%= 29 +% fmt.Ud64.length(attributor_max_iterations);
        }
        if (cmd.attributor_max_iterations_verify) {
            len +%= 35;
        }
        if (cmd.attributor_max_potential_values) |attributor_max_potential_values| {
            len +%= 35 +% fmt.Ud64.length(attributor_max_potential_values);
        }
        if (cmd.attributor_max_potential_values_iterations) |attributor_max_potential_values_iterations| {
            len +%= 46 +% fmt.Ud64.length(attributor_max_potential_values_iterations);
        }
        if (cmd.attributor_print_call_graph) {
            len +%= 30;
        }
        if (cmd.attributor_print_dep) {
            len +%= 23;
        }
        if (cmd.attributor_simplify_all_loads) {
            len +%= 32;
        }
        if (cmd.attributor_view_dep_graph) {
            len +%= 28;
        }
        if (cmd.available_load_scan_limit) |available_load_scan_limit| {
            len +%= 29 +% fmt.Ud64.length(available_load_scan_limit);
        }
        if (cmd.avoid_speculation) {
            len +%= 20;
        }
        if (cmd.basic_aa_recphi) {
            len +%= 18;
        }
        if (cmd.basic_aa_separate_storage) {
            len +%= 28;
        }
        if (cmd.bbsections_cold_text_prefix) |bbsections_cold_text_prefix| {
            len +%= 31 +% bbsections_cold_text_prefix.len;
        }
        if (cmd.bbsections_detect_source_drift) {
            len +%= 33;
        }
        if (cmd.bbsections_guided_section_prefix) {
            len +%= 35;
        }
        if (cmd.binutils_version) |binutils_version| {
            len +%= 20 +% binutils_version.len;
        }
        if (cmd.bitcode_flush_threshold) |bitcode_flush_threshold| {
            len +%= 27 +% fmt.Ud64.length(bitcode_flush_threshold);
        }
        if (cmd.bitcode_mdindex_threshold) |bitcode_mdindex_threshold| {
            len +%= 29 +% fmt.Ud64.length(bitcode_mdindex_threshold);
        }
        if (cmd.block_freq_ratio_threshold) |block_freq_ratio_threshold| {
            len +%= 30 +% fmt.Ud64.length(block_freq_ratio_threshold);
        }
        if (cmd.block_placement_exit_block_bias) |block_placement_exit_block_bias| {
            len +%= 35 +% fmt.Ud64.length(block_placement_exit_block_bias);
        }
        if (cmd.bonus_inst_threshold) |bonus_inst_threshold| {
            len +%= 24 +% fmt.Ud64.length(bonus_inst_threshold);
        }
        if (cmd.bounds_checking_single_trap) {
            len +%= 30;
        }
        if (cmd.bpf_disable_avoid_speculation) {
            len +%= 32;
        }
        if (cmd.bpf_disable_serialize_icmp) {
            len +%= 29;
        }
        if (cmd.bpf_expand_memcpy_in_order) {
            len +%= 29;
        }
        if (cmd.branch_fold_placement) {
            len +%= 24;
        }
        if (cmd.branch_relax_asm_large) {
            len +%= 25;
        }
        if (cmd.branch_relax_safety_buffer) |branch_relax_safety_buffer| {
            len +%= 30 +% fmt.Ud64.length(branch_relax_safety_buffer);
        }
        if (cmd.break_anti_dependencies) |break_anti_dependencies| {
            len +%= 27 +% break_anti_dependencies.len;
        }
        if (cmd.cache_line_size) |cache_line_size| {
            len +%= 19 +% fmt.Ud64.length(cache_line_size);
        }
        if (cmd.callgraph_dot_filename_prefix) |callgraph_dot_filename_prefix| {
            len +%= 33 +% callgraph_dot_filename_prefix.len;
        }
        if (cmd.callgraph_heat_colors) {
            len +%= 24;
        }
        if (cmd.callgraph_multigraph) {
            len +%= 23;
        }
        if (cmd.callgraph_show_weights) {
            len +%= 25;
        }
        if (cmd.callsite_splitting_duplication_threshold) |callsite_splitting_duplication_threshold| {
            len +%= 44 +% fmt.Ud64.length(callsite_splitting_duplication_threshold);
        }
        if (cmd.canon_nth_function) |canon_nth_function| {
            len +%= 22 +% fmt.Ud64.length(canon_nth_function);
        }
        if (cmd.canonicalize_icmp_predicates_to_unsigned) {
            len +%= 43;
        }
        if (cmd.capture_tracking_max_uses_to_explore) |capture_tracking_max_uses_to_explore| {
            len +%= 40 +% fmt.Ud64.length(capture_tracking_max_uses_to_explore);
        }
        if (cmd.cfg_dot_filename_prefix) |cfg_dot_filename_prefix| {
            len +%= 27 +% cfg_dot_filename_prefix.len;
        }
        if (cmd.cfg_func_name) |cfg_func_name| {
            len +%= 17 +% cfg_func_name.len;
        }
        if (cmd.cfg_heat_colors) {
            len +%= 18;
        }
        if (cmd.cfg_hide_cold_paths) |cfg_hide_cold_paths| {
            len +%= 23 +% fmt.Ud64.length(cfg_hide_cold_paths);
        }
        if (cmd.cfg_hide_deoptimize_paths) {
            len +%= 28;
        }
        if (cmd.cfg_hide_unreachable_paths) {
            len +%= 29;
        }
        if (cmd.cfg_raw_weights) {
            len +%= 18;
        }
        if (cmd.cfg_weights) {
            len +%= 14;
        }
        if (cmd.cgp_freq_ratio_to_skip_merge) |cgp_freq_ratio_to_skip_merge| {
            len +%= 32 +% fmt.Ud64.length(cgp_freq_ratio_to_skip_merge);
        }
        if (cmd.cgp_icmp_eq2icmp_st) {
            len +%= 22;
        }
        if (cmd.cgp_optimize_phi_types) {
            len +%= 25;
        }
        if (cmd.cgp_split_large_offset_gep) {
            len +%= 29;
        }
        if (cmd.cgp_type_promotion_merge) {
            len +%= 27;
        }
        if (cmd.cgp_verify_bfi_updates) {
            len +%= 25;
        }
        if (cmd.cgpp_huge_func) |cgpp_huge_func| {
            len +%= 18 +% fmt.Ud64.length(cgpp_huge_func);
        }
        if (cmd.cgscc_inline_replay) {
            len +%= 22;
        }
        if (cmd.cgscc_inline_replay_fallback) |cgscc_inline_replay_fallback| {
            len +%= 32 +% @tagName(cgscc_inline_replay_fallback).len;
        }
        if (cmd.cgscc_inline_replay_format) |cgscc_inline_replay_format| {
            len +%= 30 +% @tagName(cgscc_inline_replay_format).len;
        }
        if (cmd.cgscc_inline_replay_scope) |cgscc_inline_replay_scope| {
            len +%= 29 +% @tagName(cgscc_inline_replay_scope).len;
        }
        if (cmd.check_bfi_unknown_block_queries) {
            len +%= 34;
        }
        if (cmd.check_early_avail) {
            len +%= 20;
        }
        if (cmd.chr_bias_threshold) |chr_bias_threshold| {
            len +%= 22 +% fmt.Ud64.length(chr_bias_threshold);
        }
        if (cmd.chr_dup_threshold) |chr_dup_threshold| {
            len +%= 21 +% fmt.Ud64.length(chr_dup_threshold);
        }
        if (cmd.chr_function_list) |chr_function_list| {
            len +%= 21 +% chr_function_list.len;
        }
        if (cmd.chr_merge_threshold) |chr_merge_threshold| {
            len +%= 23 +% fmt.Ud64.length(chr_merge_threshold);
        }
        if (cmd.chr_module_list) |chr_module_list| {
            len +%= 19 +% chr_module_list.len;
        }
        if (cmd.code_model) |code_model| {
            len +%= 14 +% @tagName(code_model).len;
        }
        if (cmd.cold_branch_ratio) |cold_branch_ratio| {
            len +%= 21 +% fmt.Ud64.length(cold_branch_ratio);
        }
        if (cmd.cold_callsite_rel_freq) |cold_callsite_rel_freq| {
            len +%= 26 +% fmt.Ud64.length(cold_callsite_rel_freq);
        }
        if (cmd.cold_operand_max_cost_multiplier) |cold_operand_max_cost_multiplier| {
            len +%= 36 +% fmt.Ud64.length(cold_operand_max_cost_multiplier);
        }
        if (cmd.cold_operand_threshold) |cold_operand_threshold| {
            len +%= 26 +% fmt.Ud64.length(cold_operand_threshold);
        }
        if (cmd.cold_synthetic_count) |cold_synthetic_count| {
            len +%= 24 +% fmt.Ud64.length(cold_synthetic_count);
        }
        if (cmd.coldcc_rel_freq) |coldcc_rel_freq| {
            len +%= 19 +% fmt.Ud64.length(coldcc_rel_freq);
        }
        if (cmd.color) {
            len +%= 8;
        }
        if (cmd.combiner_global_alias_analysis) {
            len +%= 33;
        }
        if (cmd.combiner_reduce_load_op_store_width) {
            len +%= 38;
        }
        if (cmd.combiner_shrink_load_replace_store_with_store) {
            len +%= 48;
        }
        if (cmd.combiner_split_load_index) {
            len +%= 28;
        }
        if (cmd.combiner_store_merge_dependence_limit) |combiner_store_merge_dependence_limit| {
            len +%= 41 +% fmt.Ud64.length(combiner_store_merge_dependence_limit);
        }
        if (cmd.combiner_store_merging) {
            len +%= 25;
        }
        if (cmd.combiner_stress_load_slicing) {
            len +%= 31;
        }
        if (cmd.combiner_tokenfactor_inline_limit) |combiner_tokenfactor_inline_limit| {
            len +%= 37 +% fmt.Ud64.length(combiner_tokenfactor_inline_limit);
        }
        if (cmd.combiner_use_tbaa) {
            len +%= 20;
        }
        if (cmd.combiner_vector_fcopysign_extend_round) {
            len +%= 41;
        }
        if (cmd.commgep_const) {
            len +%= 16;
        }
        if (cmd.commgep_inv) {
            len +%= 14;
        }
        if (cmd.commgep_speculate) {
            len +%= 20;
        }
        if (cmd.compile_time_mem_idiom_threshold) |compile_time_mem_idiom_threshold| {
            len +%= 36 +% fmt.Ud64.length(compile_time_mem_idiom_threshold);
        }
        if (cmd.compile_twice) {
            len +%= 16;
        }
        if (cmd.compute_dead) {
            len +%= 15;
        }
        if (cmd.consthoist_gep) {
            len +%= 17;
        }
        if (cmd.consthoist_min_num_to_rebase) |consthoist_min_num_to_rebase| {
            len +%= 32 +% fmt.Ud64.length(consthoist_min_num_to_rebase);
        }
        if (cmd.consthoist_with_block_frequency) {
            len +%= 34;
        }
        if (cmd.constraint_elimination_max_rows) |constraint_elimination_max_rows| {
            len +%= 35 +% fmt.Ud64.length(constraint_elimination_max_rows);
        }
        if (cmd.cost_kind) |cost_kind| {
            len +%= 13 +% @tagName(cost_kind).len;
        }
        if (cmd.costmodel_reduxcost) {
            len +%= 22;
        }
        if (cmd.crash_diagnostics_dir) |crash_diagnostics_dir| {
            len +%= 25 +% crash_diagnostics_dir.len;
        }
        if (cmd.crash_on_ppc_vsx_self_copy) {
            len +%= 29;
        }
        if (cmd.cs_profile_generate) {
            len +%= 22;
        }
        if (cmd.cs_profile_path) |cs_profile_path| {
            len +%= 19 +% cs_profile_path.len;
        }
        if (cmd.csuses_threshold) |csuses_threshold| {
            len +%= 20 +% fmt.Ud64.length(csuses_threshold);
        }
        if (cmd.cvp_max_functions_per_value) |cvp_max_functions_per_value| {
            len +%= 31 +% fmt.Ud64.length(cvp_max_functions_per_value);
        }
        if (cmd.da_delinearize) {
            len +%= 17;
        }
        if (cmd.da_disable_delinearization_checks) {
            len +%= 36;
        }
        if (cmd.da_miv_max_level_threshold) |da_miv_max_level_threshold| {
            len +%= 30 +% fmt.Ud64.length(da_miv_max_level_threshold);
        }
        if (cmd.dag_dump_verbose) {
            len +%= 19;
        }
        if (cmd.dag_maps_huge_region) |dag_maps_huge_region| {
            len +%= 24 +% fmt.Ud64.length(dag_maps_huge_region);
        }
        if (cmd.dag_maps_reduction_size) |dag_maps_reduction_size| {
            len +%= 27 +% fmt.Ud64.length(dag_maps_reduction_size);
        }
        if (cmd.data_sections) {
            len +%= 16;
        }
        if (cmd.dataflow_edge_limit) |dataflow_edge_limit| {
            len +%= 23 +% fmt.Ud64.length(dataflow_edge_limit);
        }
        if (cmd.ddg_pi_blocks) {
            len +%= 16;
        }
        if (cmd.ddg_simplify) {
            len +%= 15;
        }
        if (cmd.debug_ata_max_blocks) |debug_ata_max_blocks| {
            len +%= 24 +% fmt.Ud64.length(debug_ata_max_blocks);
        }
        if (cmd.debug_counter) {
            len +%= 15;
        }
        if (cmd.debug_entry_values) {
            len +%= 21;
        }
        if (cmd.debug_info_correlate) {
            len +%= 23;
        }
        if (cmd.debug_pass) |debug_pass| {
            len +%= 14 +% @tagName(debug_pass).len;
        }
        if (cmd.debugger_tune) |debugger_tune| {
            len +%= 17 +% @tagName(debugger_tune).len;
        }
        if (cmd.debugify_and_strip_all_safe) {
            len +%= 30;
        }
        if (cmd.debugify_check_and_strip_all_safe) {
            len +%= 36;
        }
        if (cmd.debugify_func_limit) |debugify_func_limit| {
            len +%= 23 +% fmt.Ud64.length(debugify_func_limit);
        }
        if (cmd.debugify_level) |debugify_level| {
            len +%= 18 +% @tagName(debugify_level).len;
        }
        if (cmd.debugify_quiet) {
            len +%= 17;
        }
        if (cmd.default_gcov_version) |default_gcov_version| {
            len +%= 24 +% default_gcov_version.len;
        }
        if (cmd.default_trip_count) |default_trip_count| {
            len +%= 22 +% fmt.Ud64.length(default_trip_count);
        }
        if (cmd.demote_catchswitch_only) {
            len +%= 26;
        }
        if (cmd.denormal_fp_math) |denormal_fp_math| {
            len +%= 20 +% @tagName(denormal_fp_math).len;
        }
        if (cmd.denormal_fp_math_f32) |denormal_fp_math_f32| {
            len +%= 24 +% @tagName(denormal_fp_math_f32).len;
        }
        if (cmd.dfa_cost_threshold) |dfa_cost_threshold| {
            len +%= 22 +% fmt.Ud64.length(dfa_cost_threshold);
        }
        if (cmd.dfa_hazard_rec) {
            len +%= 17;
        }
        if (cmd.dfa_instr_limit) |dfa_instr_limit| {
            len +%= 19 +% fmt.Ud64.length(dfa_instr_limit);
        }
        if (cmd.dfa_jump_view_cfg_before) {
            len +%= 27;
        }
        if (cmd.dfa_max_num_paths) |dfa_max_num_paths| {
            len +%= 21 +% fmt.Ud64.length(dfa_max_num_paths);
        }
        if (cmd.dfa_max_path_length) |dfa_max_path_length| {
            len +%= 23 +% fmt.Ud64.length(dfa_max_path_length);
        }
        if (cmd.dfa_sched_reg_pressure_threshold) |dfa_sched_reg_pressure_threshold| {
            len +%= 36 +% fmt.Ud64.length(dfa_sched_reg_pressure_threshold);
        }
        if (cmd.dfsan_abilist) |dfsan_abilist| {
            len +%= 17 +% dfsan_abilist.len;
        }
        if (cmd.dfsan_combine_offset_labels_on_gep) {
            len +%= 37;
        }
        if (cmd.dfsan_combine_pointer_labels_on_load) {
            len +%= 39;
        }
        if (cmd.dfsan_combine_pointer_labels_on_store) {
            len +%= 40;
        }
        if (cmd.dfsan_combine_taint_lookup_table) |dfsan_combine_taint_lookup_table| {
            len +%= 36 +% dfsan_combine_taint_lookup_table.len;
        }
        if (cmd.dfsan_conditional_callbacks) {
            len +%= 30;
        }
        if (cmd.dfsan_debug_nonzero_labels) {
            len +%= 29;
        }
        if (cmd.dfsan_event_callbacks) {
            len +%= 24;
        }
        if (cmd.dfsan_ignore_personality_routine) {
            len +%= 35;
        }
        if (cmd.dfsan_instrument_with_call_threshold) |dfsan_instrument_with_call_threshold| {
            len +%= 40 +% fmt.Ud64.length(dfsan_instrument_with_call_threshold);
        }
        if (cmd.dfsan_preserve_alignment) {
            len +%= 27;
        }
        if (cmd.dfsan_reaches_function_callbacks) {
            len +%= 35;
        }
        if (cmd.dfsan_track_origins) |dfsan_track_origins| {
            len +%= 23 +% fmt.Ud64.length(dfsan_track_origins);
        }
        if (cmd.dfsan_track_select_control_flow) {
            len +%= 34;
        }
        if (cmd.disable_2addr_hack) {
            len +%= 21;
        }
        if (cmd.disable_a15_sd_optimization) {
            len +%= 30;
        }
        if (cmd.disable_adv_copy_opt) {
            len +%= 23;
        }
        if (cmd.disable_advanced_peeling) {
            len +%= 27;
        }
        if (cmd.disable_arm_loloops) {
            len +%= 22;
        }
        if (cmd.disable_arm_parallel_dsp) {
            len +%= 27;
        }
        if (cmd.disable_auto_paired_vec_st) {
            len +%= 29;
        }
        if (cmd.disable_basic_aa) {
            len +%= 19;
        }
        if (cmd.disable_binop_extract_shuffle) {
            len +%= 32;
        }
        if (cmd.disable_bitcode_version_upgrade) {
            len +%= 34;
        }
        if (cmd.disable_block_placement) {
            len +%= 26;
        }
        if (cmd.disable_bpf_peephole) {
            len +%= 23;
        }
        if (cmd.disable_branch_fold) {
            len +%= 22;
        }
        if (cmd.disable_cfi_fixup) {
            len +%= 20;
        }
        if (cmd.disable_cgp) {
            len +%= 14;
        }
        if (cmd.disable_cgp_branch_opts) {
            len +%= 26;
        }
        if (cmd.disable_cgp_ext_ld_promotion) {
            len +%= 31;
        }
        if (cmd.disable_cgp_gc_opts) {
            len +%= 22;
        }
        if (cmd.disable_cgp_select2branch) {
            len +%= 28;
        }
        if (cmd.disable_cgp_store_extract) {
            len +%= 28;
        }
        if (cmd.disable_check_noreturn_call) {
            len +%= 30;
        }
        if (cmd.disable_chr) {
            len +%= 14;
        }
        if (cmd.disable_cleanups) {
            len +%= 19;
        }
        if (cmd.disable_complex_addr_modes) {
            len +%= 29;
        }
        if (cmd.disable_const64) {
            len +%= 18;
        }
        if (cmd.disable_constant_hoisting) {
            len +%= 28;
        }
        if (cmd.disable_copyprop) {
            len +%= 19;
        }
        if (cmd.disable_debug_info_print) {
            len +%= 27;
        }
        if (cmd.disable_demotion) {
            len +%= 19;
        }
        if (cmd.disable_dfa_sched) {
            len +%= 20;
        }
        if (cmd.disable_early_ifcvt) {
            len +%= 22;
        }
        if (cmd.disable_early_taildup) {
            len +%= 24;
        }
        if (cmd.disable_expand_reductions) {
            len +%= 28;
        }
        if (cmd.disable_gep_const_evaluation) {
            len +%= 31;
        }
        if (cmd.disable_gisel_legality_check) {
            len +%= 31;
        }
        if (cmd.disable_hcp) {
            len +%= 14;
        }
        if (cmd.disable_hexagon_amodeopt) {
            len +%= 27;
        }
        if (cmd.disable_hexagon_cfgopt) {
            len +%= 25;
        }
        if (cmd.disable_hexagon_dealloc_ret) {
            len +%= 30;
        }
        if (cmd.disable_hexagon_hwloops) {
            len +%= 26;
        }
        if (cmd.disable_hexagon_misched) {
            len +%= 26;
        }
        if (cmd.disable_hexagon_nv_schedule) {
            len +%= 30;
        }
        if (cmd.disable_hexagon_opt_ext_to_64) {
            len +%= 32;
        }
        if (cmd.disable_hexagon_optszext) {
            len +%= 27;
        }
        if (cmd.disable_hexagon_peephole) {
            len +%= 27;
        }
        if (cmd.disable_hexagon_pnotp) {
            len +%= 24;
        }
        if (cmd.disable_hexagon_shuffle) {
            len +%= 26;
        }
        if (cmd.disable_hexagon_volatile_memcpy) {
            len +%= 34;
        }
        if (cmd.disable_hoisting_to_hotter_blocks) |disable_hoisting_to_hotter_blocks| {
            len +%= 37 +% @tagName(disable_hoisting_to_hotter_blocks).len;
        }
        if (cmd.disable_hsdr) {
            len +%= 15;
        }
        if (cmd.disable_i2p_p2i_opt) {
            len +%= 22;
        }
        if (cmd.disable_icp) {
            len +%= 14;
        }
        if (cmd.disable_ifcvt_diamond) {
            len +%= 24;
        }
        if (cmd.disable_ifcvt_forked_diamond) {
            len +%= 31;
        }
        if (cmd.disable_ifcvt_simple) {
            len +%= 23;
        }
        if (cmd.disable_ifcvt_simple_false) {
            len +%= 29;
        }
        if (cmd.disable_ifcvt_triangle) {
            len +%= 25;
        }
        if (cmd.disable_ifcvt_triangle_false) {
            len +%= 31;
        }
        if (cmd.disable_ifcvt_triangle_false_rev) {
            len +%= 35;
        }
        if (cmd.disable_ifcvt_triangle_rev) {
            len +%= 29;
        }
        if (cmd.disable_inlined_alloca_merging) {
            len +%= 33;
        }
        if (cmd.disable_interleaved_load_combine) {
            len +%= 35;
        }
        if (cmd.disable_lanai_mem_alu_combiner) {
            len +%= 33;
        }
        if (cmd.disable_layout_fsprofile_loader) {
            len +%= 34;
        }
        if (cmd.disable_lftr) {
            len +%= 15;
        }
        if (cmd.disable_licm_promotion) {
            len +%= 25;
        }
        if (cmd.disable_loop_level_heuristics) {
            len +%= 32;
        }
        if (cmd.disable_lsr) {
            len +%= 14;
        }
        if (cmd.disable_machine_cse) {
            len +%= 22;
        }
        if (cmd.disable_machine_dce) {
            len +%= 22;
        }
        if (cmd.disable_machine_licm) {
            len +%= 23;
        }
        if (cmd.disable_machine_sink) {
            len +%= 23;
        }
        if (cmd.disable_memcpy_idiom) {
            len +%= 23;
        }
        if (cmd.disable_memmove_idiom) {
            len +%= 24;
        }
        if (cmd.disable_memop_opt) {
            len +%= 20;
        }
        if (cmd.disable_merge_into_combines) {
            len +%= 30;
        }
        if (cmd.disable_mergeicmps) {
            len +%= 21;
        }
        if (cmd.disable_mips_delay_filler) {
            len +%= 28;
        }
        if (cmd.disable_mips_df_backward_search) {
            len +%= 34;
        }
        if (cmd.disable_mips_df_forward_search) {
            len +%= 33;
        }
        if (cmd.disable_mips_df_succbb_search) {
            len +%= 32;
        }
        if (cmd.disable_mr_partial_inlining) {
            len +%= 30;
        }
        if (cmd.disable_nofree_inference) {
            len +%= 27;
        }
        if (cmd.disable_non_allocatable_phys_copy_opt) {
            len +%= 40;
        }
        if (cmd.disable_nounwind_inference) {
            len +%= 29;
        }
        if (cmd.disable_nvjump) {
            len +%= 17;
        }
        if (cmd.disable_nvptx_load_store_vectorizer) {
            len +%= 38;
        }
        if (cmd.disable_nvptx_require_structured_cfg) {
            len +%= 39;
        }
        if (cmd.disable_ondemand_mds_loading) {
            len +%= 31;
        }
        if (cmd.disable_packetizer) {
            len +%= 21;
        }
        if (cmd.disable_partial_inlining) {
            len +%= 27;
        }
        if (cmd.disable_partial_libcall_inlining) {
            len +%= 35;
        }
        if (cmd.disable_peephole) {
            len +%= 19;
        }
        if (cmd.disable_phi_elim_edge_splitting) {
            len +%= 34;
        }
        if (cmd.disable_post_ra) {
            len +%= 18;
        }
        if (cmd.disable_postra_machine_licm) {
            len +%= 30;
        }
        if (cmd.disable_postra_machine_sink) {
            len +%= 30;
        }
        if (cmd.disable_ppc_cmp_opt) {
            len +%= 22;
        }
        if (cmd.disable_ppc_constant_hoisting) {
            len +%= 32;
        }
        if (cmd.disable_ppc_ctrloop_analysis) {
            len +%= 31;
        }
        if (cmd.disable_ppc_ctrloops) {
            len +%= 23;
        }
        if (cmd.disable_ppc_ilp_pref) {
            len +%= 23;
        }
        if (cmd.disable_ppc_innermost_loop_align32) {
            len +%= 37;
        }
        if (cmd.disable_ppc_instr_form_prep) {
            len +%= 30;
        }
        if (cmd.disable_ppc_peephole) {
            len +%= 23;
        }
        if (cmd.disable_ppc_preinc) {
            len +%= 21;
        }
        if (cmd.disable_ppc_sched_addi_load) {
            len +%= 30;
        }
        if (cmd.disable_ppc_sco) {
            len +%= 18;
        }
        if (cmd.disable_ppc_unaligned) {
            len +%= 24;
        }
        if (cmd.disable_ppc_vsx_fma_mutation) {
            len +%= 31;
        }
        if (cmd.disable_ppc_vsx_swap_removal) {
            len +%= 31;
        }
        if (cmd.disable_preheader_prot) {
            len +%= 25;
        }
        if (cmd.disable_preinline) {
            len +%= 20;
        }
        if (cmd.disable_promote_alloca_to_lds) {
            len +%= 32;
        }
        if (cmd.disable_promote_alloca_to_vector) {
            len +%= 35;
        }
        if (cmd.disable_ra_fsprofile_loader) {
            len +%= 30;
        }
        if (cmd.disable_sample_loader_inlining) {
            len +%= 33;
        }
        if (cmd.disable_sched_critical_path) {
            len +%= 30;
        }
        if (cmd.disable_sched_cycles) {
            len +%= 23;
        }
        if (cmd.disable_sched_hazard) {
            len +%= 23;
        }
        if (cmd.disable_sched_height) {
            len +%= 23;
        }
        if (cmd.disable_sched_live_uses) {
            len +%= 26;
        }
        if (cmd.disable_sched_physreg_join) {
            len +%= 29;
        }
        if (cmd.disable_sched_reg_pressure) {
            len +%= 29;
        }
        if (cmd.disable_sched_stalls) {
            len +%= 23;
        }
        if (cmd.disable_sched_vrcycle) {
            len +%= 24;
        }
        if (cmd.disable_select_optimize) {
            len +%= 26;
        }
        if (cmd.disable_separate_const_offset_from_gep) {
            len +%= 41;
        }
        if (cmd.disable_shifter_op) {
            len +%= 21;
        }
        if (cmd.disable_simplify_libcalls) {
            len +%= 28;
        }
        if (cmd.disable_sparc_delay_filler) {
            len +%= 29;
        }
        if (cmd.disable_sparc_leaf_proc) {
            len +%= 26;
        }
        if (cmd.disable_spill_fusing) {
            len +%= 23;
        }
        if (cmd.disable_spill_hoist) {
            len +%= 22;
        }
        if (cmd.disable_ssc) {
            len +%= 14;
        }
        if (cmd.disable_store_widen) {
            len +%= 22;
        }
        if (cmd.disable_strictnode_mutation) {
            len +%= 30;
        }
        if (cmd.disable_symbolication) {
            len +%= 24;
        }
        if (cmd.disable_tail_calls) {
            len +%= 21;
        }
        if (cmd.disable_tail_duplicate) {
            len +%= 25;
        }
        if (cmd.disable_thinlto_funcattrs) {
            len +%= 28;
        }
        if (cmd.disable_type_promotion) {
            len +%= 25;
        }
        if (cmd.disable_vecdbl_nv_stores) {
            len +%= 27;
        }
        if (cmd.disable_vector_combine) {
            len +%= 25;
        }
        if (cmd.disable_verify) {
            len +%= 17;
        }
        if (cmd.disable_vp) {
            len +%= 13;
        }
        if (cmd.disable_wasm_fallthrough_return_opt) {
            len +%= 38;
        }
        if (cmd.disable_whole_program_visibility) {
            len +%= 35;
        }
        if (cmd.disable_x86_domain_reassignment) {
            len +%= 34;
        }
        if (cmd.disable_x86_lea_opt) {
            len +%= 22;
        }
        if (cmd.discard_value_names) {
            len +%= 22;
        }
        if (cmd.do_comdat_renaming) {
            len +%= 21;
        }
        if (cmd.do_counter_promotion) {
            len +%= 23;
        }
        if (cmd.dom_conditions_max_uses) |dom_conditions_max_uses| {
            len +%= 27 +% fmt.Ud64.length(dom_conditions_max_uses);
        }
        if (cmd.dom_tree_reachability_max_bbs_to_explore) |dom_tree_reachability_max_bbs_to_explore| {
            len +%= 44 +% fmt.Ud64.length(dom_tree_reachability_max_bbs_to_explore);
        }
        if (cmd.dot_cfg_after_color) |dot_cfg_after_color| {
            len +%= 23 +% dot_cfg_after_color.len;
        }
        if (cmd.dot_cfg_before_color) |dot_cfg_before_color| {
            len +%= 24 +% dot_cfg_before_color.len;
        }
        if (cmd.dot_cfg_common_color) |dot_cfg_common_color| {
            len +%= 24 +% dot_cfg_common_color.len;
        }
        if (cmd.dot_cfg_dir) |dot_cfg_dir| {
            len +%= 15 +% dot_cfg_dir.len;
        }
        if (cmd.dot_ddg_filename_prefix) |dot_ddg_filename_prefix| {
            len +%= 27 +% dot_ddg_filename_prefix.len;
        }
        if (cmd.dot_ddg_only) {
            len +%= 15;
        }
        if (cmd.dot_mcfg_only) {
            len +%= 16;
        }
        if (cmd.dse_memoryssa_defs_per_block_limit) |dse_memoryssa_defs_per_block_limit| {
            len +%= 38 +% fmt.Ud64.length(dse_memoryssa_defs_per_block_limit);
        }
        if (cmd.dse_memoryssa_otherbb_cost) |dse_memoryssa_otherbb_cost| {
            len +%= 30 +% fmt.Ud64.length(dse_memoryssa_otherbb_cost);
        }
        if (cmd.dse_memoryssa_partial_store_limit) |dse_memoryssa_partial_store_limit| {
            len +%= 37 +% fmt.Ud64.length(dse_memoryssa_partial_store_limit);
        }
        if (cmd.dse_memoryssa_path_check_limit) |dse_memoryssa_path_check_limit| {
            len +%= 34 +% fmt.Ud64.length(dse_memoryssa_path_check_limit);
        }
        if (cmd.dse_memoryssa_samebb_cost) |dse_memoryssa_samebb_cost| {
            len +%= 29 +% fmt.Ud64.length(dse_memoryssa_samebb_cost);
        }
        if (cmd.dse_memoryssa_scanlimit) |dse_memoryssa_scanlimit| {
            len +%= 27 +% fmt.Ud64.length(dse_memoryssa_scanlimit);
        }
        if (cmd.dse_memoryssa_walklimit) |dse_memoryssa_walklimit| {
            len +%= 27 +% fmt.Ud64.length(dse_memoryssa_walklimit);
        }
        if (cmd.dse_optimize_memoryssa) {
            len +%= 25;
        }
        if (cmd.dump_thin_cg_sccs) {
            len +%= 20;
        }
        if (cmd.dwarf_directory) {
            len +%= 18;
        }
        if (cmd.dwarf_extended_loc) |dwarf_extended_loc| {
            len +%= 22 +% @tagName(dwarf_extended_loc).len;
        }
        if (cmd.dwarf_inlined_strings) |dwarf_inlined_strings| {
            len +%= 25 +% @tagName(dwarf_inlined_strings).len;
        }
        if (cmd.dwarf_linkage_names) |dwarf_linkage_names| {
            len +%= 23 +% @tagName(dwarf_linkage_names).len;
        }
        if (cmd.dwarf_op_convert) |dwarf_op_convert| {
            len +%= 20 +% @tagName(dwarf_op_convert).len;
        }
        if (cmd.dwarf_sections_as_references) |dwarf_sections_as_references| {
            len +%= 32 +% @tagName(dwarf_sections_as_references).len;
        }
        if (cmd.dwarf_version) |dwarf_version| {
            len +%= 17 +% fmt.Ud64.length(dwarf_version);
        }
        if (cmd.dwarf64) {
            len +%= 10;
        }
        if (cmd.eagerly_invalidate_analyses) {
            len +%= 30;
        }
        if (cmd.early_ifcvt_limit) |early_ifcvt_limit| {
            len +%= 21 +% fmt.Ud64.length(early_ifcvt_limit);
        }
        if (cmd.early_live_intervals) {
            len +%= 23;
        }
        if (cmd.earlycse_debug_hash) {
            len +%= 22;
        }
        if (cmd.earlycse_mssa_optimization_cap) |earlycse_mssa_optimization_cap| {
            len +%= 34 +% fmt.Ud64.length(earlycse_mssa_optimization_cap);
        }
        if (cmd.eif_limit) |eif_limit| {
            len +%= 13 +% fmt.Ud64.length(eif_limit);
        }
        if (cmd.eif_no_loop_exit) {
            len +%= 19;
        }
        if (cmd.emit_call_site_info) {
            len +%= 22;
        }
        if (cmd.emit_dwarf_unwind) |emit_dwarf_unwind| {
            len +%= 21 +% @tagName(emit_dwarf_unwind).len;
        }
        if (cmd.emscripten_cxx_exceptions_allowed) |emscripten_cxx_exceptions_allowed| {
            len +%= 37 +% emscripten_cxx_exceptions_allowed.len;
        }
        if (cmd.emulate_old_livedebugvalues) {
            len +%= 30;
        }
        if (cmd.emulated_tls) {
            len +%= 15;
        }
        if (cmd.enable_aa_sched_mi) {
            len +%= 21;
        }
        if (cmd.enable_acc_forwarding) {
            len +%= 24;
        }
        if (cmd.enable_alu_forwarding) {
            len +%= 24;
        }
        if (cmd.enable_amdgpu_aa) {
            len +%= 19;
        }
        if (cmd.enable_andcmp_sinking) {
            len +%= 24;
        }
        if (cmd.enable_approx_func_fp_math) {
            len +%= 29;
        }
        if (cmd.enable_arm_3_addr_conv) {
            len +%= 25;
        }
        if (cmd.enable_arm_maskedgatscat) {
            len +%= 27;
        }
        if (cmd.enable_arm_maskedldst) {
            len +%= 24;
        }
        if (cmd.enable_block_placement_stats) {
            len +%= 31;
        }
        if (cmd.enable_bsb_sched) {
            len +%= 19;
        }
        if (cmd.enable_chr) {
            len +%= 13;
        }
        if (cmd.enable_cold_section) {
            len +%= 22;
        }
        if (cmd.enable_coldcc_stress_test) {
            len +%= 28;
        }
        if (cmd.enable_complex_deinterleaving) {
            len +%= 32;
        }
        if (cmd.enable_cond_stores_vec) {
            len +%= 25;
        }
        if (cmd.enable_constraint_elimination) {
            len +%= 32;
        }
        if (cmd.enable_cse_in_irtranslator) {
            len +%= 29;
        }
        if (cmd.enable_cse_in_legalizer) {
            len +%= 26;
        }
        if (cmd.enable_cur_sched) {
            len +%= 19;
        }
        if (cmd.enable_deferred_spilling) {
            len +%= 27;
        }
        if (cmd.enable_dfa_jump_thread) {
            len +%= 25;
        }
        if (cmd.enable_double_float_shrink) {
            len +%= 29;
        }
        if (cmd.enable_dse_partial_overwrite_tracking) {
            len +%= 40;
        }
        if (cmd.enable_dse_partial_store_merging) {
            len +%= 35;
        }
        if (cmd.enable_emscripten_cxx_exceptions) {
            len +%= 35;
        }
        if (cmd.enable_emscripten_sjlj) {
            len +%= 25;
        }
        if (cmd.enable_epilogue_vectorization) {
            len +%= 32;
        }
        if (cmd.enable_ext_tsp_block_placement) {
            len +%= 33;
        }
        if (cmd.enable_falkor_hwpf_unroll_fix) {
            len +%= 32;
        }
        if (cmd.enable_fixedwidth_autovec_in_streaming_mode) {
            len +%= 46;
        }
        if (cmd.enable_fs_discriminator) {
            len +%= 26;
        }
        if (cmd.enable_gen_insn) {
            len +%= 18;
        }
        if (cmd.enable_global_analyses) {
            len +%= 25;
        }
        if (cmd.enable_global_merge) {
            len +%= 22;
        }
        if (cmd.enable_gvn_hoist) {
            len +%= 19;
        }
        if (cmd.enable_gvn_memdep) {
            len +%= 20;
        }
        if (cmd.enable_gvn_sink) {
            len +%= 18;
        }
        if (cmd.enable_heap_to_stack_conversion) {
            len +%= 34;
        }
        if (cmd.enable_hexagon_br_prob) {
            len +%= 25;
        }
        if (cmd.enable_hexagon_sdnode_sched) {
            len +%= 30;
        }
        if (cmd.enable_hexagon_vector_print) {
            len +%= 30;
        }
        if (cmd.enable_if_conversion) {
            len +%= 23;
        }
        if (cmd.enable_implicit_null_checks) {
            len +%= 30;
        }
        if (cmd.enable_import_metadata) {
            len +%= 25;
        }
        if (cmd.enable_ind_var_reg_heur) {
            len +%= 26;
        }
        if (cmd.enable_interleaved_mem_accesses) {
            len +%= 34;
        }
        if (cmd.enable_ipra) {
            len +%= 14;
        }
        if (cmd.enable_jmc_instrument) {
            len +%= 24;
        }
        if (cmd.enable_knowledge_retention) {
            len +%= 29;
        }
        if (cmd.enable_legalize_types_checking) {
            len +%= 33;
        }
        if (cmd.enable_linkonceodr_ir_outlining) {
            len +%= 34;
        }
        if (cmd.enable_linkonceodr_outlining) {
            len +%= 31;
        }
        if (cmd.enable_load_in_loop_pre) {
            len +%= 26;
        }
        if (cmd.enable_load_pre) {
            len +%= 18;
        }
        if (cmd.enable_loadstore_runtime_interleave) {
            len +%= 38;
        }
        if (cmd.enable_local_reassign) {
            len +%= 24;
        }
        if (cmd.enable_loop_distribute) {
            len +%= 25;
        }
        if (cmd.enable_loop_flatten) {
            len +%= 22;
        }
        if (cmd.enable_loop_simplifycfg_term_folding) {
            len +%= 39;
        }
        if (cmd.enable_loopinterchange) {
            len +%= 25;
        }
        if (cmd.enable_lsr_phielim) {
            len +%= 21;
        }
        if (cmd.enable_lto_internalization) {
            len +%= 29;
        }
        if (cmd.enable_machine_outliner) |enable_machine_outliner| {
            len +%= 27 +% @tagName(enable_machine_outliner).len;
        }
        if (cmd.enable_masked_interleaved_mem_accesses) {
            len +%= 41;
        }
        if (cmd.enable_matrix) {
            len +%= 16;
        }
        if (cmd.enable_mem_access_versioning) {
            len +%= 31;
        }
        if (cmd.enable_mem_prof) {
            len +%= 18;
        }
        if (cmd.enable_memcpy_dag_opt) {
            len +%= 24;
        }
        if (cmd.enable_memcpyopt_without_libcalls) {
            len +%= 36;
        }
        if (cmd.enable_merge_functions) {
            len +%= 25;
        }
        if (cmd.enable_misched) {
            len +%= 17;
        }
        if (cmd.enable_ml_inliner) |enable_ml_inliner| {
            len +%= 21 +% @tagName(enable_ml_inliner).len;
        }
        if (cmd.enable_module_inliner) {
            len +%= 24;
        }
        if (cmd.enable_mve_interleave) {
            len +%= 24;
        }
        if (cmd.enable_name_compression) {
            len +%= 26;
        }
        if (cmd.enable_newgvn) {
            len +%= 16;
        }
        if (cmd.enable_no_infs_fp_math) {
            len +%= 25;
        }
        if (cmd.enable_no_nans_fp_math) {
            len +%= 25;
        }
        if (cmd.enable_no_rerun_simplification_pipeline) {
            len +%= 42;
        }
        if (cmd.enable_no_signed_zeros_fp_math) {
            len +%= 33;
        }
        if (cmd.enable_no_trapping_fp_math) {
            len +%= 29;
        }
        if (cmd.enable_noalias_to_md_conversion) {
            len +%= 34;
        }
        if (cmd.enable_nonnull_arg_prop) {
            len +%= 26;
        }
        if (cmd.enable_nontrivial_unswitch) {
            len +%= 29;
        }
        if (cmd.enable_npm_O3_nontrivial_unswitch) {
            len +%= 36;
        }
        if (cmd.enable_npm_pgo_inline_deferral) {
            len +%= 33;
        }
        if (cmd.enable_npm_synthetic_counts) {
            len +%= 30;
        }
        if (cmd.enable_objc_arc_opts) {
            len +%= 23;
        }
        if (cmd.enable_order_file_instrumentation) {
            len +%= 36;
        }
        if (cmd.enable_partial_inlining) {
            len +%= 26;
        }
        if (cmd.enable_patchpoint_liveness) {
            len +%= 29;
        }
        if (cmd.enable_phi_of_ops) {
            len +%= 20;
        }
        if (cmd.enable_pipeliner) {
            len +%= 19;
        }
        if (cmd.enable_pipeliner_opt_size) {
            len +%= 28;
        }
        if (cmd.enable_post_misched) {
            len +%= 22;
        }
        if (cmd.enable_post_pgo_loop_rotation) {
            len +%= 32;
        }
        if (cmd.enable_ppc_branch_coalesce) {
            len +%= 29;
        }
        if (cmd.enable_ppc_extra_toc_reg_deps) {
            len +%= 32;
        }
        if (cmd.enable_ppc_gen_scalar_mass) {
            len +%= 29;
        }
        if (cmd.enable_ppc_prefetching) {
            len +%= 25;
        }
        if (cmd.enable_pre) {
            len +%= 13;
        }
        if (cmd.enable_save_restore_long) {
            len +%= 27;
        }
        if (cmd.enable_scalable_autovec_in_streaming_mode) {
            len +%= 44;
        }
        if (cmd.enable_scc_inline_advisor_printing) {
            len +%= 37;
        }
        if (cmd.enable_scoped_noalias) {
            len +%= 24;
        }
        if (cmd.enable_selectiondag_sp) {
            len +%= 25;
        }
        if (cmd.enable_shrink_wrap) {
            len +%= 21;
        }
        if (cmd.enable_sign_dependent_rounding_fp_math) {
            len +%= 41;
        }
        if (cmd.enable_split_backedge_in_load_pre) {
            len +%= 36;
        }
        if (cmd.enable_split_machine_functions) {
            len +%= 33;
        }
        if (cmd.enable_stackovf_sanitizer) {
            len +%= 28;
        }
        if (cmd.enable_store_refinement) {
            len +%= 26;
        }
        if (cmd.enable_subreg_liveness) {
            len +%= 25;
        }
        if (cmd.enable_tail_merge) {
            len +%= 20;
        }
        if (cmd.enable_tbaa) {
            len +%= 14;
        }
        if (cmd.enable_tc_latency_sched) {
            len +%= 26;
        }
        if (cmd.enable_timing_class_latency) {
            len +%= 30;
        }
        if (cmd.enable_unroll_and_jam) {
            len +%= 24;
        }
        if (cmd.enable_unsafe_fp_math) {
            len +%= 24;
        }
        if (cmd.enable_unsafe_globalsmodref_alias_results) {
            len +%= 44;
        }
        if (cmd.enable_unswitch_cost_multiplier) {
            len +%= 34;
        }
        if (cmd.enable_vfe) {
            len +%= 13;
        }
        if (cmd.enable_vplan_native_path) {
            len +%= 27;
        }
        if (cmd.enable_x86_scalar_amx) {
            len +%= 24;
        }
        if (cmd.epilogue_vectorization_force_VF) |epilogue_vectorization_force_VF| {
            len +%= 35 +% fmt.Ud64.length(epilogue_vectorization_force_VF);
        }
        if (cmd.epilogue_vectorization_minimum_VF) |epilogue_vectorization_minimum_VF| {
            len +%= 37 +% fmt.Ud64.length(epilogue_vectorization_minimum_VF);
        }
        if (cmd.exception_model) |exception_model| {
            len +%= 19 +% @tagName(exception_model).len;
        }
        if (cmd.exec_on_ir_change) |exec_on_ir_change| {
            len +%= 21 +% exec_on_ir_change.len;
        }
        if (cmd.exhaustive_register_search) {
            len +%= 29;
        }
        if (cmd.expand_all_fp_mlx) {
            len +%= 20;
        }
        if (cmd.expand_condsets_coa_limit) |expand_condsets_coa_limit| {
            len +%= 29 +% fmt.Ud64.length(expand_condsets_coa_limit);
        }
        if (cmd.expand_condsets_tfr_limit) |expand_condsets_tfr_limit| {
            len +%= 29 +% fmt.Ud64.length(expand_condsets_tfr_limit);
        }
        if (cmd.expand_constant_exprs) {
            len +%= 24;
        }
        if (cmd.expand_div_rem_bits) |expand_div_rem_bits| {
            len +%= 23 +% fmt.Ud64.length(expand_div_rem_bits);
        }
        if (cmd.expand_fp_convert_bits) |expand_fp_convert_bits| {
            len +%= 26 +% fmt.Ud64.length(expand_fp_convert_bits);
        }
        if (cmd.expand_limit) |expand_limit| {
            len +%= 16 +% fmt.Ud64.length(expand_limit);
        }
        if (cmd.expandvp_override_evl_transform) |expandvp_override_evl_transform| {
            len +%= 35 +% expandvp_override_evl_transform.len;
        }
        if (cmd.expandvp_override_mask_transform) |expandvp_override_mask_transform| {
            len +%= 36 +% expandvp_override_mask_transform.len;
        }
        if (cmd.experimental_debug_variable_locations) {
            len +%= 40;
        }
        if (cmd.expose_ppc_andi_glue_bug) {
            len +%= 27;
        }
        if (cmd.ext_tsp_apply_without_profile) {
            len +%= 32;
        }
        if (cmd.extra_vectorizer_passes) {
            len +%= 26;
        }
        if (cmd.extract_blocks_erase_funcs) {
            len +%= 29;
        }
        if (cmd.extract_blocks_file) |extract_blocks_file| {
            len +%= 23 +% extract_blocks_file.len;
        }
        if (cmd.extract_cutoff) |extract_cutoff| {
            len +%= 18 +% fmt.Ud64.length(extract_cutoff);
        }
        if (cmd.extract_needand) {
            len +%= 18;
        }
        if (cmd.extract_nosr0) {
            len +%= 16;
        }
        if (cmd.fast_cluster_threshold) |fast_cluster_threshold| {
            len +%= 26 +% fmt.Ud64.length(fast_cluster_threshold);
        }
        if (cmd.fast_isel) {
            len +%= 12;
        }
        if (cmd.fast_isel_abort) |fast_isel_abort| {
            len +%= 19 +% fmt.Ud64.length(fast_isel_abort);
        }
        if (cmd.fast_isel_report_on_fallback) {
            len +%= 31;
        }
        if (cmd.fatal_warnings) {
            len +%= 17;
        }
        if (cmd.ffast_math) {
            len +%= 13;
        }
        if (cmd.filetype) |filetype| {
            len +%= 12 +% @tagName(filetype).len;
        }
        if (cmd.filter_passes) |filter_passes| {
            len +%= 17 +% filter_passes.len;
        }
        if (cmd.filter_print_funcs) |filter_print_funcs| {
            for (filter_print_funcs) |value| {
                len +%= 22 +% value.len;
            }
        }
        if (cmd.fixup_allow_gcptr_in_csr) {
            len +%= 27;
        }
        if (cmd.fixup_byte_word_insts) {
            len +%= 24;
        }
        if (cmd.fixup_max_csr_statepoints) |fixup_max_csr_statepoints| {
            len +%= 29 +% fmt.Ud64.length(fixup_max_csr_statepoints);
        }
        if (cmd.fixup_scs_enable_copy_propagation) {
            len +%= 36;
        }
        if (cmd.fixup_scs_extend_slot_size) {
            len +%= 29;
        }
        if (cmd.flat_loop_tripcount_threshold) |flat_loop_tripcount_threshold| {
            len +%= 33 +% fmt.Ud64.length(flat_loop_tripcount_threshold);
        }
        if (cmd.flattened_profile_used) {
            len +%= 25;
        }
        if (cmd.float_abi) |float_abi| {
            len +%= 13 +% @tagName(float_abi).len;
        }
        if (cmd.float2int_max_integer_bw) |float2int_max_integer_bw| {
            len +%= 28 +% fmt.Ud64.length(float2int_max_integer_bw);
        }
        if (cmd.force_attribute) |force_attribute| {
            len +%= 19 +% force_attribute.len;
        }
        if (cmd.force_chr) {
            len +%= 12;
        }
        if (cmd.force_dwarf_frame_section) {
            len +%= 28;
        }
        if (cmd.force_fast_cluster) {
            len +%= 21;
        }
        if (cmd.force_function_specialization) {
            len +%= 32;
        }
        if (cmd.force_fuse_matrix) {
            len +%= 20;
        }
        if (cmd.force_hardware_loop_guard) {
            len +%= 28;
        }
        if (cmd.force_hardware_loop_phi) {
            len +%= 26;
        }
        if (cmd.force_hardware_loops) {
            len +%= 23;
        }
        if (cmd.force_hvx_float) {
            len +%= 18;
        }
        if (cmd.force_import_all) {
            len +%= 19;
        }
        if (cmd.force_instr_ref_livedebugvalues) {
            len +%= 34;
        }
        if (cmd.force_legal_indexing) {
            len +%= 23;
        }
        if (cmd.force_loop_cold_block) {
            len +%= 24;
        }
        if (cmd.force_mips_long_branch) {
            len +%= 25;
        }
        if (cmd.force_nested_hardware_loop) {
            len +%= 29;
        }
        if (cmd.force_ordered_reductions) {
            len +%= 27;
        }
        if (cmd.force_pgso) {
            len +%= 13;
        }
        if (cmd.force_precise_rotation_cost) {
            len +%= 30;
        }
        if (cmd.force_remove_attribute) |force_remove_attribute| {
            len +%= 26 +% force_remove_attribute.len;
        }
        if (cmd.force_split_store) {
            len +%= 20;
        }
        if (cmd.force_streaming_compatible_sve) {
            len +%= 33;
        }
        if (cmd.force_summary_edges_cold) |force_summary_edges_cold| {
            len +%= 28 +% @tagName(force_summary_edges_cold).len;
        }
        if (cmd.force_target_instruction_cost) |force_target_instruction_cost| {
            len +%= 33 +% fmt.Ud64.length(force_target_instruction_cost);
        }
        if (cmd.force_target_max_scalar_interleave) |force_target_max_scalar_interleave| {
            len +%= 38 +% fmt.Ud64.length(force_target_max_scalar_interleave);
        }
        if (cmd.force_target_max_vector_interleave) |force_target_max_vector_interleave| {
            len +%= 38 +% fmt.Ud64.length(force_target_max_vector_interleave);
        }
        if (cmd.force_target_num_scalar_regs) |force_target_num_scalar_regs| {
            len +%= 32 +% fmt.Ud64.length(force_target_num_scalar_regs);
        }
        if (cmd.force_target_num_vector_regs) |force_target_num_vector_regs| {
            len +%= 32 +% fmt.Ud64.length(force_target_num_vector_regs);
        }
        if (cmd.force_target_supports_scalable_vectors) {
            len +%= 41;
        }
        if (cmd.force_vector_interleave) |force_vector_interleave| {
            len +%= 27 +% fmt.Ud64.length(force_vector_interleave);
        }
        if (cmd.force_vector_width) |force_vector_width| {
            len +%= 22 +% fmt.Ud64.length(force_vector_width);
        }
        if (cmd.force_widen_divrem_via_safe_divisor) {
            len +%= 38;
        }
        if (cmd.forget_scev_loop_unroll) {
            len +%= 26;
        }
        if (cmd.forward_switch_cond) {
            len +%= 22;
        }
        if (cmd.fp_contract) |fp_contract| {
            len +%= 15 +% @tagName(fp_contract).len;
        }
        if (cmd.frame_helper_size_threshold) |frame_helper_size_threshold| {
            len +%= 31 +% fmt.Ud64.length(frame_helper_size_threshold);
        }
        if (cmd.frame_pointer) |frame_pointer| {
            len +%= 17 +% @tagName(frame_pointer).len;
        }
        if (cmd.freeze_loop_unswitch_cond) {
            len +%= 28;
        }
        if (cmd.fs_no_final_discrim) {
            len +%= 22;
        }
        if (cmd.fs_profile_debug_bw_threshold) |fs_profile_debug_bw_threshold| {
            len +%= 33 +% fmt.Ud64.length(fs_profile_debug_bw_threshold);
        }
        if (cmd.fs_profile_debug_prob_diff_threshold) |fs_profile_debug_prob_diff_threshold| {
            len +%= 40 +% fmt.Ud64.length(fs_profile_debug_prob_diff_threshold);
        }
        if (cmd.fs_profile_file) |fs_profile_file| {
            len +%= 19 +% fs_profile_file.len;
        }
        if (cmd.fs_remapping_file) |fs_remapping_file| {
            len +%= 21 +% fs_remapping_file.len;
        }
        if (cmd.fs_viewbfi_after) {
            len +%= 19;
        }
        if (cmd.fs_viewbfi_before) {
            len +%= 20;
        }
        if (cmd.func_specialization_avg_iters_cost) |func_specialization_avg_iters_cost| {
            len +%= 38 +% fmt.Ud64.length(func_specialization_avg_iters_cost);
        }
        if (cmd.func_specialization_max_clones) |func_specialization_max_clones| {
            len +%= 34 +% fmt.Ud64.length(func_specialization_max_clones);
        }
        if (cmd.func_specialization_max_iters) |func_specialization_max_iters| {
            len +%= 33 +% fmt.Ud64.length(func_specialization_max_iters);
        }
        if (cmd.func_specialization_on_address) {
            len +%= 33;
        }
        if (cmd.func_specialization_size_threshold) |func_specialization_size_threshold| {
            len +%= 38 +% fmt.Ud64.length(func_specialization_size_threshold);
        }
        if (cmd.function_sections) {
            len +%= 20;
        }
        if (cmd.function_specialization_for_literal_constant) {
            len +%= 47;
        }
        if (cmd.fuse_matrix) {
            len +%= 14;
        }
        if (cmd.fuse_matrix_tile_size) |fuse_matrix_tile_size| {
            len +%= 25 +% fmt.Ud64.length(fuse_matrix_tile_size);
        }
        if (cmd.fuse_matrix_use_loops) {
            len +%= 24;
        }
        if (cmd.gcov_atomic_counter) {
            len +%= 22;
        }
        if (cmd.generate_arange_section) {
            len +%= 26;
        }
        if (cmd.generate_merged_base_profiles) {
            len +%= 32;
        }
        if (cmd.generate_type_units) {
            len +%= 22;
        }
        if (cmd.global_isel) {
            len +%= 14;
        }
        if (cmd.global_isel_abort) |global_isel_abort| {
            len +%= 21 +% @tagName(global_isel_abort).len;
        }
        if (cmd.global_merge_group_by_use) {
            len +%= 28;
        }
        if (cmd.global_merge_ignore_single_use) {
            len +%= 33;
        }
        if (cmd.global_merge_max_offset) |global_merge_max_offset| {
            len +%= 27 +% fmt.Ud64.length(global_merge_max_offset);
        }
        if (cmd.global_merge_on_const) {
            len +%= 24;
        }
        if (cmd.global_merge_on_external) {
            len +%= 27;
        }
        if (cmd.gpsize) |gpsize| {
            len +%= 10 +% fmt.Ud64.length(gpsize);
        }
        if (cmd.greedy_regclass_priority_trumps_globalness) {
            len +%= 45;
        }
        if (cmd.greedy_reverse_local_assignment) {
            len +%= 34;
        }
        if (cmd.grow_region_complexity_budget) |grow_region_complexity_budget| {
            len +%= 33 +% fmt.Ud64.length(grow_region_complexity_budget);
        }
        if (cmd.guard_widening_widen_branch_guards) {
            len +%= 37;
        }
        if (cmd.guards_predicate_pass_branch_weight) |guards_predicate_pass_branch_weight| {
            len +%= 39 +% fmt.Ud64.length(guards_predicate_pass_branch_weight);
        }
        if (cmd.gvn_add_phi_translation) {
            len +%= 26;
        }
        if (cmd.gvn_hoist_max_bbs) |gvn_hoist_max_bbs| {
            len +%= 21 +% fmt.Ud64.length(gvn_hoist_max_bbs);
        }
        if (cmd.gvn_hoist_max_chain_length) |gvn_hoist_max_chain_length| {
            len +%= 30 +% fmt.Ud64.length(gvn_hoist_max_chain_length);
        }
        if (cmd.gvn_hoist_max_depth) |gvn_hoist_max_depth| {
            len +%= 23 +% fmt.Ud64.length(gvn_hoist_max_depth);
        }
        if (cmd.gvn_max_block_speculations) |gvn_max_block_speculations| {
            len +%= 30 +% fmt.Ud64.length(gvn_max_block_speculations);
        }
        if (cmd.gvn_max_hoisted) |gvn_max_hoisted| {
            len +%= 19 +% fmt.Ud64.length(gvn_max_hoisted);
        }
        if (cmd.gvn_max_num_deps) |gvn_max_num_deps| {
            len +%= 20 +% fmt.Ud64.length(gvn_max_num_deps);
        }
        if (cmd.gvn_max_num_visited_insts) |gvn_max_num_visited_insts| {
            len +%= 29 +% fmt.Ud64.length(gvn_max_num_visited_insts);
        }
        if (cmd.hardware_loop_counter_bitwidth) |hardware_loop_counter_bitwidth| {
            len +%= 34 +% fmt.Ud64.length(hardware_loop_counter_bitwidth);
        }
        if (cmd.hardware_loop_decrement) |hardware_loop_decrement| {
            len +%= 27 +% fmt.Ud64.length(hardware_loop_decrement);
        }
        if (cmd.hash_based_counter_split) {
            len +%= 27;
        }
        if (cmd.help) {
            len +%= 7;
        }
        if (cmd.help_hidden) {
            len +%= 14;
        }
        if (cmd.help_list) {
            len +%= 12;
        }
        if (cmd.help_list_hidden) {
            len +%= 19;
        }
        if (cmd.hexagon_align_loads) {
            len +%= 22;
        }
        if (cmd.hexagon_amode_growth_limit) |hexagon_amode_growth_limit| {
            len +%= 30 +% fmt.Ud64.length(hexagon_amode_growth_limit);
        }
        if (cmd.hexagon_autohvx) {
            len +%= 18;
        }
        if (cmd.hexagon_bit) {
            len +%= 14;
        }
        if (cmd.hexagon_cext) {
            len +%= 15;
        }
        if (cmd.hexagon_cext_limit) |hexagon_cext_limit| {
            len +%= 22 +% fmt.Ud64.length(hexagon_cext_limit);
        }
        if (cmd.hexagon_cext_threshold) |hexagon_cext_threshold| {
            len +%= 26 +% fmt.Ud64.length(hexagon_cext_threshold);
        }
        if (cmd.hexagon_check_bank_conflict) {
            len +%= 30;
        }
        if (cmd.hexagon_commgep) {
            len +%= 18;
        }
        if (cmd.hexagon_disable_args_min_alignment) {
            len +%= 37;
        }
        if (cmd.hexagon_eif) {
            len +%= 14;
        }
        if (cmd.hexagon_emit_jt_text) {
            len +%= 23;
        }
        if (cmd.hexagon_emit_jump_tables) {
            len +%= 27;
        }
        if (cmd.hexagon_emit_lookup_tables) {
            len +%= 29;
        }
        if (cmd.hexagon_emit_lut_text) {
            len +%= 24;
        }
        if (cmd.hexagon_enable_branch_prediction) {
            len +%= 35;
        }
        if (cmd.hexagon_expand_condsets) {
            len +%= 26;
        }
        if (cmd.hexagon_extract) {
            len +%= 18;
        }
        if (cmd.hexagon_fp_elim) {
            len +%= 18;
        }
        if (cmd.hexagon_frame_index_reuse_limit) |hexagon_frame_index_reuse_limit| {
            len +%= 35 +% fmt.Ud64.length(hexagon_frame_index_reuse_limit);
        }
        if (cmd.hexagon_frame_index_search_range) |hexagon_frame_index_search_range| {
            len +%= 36 +% fmt.Ud64.length(hexagon_frame_index_search_range);
        }
        if (cmd.hexagon_gen_mux_threshold) |hexagon_gen_mux_threshold| {
            len +%= 29 +% fmt.Ud64.length(hexagon_gen_mux_threshold);
        }
        if (cmd.hexagon_gen_pred) {
            len +%= 19;
        }
        if (cmd.hexagon_hvx_widen) |hexagon_hvx_widen| {
            len +%= 21 +% fmt.Ud64.length(hexagon_hvx_widen);
        }
        if (cmd.hexagon_hwloop_preheader) {
            len +%= 27;
        }
        if (cmd.hexagon_initial_cfg_cleanup) {
            len +%= 30;
        }
        if (cmd.hexagon_insert) {
            len +%= 17;
        }
        if (cmd.hexagon_instsimplify) {
            len +%= 23;
        }
        if (cmd.hexagon_isel_su) {
            len +%= 18;
        }
        if (cmd.hexagon_long_calls) {
            len +%= 21;
        }
        if (cmd.hexagon_loop_prefetch) {
            len +%= 24;
        }
        if (cmd.hexagon_loop_range) |hexagon_loop_range| {
            len +%= 22 +% fmt.Ud64.length(hexagon_loop_range);
        }
        if (cmd.hexagon_loop_resched) {
            len +%= 23;
        }
        if (cmd.hexagon_masked_vmem) {
            len +%= 22;
        }
        if (cmd.hexagon_mux) {
            len +%= 14;
        }
        if (cmd.hexagon_noopt) {
            len +%= 16;
        }
        if (cmd.hexagon_opt_spill) {
            len +%= 20;
        }
        if (cmd.hexagon_opt_vextract) {
            len +%= 23;
        }
        if (cmd.hexagon_packetize_volatiles) {
            len +%= 30;
        }
        if (cmd.hexagon_pred_calls) {
            len +%= 21;
        }
        if (cmd.hexagon_sched_inline_asm) {
            len +%= 27;
        }
        if (cmd.hexagon_shrink_frame) {
            len +%= 23;
        }
        if (cmd.hexagon_small_data_threshold) |hexagon_small_data_threshold| {
            len +%= 32 +% fmt.Ud64.length(hexagon_small_data_threshold);
        }
        if (cmd.hexagon_statics_in_small_data) {
            len +%= 32;
        }
        if (cmd.hexagon_subreg_liveness) {
            len +%= 26;
        }
        if (cmd.hexagon_vector_combine) {
            len +%= 25;
        }
        if (cmd.hexagon_vextract_threshold) |hexagon_vextract_threshold| {
            len +%= 30 +% fmt.Ud64.length(hexagon_vextract_threshold);
        }
        if (cmd.hexagon_vlcr_iteration_lim) |hexagon_vlcr_iteration_lim| {
            len +%= 30 +% fmt.Ud64.length(hexagon_vlcr_iteration_lim);
        }
        if (cmd.hexbit_bitsplit) {
            len +%= 18;
        }
        if (cmd.hexbit_extract) {
            len +%= 17;
        }
        if (cmd.hexbit_keep_tied) {
            len +%= 19;
        }
        if (cmd.hexbit_max_bitsplit) |hexbit_max_bitsplit| {
            len +%= 23 +% fmt.Ud64.length(hexbit_max_bitsplit);
        }
        if (cmd.hexbit_max_extract) |hexbit_max_extract| {
            len +%= 22 +% fmt.Ud64.length(hexbit_max_extract);
        }
        if (cmd.hexbit_registerset_limit) |hexbit_registerset_limit| {
            len +%= 28 +% fmt.Ud64.length(hexbit_registerset_limit);
        }
        if (cmd.hints_allow_reordering) {
            len +%= 25;
        }
        if (cmd.hlir_simplify_limit) |hlir_simplify_limit| {
            len +%= 23 +% fmt.Ud64.length(hlir_simplify_limit);
        }
        if (cmd.hoist_cheap_insts) {
            len +%= 20;
        }
        if (cmd.hoist_common_insts) {
            len +%= 21;
        }
        if (cmd.hoist_const_stores) {
            len +%= 21;
        }
        if (cmd.homogeneous_prolog_epilog) {
            len +%= 28;
        }
        if (cmd.hot_callsite_rel_freq) |hot_callsite_rel_freq| {
            len +%= 25 +% fmt.Ud64.length(hot_callsite_rel_freq);
        }
        if (cmd.hot_callsite_threshold) |hot_callsite_threshold| {
            len +%= 26 +% fmt.Ud64.length(hot_callsite_threshold);
        }
        if (cmd.hot_cold_split) {
            len +%= 17;
        }
        if (cmd.hot_cold_static_analysis) {
            len +%= 27;
        }
        if (cmd.hotcoldsplit_cold_section_name) |hotcoldsplit_cold_section_name| {
            len +%= 34 +% hotcoldsplit_cold_section_name.len;
        }
        if (cmd.hotcoldsplit_max_params) |hotcoldsplit_max_params| {
            len +%= 27 +% fmt.Ud64.length(hotcoldsplit_max_params);
        }
        if (cmd.hotcoldsplit_threshold) |hotcoldsplit_threshold| {
            len +%= 26 +% fmt.Ud64.length(hotcoldsplit_threshold);
        }
        if (cmd.hsdr_no_mem) {
            len +%= 14;
        }
        if (cmd.hsdr_split_all) {
            len +%= 17;
        }
        if (cmd.huge_size_for_split) |huge_size_for_split| {
            len +%= 23 +% fmt.Ud64.length(huge_size_for_split);
        }
        if (cmd.hwasan_experimental_use_page_aliases) {
            len +%= 39;
        }
        if (cmd.hwasan_generate_tags_with_calls) {
            len +%= 34;
        }
        if (cmd.hwasan_globals) {
            len +%= 17;
        }
        if (cmd.hwasan_inline_all_checks) {
            len +%= 27;
        }
        if (cmd.hwasan_instrument_atomics) {
            len +%= 28;
        }
        if (cmd.hwasan_instrument_byval) {
            len +%= 26;
        }
        if (cmd.hwasan_instrument_landing_pads) {
            len +%= 33;
        }
        if (cmd.hwasan_instrument_mem_intrinsics) {
            len +%= 35;
        }
        if (cmd.hwasan_instrument_personality_functions) {
            len +%= 42;
        }
        if (cmd.hwasan_instrument_reads) {
            len +%= 26;
        }
        if (cmd.hwasan_instrument_stack) {
            len +%= 26;
        }
        if (cmd.hwasan_instrument_with_calls) {
            len +%= 31;
        }
        if (cmd.hwasan_instrument_writes) {
            len +%= 27;
        }
        if (cmd.hwasan_kernel) {
            len +%= 16;
        }
        if (cmd.hwasan_kernel_mem_intrinsic_prefix) {
            len +%= 37;
        }
        if (cmd.hwasan_mapping_offset) |hwasan_mapping_offset| {
            len +%= 25 +% fmt.Ud64.length(hwasan_mapping_offset);
        }
        if (cmd.hwasan_match_all_tag) |hwasan_match_all_tag| {
            len +%= 24 +% fmt.Ud64.length(hwasan_match_all_tag);
        }
        if (cmd.hwasan_memory_access_callback_prefix) |hwasan_memory_access_callback_prefix| {
            len +%= 40 +% hwasan_memory_access_callback_prefix.len;
        }
        if (cmd.hwasan_record_stack_history) |hwasan_record_stack_history| {
            len +%= 31 +% @tagName(hwasan_record_stack_history).len;
        }
        if (cmd.hwasan_recover) {
            len +%= 17;
        }
        if (cmd.hwasan_uar_retag_to_zero) {
            len +%= 27;
        }
        if (cmd.hwasan_use_after_scope) {
            len +%= 25;
        }
        if (cmd.hwasan_use_short_granules) {
            len +%= 28;
        }
        if (cmd.hwasan_use_stack_safety) {
            len +%= 26;
        }
        if (cmd.hwasan_with_ifunc) {
            len +%= 20;
        }
        if (cmd.hwasan_with_tls) {
            len +%= 18;
        }
        if (cmd.hwloop_spec_preheader) {
            len +%= 24;
        }
        if (cmd.icp_call_only) {
            len +%= 16;
        }
        if (cmd.icp_csskip) |icp_csskip| {
            len +%= 14 +% fmt.Ud64.length(icp_csskip);
        }
        if (cmd.icp_cutoff) |icp_cutoff| {
            len +%= 14 +% fmt.Ud64.length(icp_cutoff);
        }
        if (cmd.icp_dumpafter) {
            len +%= 16;
        }
        if (cmd.icp_invoke_only) {
            len +%= 18;
        }
        if (cmd.icp_lto) {
            len +%= 10;
        }
        if (cmd.icp_max_annotations) |icp_max_annotations| {
            len +%= 23 +% fmt.Ud64.length(icp_max_annotations);
        }
        if (cmd.icp_max_prom) |icp_max_prom| {
            len +%= 16 +% fmt.Ud64.length(icp_max_prom);
        }
        if (cmd.icp_remaining_percent_threshold) |icp_remaining_percent_threshold| {
            len +%= 35 +% fmt.Ud64.length(icp_remaining_percent_threshold);
        }
        if (cmd.icp_samplepgo) {
            len +%= 16;
        }
        if (cmd.icp_total_percent_threshold) |icp_total_percent_threshold| {
            len +%= 31 +% fmt.Ud64.length(icp_total_percent_threshold);
        }
        if (cmd.ifcvt_branch_fold) {
            len +%= 20;
        }
        if (cmd.ifcvt_fn_start) |ifcvt_fn_start| {
            len +%= 18 +% fmt.Ud64.length(ifcvt_fn_start);
        }
        if (cmd.ifcvt_fn_stop) |ifcvt_fn_stop| {
            len +%= 17 +% fmt.Ud64.length(ifcvt_fn_stop);
        }
        if (cmd.ifcvt_limit) |ifcvt_limit| {
            len +%= 15 +% fmt.Ud64.length(ifcvt_limit);
        }
        if (cmd.ignore_bb_reg_pressure) {
            len +%= 25;
        }
        if (cmd.ignore_tti_inline_compatible) {
            len +%= 31;
        }
        if (cmd.ignore_xcoff_visibility) {
            len +%= 26;
        }
        if (cmd.imp_null_check_page_size) |imp_null_check_page_size| {
            len +%= 28 +% fmt.Ud64.length(imp_null_check_page_size);
        }
        if (cmd.imp_null_max_insts_to_consider) |imp_null_max_insts_to_consider| {
            len +%= 34 +% fmt.Ud64.length(imp_null_max_insts_to_consider);
        }
        if (cmd.import_all_index) {
            len +%= 19;
        }
        if (cmd.import_cold_multiplier) |import_cold_multiplier| {
            len +%= 26 +% fmt.Ud64.length(import_cold_multiplier);
        }
        if (cmd.import_constants_with_refs) {
            len +%= 29;
        }
        if (cmd.import_critical_multiplier) |import_critical_multiplier| {
            len +%= 30 +% fmt.Ud64.length(import_critical_multiplier);
        }
        if (cmd.import_cutoff) |import_cutoff| {
            len +%= 17 +% fmt.Ud64.length(import_cutoff);
        }
        if (cmd.import_full_type_definitions) {
            len +%= 31;
        }
        if (cmd.import_hot_evolution_factor) |import_hot_evolution_factor| {
            len +%= 31 +% fmt.Ud64.length(import_hot_evolution_factor);
        }
        if (cmd.import_hot_multiplier) |import_hot_multiplier| {
            len +%= 25 +% fmt.Ud64.length(import_hot_multiplier);
        }
        if (cmd.import_instr_evolution_factor) |import_instr_evolution_factor| {
            len +%= 33 +% fmt.Ud64.length(import_instr_evolution_factor);
        }
        if (cmd.import_instr_limit) |import_instr_limit| {
            len +%= 22 +% fmt.Ud64.length(import_instr_limit);
        }
        if (cmd.incremental_linker_compatible) {
            len +%= 32;
        }
        if (cmd.indvars_post_increment_ranges) {
            len +%= 32;
        }
        if (cmd.indvars_predicate_loops) {
            len +%= 26;
        }
        if (cmd.indvars_widen_indvars) {
            len +%= 24;
        }
        if (cmd.info_output_file) |info_output_file| {
            len +%= 20 +% info_output_file.len;
        }
        if (cmd.initial_synthetic_count) |initial_synthetic_count| {
            len +%= 27 +% fmt.Ud64.length(initial_synthetic_count);
        }
        if (cmd.inline_call_penalty) |inline_call_penalty| {
            len +%= 23 +% fmt.Ud64.length(inline_call_penalty);
        }
        if (cmd.inline_caller_superset_nobuiltin) {
            len +%= 35;
        }
        if (cmd.inline_cold_callsite_threshold) |inline_cold_callsite_threshold| {
            len +%= 34 +% fmt.Ud64.length(inline_cold_callsite_threshold);
        }
        if (cmd.inline_cost_full) {
            len +%= 19;
        }
        if (cmd.inline_deferral) {
            len +%= 18;
        }
        if (cmd.inline_deferral_scale) |inline_deferral_scale| {
            len +%= 25 +% fmt.Ud64.length(inline_deferral_scale);
        }
        if (cmd.inline_enable_cost_benefit_analysis) {
            len +%= 38;
        }
        if (cmd.inline_instr_cost) |inline_instr_cost| {
            len +%= 21 +% fmt.Ud64.length(inline_instr_cost);
        }
        if (cmd.inline_max_stacksize) |inline_max_stacksize| {
            len +%= 24 +% fmt.Ud64.length(inline_max_stacksize);
        }
        if (cmd.inline_memaccess_cost) |inline_memaccess_cost| {
            len +%= 25 +% fmt.Ud64.length(inline_memaccess_cost);
        }
        if (cmd.inline_priority_mode) |inline_priority_mode| {
            len +%= 24 +% @tagName(inline_priority_mode).len;
        }
        if (cmd.inline_remark_attribute) {
            len +%= 26;
        }
        if (cmd.inline_savings_multiplier) |inline_savings_multiplier| {
            len +%= 29 +% fmt.Ud64.length(inline_savings_multiplier);
        }
        if (cmd.inline_size_allowance) |inline_size_allowance| {
            len +%= 25 +% fmt.Ud64.length(inline_size_allowance);
        }
        if (cmd.inline_synthetic_count) |inline_synthetic_count| {
            len +%= 26 +% fmt.Ud64.length(inline_synthetic_count);
        }
        if (cmd.inline_threshold) |inline_threshold| {
            len +%= 20 +% fmt.Ud64.length(inline_threshold);
        }
        if (cmd.inlinecold_threshold) |inlinecold_threshold| {
            len +%= 24 +% fmt.Ud64.length(inlinecold_threshold);
        }
        if (cmd.inlinedefault_threshold) |inlinedefault_threshold| {
            len +%= 27 +% fmt.Ud64.length(inlinedefault_threshold);
        }
        if (cmd.inlinehint_threshold) |inlinehint_threshold| {
            len +%= 24 +% fmt.Ud64.length(inlinehint_threshold);
        }
        if (cmd.inliner_function_import_stats) |inliner_function_import_stats| {
            len +%= 33 +% @tagName(inliner_function_import_stats).len;
        }
        if (cmd.insert_all0) {
            len +%= 14;
        }
        if (cmd.insert_const) {
            len +%= 15;
        }
        if (cmd.insert_dist_cutoff) |insert_dist_cutoff| {
            len +%= 22 +% fmt.Ud64.length(insert_dist_cutoff);
        }
        if (cmd.insert_has0) {
            len +%= 14;
        }
        if (cmd.insert_max_ifmap) |insert_max_ifmap| {
            len +%= 20 +% fmt.Ud64.length(insert_max_ifmap);
        }
        if (cmd.insert_max_orl) |insert_max_orl| {
            len +%= 18 +% fmt.Ud64.length(insert_max_orl);
        }
        if (cmd.insert_timing) {
            len +%= 16;
        }
        if (cmd.insert_timing_detail) {
            len +%= 23;
        }
        if (cmd.insert_vreg_cutoff) |insert_vreg_cutoff| {
            len +%= 22 +% fmt.Ud64.length(insert_vreg_cutoff);
        }
        if (cmd.instcombine_code_sinking) {
            len +%= 27;
        }
        if (cmd.instcombine_guard_widening_window) |instcombine_guard_widening_window| {
            len +%= 37 +% fmt.Ud64.length(instcombine_guard_widening_window);
        }
        if (cmd.instcombine_infinite_loop_threshold) |instcombine_infinite_loop_threshold| {
            len +%= 39 +% fmt.Ud64.length(instcombine_infinite_loop_threshold);
        }
        if (cmd.instcombine_lower_dbg_declare) |instcombine_lower_dbg_declare| {
            len +%= 33 +% fmt.Ud64.length(instcombine_lower_dbg_declare);
        }
        if (cmd.instcombine_max_copied_from_constant_users) |instcombine_max_copied_from_constant_users| {
            len +%= 46 +% fmt.Ud64.length(instcombine_max_copied_from_constant_users);
        }
        if (cmd.instcombine_max_iterations) |instcombine_max_iterations| {
            len +%= 30 +% fmt.Ud64.length(instcombine_max_iterations);
        }
        if (cmd.instcombine_max_num_phis) |instcombine_max_num_phis| {
            len +%= 28 +% fmt.Ud64.length(instcombine_max_num_phis);
        }
        if (cmd.instcombine_max_sink_users) |instcombine_max_sink_users| {
            len +%= 30 +% fmt.Ud64.length(instcombine_max_sink_users);
        }
        if (cmd.instcombine_maxarray_size) |instcombine_maxarray_size| {
            len +%= 29 +% fmt.Ud64.length(instcombine_maxarray_size);
        }
        if (cmd.instcombine_negator_enabled) {
            len +%= 30;
        }
        if (cmd.instcombine_negator_max_depth) |instcombine_negator_max_depth| {
            len +%= 33 +% fmt.Ud64.length(instcombine_negator_max_depth);
        }
        if (cmd.instrprof_atomic_counter_update_all) {
            len +%= 38;
        }
        if (cmd.interleave_loops) {
            len +%= 19;
        }
        if (cmd.interleave_small_loop_scalar_reduction) {
            len +%= 41;
        }
        if (cmd.internalize_public_api_file) |internalize_public_api_file| {
            len +%= 31 +% internalize_public_api_file.len;
        }
        if (cmd.internalize_public_api_list) {
            len +%= 30;
        }
        if (cmd.interpreter_print_volatile) {
            len +%= 29;
        }
        if (cmd.intra_scc_cost_multiplier) |intra_scc_cost_multiplier| {
            len +%= 29 +% fmt.Ud64.length(intra_scc_cost_multiplier);
        }
        if (cmd.ir_outliner) {
            len +%= 14;
        }
        if (cmd.irce_allow_narrow_latch) {
            len +%= 26;
        }
        if (cmd.irce_allow_unsigned_latch) {
            len +%= 28;
        }
        if (cmd.irce_loop_size_cutoff) |irce_loop_size_cutoff| {
            len +%= 25 +% fmt.Ud64.length(irce_loop_size_cutoff);
        }
        if (cmd.irce_min_runtime_iterations) |irce_min_runtime_iterations| {
            len +%= 31 +% fmt.Ud64.length(irce_min_runtime_iterations);
        }
        if (cmd.irce_print_changed_loops) {
            len +%= 27;
        }
        if (cmd.irce_print_range_checks) {
            len +%= 26;
        }
        if (cmd.irce_skip_profitability_checks) {
            len +%= 33;
        }
        if (cmd.isel_rebalance_addr) {
            len +%= 22;
        }
        if (cmd.iterative_bfi_max_iterations_per_block) |iterative_bfi_max_iterations_per_block| {
            len +%= 42 +% fmt.Ud64.length(iterative_bfi_max_iterations_per_block);
        }
        if (cmd.iterative_bfi_precision) |iterative_bfi_precision| {
            len +%= 27 +% fmt.Ud64.length(iterative_bfi_precision);
        }
        if (cmd.iterative_counter_promotion) {
            len +%= 30;
        }
        if (cmd.join_globalcopies) {
            len +%= 20;
        }
        if (cmd.join_liveintervals) {
            len +%= 21;
        }
        if (cmd.join_splitedges) {
            len +%= 18;
        }
        if (cmd.jump_inst_cost) |jump_inst_cost| {
            len +%= 18 +% fmt.Ud64.length(jump_inst_cost);
        }
        if (cmd.jump_is_expensive) {
            len +%= 20;
        }
        if (cmd.jump_table_density) |jump_table_density| {
            len +%= 22 +% fmt.Ud64.length(jump_table_density);
        }
        if (cmd.jump_threading_across_loop_headers) {
            len +%= 37;
        }
        if (cmd.jump_threading_implication_search_threshold) |jump_threading_implication_search_threshold| {
            len +%= 47 +% fmt.Ud64.length(jump_threading_implication_search_threshold);
        }
        if (cmd.jump_threading_phi_threshold) |jump_threading_phi_threshold| {
            len +%= 32 +% fmt.Ud64.length(jump_threading_phi_threshold);
        }
        if (cmd.jump_threading_threshold) |jump_threading_threshold| {
            len +%= 28 +% fmt.Ud64.length(jump_threading_threshold);
        }
        if (cmd.keep_inline_advisor_for_printing) {
            len +%= 35;
        }
        if (cmd.keep_loops) {
            len +%= 13;
        }
        if (cmd.lanai_constant_mul_threshold) |lanai_constant_mul_threshold| {
            len +%= 32 +% fmt.Ud64.length(lanai_constant_mul_threshold);
        }
        if (cmd.lanai_nop_delay_filler) {
            len +%= 25;
        }
        if (cmd.lanai_ssection_threshold) |lanai_ssection_threshold| {
            len +%= 28 +% fmt.Ud64.length(lanai_ssection_threshold);
        }
        if (cmd.large_interval_freq_threshold) |large_interval_freq_threshold| {
            len +%= 33 +% fmt.Ud64.length(large_interval_freq_threshold);
        }
        if (cmd.large_interval_size_threshold) |large_interval_size_threshold| {
            len +%= 33 +% fmt.Ud64.length(large_interval_size_threshold);
        }
        if (cmd.late_remat_update_threshold) |late_remat_update_threshold| {
            len +%= 31 +% fmt.Ud64.length(late_remat_update_threshold);
        }
        if (cmd.lcr_max_depth) |lcr_max_depth| {
            len +%= 17 +% fmt.Ud64.length(lcr_max_depth);
        }
        if (cmd.lcr_max_interf) |lcr_max_interf| {
            len +%= 18 +% fmt.Ud64.length(lcr_max_interf);
        }
        if (cmd.ldstmemcpy_glue_max) |ldstmemcpy_glue_max| {
            len +%= 23 +% fmt.Ud64.length(ldstmemcpy_glue_max);
        }
        if (cmd.licm_control_flow_hoisting) {
            len +%= 29;
        }
        if (cmd.licm_force_thread_model_single) {
            len +%= 33;
        }
        if (cmd.licm_max_num_uses_traversed) |licm_max_num_uses_traversed| {
            len +%= 31 +% fmt.Ud64.length(licm_max_num_uses_traversed);
        }
        if (cmd.licm_mssa_max_acc_promotion) |licm_mssa_max_acc_promotion| {
            len +%= 31 +% fmt.Ud64.length(licm_mssa_max_acc_promotion);
        }
        if (cmd.licm_mssa_optimization_cap) |licm_mssa_optimization_cap| {
            len +%= 30 +% fmt.Ud64.length(licm_mssa_optimization_cap);
        }
        if (cmd.licm_versioning_invariant_threshold) |licm_versioning_invariant_threshold| {
            len +%= 39 +% fmt.Ud64.length(licm_versioning_invariant_threshold);
        }
        if (cmd.licm_versioning_max_depth_threshold) |licm_versioning_max_depth_threshold| {
            len +%= 39 +% fmt.Ud64.length(licm_versioning_max_depth_threshold);
        }
        if (cmd.likely_branch_weight) |likely_branch_weight| {
            len +%= 24 +% fmt.Ud64.length(likely_branch_weight);
        }
        if (cmd.limit_float_precision) |limit_float_precision| {
            len +%= 25 +% fmt.Ud64.length(limit_float_precision);
        }
        if (cmd.live_debug_variables) {
            len +%= 23;
        }
        if (cmd.livedebugvalues_input_bb_limit) |livedebugvalues_input_bb_limit| {
            len +%= 34 +% fmt.Ud64.length(livedebugvalues_input_bb_limit);
        }
        if (cmd.livedebugvalues_input_dbg_value_limit) |livedebugvalues_input_dbg_value_limit| {
            len +%= 41 +% fmt.Ud64.length(livedebugvalues_input_dbg_value_limit);
        }
        if (cmd.livedebugvalues_max_stack_slots) |livedebugvalues_max_stack_slots| {
            len +%= 35 +% fmt.Ud64.length(livedebugvalues_max_stack_slots);
        }
        if (cmd.load) |load| {
            len +%= 8 +% load.len;
        }
        if (cmd.locally_hot_callsite_threshold) |locally_hot_callsite_threshold| {
            len +%= 34 +% fmt.Ud64.length(locally_hot_callsite_threshold);
        }
        if (cmd.loongarch_check_zero_division) {
            len +%= 32;
        }
        if (cmd.loongarch_numeric_reg) {
            len +%= 24;
        }
        if (cmd.loop_deletion_enable_symbolic_execution) {
            len +%= 42;
        }
        if (cmd.loop_distribute_non_if_convertible) {
            len +%= 37;
        }
        if (cmd.loop_distribute_scev_check_threshold) |loop_distribute_scev_check_threshold| {
            len +%= 40 +% fmt.Ud64.length(loop_distribute_scev_check_threshold);
        }
        if (cmd.loop_distribute_scev_check_threshold_with_pragma) |loop_distribute_scev_check_threshold_with_pragma| {
            len +%= 52 +% fmt.Ud64.length(loop_distribute_scev_check_threshold_with_pragma);
        }
        if (cmd.loop_distribute_verify) {
            len +%= 25;
        }
        if (cmd.loop_flatten_assume_no_overflow) {
            len +%= 34;
        }
        if (cmd.loop_flatten_cost_threshold) |loop_flatten_cost_threshold| {
            len +%= 31 +% fmt.Ud64.length(loop_flatten_cost_threshold);
        }
        if (cmd.loop_flatten_widen_iv) {
            len +%= 24;
        }
        if (cmd.loop_fusion_dependence_analysis) |loop_fusion_dependence_analysis| {
            len +%= 35 +% @tagName(loop_fusion_dependence_analysis).len;
        }
        if (cmd.loop_fusion_peel_max_count) |loop_fusion_peel_max_count| {
            len +%= 30 +% fmt.Ud64.length(loop_fusion_peel_max_count);
        }
        if (cmd.loop_interchange_threshold) |loop_interchange_threshold| {
            len +%= 30 +% fmt.Ud64.length(loop_interchange_threshold);
        }
        if (cmd.loop_load_elimination_scev_check_threshold) |loop_load_elimination_scev_check_threshold| {
            len +%= 46 +% fmt.Ud64.length(loop_load_elimination_scev_check_threshold);
        }
        if (cmd.loop_predication_enable_count_down_loop) {
            len +%= 42;
        }
        if (cmd.loop_predication_enable_iv_truncation) {
            len +%= 40;
        }
        if (cmd.loop_predication_insert_assumes_of_predicated_guards_conditions) {
            len +%= 66;
        }
        if (cmd.loop_predication_latch_probability_scale) |loop_predication_latch_probability_scale| {
            len +%= 44 +% fmt.Ud64.length(loop_predication_latch_probability_scale);
        }
        if (cmd.loop_predication_predicate_widenable_branches_to_deopt) {
            len +%= 57;
        }
        if (cmd.loop_predication_skip_profitability_checks) {
            len +%= 45;
        }
        if (cmd.loop_prefetch_writes) {
            len +%= 23;
        }
        if (cmd.loop_rotate_multi) {
            len +%= 20;
        }
        if (cmd.loop_to_cold_block_ratio) |loop_to_cold_block_ratio| {
            len +%= 28 +% fmt.Ud64.length(loop_to_cold_block_ratio);
        }
        if (cmd.loop_vectorize_with_block_frequency) {
            len +%= 38;
        }
        if (cmd.loop_version_annotate_no_alias) {
            len +%= 33;
        }
        if (cmd.lower_global_dtors_via_cxa_atexit) {
            len +%= 36;
        }
        if (cmd.lower_interleaved_accesses) {
            len +%= 29;
        }
        if (cmd.lowertypetests_avoid_reuse) {
            len +%= 29;
        }
        if (cmd.lowertypetests_drop_type_tests) {
            len +%= 33;
        }
        if (cmd.lowertypetests_read_summary) |lowertypetests_read_summary| {
            len +%= 31 +% lowertypetests_read_summary.len;
        }
        if (cmd.lowertypetests_summary_action) |lowertypetests_summary_action| {
            len +%= 33 +% @tagName(lowertypetests_summary_action).len;
        }
        if (cmd.lowertypetests_write_summary) |lowertypetests_write_summary| {
            len +%= 32 +% lowertypetests_write_summary.len;
        }
        if (cmd.lsr_complexity_limit) |lsr_complexity_limit| {
            len +%= 24 +% fmt.Ud64.length(lsr_complexity_limit);
        }
        if (cmd.lsr_drop_solution) {
            len +%= 20;
        }
        if (cmd.lsr_exp_narrow) {
            len +%= 17;
        }
        if (cmd.lsr_filter_same_scaled_reg) {
            len +%= 29;
        }
        if (cmd.lsr_insns_cost) {
            len +%= 17;
        }
        if (cmd.lsr_preferred_addressing_mode) |lsr_preferred_addressing_mode| {
            len +%= 33 +% @tagName(lsr_preferred_addressing_mode).len;
        }
        if (cmd.lsr_setupcost_depth_limit) |lsr_setupcost_depth_limit| {
            len +%= 29 +% fmt.Ud64.length(lsr_setupcost_depth_limit);
        }
        if (cmd.lsr_term_fold) {
            len +%= 16;
        }
        if (cmd.lto_aix_system_assembler) |lto_aix_system_assembler| {
            len +%= 28 +% lto_aix_system_assembler.len;
        }
        if (cmd.lto_discard_value_names) {
            len +%= 26;
        }
        if (cmd.lto_embed_bitcode) |lto_embed_bitcode| {
            len +%= 21 +% @tagName(lto_embed_bitcode).len;
        }
        if (cmd.lto_pass_remarks_filter) |lto_pass_remarks_filter| {
            len +%= 27 +% lto_pass_remarks_filter.len;
        }
        if (cmd.lto_pass_remarks_format) |lto_pass_remarks_format| {
            len +%= 27 +% lto_pass_remarks_format.len;
        }
        if (cmd.lto_pass_remarks_hotness_threshold) {
            len +%= 37;
        }
        if (cmd.lto_pass_remarks_output) |lto_pass_remarks_output| {
            len +%= 27 +% lto_pass_remarks_output.len;
        }
        if (cmd.lto_pass_remarks_with_hotness) {
            len +%= 32;
        }
        if (cmd.lto_stats_file) |lto_stats_file| {
            len +%= 18 +% lto_stats_file.len;
        }
        if (cmd.machine_combiner_dump_subst_intrs) {
            len +%= 36;
        }
        if (cmd.machine_combiner_inc_threshold) |machine_combiner_inc_threshold| {
            len +%= 34 +% fmt.Ud64.length(machine_combiner_inc_threshold);
        }
        if (cmd.machine_combiner_verify_pattern_order) {
            len +%= 40;
        }
        if (cmd.machine_outliner_reruns) |machine_outliner_reruns| {
            len +%= 27 +% fmt.Ud64.length(machine_outliner_reruns);
        }
        if (cmd.machine_sink_bfi) {
            len +%= 19;
        }
        if (cmd.machine_sink_cycle_limit) |machine_sink_cycle_limit| {
            len +%= 28 +% fmt.Ud64.length(machine_sink_cycle_limit);
        }
        if (cmd.machine_sink_load_blocks_threshold) |machine_sink_load_blocks_threshold| {
            len +%= 38 +% fmt.Ud64.length(machine_sink_load_blocks_threshold);
        }
        if (cmd.machine_sink_load_instrs_threshold) |machine_sink_load_instrs_threshold| {
            len +%= 38 +% fmt.Ud64.length(machine_sink_load_instrs_threshold);
        }
        if (cmd.machine_sink_split) {
            len +%= 21;
        }
        if (cmd.machine_sink_split_probability_threshold) |machine_sink_split_probability_threshold| {
            len +%= 44 +% fmt.Ud64.length(machine_sink_split_probability_threshold);
        }
        if (cmd.mandatory_inlining_first) {
            len +%= 27;
        }
        if (cmd.march) |march| {
            len +%= 9 +% march.len;
        }
        if (cmd.mark_data_regions) {
            len +%= 20;
        }
        if (cmd.matrix_allow_contract) {
            len +%= 24;
        }
        if (cmd.matrix_default_layout) |matrix_default_layout| {
            len +%= 25 +% @tagName(matrix_default_layout).len;
        }
        if (cmd.matrix_print_after_transpose_opt) {
            len +%= 35;
        }
        if (cmd.max_booleans_in_control_flow_hub) |max_booleans_in_control_flow_hub| {
            len +%= 36 +% fmt.Ud64.length(max_booleans_in_control_flow_hub);
        }
        if (cmd.max_bytes_for_alignment) |max_bytes_for_alignment| {
            len +%= 27 +% fmt.Ud64.length(max_bytes_for_alignment);
        }
        if (cmd.max_counter_promotions) |max_counter_promotions| {
            len +%= 26 +% fmt.Ud64.length(max_counter_promotions);
        }
        if (cmd.max_counter_promotions_per_loop) |max_counter_promotions_per_loop| {
            len +%= 35 +% fmt.Ud64.length(max_counter_promotions_per_loop);
        }
        if (cmd.max_deopt_or_unreachable_succ_check_depth) |max_deopt_or_unreachable_succ_check_depth| {
            len +%= 45 +% fmt.Ud64.length(max_deopt_or_unreachable_succ_check_depth);
        }
        if (cmd.max_dependences) |max_dependences| {
            len +%= 19 +% fmt.Ud64.length(max_dependences);
        }
        if (cmd.max_forked_scev_depth) |max_forked_scev_depth| {
            len +%= 25 +% fmt.Ud64.length(max_forked_scev_depth);
        }
        if (cmd.max_heap_to_stack_size) |max_heap_to_stack_size| {
            len +%= 26 +% fmt.Ud64.length(max_heap_to_stack_size);
        }
        if (cmd.max_hsdr) |max_hsdr| {
            len +%= 12 +% fmt.Ud64.length(max_hsdr);
        }
        if (cmd.max_inst_checked_for_throw_during_inlining) |max_inst_checked_for_throw_during_inlining| {
            len +%= 46 +% fmt.Ud64.length(max_inst_checked_for_throw_during_inlining);
        }
        if (cmd.max_interleave_group_factor) |max_interleave_group_factor| {
            len +%= 31 +% fmt.Ud64.length(max_interleave_group_factor);
        }
        if (cmd.max_jump_table_size) |max_jump_table_size| {
            len +%= 23 +% fmt.Ud64.length(max_jump_table_size);
        }
        if (cmd.max_loads_per_memcmp) |max_loads_per_memcmp| {
            len +%= 24 +% fmt.Ud64.length(max_loads_per_memcmp);
        }
        if (cmd.max_loads_per_memcmp_opt_size) |max_loads_per_memcmp_opt_size| {
            len +%= 33 +% fmt.Ud64.length(max_loads_per_memcmp_opt_size);
        }
        if (cmd.max_nested_scalar_reduction_interleave) |max_nested_scalar_reduction_interleave| {
            len +%= 42 +% fmt.Ud64.length(max_nested_scalar_reduction_interleave);
        }
        if (cmd.max_num_inline_blocks) |max_num_inline_blocks| {
            len +%= 25 +% fmt.Ud64.length(max_num_inline_blocks);
        }
        if (cmd.max_num_inst_between_tfr_and_nv_store) |max_num_inst_between_tfr_and_nv_store| {
            len +%= 41 +% fmt.Ud64.length(max_num_inst_between_tfr_and_nv_store);
        }
        if (cmd.max_partial_inlining) |max_partial_inlining| {
            len +%= 24 +% fmt.Ud64.length(max_partial_inlining);
        }
        if (cmd.max_prefetch_iters_ahead) |max_prefetch_iters_ahead| {
            len +%= 28 +% fmt.Ud64.length(max_prefetch_iters_ahead);
        }
        if (cmd.max_registers_for_gc_values) |max_registers_for_gc_values| {
            len +%= 31 +% fmt.Ud64.length(max_registers_for_gc_values);
        }
        if (cmd.max_sched_reorder) |max_sched_reorder| {
            len +%= 21 +% fmt.Ud64.length(max_sched_reorder);
        }
        if (cmd.max_speculation_depth) |max_speculation_depth| {
            len +%= 25 +% fmt.Ud64.length(max_speculation_depth);
        }
        if (cmd.max_store_memcpy) |max_store_memcpy| {
            len +%= 20 +% fmt.Ud64.length(max_store_memcpy);
        }
        if (cmd.max_store_memcpy_Os) |max_store_memcpy_Os| {
            len +%= 23 +% fmt.Ud64.length(max_store_memcpy_Os);
        }
        if (cmd.max_store_memmove) |max_store_memmove| {
            len +%= 21 +% fmt.Ud64.length(max_store_memmove);
        }
        if (cmd.max_store_memmove_Os) |max_store_memmove_Os| {
            len +%= 24 +% fmt.Ud64.length(max_store_memmove_Os);
        }
        if (cmd.max_store_memset) |max_store_memset| {
            len +%= 20 +% fmt.Ud64.length(max_store_memset);
        }
        if (cmd.max_store_memset_Os) |max_store_memset_Os| {
            len +%= 23 +% fmt.Ud64.length(max_store_memset_Os);
        }
        if (cmd.max_switch_cases_per_result) |max_switch_cases_per_result| {
            len +%= 31 +% fmt.Ud64.length(max_switch_cases_per_result);
        }
        if (cmd.max_uses_for_sinking) |max_uses_for_sinking| {
            len +%= 24 +% fmt.Ud64.length(max_uses_for_sinking);
        }
        if (cmd.mc_relax_all) {
            len +%= 15;
        }
        if (cmd.mcabac) {
            len +%= 9;
        }
        if (cmd.mcfg_dot_filename_prefix) |mcfg_dot_filename_prefix| {
            len +%= 28 +% mcfg_dot_filename_prefix.len;
        }
        if (cmd.mcfg_func_name) |mcfg_func_name| {
            len +%= 18 +% mcfg_func_name.len;
        }
        if (cmd.mcp_use_is_copy_instr) {
            len +%= 24;
        }
        if (cmd.mcpu) |mcpu| {
            len +%= 8 +% mcpu.len;
        }
        if (cmd.meabi) |meabi| {
            len +%= 9 +% @tagName(meabi).len;
        }
        if (cmd.mem_loc_frag_fill) {
            len +%= 20;
        }
        if (cmd.membedded_data) {
            len +%= 17;
        }
        if (cmd.memcmp_num_loads_per_block) |memcmp_num_loads_per_block| {
            len +%= 30 +% fmt.Ud64.length(memcmp_num_loads_per_block);
        }
        if (cmd.memdep_block_number_limit) |memdep_block_number_limit| {
            len +%= 29 +% fmt.Ud64.length(memdep_block_number_limit);
        }
        if (cmd.memdep_block_scan_limit) |memdep_block_scan_limit| {
            len +%= 27 +% fmt.Ud64.length(memdep_block_scan_limit);
        }
        if (cmd.memop_max_annotations) |memop_max_annotations| {
            len +%= 25 +% fmt.Ud64.length(memop_max_annotations);
        }
        if (cmd.memop_value_prof_max_opt_size) |memop_value_prof_max_opt_size| {
            len +%= 33 +% fmt.Ud64.length(memop_value_prof_max_opt_size);
        }
        if (cmd.memory_check_merge_threshold) |memory_check_merge_threshold| {
            len +%= 32 +% fmt.Ud64.length(memory_check_merge_threshold);
        }
        if (cmd.memprof_accesses_per_byte_cold_threshold) |memprof_accesses_per_byte_cold_threshold| {
            len +%= 44 +% fmt.Ud64.length(memprof_accesses_per_byte_cold_threshold);
        }
        if (cmd.memprof_debug) |memprof_debug| {
            len +%= 17 +% fmt.Ud64.length(memprof_debug);
        }
        if (cmd.memprof_debug_func) |memprof_debug_func| {
            len +%= 22 +% memprof_debug_func.len;
        }
        if (cmd.memprof_debug_max) |memprof_debug_max| {
            len +%= 21 +% fmt.Ud64.length(memprof_debug_max);
        }
        if (cmd.memprof_debug_min) |memprof_debug_min| {
            len +%= 21 +% fmt.Ud64.length(memprof_debug_min);
        }
        if (cmd.memprof_guard_against_version_mismatch) {
            len +%= 41;
        }
        if (cmd.memprof_instrument_atomics) {
            len +%= 29;
        }
        if (cmd.memprof_instrument_reads) {
            len +%= 27;
        }
        if (cmd.memprof_instrument_stack) {
            len +%= 27;
        }
        if (cmd.memprof_instrument_writes) {
            len +%= 28;
        }
        if (cmd.memprof_mapping_granularity) |memprof_mapping_granularity| {
            len +%= 31 +% fmt.Ud64.length(memprof_mapping_granularity);
        }
        if (cmd.memprof_mapping_scale) |memprof_mapping_scale| {
            len +%= 25 +% fmt.Ud64.length(memprof_mapping_scale);
        }
        if (cmd.memprof_memory_access_callback_prefix) |memprof_memory_access_callback_prefix| {
            len +%= 41 +% memprof_memory_access_callback_prefix.len;
        }
        if (cmd.memprof_min_lifetime_cold_threshold) |memprof_min_lifetime_cold_threshold| {
            len +%= 39 +% fmt.Ud64.length(memprof_min_lifetime_cold_threshold);
        }
        if (cmd.memprof_use_callbacks) {
            len +%= 24;
        }
        if (cmd.memssa_check_limit) |memssa_check_limit| {
            len +%= 22 +% fmt.Ud64.length(memssa_check_limit);
        }
        if (cmd.mergefunc_preserve_debug_info) {
            len +%= 32;
        }
        if (cmd.mergefunc_use_aliases) {
            len +%= 24;
        }
        if (cmd.mergefunc_verify) |mergefunc_verify| {
            len +%= 20 +% fmt.Ud64.length(mergefunc_verify);
        }
        if (cmd.merror_missing_parenthesis) {
            len +%= 29;
        }
        if (cmd.merror_noncontigious_register) {
            len +%= 32;
        }
        if (cmd.mextern_sdata) {
            len +%= 16;
        }
        if (cmd.mfix4300) {
            len +%= 11;
        }
        if (cmd.mfs_count_threshold) |mfs_count_threshold| {
            len +%= 23 +% fmt.Ud64.length(mfs_count_threshold);
        }
        if (cmd.mfs_psi_cutoff) |mfs_psi_cutoff| {
            len +%= 18 +% fmt.Ud64.length(mfs_psi_cutoff);
        }
        if (cmd.mfs_split_ehcode) {
            len +%= 19;
        }
        if (cmd.mgpopt) {
            len +%= 9;
        }
        if (cmd.mhvx) |mhvx| {
            len +%= 8 +% @tagName(mhvx).len;
        }
        if (cmd.mhvx_ieee_fp) {
            len +%= 15;
        }
        if (cmd.mhwmult) |mhwmult| {
            len +%= 11 +% @tagName(mhwmult).len;
        }
        if (cmd.min_block_execution) |min_block_execution| {
            len +%= 23 +% fmt.Ud64.length(min_block_execution);
        }
        if (cmd.min_ctr_loop_threshold) |min_ctr_loop_threshold| {
            len +%= 26 +% fmt.Ud64.length(min_ctr_loop_threshold);
        }
        if (cmd.min_jump_table_entries) |min_jump_table_entries| {
            len +%= 26 +% fmt.Ud64.length(min_jump_table_entries);
        }
        if (cmd.min_prefetch_stride) |min_prefetch_stride| {
            len +%= 23 +% fmt.Ud64.length(min_prefetch_stride);
        }
        if (cmd.min_region_size_ratio) |min_region_size_ratio| {
            len +%= 25 +% fmt.Ud64.length(min_region_size_ratio);
        }
        if (cmd.minimize_addr_in_v5) |minimize_addr_in_v5| {
            len +%= 23 +% @tagName(minimize_addr_in_v5).len;
        }
        if (cmd.minimum_jump_tables) |minimum_jump_tables| {
            len +%= 23 +% fmt.Ud64.length(minimum_jump_tables);
        }
        if (cmd.mips_align_constant_islands) {
            len +%= 30;
        }
        if (cmd.mips_compact_branches) |mips_compact_branches| {
            len +%= 25 +% @tagName(mips_compact_branches).len;
        }
        if (cmd.mips_constant_islands_no_load_relaxation) {
            len +%= 43;
        }
        if (cmd.mips_constant_islands_small_offset) |mips_constant_islands_small_offset| {
            len +%= 38 +% fmt.Ud64.length(mips_constant_islands_small_offset);
        }
        if (cmd.mips_erase_gp_opnd) {
            len +%= 21;
        }
        if (cmd.mips_fix_global_base_reg) {
            len +%= 27;
        }
        if (cmd.mips_jalr_reloc) {
            len +%= 18;
        }
        if (cmd.mips_load_target_from_got) {
            len +%= 28;
        }
        if (cmd.mips_mixed_16_32) {
            len +%= 19;
        }
        if (cmd.mips_os16) {
            len +%= 12;
        }
        if (cmd.mips_round_section_sizes) {
            len +%= 27;
        }
        if (cmd.mips_ssection_threshold) |mips_ssection_threshold| {
            len +%= 27 +% fmt.Ud64.length(mips_ssection_threshold);
        }
        if (cmd.mips_tail_calls) {
            len +%= 18;
        }
        if (cmd.mips16_constant_islands) {
            len +%= 26;
        }
        if (cmd.mips16_dont_expand_cond_pseudo) {
            len +%= 33;
        }
        if (cmd.mips16_hard_float) {
            len +%= 20;
        }
        if (cmd.mips32_function_mask) |mips32_function_mask| {
            len +%= 24 +% mips32_function_mask.len;
        }
        if (cmd.mipspostlegalizercombinerhelper_disable_rule) |mipspostlegalizercombinerhelper_disable_rule| {
            len +%= 48 +% mipspostlegalizercombinerhelper_disable_rule.len;
        }
        if (cmd.mipspostlegalizercombinerhelper_only_enable_rule) |mipspostlegalizercombinerhelper_only_enable_rule| {
            len +%= 52 +% mipspostlegalizercombinerhelper_only_enable_rule.len;
        }
        if (cmd.mir_debug_loc) {
            len +%= 16;
        }
        if (cmd.mir_strip_debugify_only) {
            len +%= 26;
        }
        if (cmd.mir_vreg_namer_use_stable_hash) {
            len +%= 33;
        }
        if (cmd.misched) |misched| {
            len +%= 11 +% @tagName(misched).len;
        }
        if (cmd.misched_bottomup) {
            len +%= 19;
        }
        if (cmd.misched_cluster) {
            len +%= 18;
        }
        if (cmd.misched_cyclicpath) {
            len +%= 21;
        }
        if (cmd.misched_dcpl) {
            len +%= 15;
        }
        if (cmd.misched_fusion) {
            len +%= 17;
        }
        if (cmd.misched_limit) |misched_limit| {
            len +%= 17 +% fmt.Ud64.length(misched_limit);
        }
        if (cmd.misched_postra) {
            len +%= 17;
        }
        if (cmd.misched_regpressure) {
            len +%= 22;
        }
        if (cmd.misched_topdown) {
            len +%= 18;
        }
        if (cmd.misched_verbose_level) |misched_verbose_level| {
            len +%= 25 +% fmt.Ud64.length(misched_verbose_level);
        }
        if (cmd.misexpect_tolerance) |misexpect_tolerance| {
            len +%= 23 +% fmt.Ud64.length(misexpect_tolerance);
        }
        if (cmd.misfetch_cost) |misfetch_cost| {
            len +%= 17 +% fmt.Ud64.length(misfetch_cost);
        }
        if (cmd.mispredict_default_rate) |mispredict_default_rate| {
            len +%= 27 +% fmt.Ud64.length(mispredict_default_rate);
        }
        if (cmd.ml_advisor_keep_fpi_cache) {
            len +%= 28;
        }
        if (cmd.ml_advisor_size_increase_threshold) |ml_advisor_size_increase_threshold| {
            len +%= 38 +% fmt.Ud64.length(ml_advisor_size_increase_threshold);
        }
        if (cmd.mlocal_sdata) {
            len +%= 15;
        }
        if (cmd.mno_check_zero_division) {
            len +%= 26;
        }
        if (cmd.mno_compound) {
            len +%= 15;
        }
        if (cmd.mno_fixup) {
            len +%= 12;
        }
        if (cmd.mno_hvx) {
            len +%= 10;
        }
        if (cmd.mno_ldc1_sdc1) {
            len +%= 16;
        }
        if (cmd.mno_pairing) {
            len +%= 14;
        }
        if (cmd.mno_sort_sda) {
            len +%= 15;
        }
        if (cmd.module_summary_dot_file) |module_summary_dot_file| {
            len +%= 27 +% module_summary_dot_file.len;
        }
        if (cmd.moudle_inliner_top_priority_threshold) |moudle_inliner_top_priority_threshold| {
            len +%= 41 +% fmt.Ud64.length(moudle_inliner_top_priority_threshold);
        }
        if (cmd.msan_and_mask) |msan_and_mask| {
            len +%= 17 +% fmt.Ud64.length(msan_and_mask);
        }
        if (cmd.msan_check_access_address) {
            len +%= 28;
        }
        if (cmd.msan_check_constant_shadow) {
            len +%= 29;
        }
        if (cmd.msan_disable_checks) {
            len +%= 22;
        }
        if (cmd.msan_disambiguate_warning_threshold) |msan_disambiguate_warning_threshold| {
            len +%= 39 +% fmt.Ud64.length(msan_disambiguate_warning_threshold);
        }
        if (cmd.msan_dump_strict_instructions) {
            len +%= 32;
        }
        if (cmd.msan_eager_checks) {
            len +%= 20;
        }
        if (cmd.msan_handle_asm_conservative) {
            len +%= 31;
        }
        if (cmd.msan_handle_icmp) {
            len +%= 19;
        }
        if (cmd.msan_handle_icmp_exact) {
            len +%= 25;
        }
        if (cmd.msan_handle_lifetime_intrinsics) {
            len +%= 34;
        }
        if (cmd.msan_instrumentation_with_call_threshold) |msan_instrumentation_with_call_threshold| {
            len +%= 44 +% fmt.Ud64.length(msan_instrumentation_with_call_threshold);
        }
        if (cmd.msan_keep_going) {
            len +%= 18;
        }
        if (cmd.msan_kernel) {
            len +%= 14;
        }
        if (cmd.msan_origin_base) |msan_origin_base| {
            len +%= 20 +% fmt.Ud64.length(msan_origin_base);
        }
        if (cmd.msan_poison_stack) {
            len +%= 20;
        }
        if (cmd.msan_poison_stack_pattern) |msan_poison_stack_pattern| {
            len +%= 29 +% fmt.Ud64.length(msan_poison_stack_pattern);
        }
        if (cmd.msan_poison_stack_with_call) {
            len +%= 30;
        }
        if (cmd.msan_poison_undef) {
            len +%= 20;
        }
        if (cmd.msan_print_stack_names) {
            len +%= 25;
        }
        if (cmd.msan_shadow_base) |msan_shadow_base| {
            len +%= 20 +% fmt.Ud64.length(msan_shadow_base);
        }
        if (cmd.msan_track_origins) |msan_track_origins| {
            len +%= 22 +% fmt.Ud64.length(msan_track_origins);
        }
        if (cmd.msan_with_comdat) {
            len +%= 19;
        }
        if (cmd.msan_xor_mask) |msan_xor_mask| {
            len +%= 17 +% fmt.Ud64.length(msan_xor_mask);
        }
        if (cmd.msp430_branch_select) {
            len +%= 23;
        }
        if (cmd.msp430_no_legal_immediate) {
            len +%= 28;
        }
        if (cmd.mtriple) |mtriple| {
            len +%= 11 +% mtriple.len;
        }
        if (cmd.mul_constant_optimization) {
            len +%= 28;
        }
        if (cmd.mv5) {
            len +%= 6;
        }
        if (cmd.mv55) {
            len +%= 7;
        }
        if (cmd.mv60) {
            len +%= 7;
        }
        if (cmd.mv62) {
            len +%= 7;
        }
        if (cmd.mv65) {
            len +%= 7;
        }
        if (cmd.mv66) {
            len +%= 7;
        }
        if (cmd.mv67) {
            len +%= 7;
        }
        if (cmd.mv67t) {
            len +%= 8;
        }
        if (cmd.mv68) {
            len +%= 7;
        }
        if (cmd.mv69) {
            len +%= 7;
        }
        if (cmd.mv71) {
            len +%= 7;
        }
        if (cmd.mv71t) {
            len +%= 8;
        }
        if (cmd.mv73) {
            len +%= 7;
        }
        if (cmd.mve_max_interleave_factor) |mve_max_interleave_factor| {
            len +%= 29 +% fmt.Ud64.length(mve_max_interleave_factor);
        }
        if (cmd.mwarn_missing_parenthesis) {
            len +%= 28;
        }
        if (cmd.mwarn_noncontigious_register) {
            len +%= 31;
        }
        if (cmd.mwarn_sign_mismatch) {
            len +%= 22;
        }
        if (cmd.no_deprecated_warn) {
            len +%= 21;
        }
        if (cmd.no_discriminators) {
            len +%= 20;
        }
        if (cmd.no_dwarf_ranges_section) {
            len +%= 26;
        }
        if (cmd.no_integrated_as) {
            len +%= 19;
        }
        if (cmd.no_pgo_warn_mismatch) {
            len +%= 23;
        }
        if (cmd.no_pgo_warn_mismatch_comdat_weak) {
            len +%= 35;
        }
        if (cmd.no_phi_elim_live_out_early_exit) {
            len +%= 34;
        }
        if (cmd.no_stack_coloring) {
            len +%= 20;
        }
        if (cmd.no_stack_slot_sharing) {
            len +%= 24;
        }
        if (cmd.no_type_check) {
            len +%= 16;
        }
        if (cmd.no_warn) {
            len +%= 10;
        }
        if (cmd.no_warn_sample_unused) {
            len +%= 24;
        }
        if (cmd.no_x86_call_frame_opt) {
            len +%= 24;
        }
        if (cmd.no_xray_index) {
            len +%= 16;
        }
        if (cmd.non_global_value_max_name_size) |non_global_value_max_name_size| {
            len +%= 34 +% fmt.Ud64.length(non_global_value_max_name_size);
        }
        if (cmd.nozero_initialized_in_bss) {
            len +%= 28;
        }
        if (cmd.number_scavenger_slots) |number_scavenger_slots| {
            len +%= 26 +% fmt.Ud64.length(number_scavenger_slots);
        }
        if (cmd.nvj_count) |nvj_count| {
            len +%= 13 +% fmt.Ud64.length(nvj_count);
        }
        if (cmd.nvptx_fma_level) |nvptx_fma_level| {
            len +%= 19 +% fmt.Ud64.length(nvptx_fma_level);
        }
        if (cmd.nvptx_no_f16_math) {
            len +%= 20;
        }
        if (cmd.nvptx_prec_divf32) |nvptx_prec_divf32| {
            len +%= 21 +% fmt.Ud64.length(nvptx_prec_divf32);
        }
        if (cmd.nvptx_prec_sqrtf32) {
            len +%= 21;
        }
        if (cmd.nvptx_sched4reg) {
            len +%= 18;
        }
        if (cmd.nvptx_short_ptr) {
            len +%= 18;
        }
        if (cmd.nvvm_intr_range_sm) |nvvm_intr_range_sm| {
            len +%= 22 +% fmt.Ud64.length(nvvm_intr_range_sm);
        }
        if (cmd.nvvm_reflect_enable) {
            len +%= 22;
        }
        if (cmd.old_thumb2_ifcvt) {
            len +%= 19;
        }
        if (cmd.only_nonnested_memmove_idiom) {
            len +%= 31;
        }
        if (cmd.only_simple_regions) {
            len +%= 22;
        }
        if (cmd.opaque_pointers) {
            len +%= 18;
        }
        if (cmd.openmp_deduce_icv_values) {
            len +%= 27;
        }
        if (cmd.openmp_hide_memory_transfer_latency) {
            len +%= 38;
        }
        if (cmd.openmp_ir_builder_optimistic_attributes) {
            len +%= 42;
        }
        if (cmd.openmp_ir_builder_unroll_threshold_factor) |openmp_ir_builder_unroll_threshold_factor| {
            len +%= 45 +% fmt.Ud64.length(openmp_ir_builder_unroll_threshold_factor);
        }
        if (cmd.openmp_opt_disable) {
            len +%= 21;
        }
        if (cmd.openmp_opt_disable_barrier_elimination) {
            len +%= 41;
        }
        if (cmd.openmp_opt_disable_deglobalization) {
            len +%= 37;
        }
        if (cmd.openmp_opt_disable_folding) {
            len +%= 29;
        }
        if (cmd.openmp_opt_disable_internalization) {
            len +%= 37;
        }
        if (cmd.openmp_opt_disable_spmdization) {
            len +%= 33;
        }
        if (cmd.openmp_opt_disable_state_machine_rewrite) {
            len +%= 43;
        }
        if (cmd.openmp_opt_enable_merging) {
            len +%= 28;
        }
        if (cmd.openmp_opt_inline_device) {
            len +%= 27;
        }
        if (cmd.openmp_opt_max_iterations) |openmp_opt_max_iterations| {
            len +%= 29 +% fmt.Ud64.length(openmp_opt_max_iterations);
        }
        if (cmd.openmp_opt_print_module_after) {
            len +%= 32;
        }
        if (cmd.openmp_opt_print_module_before) {
            len +%= 33;
        }
        if (cmd.openmp_opt_shared_limit) |openmp_opt_shared_limit| {
            len +%= 27 +% fmt.Ud64.length(openmp_opt_shared_limit);
        }
        if (cmd.openmp_opt_verbose_remarks) {
            len +%= 29;
        }
        if (cmd.openmp_print_gpu_kernels) {
            len +%= 27;
        }
        if (cmd.openmp_print_icv_values) {
            len +%= 26;
        }
        if (cmd.opt_bisect_limit) |opt_bisect_limit| {
            len +%= 20 +% fmt.Ud64.length(opt_bisect_limit);
        }
        if (cmd.opt_bisect_print_ir_path) |opt_bisect_print_ir_path| {
            len +%= 28 +% opt_bisect_print_ir_path.len;
        }
        if (cmd.optimize_regalloc) {
            len +%= 20;
        }
        if (cmd.optsize_jump_table_density) |optsize_jump_table_density| {
            len +%= 30 +% fmt.Ud64.length(optsize_jump_table_density);
        }
        if (cmd.orderfile_write_mapping) |orderfile_write_mapping| {
            len +%= 27 +% orderfile_write_mapping.len;
        }
        if (cmd.outline_region_freq_percent) |outline_region_freq_percent| {
            len +%= 31 +% fmt.Ud64.length(outline_region_freq_percent);
        }
        if (cmd.overwrite_existing_weights) {
            len +%= 29;
        }
        if (cmd.partial_inlining_extra_penalty) |partial_inlining_extra_penalty| {
            len +%= 34 +% fmt.Ud64.length(partial_inlining_extra_penalty);
        }
        if (cmd.partial_profile) {
            len +%= 18;
        }
        if (cmd.partial_reg_update_clearance) |partial_reg_update_clearance| {
            len +%= 32 +% fmt.Ud64.length(partial_reg_update_clearance);
        }
        if (cmd.partial_sample_profile_working_set_size_scale_factor) |partial_sample_profile_working_set_size_scale_factor| {
            len +%= 56 +% fmt.Ud64.length(partial_sample_profile_working_set_size_scale_factor);
        }
        if (cmd.partial_unrolling_threshold) |partial_unrolling_threshold| {
            len +%= 31 +% fmt.Ud64.length(partial_unrolling_threshold);
        }
        if (cmd.pass_remarks) |pass_remarks| {
            len +%= 16 +% pass_remarks.len;
        }
        if (cmd.pass_remarks_analysis) |pass_remarks_analysis| {
            len +%= 25 +% pass_remarks_analysis.len;
        }
        if (cmd.pass_remarks_filter) |pass_remarks_filter| {
            len +%= 23 +% pass_remarks_filter.len;
        }
        if (cmd.pass_remarks_format) |pass_remarks_format| {
            len +%= 23 +% pass_remarks_format.len;
        }
        if (cmd.pass_remarks_hotness_threshold) {
            len +%= 33;
        }
        if (cmd.pass_remarks_missed) |pass_remarks_missed| {
            len +%= 23 +% pass_remarks_missed.len;
        }
        if (cmd.pass_remarks_output) |pass_remarks_output| {
            len +%= 23 +% pass_remarks_output.len;
        }
        if (cmd.pass_remarks_with_hotness) {
            len +%= 28;
        }
        if (cmd.pbqp_coalescing) {
            len +%= 18;
        }
        if (cmd.persist_profile_staleness) {
            len +%= 28;
        }
        if (cmd.pgo_critical_edge_threshold) |pgo_critical_edge_threshold| {
            len +%= 31 +% fmt.Ud64.length(pgo_critical_edge_threshold);
        }
        if (cmd.pgo_emit_branch_prob) {
            len +%= 23;
        }
        if (cmd.pgo_fix_entry_count) {
            len +%= 22;
        }
        if (cmd.pgo_function_entry_coverage) {
            len +%= 30;
        }
        if (cmd.pgo_function_size_threshold) |pgo_function_size_threshold| {
            len +%= 31 +% fmt.Ud64.length(pgo_function_size_threshold);
        }
        if (cmd.pgo_instr_memop) {
            len +%= 18;
        }
        if (cmd.pgo_instr_old_cfg_hashing) {
            len +%= 28;
        }
        if (cmd.pgo_instr_select) {
            len +%= 19;
        }
        if (cmd.pgo_instrument_entry) {
            len +%= 23;
        }
        if (cmd.pgo_match_memprof) {
            len +%= 20;
        }
        if (cmd.pgo_memop_count_threshold) |pgo_memop_count_threshold| {
            len +%= 29 +% fmt.Ud64.length(pgo_memop_count_threshold);
        }
        if (cmd.pgo_memop_max_version) |pgo_memop_max_version| {
            len +%= 25 +% fmt.Ud64.length(pgo_memop_max_version);
        }
        if (cmd.pgo_memop_optimize_memcmp_bcmp) {
            len +%= 33;
        }
        if (cmd.pgo_memop_percent_threshold) |pgo_memop_percent_threshold| {
            len +%= 31 +% fmt.Ud64.length(pgo_memop_percent_threshold);
        }
        if (cmd.pgo_memop_scale_count) {
            len +%= 24;
        }
        if (cmd.pgo_test_profile_file) |pgo_test_profile_file| {
            len +%= 25 +% pgo_test_profile_file.len;
        }
        if (cmd.pgo_test_profile_remapping_file) |pgo_test_profile_remapping_file| {
            len +%= 35 +% pgo_test_profile_remapping_file.len;
        }
        if (cmd.pgo_verify_bfi) {
            len +%= 17;
        }
        if (cmd.pgo_verify_bfi_cutoff) |pgo_verify_bfi_cutoff| {
            len +%= 25 +% fmt.Ud64.length(pgo_verify_bfi_cutoff);
        }
        if (cmd.pgo_verify_bfi_ratio) |pgo_verify_bfi_ratio| {
            len +%= 24 +% fmt.Ud64.length(pgo_verify_bfi_ratio);
        }
        if (cmd.pgo_verify_hot_bfi) {
            len +%= 21;
        }
        if (cmd.pgo_view_counts) |pgo_view_counts| {
            len +%= 19 +% @tagName(pgo_view_counts).len;
        }
        if (cmd.pgo_view_raw_counts) |pgo_view_raw_counts| {
            len +%= 23 +% @tagName(pgo_view_raw_counts).len;
        }
        if (cmd.pgo_warn_misexpect) {
            len +%= 21;
        }
        if (cmd.pgo_warn_missing_function) {
            len +%= 28;
        }
        if (cmd.pgso) {
            len +%= 7;
        }
        if (cmd.pgso_cold_code_only) {
            len +%= 22;
        }
        if (cmd.pgso_cold_code_only_for_instr_pgo) {
            len +%= 36;
        }
        if (cmd.pgso_cold_code_only_for_partial_sample_pgo) {
            len +%= 45;
        }
        if (cmd.pgso_cold_code_only_for_sample_pgo) {
            len +%= 37;
        }
        if (cmd.pgso_cutoff_instr_prof) |pgso_cutoff_instr_prof| {
            len +%= 26 +% fmt.Ud64.length(pgso_cutoff_instr_prof);
        }
        if (cmd.pgso_cutoff_sample_prof) |pgso_cutoff_sample_prof| {
            len +%= 27 +% fmt.Ud64.length(pgso_cutoff_sample_prof);
        }
        if (cmd.pgso_lwss_only) {
            len +%= 17;
        }
        if (cmd.phi_elim_split_all_critical_edges) {
            len +%= 36;
        }
        if (cmd.phi_node_folding_threshold) |phi_node_folding_threshold| {
            len +%= 30 +% fmt.Ud64.length(phi_node_folding_threshold);
        }
        if (cmd.phicse_debug_hash) {
            len +%= 20;
        }
        if (cmd.phicse_num_phi_smallsize) |phicse_num_phi_smallsize| {
            len +%= 28 +% fmt.Ud64.length(phicse_num_phi_smallsize);
        }
        if (cmd.pi_force_live_exit_outline) {
            len +%= 29;
        }
        if (cmd.pi_mark_coldcc) {
            len +%= 17;
        }
        if (cmd.pipeliner_annotate_for_testing) {
            len +%= 33;
        }
        if (cmd.pipeliner_dbg_res) {
            len +%= 20;
        }
        if (cmd.pipeliner_experimental_cg) {
            len +%= 28;
        }
        if (cmd.pipeliner_force_ii) |pipeliner_force_ii| {
            len +%= 22 +% fmt.Ud64.length(pipeliner_force_ii);
        }
        if (cmd.pipeliner_force_issue_width) |pipeliner_force_issue_width| {
            len +%= 31 +% fmt.Ud64.length(pipeliner_force_issue_width);
        }
        if (cmd.pipeliner_max_mii) |pipeliner_max_mii| {
            len +%= 21 +% fmt.Ud64.length(pipeliner_max_mii);
        }
        if (cmd.pipeliner_max_stages) |pipeliner_max_stages| {
            len +%= 24 +% fmt.Ud64.length(pipeliner_max_stages);
        }
        if (cmd.pipeliner_prune_deps) {
            len +%= 23;
        }
        if (cmd.pipeliner_prune_loop_carried) {
            len +%= 31;
        }
        if (cmd.pipeliner_show_mask) {
            len +%= 22;
        }
        if (cmd.poison_checking_function_local) {
            len +%= 33;
        }
        if (cmd.post_RA_scheduler) {
            len +%= 20;
        }
        if (cmd.postra_sched_debugdiv) |postra_sched_debugdiv| {
            len +%= 25 +% fmt.Ud64.length(postra_sched_debugdiv);
        }
        if (cmd.postra_sched_debugmod) |postra_sched_debugmod| {
            len +%= 25 +% fmt.Ud64.length(postra_sched_debugmod);
        }
        if (cmd.ppc_always_use_base_pointer) {
            len +%= 30;
        }
        if (cmd.ppc_asm_full_reg_names) {
            len +%= 25;
        }
        if (cmd.ppc_bit_perm_rewriter_stress_rotates) {
            len +%= 39;
        }
        if (cmd.ppc_chaincommon_max_vars) |ppc_chaincommon_max_vars| {
            len +%= 28 +% fmt.Ud64.length(ppc_chaincommon_max_vars);
        }
        if (cmd.ppc_chaincommon_min_threshold) |ppc_chaincommon_min_threshold| {
            len +%= 33 +% fmt.Ud64.length(ppc_chaincommon_min_threshold);
        }
        if (cmd.ppc_convert_rr_to_ri) {
            len +%= 23;
        }
        if (cmd.ppc_disable_non_volatile_cr) {
            len +%= 30;
        }
        if (cmd.ppc_disable_perfect_shuffle) {
            len +%= 30;
        }
        if (cmd.ppc_dispprep_min_threshold) |ppc_dispprep_min_threshold| {
            len +%= 30 +% fmt.Ud64.length(ppc_dispprep_min_threshold);
        }
        if (cmd.ppc_dqprep_max_vars) |ppc_dqprep_max_vars| {
            len +%= 23 +% fmt.Ud64.length(ppc_dqprep_max_vars);
        }
        if (cmd.ppc_dsprep_max_vars) |ppc_dsprep_max_vars| {
            len +%= 23 +% fmt.Ud64.length(ppc_dsprep_max_vars);
        }
        if (cmd.ppc_eliminate_signext) {
            len +%= 24;
        }
        if (cmd.ppc_eliminate_zeroext) {
            len +%= 24;
        }
        if (cmd.ppc_enable_coldcc) {
            len +%= 20;
        }
        if (cmd.ppc_enable_gpr_to_vsr_spills) {
            len +%= 31;
        }
        if (cmd.ppc_enable_pe_vector_spills) {
            len +%= 30;
        }
        if (cmd.ppc_enable_pipeliner) {
            len +%= 23;
        }
        if (cmd.ppc_fma_rp_factor) |ppc_fma_rp_factor| {
            len +%= 21 +% fmt.Ud64.length(ppc_fma_rp_factor);
        }
        if (cmd.ppc_fma_rp_reduction) {
            len +%= 23;
        }
        if (cmd.ppc_formprep_chain_commoning) {
            len +%= 31;
        }
        if (cmd.ppc_formprep_max_vars) |ppc_formprep_max_vars| {
            len +%= 25 +% fmt.Ud64.length(ppc_formprep_max_vars);
        }
        if (cmd.ppc_formprep_prefer_update) {
            len +%= 29;
        }
        if (cmd.ppc_formprep_update_nonconst_inc) {
            len +%= 35;
        }
        if (cmd.ppc_gen_isel) {
            len +%= 15;
        }
        if (cmd.ppc_gep_opt) {
            len +%= 14;
        }
        if (cmd.ppc_gpr_icmps) |ppc_gpr_icmps| {
            len +%= 17 +% @tagName(ppc_gpr_icmps).len;
        }
        if (cmd.ppc_late_peephole) {
            len +%= 20;
        }
        if (cmd.ppc_lsr_no_insns_cost) {
            len +%= 24;
        }
        if (cmd.ppc_machine_combiner) {
            len +%= 23;
        }
        if (cmd.ppc_max_crbit_spill_dist) |ppc_max_crbit_spill_dist| {
            len +%= 28 +% fmt.Ud64.length(ppc_max_crbit_spill_dist);
        }
        if (cmd.ppc_old_latency_calc) {
            len +%= 23;
        }
        if (cmd.ppc_opt_conditional_trap) {
            len +%= 27;
        }
        if (cmd.ppc_pcrel_linker_opt) {
            len +%= 23;
        }
        if (cmd.ppc_postra_bias_addi) {
            len +%= 23;
        }
        if (cmd.ppc_preinc_prep_max_vars) |ppc_preinc_prep_max_vars| {
            len +%= 28 +% fmt.Ud64.length(ppc_preinc_prep_max_vars);
        }
        if (cmd.ppc_quadword_atomics) {
            len +%= 23;
        }
        if (cmd.ppc_reduce_cr_logicals) {
            len +%= 25;
        }
        if (cmd.ppc_reg_to_imm_fixed_point) {
            len +%= 29;
        }
        if (cmd.ppc_reg_with_percent_prefix) {
            len +%= 30;
        }
        if (cmd.ppc_set_dscr) |ppc_set_dscr| {
            len +%= 16 +% fmt.Ud64.length(ppc_set_dscr);
        }
        if (cmd.ppc_stack_ptr_caller_preserved) {
            len +%= 33;
        }
        if (cmd.ppc_tls_opt) {
            len +%= 14;
        }
        if (cmd.ppc_track_subreg_liveness) {
            len +%= 28;
        }
        if (cmd.ppc_use_absolute_jumptables) {
            len +%= 30;
        }
        if (cmd.ppc_use_base_pointer) {
            len +%= 23;
        }
        if (cmd.ppc_use_bit_perm_rewriter) {
            len +%= 28;
        }
        if (cmd.ppc_use_branch_hint) {
            len +%= 22;
        }
        if (cmd.ppc_vsr_nums_as_vr) {
            len +%= 21;
        }
        if (cmd.pragma_unroll_and_jam_threshold) |pragma_unroll_and_jam_threshold| {
            len +%= 35 +% fmt.Ud64.length(pragma_unroll_and_jam_threshold);
        }
        if (cmd.pragma_unroll_threshold) |pragma_unroll_threshold| {
            len +%= 27 +% fmt.Ud64.length(pragma_unroll_threshold);
        }
        if (cmd.pragma_vectorize_scev_check_threshold) |pragma_vectorize_scev_check_threshold| {
            len +%= 41 +% fmt.Ud64.length(pragma_vectorize_scev_check_threshold);
        }
        if (cmd.pre_RA_sched) |pre_RA_sched| {
            len +%= 16 +% @tagName(pre_RA_sched).len;
        }
        if (cmd.precise_rotation_cost) {
            len +%= 24;
        }
        if (cmd.prefer_inloop_reductions) {
            len +%= 27;
        }
        if (cmd.prefer_no_csel) {
            len +%= 17;
        }
        if (cmd.prefer_predicate_over_epilogue) |prefer_predicate_over_epilogue| {
            len +%= 34 +% @tagName(prefer_predicate_over_epilogue).len;
        }
        if (cmd.prefer_predicated_reduction_select) {
            len +%= 37;
        }
        if (cmd.prefetch_distance) |prefetch_distance| {
            len +%= 21 +% fmt.Ud64.length(prefetch_distance);
        }
        if (cmd.prefetch_hints_file) |prefetch_hints_file| {
            len +%= 23 +% prefetch_hints_file.len;
        }
        if (cmd.preinline_threshold) |preinline_threshold| {
            len +%= 23 +% fmt.Ud64.length(preinline_threshold);
        }
        if (cmd.preserve_alignment_assumptions_during_inlining) {
            len +%= 49;
        }
        if (cmd.preserve_as_comments) {
            len +%= 23;
        }
        if (cmd.print_after) |print_after| {
            len +%= 15 +% print_after.len;
        }
        if (cmd.print_after_all) {
            len +%= 18;
        }
        if (cmd.print_after_isel) {
            len +%= 19;
        }
        if (cmd.print_all_options) {
            len +%= 20;
        }
        if (cmd.print_before) |print_before| {
            len +%= 16 +% print_before.len;
        }
        if (cmd.print_before_all) {
            len +%= 19;
        }
        if (cmd.print_before_changed) {
            len +%= 23;
        }
        if (cmd.print_bfi) {
            len +%= 12;
        }
        if (cmd.print_bfi_func_name) |print_bfi_func_name| {
            len +%= 23 +% print_bfi_func_name.len;
        }
        if (cmd.print_bpi) {
            len +%= 12;
        }
        if (cmd.print_bpi_func_name) |print_bpi_func_name| {
            len +%= 23 +% print_bpi_func_name.len;
        }
        if (cmd.print_changed) |print_changed| {
            len +%= 17 +% @tagName(print_changed).len;
        }
        if (cmd.print_changed_dot_path) |print_changed_dot_path| {
            len +%= 26 +% print_changed_dot_path.len;
        }
        if (cmd.print_debug_ata) {
            len +%= 18;
        }
        if (cmd.print_debug_counter) {
            len +%= 22;
        }
        if (cmd.print_failed_fuse_candidates) {
            len +%= 31;
        }
        if (cmd.print_gc) {
            len +%= 11;
        }
        if (cmd.print_import_failures) {
            len +%= 24;
        }
        if (cmd.print_imports) {
            len +%= 16;
        }
        if (cmd.print_instruction_comments) {
            len +%= 29;
        }
        if (cmd.print_isel_input) {
            len +%= 19;
        }
        if (cmd.print_lsr_output) {
            len +%= 19;
        }
        if (cmd.print_lvi_after_jump_threading) {
            len +%= 33;
        }
        if (cmd.print_machine_bfi) {
            len +%= 20;
        }
        if (cmd.print_module_scope) {
            len +%= 21;
        }
        if (cmd.print_on_crash) {
            len +%= 17;
        }
        if (cmd.print_options) {
            len +%= 16;
        }
        if (cmd.print_pipeline_passes) {
            len +%= 24;
        }
        if (cmd.print_region_style) |print_region_style| {
            len +%= 22 +% @tagName(print_region_style).len;
        }
        if (cmd.print_regmask_num_regs) |print_regmask_num_regs| {
            len +%= 26 +% fmt.Ud64.length(print_regmask_num_regs);
        }
        if (cmd.print_regusage) {
            len +%= 17;
        }
        if (cmd.print_slotindexes) {
            len +%= 20;
        }
        if (cmd.print_summary_global_ids) {
            len +%= 27;
        }
        if (cmd.procres_cost_lim) |procres_cost_lim| {
            len +%= 20 +% fmt.Ud64.length(procres_cost_lim);
        }
        if (cmd.profile_accurate_for_symsinlist) {
            len +%= 34;
        }
        if (cmd.profile_guided_section_prefix) {
            len +%= 32;
        }
        if (cmd.profile_isfs) {
            len +%= 15;
        }
        if (cmd.profile_likely_prob) |profile_likely_prob| {
            len +%= 23 +% fmt.Ud64.length(profile_likely_prob);
        }
        if (cmd.profile_sample_accurate) {
            len +%= 26;
        }
        if (cmd.profile_sample_block_accurate) {
            len +%= 32;
        }
        if (cmd.profile_summary_contextless) {
            len +%= 30;
        }
        if (cmd.profile_summary_cutoff_cold) |profile_summary_cutoff_cold| {
            len +%= 31 +% fmt.Ud64.length(profile_summary_cutoff_cold);
        }
        if (cmd.profile_summary_cutoff_hot) |profile_summary_cutoff_hot| {
            len +%= 30 +% fmt.Ud64.length(profile_summary_cutoff_hot);
        }
        if (cmd.profile_summary_huge_working_set_size_threshold) |profile_summary_huge_working_set_size_threshold| {
            len +%= 51 +% fmt.Ud64.length(profile_summary_huge_working_set_size_threshold);
        }
        if (cmd.profile_summary_large_working_set_size_threshold) |profile_summary_large_working_set_size_threshold| {
            len +%= 52 +% fmt.Ud64.length(profile_summary_large_working_set_size_threshold);
        }
        if (cmd.profile_symbol_list_cutoff) |profile_symbol_list_cutoff| {
            len +%= 30 +% fmt.Ud64.length(profile_symbol_list_cutoff);
        }
        if (cmd.profile_unknown_in_special_section) {
            len +%= 37;
        }
        if (cmd.propagate_attrs) {
            len +%= 18;
        }
        if (cmd.protect_from_escaped_allocas) {
            len +%= 31;
        }
        if (cmd.r600_ir_structurize) {
            len +%= 22;
        }
        if (cmd.rafast_ignore_missing_defs) {
            len +%= 29;
        }
        if (cmd.rdf_dump) {
            len +%= 11;
        }
        if (cmd.rdf_limit) |rdf_limit| {
            len +%= 13 +% fmt.Ud64.length(rdf_limit);
        }
        if (cmd.rdf_liveness_max_rec) |rdf_liveness_max_rec| {
            len +%= 24 +% fmt.Ud64.length(rdf_liveness_max_rec);
        }
        if (cmd.rdf_opt) {
            len +%= 10;
        }
        if (cmd.reassociate_geps_verify_no_dead_code) {
            len +%= 39;
        }
        if (cmd.rebalance_only_imbal) {
            len +%= 23;
        }
        if (cmd.rebalance_only_opt) {
            len +%= 21;
        }
        if (cmd.recurrence_chain_limit) |recurrence_chain_limit| {
            len +%= 26 +% fmt.Ud64.length(recurrence_chain_limit);
        }
        if (cmd.recursive_inline_max_stacksize) |recursive_inline_max_stacksize| {
            len +%= 34 +% fmt.Ud64.length(recursive_inline_max_stacksize);
        }
        if (cmd.regalloc) |regalloc| {
            len +%= 12 +% @tagName(regalloc).len;
        }
        if (cmd.regalloc_cheap_remat_weight) |regalloc_cheap_remat_weight| {
            len +%= 31 +% fmt.Ud64.length(regalloc_cheap_remat_weight);
        }
        if (cmd.regalloc_copy_weight) |regalloc_copy_weight| {
            len +%= 24 +% fmt.Ud64.length(regalloc_copy_weight);
        }
        if (cmd.regalloc_csr_first_time_cost) |regalloc_csr_first_time_cost| {
            len +%= 32 +% fmt.Ud64.length(regalloc_csr_first_time_cost);
        }
        if (cmd.regalloc_enable_advisor) |regalloc_enable_advisor| {
            len +%= 27 +% @tagName(regalloc_enable_advisor).len;
        }
        if (cmd.regalloc_enable_priority_advisor) |regalloc_enable_priority_advisor| {
            len +%= 36 +% @tagName(regalloc_enable_priority_advisor).len;
        }
        if (cmd.regalloc_eviction_max_interference_cutoff) |regalloc_eviction_max_interference_cutoff| {
            len +%= 45 +% fmt.Ud64.length(regalloc_eviction_max_interference_cutoff);
        }
        if (cmd.regalloc_expensive_remat_weight) |regalloc_expensive_remat_weight| {
            len +%= 35 +% fmt.Ud64.length(regalloc_expensive_remat_weight);
        }
        if (cmd.regalloc_load_weight) |regalloc_load_weight| {
            len +%= 24 +% fmt.Ud64.length(regalloc_load_weight);
        }
        if (cmd.regalloc_store_weight) |regalloc_store_weight| {
            len +%= 25 +% fmt.Ud64.length(regalloc_store_weight);
        }
        if (cmd.regbankselect_fast) {
            len +%= 21;
        }
        if (cmd.regbankselect_greedy) {
            len +%= 23;
        }
        if (cmd.relax_elf_relocations) {
            len +%= 24;
        }
        if (cmd.relax_nv_checks) {
            len +%= 18;
        }
        if (cmd.relocation_model) |relocation_model| {
            len +%= 20 +% @tagName(relocation_model).len;
        }
        if (cmd.remarks_section) {
            len +%= 18;
        }
        if (cmd.remat_pic_stub_load) {
            len +%= 22;
        }
        if (cmd.rename_exclude_alias_prefixes) |rename_exclude_alias_prefixes| {
            len +%= 33 +% rename_exclude_alias_prefixes.len;
        }
        if (cmd.rename_exclude_function_prefixes) |rename_exclude_function_prefixes| {
            len +%= 36 +% rename_exclude_function_prefixes.len;
        }
        if (cmd.rename_exclude_global_prefixes) |rename_exclude_global_prefixes| {
            len +%= 34 +% rename_exclude_global_prefixes.len;
        }
        if (cmd.rename_exclude_struct_prefixes) |rename_exclude_struct_prefixes| {
            len +%= 34 +% rename_exclude_struct_prefixes.len;
        }
        if (cmd.renumber_blocks_before_view) {
            len +%= 30;
        }
        if (cmd.replexitval) |replexitval| {
            len +%= 15 +% @tagName(replexitval).len;
        }
        if (cmd.report_profile_staleness) {
            len +%= 27;
        }
        if (cmd.reroll_num_tolerated_failed_matches) |reroll_num_tolerated_failed_matches| {
            len +%= 39 +% fmt.Ud64.length(reroll_num_tolerated_failed_matches);
        }
        if (cmd.reserve_regs_for_regalloc) |reserve_regs_for_regalloc| {
            len +%= 29 +% reserve_regs_for_regalloc.len;
        }
        if (cmd.restrict_statepoint_remat) {
            len +%= 28;
        }
        if (cmd.reverse_csr_restore_seq) {
            len +%= 26;
        }
        if (cmd.rewrite_map_file) |rewrite_map_file| {
            len +%= 20 +% rewrite_map_file.len;
        }
        if (cmd.rewrite_phi_limit) |rewrite_phi_limit| {
            len +%= 21 +% fmt.Ud64.length(rewrite_phi_limit);
        }
        if (cmd.riscv_disable_insert_vsetvl_phi_opt) {
            len +%= 38;
        }
        if (cmd.riscv_disable_regalloc_hints) {
            len +%= 31;
        }
        if (cmd.riscv_disable_sextw_removal) {
            len +%= 30;
        }
        if (cmd.riscv_disable_strip_w_suffix) {
            len +%= 31;
        }
        if (cmd.riscv_disable_using_constant_pool_for_large_ints) {
            len +%= 51;
        }
        if (cmd.riscv_enable_copyelim) {
            len +%= 24;
        }
        if (cmd.riscv_enable_global_merge) {
            len +%= 28;
        }
        if (cmd.riscv_enable_machine_combiner) {
            len +%= 32;
        }
        if (cmd.riscv_enable_subreg_liveness) {
            len +%= 31;
        }
        if (cmd.riscv_insert_vsetvl_strict_asserts) {
            len +%= 37;
        }
        if (cmd.riscv_lower_ext_max_web_size) |riscv_lower_ext_max_web_size| {
            len +%= 32 +% fmt.Ud64.length(riscv_lower_ext_max_web_size);
        }
        if (cmd.riscv_lower_form_vw_w_with_splat) {
            len +%= 35;
        }
        if (cmd.riscv_lower_fp_repeated_divisors) |riscv_lower_fp_repeated_divisors| {
            len +%= 36 +% fmt.Ud64.length(riscv_lower_fp_repeated_divisors);
        }
        if (cmd.riscv_max_build_ints_cost) |riscv_max_build_ints_cost| {
            len +%= 29 +% fmt.Ud64.length(riscv_max_build_ints_cost);
        }
        if (cmd.riscv_no_aliases) {
            len +%= 19;
        }
        if (cmd.riscv_prefer_whole_register_move) {
            len +%= 35;
        }
        if (cmd.riscv_v_fixed_length_vector_lmul_max) |riscv_v_fixed_length_vector_lmul_max| {
            len +%= 40 +% fmt.Ud64.length(riscv_v_fixed_length_vector_lmul_max);
        }
        if (cmd.riscv_v_register_bit_width_lmul) |riscv_v_register_bit_width_lmul| {
            len +%= 35 +% fmt.Ud64.length(riscv_v_register_bit_width_lmul);
        }
        if (cmd.riscv_v_slp_max_vf) |riscv_v_slp_max_vf| {
            len +%= 22 +% fmt.Ud64.length(riscv_v_slp_max_vf);
        }
        if (cmd.riscv_v_vector_bits_max) |riscv_v_vector_bits_max| {
            len +%= 27 +% fmt.Ud64.length(riscv_v_vector_bits_max);
        }
        if (cmd.riscv_v_vector_bits_min) |riscv_v_vector_bits_min| {
            len +%= 27 +% fmt.Ud64.length(riscv_v_vector_bits_min);
        }
        if (cmd.rotation_max_header_size) |rotation_max_header_size| {
            len +%= 28 +% fmt.Ud64.length(rotation_max_header_size);
        }
        if (cmd.rotation_prepare_for_lto) {
            len +%= 27;
        }
        if (cmd.rs4gc_allow_statepoint_with_no_deopt_info) {
            len +%= 44;
        }
        if (cmd.rs4gc_clobber_non_live) {
            len +%= 25;
        }
        if (cmd.rs4gc_remat_derived_at_uses) {
            len +%= 30;
        }
        if (cmd.run_pass) |run_pass| {
            len +%= 12 +% run_pass.len;
        }
        if (cmd.runtime_check_per_loop_load_elim) |runtime_check_per_loop_load_elim| {
            len +%= 36 +% fmt.Ud64.length(runtime_check_per_loop_load_elim);
        }
        if (cmd.runtime_counter_relocation) {
            len +%= 29;
        }
        if (cmd.runtime_mem_idiom_threshold) |runtime_mem_idiom_threshold| {
            len +%= 31 +% fmt.Ud64.length(runtime_mem_idiom_threshold);
        }
        if (cmd.runtime_memory_check_threshold) |runtime_memory_check_threshold| {
            len +%= 34 +% fmt.Ud64.length(runtime_memory_check_threshold);
        }
        if (cmd.safe_stack_coloring) {
            len +%= 22;
        }
        if (cmd.safe_stack_layout) {
            len +%= 20;
        }
        if (cmd.safepoint_ir_verifier_print_only) {
            len +%= 35;
        }
        if (cmd.safestack_use_pointer_address) {
            len +%= 32;
        }
        if (cmd.sample_profile_check_record_coverage) |sample_profile_check_record_coverage| {
            len +%= 40 +% fmt.Ud64.length(sample_profile_check_record_coverage);
        }
        if (cmd.sample_profile_check_sample_coverage) |sample_profile_check_sample_coverage| {
            len +%= 40 +% fmt.Ud64.length(sample_profile_check_sample_coverage);
        }
        if (cmd.sample_profile_cold_inline_threshold) |sample_profile_cold_inline_threshold| {
            len +%= 40 +% fmt.Ud64.length(sample_profile_cold_inline_threshold);
        }
        if (cmd.sample_profile_even_flow_distribution) {
            len +%= 40;
        }
        if (cmd.sample_profile_file) |sample_profile_file| {
            len +%= 23 +% sample_profile_file.len;
        }
        if (cmd.sample_profile_hot_inline_threshold) |sample_profile_hot_inline_threshold| {
            len +%= 39 +% fmt.Ud64.length(sample_profile_hot_inline_threshold);
        }
        if (cmd.sample_profile_icp_max_prom) |sample_profile_icp_max_prom| {
            len +%= 31 +% fmt.Ud64.length(sample_profile_icp_max_prom);
        }
        if (cmd.sample_profile_icp_relative_hotness) |sample_profile_icp_relative_hotness| {
            len +%= 39 +% fmt.Ud64.length(sample_profile_icp_relative_hotness);
        }
        if (cmd.sample_profile_icp_relative_hotness_skip) |sample_profile_icp_relative_hotness_skip| {
            len +%= 44 +% fmt.Ud64.length(sample_profile_icp_relative_hotness_skip);
        }
        if (cmd.sample_profile_inline_growth_limit) |sample_profile_inline_growth_limit| {
            len +%= 38 +% fmt.Ud64.length(sample_profile_inline_growth_limit);
        }
        if (cmd.sample_profile_inline_limit_max) |sample_profile_inline_limit_max| {
            len +%= 35 +% fmt.Ud64.length(sample_profile_inline_limit_max);
        }
        if (cmd.sample_profile_inline_limit_min) |sample_profile_inline_limit_min| {
            len +%= 35 +% fmt.Ud64.length(sample_profile_inline_limit_min);
        }
        if (cmd.sample_profile_inline_replay) |sample_profile_inline_replay| {
            len +%= 32 +% sample_profile_inline_replay.len;
        }
        if (cmd.sample_profile_inline_replay_fallback) |sample_profile_inline_replay_fallback| {
            len +%= 41 +% @tagName(sample_profile_inline_replay_fallback).len;
        }
        if (cmd.sample_profile_inline_replay_format) |sample_profile_inline_replay_format| {
            len +%= 39 +% @tagName(sample_profile_inline_replay_format).len;
        }
        if (cmd.sample_profile_inline_replay_scope) |sample_profile_inline_replay_scope| {
            len +%= 38 +% @tagName(sample_profile_inline_replay_scope).len;
        }
        if (cmd.sample_profile_inline_size) {
            len +%= 29;
        }
        if (cmd.sample_profile_join_islands) {
            len +%= 30;
        }
        if (cmd.sample_profile_max_propagate_iterations) |sample_profile_max_propagate_iterations| {
            len +%= 43 +% fmt.Ud64.length(sample_profile_max_propagate_iterations);
        }
        if (cmd.sample_profile_merge_inlinee) {
            len +%= 31;
        }
        if (cmd.sample_profile_prioritized_inline) {
            len +%= 36;
        }
        if (cmd.sample_profile_profi_cost_block_dec) |sample_profile_profi_cost_block_dec| {
            len +%= 39 +% fmt.Ud64.length(sample_profile_profi_cost_block_dec);
        }
        if (cmd.sample_profile_profi_cost_block_entry_dec) |sample_profile_profi_cost_block_entry_dec| {
            len +%= 45 +% fmt.Ud64.length(sample_profile_profi_cost_block_entry_dec);
        }
        if (cmd.sample_profile_profi_cost_block_entry_inc) |sample_profile_profi_cost_block_entry_inc| {
            len +%= 45 +% fmt.Ud64.length(sample_profile_profi_cost_block_entry_inc);
        }
        if (cmd.sample_profile_profi_cost_block_inc) |sample_profile_profi_cost_block_inc| {
            len +%= 39 +% fmt.Ud64.length(sample_profile_profi_cost_block_inc);
        }
        if (cmd.sample_profile_profi_cost_block_unknown_inc) |sample_profile_profi_cost_block_unknown_inc| {
            len +%= 47 +% fmt.Ud64.length(sample_profile_profi_cost_block_unknown_inc);
        }
        if (cmd.sample_profile_profi_cost_block_zero_inc) |sample_profile_profi_cost_block_zero_inc| {
            len +%= 44 +% fmt.Ud64.length(sample_profile_profi_cost_block_zero_inc);
        }
        if (cmd.sample_profile_rebalance_unknown) {
            len +%= 35;
        }
        if (cmd.sample_profile_recursive_inline) {
            len +%= 34;
        }
        if (cmd.sample_profile_remapping_file) |sample_profile_remapping_file| {
            len +%= 33 +% sample_profile_remapping_file.len;
        }
        if (cmd.sample_profile_top_down_load) {
            len +%= 31;
        }
        if (cmd.sample_profile_use_preinliner) {
            len +%= 32;
        }
        if (cmd.sample_profile_use_profi) {
            len +%= 27;
        }
        if (cmd.sanitizer_coverage_control_flow) {
            len +%= 34;
        }
        if (cmd.sanitizer_coverage_inline_8bit_counters) {
            len +%= 42;
        }
        if (cmd.sanitizer_coverage_inline_bool_flag) {
            len +%= 38;
        }
        if (cmd.sanitizer_coverage_level) |sanitizer_coverage_level| {
            len +%= 28 +% fmt.Ud64.length(sanitizer_coverage_level);
        }
        if (cmd.sanitizer_coverage_pc_table) {
            len +%= 30;
        }
        if (cmd.sanitizer_coverage_prune_blocks) {
            len +%= 34;
        }
        if (cmd.sanitizer_coverage_stack_depth) {
            len +%= 33;
        }
        if (cmd.sanitizer_coverage_trace_compares) {
            len +%= 36;
        }
        if (cmd.sanitizer_coverage_trace_divs) {
            len +%= 32;
        }
        if (cmd.sanitizer_coverage_trace_geps) {
            len +%= 32;
        }
        if (cmd.sanitizer_coverage_trace_loads) {
            len +%= 33;
        }
        if (cmd.sanitizer_coverage_trace_pc) {
            len +%= 30;
        }
        if (cmd.sanitizer_coverage_trace_pc_guard) {
            len +%= 36;
        }
        if (cmd.sanitizer_coverage_trace_stores) {
            len +%= 34;
        }
        if (cmd.sanitizer_metadata_atomics) {
            len +%= 29;
        }
        if (cmd.sanitizer_metadata_covered) {
            len +%= 29;
        }
        if (cmd.sanitizer_metadata_uar) {
            len +%= 25;
        }
        if (cmd.sanitizer_metadata_weak_callbacks) {
            len +%= 36;
        }
        if (cmd.scalable_vectorization) |scalable_vectorization| {
            len +%= 26 +% @tagName(scalable_vectorization).len;
        }
        if (cmd.scalar_evolution_classify_expressions) {
            len +%= 40;
        }
        if (cmd.scalar_evolution_finite_loop) {
            len +%= 31;
        }
        if (cmd.scalar_evolution_huge_expr_threshold) |scalar_evolution_huge_expr_threshold| {
            len +%= 40 +% fmt.Ud64.length(scalar_evolution_huge_expr_threshold);
        }
        if (cmd.scalar_evolution_max_add_rec_size) |scalar_evolution_max_add_rec_size| {
            len +%= 37 +% fmt.Ud64.length(scalar_evolution_max_add_rec_size);
        }
        if (cmd.scalar_evolution_max_arith_depth) |scalar_evolution_max_arith_depth| {
            len +%= 36 +% fmt.Ud64.length(scalar_evolution_max_arith_depth);
        }
        if (cmd.scalar_evolution_max_cast_depth) |scalar_evolution_max_cast_depth| {
            len +%= 35 +% fmt.Ud64.length(scalar_evolution_max_cast_depth);
        }
        if (cmd.scalar_evolution_max_constant_evolving_depth) |scalar_evolution_max_constant_evolving_depth| {
            len +%= 48 +% fmt.Ud64.length(scalar_evolution_max_constant_evolving_depth);
        }
        if (cmd.scalar_evolution_max_scc_analysis_depth) |scalar_evolution_max_scc_analysis_depth| {
            len +%= 43 +% fmt.Ud64.length(scalar_evolution_max_scc_analysis_depth);
        }
        if (cmd.scalar_evolution_max_scev_compare_depth) |scalar_evolution_max_scev_compare_depth| {
            len +%= 43 +% fmt.Ud64.length(scalar_evolution_max_scev_compare_depth);
        }
        if (cmd.scalar_evolution_max_scev_operations_implication_depth) |scalar_evolution_max_scev_operations_implication_depth| {
            len +%= 58 +% fmt.Ud64.length(scalar_evolution_max_scev_operations_implication_depth);
        }
        if (cmd.scalar_evolution_max_value_compare_depth) |scalar_evolution_max_value_compare_depth| {
            len +%= 44 +% fmt.Ud64.length(scalar_evolution_max_value_compare_depth);
        }
        if (cmd.scalar_evolution_use_context_for_no_wrap_flag_strenghening) {
            len +%= 61;
        }
        if (cmd.scalar_evolution_use_expensive_range_sharpening) {
            len +%= 50;
        }
        if (cmd.scalarize_load_store) {
            len +%= 23;
        }
        if (cmd.scalarize_variable_insert_extract) {
            len +%= 36;
        }
        if (cmd.scale_partial_sample_profile_working_set_size) {
            len +%= 48;
        }
        if (cmd.scev_addops_inline_threshold) |scev_addops_inline_threshold| {
            len +%= 32 +% fmt.Ud64.length(scev_addops_inline_threshold);
        }
        if (cmd.scev_cheap_expansion_budget) |scev_cheap_expansion_budget| {
            len +%= 31 +% fmt.Ud64.length(scev_cheap_expansion_budget);
        }
        if (cmd.scev_mulops_inline_threshold) |scev_mulops_inline_threshold| {
            len +%= 32 +% fmt.Ud64.length(scev_mulops_inline_threshold);
        }
        if (cmd.scev_range_iter_threshold) |scev_range_iter_threshold| {
            len +%= 29 +% fmt.Ud64.length(scev_range_iter_threshold);
        }
        if (cmd.scev_verify_ir) {
            len +%= 17;
        }
        if (cmd.sched_avg_ipc) |sched_avg_ipc| {
            len +%= 17 +% fmt.Ud64.length(sched_avg_ipc);
        }
        if (cmd.sched_high_latency_cycles) |sched_high_latency_cycles| {
            len +%= 29 +% fmt.Ud64.length(sched_high_latency_cycles);
        }
        if (cmd.sched_preds_closer) {
            len +%= 21;
        }
        if (cmd.sched_retval_optimization) {
            len +%= 28;
        }
        if (cmd.scheditins) {
            len +%= 13;
        }
        if (cmd.schedmodel) {
            len +%= 13;
        }
        if (cmd.schedule_ppc_vsx_fma_mutation_early) {
            len +%= 38;
        }
        if (cmd.select_opti_loop_cycle_gain_threshold) |select_opti_loop_cycle_gain_threshold| {
            len +%= 41 +% fmt.Ud64.length(select_opti_loop_cycle_gain_threshold);
        }
        if (cmd.select_opti_loop_gradient_gain_threshold) |select_opti_loop_gradient_gain_threshold| {
            len +%= 44 +% fmt.Ud64.length(select_opti_loop_gradient_gain_threshold);
        }
        if (cmd.select_opti_loop_relative_gain_threshold) |select_opti_loop_relative_gain_threshold| {
            len +%= 44 +% fmt.Ud64.length(select_opti_loop_relative_gain_threshold);
        }
        if (cmd.sgpr_regalloc) |sgpr_regalloc| {
            len +%= 17 +% @tagName(sgpr_regalloc).len;
        }
        if (cmd.show_fs_branchprob) {
            len +%= 21;
        }
        if (cmd.show_mc_encoding) {
            len +%= 19;
        }
        if (cmd.shrink_frame_limit) |shrink_frame_limit| {
            len +%= 22 +% fmt.Ud64.length(shrink_frame_limit);
        }
        if (cmd.simple_loop_unswitch_drop_non_trivial_implicit_null_checks) {
            len +%= 61;
        }
        if (cmd.simple_loop_unswitch_guards) {
            len +%= 30;
        }
        if (cmd.simple_loop_unswitch_memoryssa_threshold) |simple_loop_unswitch_memoryssa_threshold| {
            len +%= 44 +% fmt.Ud64.length(simple_loop_unswitch_memoryssa_threshold);
        }
        if (cmd.simplify_mir) {
            len +%= 15;
        }
        if (cmd.simplifycfg_branch_fold_common_dest_vector_multiplier) |simplifycfg_branch_fold_common_dest_vector_multiplier| {
            len +%= 57 +% fmt.Ud64.length(simplifycfg_branch_fold_common_dest_vector_multiplier);
        }
        if (cmd.simplifycfg_branch_fold_threshold) |simplifycfg_branch_fold_threshold| {
            len +%= 37 +% fmt.Ud64.length(simplifycfg_branch_fold_threshold);
        }
        if (cmd.simplifycfg_hoist_common) {
            len +%= 27;
        }
        if (cmd.simplifycfg_hoist_common_skip_limit) |simplifycfg_hoist_common_skip_limit| {
            len +%= 39 +% fmt.Ud64.length(simplifycfg_hoist_common_skip_limit);
        }
        if (cmd.simplifycfg_hoist_cond_stores) {
            len +%= 32;
        }
        if (cmd.simplifycfg_max_small_block_size) |simplifycfg_max_small_block_size| {
            len +%= 36 +% fmt.Ud64.length(simplifycfg_max_small_block_size);
        }
        if (cmd.simplifycfg_merge_compatible_invokes) {
            len +%= 39;
        }
        if (cmd.simplifycfg_merge_cond_stores) {
            len +%= 32;
        }
        if (cmd.simplifycfg_merge_cond_stores_aggressively) {
            len +%= 45;
        }
        if (cmd.simplifycfg_require_and_preserve_domtree) {
            len +%= 43;
        }
        if (cmd.simplifycfg_sink_common) {
            len +%= 26;
        }
        if (cmd.sink_common_insts) {
            len +%= 20;
        }
        if (cmd.sink_freq_percent_threshold) |sink_freq_percent_threshold| {
            len +%= 31 +% fmt.Ud64.length(sink_freq_percent_threshold);
        }
        if (cmd.sink_insts_to_avoid_spills) {
            len +%= 29;
        }
        if (cmd.skip_mips_long_branch) {
            len +%= 24;
        }
        if (cmd.skip_ret_exit_block) {
            len +%= 22;
        }
        if (cmd.slot1_store_slot0_load) {
            len +%= 25;
        }
        if (cmd.slp_max_look_ahead_depth) |slp_max_look_ahead_depth| {
            len +%= 28 +% fmt.Ud64.length(slp_max_look_ahead_depth);
        }
        if (cmd.slp_max_reg_size) |slp_max_reg_size| {
            len +%= 20 +% fmt.Ud64.length(slp_max_reg_size);
        }
        if (cmd.slp_max_root_look_ahead_depth) |slp_max_root_look_ahead_depth| {
            len +%= 33 +% fmt.Ud64.length(slp_max_root_look_ahead_depth);
        }
        if (cmd.slp_max_store_lookup) |slp_max_store_lookup| {
            len +%= 24 +% fmt.Ud64.length(slp_max_store_lookup);
        }
        if (cmd.slp_max_vf) |slp_max_vf| {
            len +%= 14 +% fmt.Ud64.length(slp_max_vf);
        }
        if (cmd.slp_min_reg_size) |slp_min_reg_size| {
            len +%= 20 +% fmt.Ud64.length(slp_min_reg_size);
        }
        if (cmd.slp_min_tree_size) |slp_min_tree_size| {
            len +%= 21 +% fmt.Ud64.length(slp_min_tree_size);
        }
        if (cmd.slp_recursion_max_depth) |slp_recursion_max_depth| {
            len +%= 27 +% fmt.Ud64.length(slp_recursion_max_depth);
        }
        if (cmd.slp_schedule_budget) |slp_schedule_budget| {
            len +%= 23 +% fmt.Ud64.length(slp_schedule_budget);
        }
        if (cmd.slp_threshold) |slp_threshold| {
            len +%= 17 +% fmt.Ud64.length(slp_threshold);
        }
        if (cmd.slp_vectorize_hor) {
            len +%= 20;
        }
        if (cmd.slp_vectorize_hor_store) {
            len +%= 26;
        }
        if (cmd.small_loop_cost) |small_loop_cost| {
            len +%= 19 +% fmt.Ud64.length(small_loop_cost);
        }
        if (cmd.sort_profiled_scc_member) {
            len +%= 27;
        }
        if (cmd.sort_timers) {
            len +%= 14;
        }
        if (cmd.sparc_bpcc_offset_bits) |sparc_bpcc_offset_bits| {
            len +%= 26 +% fmt.Ud64.length(sparc_bpcc_offset_bits);
        }
        if (cmd.sparc_enable_branch_relax) {
            len +%= 28;
        }
        if (cmd.sparc_reserve_app_registers) {
            len +%= 30;
        }
        if (cmd.spec_exec_max_not_hoisted) |spec_exec_max_not_hoisted| {
            len +%= 29 +% fmt.Ud64.length(spec_exec_max_not_hoisted);
        }
        if (cmd.spec_exec_max_speculation_cost) |spec_exec_max_speculation_cost| {
            len +%= 34 +% fmt.Ud64.length(spec_exec_max_speculation_cost);
        }
        if (cmd.spec_exec_only_if_divergent_target) {
            len +%= 37;
        }
        if (cmd.speculate_one_expensive_inst) {
            len +%= 31;
        }
        if (cmd.speculative_counter_promotion_max_exiting) |speculative_counter_promotion_max_exiting| {
            len +%= 45 +% fmt.Ud64.length(speculative_counter_promotion_max_exiting);
        }
        if (cmd.speculative_counter_promotion_to_loop) {
            len +%= 40;
        }
        if (cmd.spill_func_threshold) |spill_func_threshold| {
            len +%= 24 +% fmt.Ud64.length(spill_func_threshold);
        }
        if (cmd.spill_func_threshold_Os) |spill_func_threshold_Os| {
            len +%= 27 +% fmt.Ud64.length(spill_func_threshold_Os);
        }
        if (cmd.split_dwarf_cross_cu_references) {
            len +%= 34;
        }
        if (cmd.split_dwarf_file) |split_dwarf_file| {
            len +%= 20 +% split_dwarf_file.len;
        }
        if (cmd.split_dwarf_output) |split_dwarf_output| {
            len +%= 22 +% split_dwarf_output.len;
        }
        if (cmd.split_machine_functions) {
            len +%= 26;
        }
        if (cmd.split_spill_mode) |split_spill_mode| {
            len +%= 20 +% @tagName(split_spill_mode).len;
        }
        if (cmd.spp_all_backedges) {
            len +%= 20;
        }
        if (cmd.spp_counted_loop_trip_width) |spp_counted_loop_trip_width| {
            len +%= 31 +% fmt.Ud64.length(spp_counted_loop_trip_width);
        }
        if (cmd.spp_no_backedge) {
            len +%= 18;
        }
        if (cmd.spp_no_call) {
            len +%= 14;
        }
        if (cmd.spp_no_entry) {
            len +%= 15;
        }
        if (cmd.spp_print_base_pointers) {
            len +%= 26;
        }
        if (cmd.spp_print_liveset) {
            len +%= 20;
        }
        if (cmd.spp_print_liveset_size) {
            len +%= 25;
        }
        if (cmd.spp_rematerialization_threshold) |spp_rematerialization_threshold| {
            len +%= 35 +% fmt.Ud64.length(spp_rematerialization_threshold);
        }
        if (cmd.spp_split_backedge) {
            len +%= 21;
        }
        if (cmd.sroa_strict_inbounds) {
            len +%= 23;
        }
        if (cmd.ssc_dce_limit) |ssc_dce_limit| {
            len +%= 17 +% fmt.Ud64.length(ssc_dce_limit);
        }
        if (cmd.stack_safety_max_iterations) |stack_safety_max_iterations| {
            len +%= 31 +% fmt.Ud64.length(stack_safety_max_iterations);
        }
        if (cmd.stack_safety_print) {
            len +%= 21;
        }
        if (cmd.stack_safety_run) {
            len +%= 19;
        }
        if (cmd.stack_size_section) {
            len +%= 21;
        }
        if (cmd.stack_symbol_ordering) {
            len +%= 24;
        }
        if (cmd.stack_tagging_first_slot_opt) {
            len +%= 31;
        }
        if (cmd.stack_tagging_merge_init) {
            len +%= 27;
        }
        if (cmd.stack_tagging_merge_init_scan_limit) |stack_tagging_merge_init_scan_limit| {
            len +%= 39 +% fmt.Ud64.length(stack_tagging_merge_init_scan_limit);
        }
        if (cmd.stack_tagging_merge_init_size_limit) |stack_tagging_merge_init_size_limit| {
            len +%= 39 +% fmt.Ud64.length(stack_tagging_merge_init_size_limit);
        }
        if (cmd.stack_tagging_merge_settag) {
            len +%= 29;
        }
        if (cmd.stack_tagging_unchecked_ld_st) |stack_tagging_unchecked_ld_st| {
            len +%= 33 +% @tagName(stack_tagging_unchecked_ld_st).len;
        }
        if (cmd.stack_tagging_use_stack_safety) {
            len +%= 33;
        }
        if (cmd.stackcoloring_lifetime_start_on_first_use) {
            len +%= 44;
        }
        if (cmd.stackmap_version) |stackmap_version| {
            len +%= 20 +% fmt.Ud64.length(stackmap_version);
        }
        if (cmd.stackrealign) {
            len +%= 15;
        }
        if (cmd.start_after) |start_after| {
            len +%= 15 +% start_after.len;
        }
        if (cmd.start_before) |start_before| {
            len +%= 16 +% start_before.len;
        }
        if (cmd.static_func_full_module_prefix) {
            len +%= 33;
        }
        if (cmd.static_func_strip_dirname_prefix) |static_func_strip_dirname_prefix| {
            len +%= 36 +% fmt.Ud64.length(static_func_strip_dirname_prefix);
        }
        if (cmd.static_likely_prob) |static_likely_prob| {
            len +%= 22 +% fmt.Ud64.length(static_likely_prob);
        }
        if (cmd.stats) {
            len +%= 8;
        }
        if (cmd.stats_json) {
            len +%= 13;
        }
        if (cmd.stop_after) |stop_after| {
            len +%= 14 +% stop_after.len;
        }
        if (cmd.stop_before) |stop_before| {
            len +%= 15 +% stop_before.len;
        }
        if (cmd.store_to_load_forwarding_conflict_detection) {
            len +%= 46;
        }
        if (cmd.stress_cgp_ext_ld_promotion) {
            len +%= 30;
        }
        if (cmd.stress_cgp_store_extract) {
            len +%= 27;
        }
        if (cmd.stress_early_ifcvt) {
            len +%= 21;
        }
        if (cmd.stress_regalloc) |stress_regalloc| {
            len +%= 19 +% fmt.Ud64.length(stress_regalloc);
        }
        if (cmd.strict_dwarf) {
            len +%= 15;
        }
        if (cmd.structurizecfg_relaxed_uniform_regions) {
            len +%= 41;
        }
        if (cmd.structurizecfg_skip_uniform_regions) {
            len +%= 38;
        }
        if (cmd.summary_file) |summary_file| {
            len +%= 16 +% summary_file.len;
        }
        if (cmd.sve_gather_overhead) |sve_gather_overhead| {
            len +%= 23 +% fmt.Ud64.length(sve_gather_overhead);
        }
        if (cmd.sve_scatter_overhead) |sve_scatter_overhead| {
            len +%= 24 +% fmt.Ud64.length(sve_scatter_overhead);
        }
        if (cmd.sve_tail_folding) |sve_tail_folding| {
            len +%= 20 +% sve_tail_folding.len;
        }
        if (cmd.swift_async_fp) |swift_async_fp| {
            len +%= 18 +% @tagName(swift_async_fp).len;
        }
        if (cmd.switch_peel_threshold) |switch_peel_threshold| {
            len +%= 25 +% fmt.Ud64.length(switch_peel_threshold);
        }
        if (cmd.switch_range_to_icmp) {
            len +%= 23;
        }
        if (cmd.switch_to_lookup) {
            len +%= 19;
        }
        if (cmd.systemz_subreg_liveness) {
            len +%= 26;
        }
        if (cmd.t2_reduce_limit) |t2_reduce_limit| {
            len +%= 19 +% fmt.Ud64.length(t2_reduce_limit);
        }
        if (cmd.t2_reduce_limit2) |t2_reduce_limit2| {
            len +%= 20 +% fmt.Ud64.length(t2_reduce_limit2);
        }
        if (cmd.t2_reduce_limit3) |t2_reduce_limit3| {
            len +%= 20 +% fmt.Ud64.length(t2_reduce_limit3);
        }
        if (cmd.tail_dup_indirect_size) |tail_dup_indirect_size| {
            len +%= 26 +% fmt.Ud64.length(tail_dup_indirect_size);
        }
        if (cmd.tail_dup_limit) |tail_dup_limit| {
            len +%= 18 +% fmt.Ud64.length(tail_dup_limit);
        }
        if (cmd.tail_dup_placement) {
            len +%= 21;
        }
        if (cmd.tail_dup_placement_aggressive_threshold) |tail_dup_placement_aggressive_threshold| {
            len +%= 43 +% fmt.Ud64.length(tail_dup_placement_aggressive_threshold);
        }
        if (cmd.tail_dup_placement_penalty) |tail_dup_placement_penalty| {
            len +%= 30 +% fmt.Ud64.length(tail_dup_placement_penalty);
        }
        if (cmd.tail_dup_placement_threshold) |tail_dup_placement_threshold| {
            len +%= 32 +% fmt.Ud64.length(tail_dup_placement_threshold);
        }
        if (cmd.tail_dup_profile_percent_threshold) |tail_dup_profile_percent_threshold| {
            len +%= 38 +% fmt.Ud64.length(tail_dup_profile_percent_threshold);
        }
        if (cmd.tail_dup_size) |tail_dup_size| {
            len +%= 17 +% fmt.Ud64.length(tail_dup_size);
        }
        if (cmd.tail_dup_verify) {
            len +%= 18;
        }
        if (cmd.tail_merge_size) |tail_merge_size| {
            len +%= 19 +% fmt.Ud64.length(tail_merge_size);
        }
        if (cmd.tail_merge_threshold) |tail_merge_threshold| {
            len +%= 24 +% fmt.Ud64.length(tail_merge_threshold);
        }
        if (cmd.tail_predication) |tail_predication| {
            len +%= 20 +% @tagName(tail_predication).len;
        }
        if (cmd.tailcallopt) {
            len +%= 14;
        }
        if (cmd.target_abi) |target_abi| {
            len +%= 14 +% target_abi.len;
        }
        if (cmd.temporal_reuse_threshold) |temporal_reuse_threshold| {
            len +%= 28 +% fmt.Ud64.length(temporal_reuse_threshold);
        }
        if (cmd.terminal_rule) {
            len +%= 16;
        }
        if (cmd.tfutils_use_simplelogger) {
            len +%= 27;
        }
        if (cmd.thinlto_assume_merged) {
            len +%= 24;
        }
        if (cmd.thinlto_synthesize_entry_counts) {
            len +%= 34;
        }
        if (cmd.thread_model) |thread_model| {
            len +%= 16 +% @tagName(thread_model).len;
        }
        if (cmd.threads) |threads| {
            len +%= 11 +% fmt.Ud64.length(threads);
        }
        if (cmd.time_compilations) |time_compilations| {
            len +%= 21 +% fmt.Ud64.length(time_compilations);
        }
        if (cmd.time_passes) {
            len +%= 14;
        }
        if (cmd.time_passes_per_run) {
            len +%= 22;
        }
        if (cmd.time_trace) {
            len +%= 13;
        }
        if (cmd.time_trace_file) |time_trace_file| {
            len +%= 19 +% time_trace_file.len;
        }
        if (cmd.time_trace_granularity) |time_trace_granularity| {
            len +%= 26 +% fmt.Ud64.length(time_trace_granularity);
        }
        if (cmd.tiny_trip_count_interleave_threshold) |tiny_trip_count_interleave_threshold| {
            len +%= 40 +% fmt.Ud64.length(tiny_trip_count_interleave_threshold);
        }
        if (cmd.tls_load_hoist) {
            len +%= 17;
        }
        if (cmd.tls_size) |tls_size| {
            len +%= 12 +% fmt.Ud64.length(tls_size);
        }
        if (cmd.trace_gv_placement) {
            len +%= 21;
        }
        if (cmd.trace_hex_vector_stores_only) {
            len +%= 31;
        }
        if (cmd.track_memory) {
            len +%= 15;
        }
        if (cmd.trap_func) |trap_func| {
            len +%= 13 +% trap_func.len;
        }
        if (cmd.trap_unreachable) {
            len +%= 19;
        }
        if (cmd.treat_scalable_fixed_error_as_warning) {
            len +%= 40;
        }
        if (cmd.triangle_chain_count) |triangle_chain_count| {
            len +%= 24 +% fmt.Ud64.length(triangle_chain_count);
        }
        if (cmd.trim_var_locs) {
            len +%= 16;
        }
        if (cmd.tsan_compound_read_before_write) {
            len +%= 34;
        }
        if (cmd.tsan_distinguish_volatile) {
            len +%= 28;
        }
        if (cmd.tsan_handle_cxx_exceptions) {
            len +%= 29;
        }
        if (cmd.tsan_instrument_atomics) {
            len +%= 26;
        }
        if (cmd.tsan_instrument_func_entry_exit) {
            len +%= 34;
        }
        if (cmd.tsan_instrument_memintrinsics) {
            len +%= 32;
        }
        if (cmd.tsan_instrument_memory_accesses) {
            len +%= 34;
        }
        if (cmd.tsan_instrument_read_before_write) {
            len +%= 36;
        }
        if (cmd.two_entry_phi_node_folding_threshold) |two_entry_phi_node_folding_threshold| {
            len +%= 40 +% fmt.Ud64.length(two_entry_phi_node_folding_threshold);
        }
        if (cmd.twoaddr_reschedule) {
            len +%= 21;
        }
        if (cmd.type_based_intrinsic_cost) {
            len +%= 28;
        }
        if (cmd.undef_reg_clearance) |undef_reg_clearance| {
            len +%= 23 +% fmt.Ud64.length(undef_reg_clearance);
        }
        if (cmd.unique_basic_block_section_names) {
            len +%= 35;
        }
        if (cmd.unique_section_names) {
            len +%= 23;
        }
        if (cmd.unlikely_branch_weight) |unlikely_branch_weight| {
            len +%= 26 +% fmt.Ud64.length(unlikely_branch_weight);
        }
        if (cmd.unroll_allow_loop_nests_peeling) {
            len +%= 34;
        }
        if (cmd.unroll_allow_partial) {
            len +%= 23;
        }
        if (cmd.unroll_allow_peeling) {
            len +%= 23;
        }
        if (cmd.unroll_allow_remainder) {
            len +%= 25;
        }
        if (cmd.unroll_and_jam_count) |unroll_and_jam_count| {
            len +%= 24 +% fmt.Ud64.length(unroll_and_jam_count);
        }
        if (cmd.unroll_and_jam_threshold) |unroll_and_jam_threshold| {
            len +%= 28 +% fmt.Ud64.length(unroll_and_jam_threshold);
        }
        if (cmd.unroll_count) |unroll_count| {
            len +%= 16 +% fmt.Ud64.length(unroll_count);
        }
        if (cmd.unroll_force_peel_count) |unroll_force_peel_count| {
            len +%= 27 +% fmt.Ud64.length(unroll_force_peel_count);
        }
        if (cmd.unroll_full_max_count) |unroll_full_max_count| {
            len +%= 25 +% fmt.Ud64.length(unroll_full_max_count);
        }
        if (cmd.unroll_max_count) |unroll_max_count| {
            len +%= 20 +% fmt.Ud64.length(unroll_max_count);
        }
        if (cmd.unroll_max_iteration_count_to_analyze) |unroll_max_iteration_count_to_analyze| {
            len +%= 41 +% fmt.Ud64.length(unroll_max_iteration_count_to_analyze);
        }
        if (cmd.unroll_max_percent_threshold_boost) |unroll_max_percent_threshold_boost| {
            len +%= 38 +% fmt.Ud64.length(unroll_max_percent_threshold_boost);
        }
        if (cmd.unroll_max_upperbound) |unroll_max_upperbound| {
            len +%= 25 +% fmt.Ud64.length(unroll_max_upperbound);
        }
        if (cmd.unroll_optsize_threshold) |unroll_optsize_threshold| {
            len +%= 28 +% fmt.Ud64.length(unroll_optsize_threshold);
        }
        if (cmd.unroll_partial_threshold) |unroll_partial_threshold| {
            len +%= 28 +% fmt.Ud64.length(unroll_partial_threshold);
        }
        if (cmd.unroll_peel_count) |unroll_peel_count| {
            len +%= 21 +% fmt.Ud64.length(unroll_peel_count);
        }
        if (cmd.unroll_peel_max_count) |unroll_peel_max_count| {
            len +%= 25 +% fmt.Ud64.length(unroll_peel_max_count);
        }
        if (cmd.unroll_remainder) {
            len +%= 19;
        }
        if (cmd.unroll_revisit_child_loops) {
            len +%= 29;
        }
        if (cmd.unroll_runtime) {
            len +%= 17;
        }
        if (cmd.unroll_runtime_epilog) {
            len +%= 24;
        }
        if (cmd.unroll_runtime_multi_exit) {
            len +%= 28;
        }
        if (cmd.unroll_runtime_other_exit_predictable) {
            len +%= 40;
        }
        if (cmd.unroll_threshold) |unroll_threshold| {
            len +%= 20 +% fmt.Ud64.length(unroll_threshold);
        }
        if (cmd.unroll_threshold_aggressive) |unroll_threshold_aggressive| {
            len +%= 31 +% fmt.Ud64.length(unroll_threshold_aggressive);
        }
        if (cmd.unroll_threshold_default) |unroll_threshold_default| {
            len +%= 28 +% fmt.Ud64.length(unroll_threshold_default);
        }
        if (cmd.unroll_verify_domtree) {
            len +%= 24;
        }
        if (cmd.unroll_verify_loopinfo) {
            len +%= 25;
        }
        if (cmd.unswitch_num_initial_unscaled_candidates) |unswitch_num_initial_unscaled_candidates| {
            len +%= 44 +% fmt.Ud64.length(unswitch_num_initial_unscaled_candidates);
        }
        if (cmd.unswitch_siblings_toplevel_div) |unswitch_siblings_toplevel_div| {
            len +%= 34 +% fmt.Ud64.length(unswitch_siblings_toplevel_div);
        }
        if (cmd.unswitch_threshold) |unswitch_threshold| {
            len +%= 22 +% fmt.Ud64.length(unswitch_threshold);
        }
        if (cmd.update_pseudo_probe) {
            len +%= 22;
        }
        if (cmd.update_return_attrs) {
            len +%= 22;
        }
        if (cmd.use_ctors) {
            len +%= 12;
        }
        if (cmd.use_dbg_addr) {
            len +%= 15;
        }
        if (cmd.use_dereferenceable_at_point_semantics) |use_dereferenceable_at_point_semantics| {
            len +%= 42 +% fmt.Ud64.length(use_dereferenceable_at_point_semantics);
        }
        if (cmd.use_dwarf_ranges_base_address_specifier) {
            len +%= 42;
        }
        if (cmd.use_gnu_debug_macro) {
            len +%= 22;
        }
        if (cmd.use_gpu_divergence_analysis) {
            len +%= 30;
        }
        if (cmd.use_iterative_bfi_inference) {
            len +%= 30;
        }
        if (cmd.use_leb128_directives) {
            len +%= 24;
        }
        if (cmd.use_lir_code_size_heurs) {
            len +%= 26;
        }
        if (cmd.use_mbpi) {
            len +%= 11;
        }
        if (cmd.use_newer_candidate) {
            len +%= 22;
        }
        if (cmd.use_noalias_intrinsic_during_inlining) {
            len +%= 40;
        }
        if (cmd.use_profiled_call_graph) {
            len +%= 26;
        }
        if (cmd.use_registers_for_deopt_values) {
            len +%= 33;
        }
        if (cmd.use_registers_for_gc_values_in_landing_pad) {
            len +%= 45;
        }
        if (cmd.use_segment_set_for_physregs) {
            len +%= 31;
        }
        if (cmd.use_source_filename_for_promoted_locals) {
            len +%= 42;
        }
        if (cmd.use_tbaa_in_sched_mi) {
            len +%= 23;
        }
        if (cmd.use_unknown_locations) |use_unknown_locations| {
            len +%= 25 +% @tagName(use_unknown_locations).len;
        }
        if (cmd.vec_extabi) {
            len +%= 13;
        }
        if (cmd.vector_combine_max_scan_instrs) |vector_combine_max_scan_instrs| {
            len +%= 34 +% fmt.Ud64.length(vector_combine_max_scan_instrs);
        }
        if (cmd.vector_library) |vector_library| {
            len +%= 18 +% @tagName(vector_library).len;
        }
        if (cmd.vectorize_loops) {
            len +%= 18;
        }
        if (cmd.vectorize_memory_check_threshold) |vectorize_memory_check_threshold| {
            len +%= 36 +% fmt.Ud64.length(vectorize_memory_check_threshold);
        }
        if (cmd.vectorize_num_stores_pred) |vectorize_num_stores_pred| {
            len +%= 29 +% fmt.Ud64.length(vectorize_num_stores_pred);
        }
        if (cmd.vectorize_scev_check_threshold) |vectorize_scev_check_threshold| {
            len +%= 34 +% fmt.Ud64.length(vectorize_scev_check_threshold);
        }
        if (cmd.vectorize_slp) {
            len +%= 16;
        }
        if (cmd.vectorizer_maximize_bandwidth) {
            len +%= 32;
        }
        if (cmd.vectorizer_min_trip_count) |vectorizer_min_trip_count| {
            len +%= 29 +% fmt.Ud64.length(vectorizer_min_trip_count);
        }
        if (cmd.verify_arm_pseudo_expand) {
            len +%= 27;
        }
        if (cmd.verify_assumption_cache) {
            len +%= 26;
        }
        if (cmd.verify_cfg_preserved) {
            len +%= 23;
        }
        if (cmd.verify_cfiinstrs) {
            len +%= 19;
        }
        if (cmd.verify_coalescing) {
            len +%= 20;
        }
        if (cmd.verify_dom_info) {
            len +%= 18;
        }
        if (cmd.verify_indvars) {
            len +%= 17;
        }
        if (cmd.verify_loop_info) {
            len +%= 19;
        }
        if (cmd.verify_loop_lcssa) {
            len +%= 20;
        }
        if (cmd.verify_machine_dom_info) {
            len +%= 26;
        }
        if (cmd.verify_machineinstrs) {
            len +%= 23;
        }
        if (cmd.verify_memoryssa) {
            len +%= 19;
        }
        if (cmd.verify_misched) {
            len +%= 17;
        }
        if (cmd.verify_noalias_scope_decl_dom) {
            len +%= 32;
        }
        if (cmd.verify_predicateinfo) {
            len +%= 23;
        }
        if (cmd.verify_pseudo_probe) {
            len +%= 22;
        }
        if (cmd.verify_pseudo_probe_funcs) |verify_pseudo_probe_funcs| {
            len +%= 29 +% verify_pseudo_probe_funcs.len;
        }
        if (cmd.verify_regalloc) {
            len +%= 18;
        }
        if (cmd.verify_region_info) {
            len +%= 21;
        }
        if (cmd.verify_scev) {
            len +%= 14;
        }
        if (cmd.verify_scev_maps) {
            len +%= 19;
        }
        if (cmd.verify_scev_strict) {
            len +%= 21;
        }
        if (cmd.version) {
            len +%= 10;
        }
        if (cmd.vgpr_regalloc) |vgpr_regalloc| {
            len +%= 17 +% @tagName(vgpr_regalloc).len;
        }
        if (cmd.view_bfi_func_name) |view_bfi_func_name| {
            len +%= 22 +% view_bfi_func_name.len;
        }
        if (cmd.view_block_freq_propagation_dags) |view_block_freq_propagation_dags| {
            len +%= 36 +% @tagName(view_block_freq_propagation_dags).len;
        }
        if (cmd.view_block_layout_with_bfi) |view_block_layout_with_bfi| {
            len +%= 30 +% @tagName(view_block_layout_with_bfi).len;
        }
        if (cmd.view_edge_bundles) {
            len +%= 20;
        }
        if (cmd.view_hot_freq_percent) |view_hot_freq_percent| {
            len +%= 25 +% fmt.Ud64.length(view_hot_freq_percent);
        }
        if (cmd.view_machine_block_freq_propagation_dags) |view_machine_block_freq_propagation_dags| {
            len +%= 44 +% @tagName(view_machine_block_freq_propagation_dags).len;
        }
        if (cmd.view_slp_tree) {
            len +%= 16;
        }
        if (cmd.vliw_misched_reg_pressure) |vliw_misched_reg_pressure| {
            len +%= 29 +% fmt.Ud64.length(vliw_misched_reg_pressure);
        }
        if (cmd.vp_counters_per_site) |vp_counters_per_site| {
            len +%= 24 +% fmt.Ud64.length(vp_counters_per_site);
        }
        if (cmd.vp_static_alloc) {
            len +%= 18;
        }
        if (cmd.vplan_build_stress_test) {
            len +%= 26;
        }
        if (cmd.vplan_print_in_dot_format) {
            len +%= 28;
        }
        if (cmd.vplan_verify_hcfg) {
            len +%= 20;
        }
        if (cmd.wasm_disable_explicit_locals) {
            len +%= 31;
        }
        if (cmd.wasm_enable_eh) {
            len +%= 17;
        }
        if (cmd.wasm_enable_sjlj) {
            len +%= 19;
        }
        if (cmd.wasm_keep_registers) {
            len +%= 22;
        }
        if (cmd.whole_program_visibility) {
            len +%= 27;
        }
        if (cmd.wholeprogramdevirt_branch_funnel_threshold) |wholeprogramdevirt_branch_funnel_threshold| {
            len +%= 46 +% fmt.Ud64.length(wholeprogramdevirt_branch_funnel_threshold);
        }
        if (cmd.wholeprogramdevirt_check) |wholeprogramdevirt_check| {
            len +%= 28 +% @tagName(wholeprogramdevirt_check).len;
        }
        if (cmd.wholeprogramdevirt_print_index_based) {
            len +%= 39;
        }
        if (cmd.wholeprogramdevirt_read_summary) |wholeprogramdevirt_read_summary| {
            len +%= 35 +% wholeprogramdevirt_read_summary.len;
        }
        if (cmd.wholeprogramdevirt_skip) |wholeprogramdevirt_skip| {
            len +%= 27 +% wholeprogramdevirt_skip.len;
        }
        if (cmd.wholeprogramdevirt_summary_action) |wholeprogramdevirt_summary_action| {
            len +%= 37 +% @tagName(wholeprogramdevirt_summary_action).len;
        }
        if (cmd.wholeprogramdevirt_write_summary) |wholeprogramdevirt_write_summary| {
            len +%= 36 +% wholeprogramdevirt_write_summary.len;
        }
        if (cmd.write_relbf_to_summary) {
            len +%= 25;
        }
        if (cmd.x86_align_branch) |x86_align_branch| {
            len +%= 20 +% x86_align_branch.len;
        }
        if (cmd.x86_align_branch_boundary) |x86_align_branch_boundary| {
            len +%= 29 +% fmt.Ud64.length(x86_align_branch_boundary);
        }
        if (cmd.x86_and_imm_shrink) {
            len +%= 21;
        }
        if (cmd.x86_asm_syntax) |x86_asm_syntax| {
            len +%= 18 +% @tagName(x86_asm_syntax).len;
        }
        if (cmd.x86_branches_within_32B_boundaries) {
            len +%= 37;
        }
        if (cmd.x86_bypass_prefetch_instructions) {
            len +%= 35;
        }
        if (cmd.x86_cmov_converter) {
            len +%= 21;
        }
        if (cmd.x86_cmov_converter_force_all) {
            len +%= 31;
        }
        if (cmd.x86_cmov_converter_force_mem_operand) {
            len +%= 39;
        }
        if (cmd.x86_cmov_converter_threshold) |x86_cmov_converter_threshold| {
            len +%= 32 +% fmt.Ud64.length(x86_cmov_converter_threshold);
        }
        if (cmd.x86_disable_avoid_SFB) {
            len +%= 24;
        }
        if (cmd.x86_discriminate_memops) {
            len +%= 26;
        }
        if (cmd.x86_early_ifcvt) {
            len +%= 18;
        }
        if (cmd.x86_experimental_lvi_inline_asm_hardening) {
            len +%= 44;
        }
        if (cmd.x86_experimental_pref_innermost_loop_alignment) |x86_experimental_pref_innermost_loop_alignment| {
            len +%= 50 +% fmt.Ud64.length(x86_experimental_pref_innermost_loop_alignment);
        }
        if (cmd.x86_experimental_unordered_atomic_isel) {
            len +%= 41;
        }
        if (cmd.x86_indirect_branch_tracking) {
            len +%= 31;
        }
        if (cmd.x86_lvi_load_dot) {
            len +%= 19;
        }
        if (cmd.x86_lvi_load_dot_only) {
            len +%= 24;
        }
        if (cmd.x86_lvi_load_dot_verify) {
            len +%= 26;
        }
        if (cmd.x86_lvi_load_no_cbranch) {
            len +%= 26;
        }
        if (cmd.x86_lvi_load_opt_plugin) |x86_lvi_load_opt_plugin| {
            len +%= 27 +% x86_lvi_load_opt_plugin.len;
        }
        if (cmd.x86_machine_combiner) {
            len +%= 23;
        }
        if (cmd.x86_pad_for_align) {
            len +%= 20;
        }
        if (cmd.x86_pad_for_branch_align) {
            len +%= 27;
        }
        if (cmd.x86_pad_max_prefix_size) |x86_pad_max_prefix_size| {
            len +%= 27 +% fmt.Ud64.length(x86_pad_max_prefix_size);
        }
        if (cmd.x86_promote_anyext_load) {
            len +%= 26;
        }
        if (cmd.x86_seses_enable_without_lvi_cfi) {
            len +%= 35;
        }
        if (cmd.x86_seses_omit_branch_lfences) {
            len +%= 32;
        }
        if (cmd.x86_seses_one_lfence_per_bb) {
            len +%= 30;
        }
        if (cmd.x86_seses_only_lfence_non_const) {
            len +%= 34;
        }
        if (cmd.x86_sfb_inspection_limit) |x86_sfb_inspection_limit| {
            len +%= 28 +% fmt.Ud64.length(x86_sfb_inspection_limit);
        }
        if (cmd.x86_slh_fence_call_and_ret) {
            len +%= 29;
        }
        if (cmd.x86_slh_indirect) {
            len +%= 19;
        }
        if (cmd.x86_slh_ip) {
            len +%= 13;
        }
        if (cmd.x86_slh_lfence) {
            len +%= 17;
        }
        if (cmd.x86_slh_loads) {
            len +%= 16;
        }
        if (cmd.x86_slh_post_load) {
            len +%= 20;
        }
        if (cmd.x86_speculative_load_hardening) {
            len +%= 33;
        }
        if (cmd.x86_tile_ra) {
            len +%= 14;
        }
        if (cmd.x86_use_base_pointer) {
            len +%= 23;
        }
        if (cmd.x86_use_fsrm_for_memcpy) {
            len +%= 26;
        }
        if (cmd.x86_use_vzeroupper) {
            len +%= 21;
        }
        if (cmd.xcoff_traceback_table) {
            len +%= 24;
        }
        if (cmd.xcore_max_threads) |xcore_max_threads| {
            len +%= 21 +% fmt.Ud64.length(xcore_max_threads);
        }
        return len;
    }
    pub fn formatWrite(cmd: *LLCCommand, llc_exe: []const u8, array: anytype) void {
        @setRuntimeSafety(false);
        array.writeMany(llc_exe);
        array.writeOne(0);
        if (cmd.aarch64_a57_fp_load_balancing_force_all) {
            array.writeMany("--aarch64-a57-fp-load-balancing-force-all\x00");
        }
        if (cmd.aarch64_a57_fp_load_balancing_override) |aarch64_a57_fp_load_balancing_override| {
            array.writeMany("--aarch64-a57-fp-load-balancing-override\x00");
            array.writeFormat(fmt.ud64(aarch64_a57_fp_load_balancing_override));
            array.writeOne(0);
        }
        if (cmd.aarch64_bcc_offset_bits) |aarch64_bcc_offset_bits| {
            array.writeMany("--aarch64-bcc-offset-bits\x00");
            array.writeFormat(fmt.ud64(aarch64_bcc_offset_bits));
            array.writeOne(0);
        }
        if (cmd.aarch64_cbz_offset_bits) |aarch64_cbz_offset_bits| {
            array.writeMany("--aarch64-cbz-offset-bits\x00");
            array.writeFormat(fmt.ud64(aarch64_cbz_offset_bits));
            array.writeOne(0);
        }
        if (cmd.aarch64_ccmp_limit) |aarch64_ccmp_limit| {
            array.writeMany("--aarch64-ccmp-limit\x00");
            array.writeFormat(fmt.ud64(aarch64_ccmp_limit));
            array.writeOne(0);
        }
        if (cmd.aarch64_early_ifcvt) {
            array.writeMany("--aarch64-early-ifcvt\x00");
        }
        if (cmd.aarch64_elf_ldtls_generation) {
            array.writeMany("--aarch64-elf-ldtls-generation\x00");
        }
        if (cmd.aarch64_enable_atomic_cfg_tidy) {
            array.writeMany("--aarch64-enable-atomic-cfg-tidy\x00");
        }
        if (cmd.aarch64_enable_branch_relax) {
            array.writeMany("--aarch64-enable-branch-relax\x00");
        }
        if (cmd.aarch64_enable_branch_targets) {
            array.writeMany("--aarch64-enable-branch-targets\x00");
        }
        if (cmd.aarch64_enable_ccmp) {
            array.writeMany("--aarch64-enable-ccmp\x00");
        }
        if (cmd.aarch64_enable_collect_loh) {
            array.writeMany("--aarch64-enable-collect-loh\x00");
        }
        if (cmd.aarch64_enable_compress_jump_tables) {
            array.writeMany("--aarch64-enable-compress-jump-tables\x00");
        }
        if (cmd.aarch64_enable_cond_br_tune) {
            array.writeMany("--aarch64-enable-cond-br-tune\x00");
        }
        if (cmd.aarch64_enable_condopt) {
            array.writeMany("--aarch64-enable-condopt\x00");
        }
        if (cmd.aarch64_enable_copy_propagation) {
            array.writeMany("--aarch64-enable-copy-propagation\x00");
        }
        if (cmd.aarch64_enable_copyelim) {
            array.writeMany("--aarch64-enable-copyelim\x00");
        }
        if (cmd.aarch64_enable_dead_defs) {
            array.writeMany("--aarch64-enable-dead-defs\x00");
        }
        if (cmd.aarch64_enable_early_ifcvt) {
            array.writeMany("--aarch64-enable-early-ifcvt\x00");
        }
        if (cmd.aarch64_enable_falkor_hwpf_fix) {
            array.writeMany("--aarch64-enable-falkor-hwpf-fix\x00");
        }
        if (cmd.aarch64_enable_gep_opt) {
            array.writeMany("--aarch64-enable-gep-opt\x00");
        }
        if (cmd.aarch64_enable_gisel_ldst_postlegal) {
            array.writeMany("--aarch64-enable-gisel-ldst-postlegal\x00");
        }
        if (cmd.aarch64_enable_gisel_ldst_prelegal) {
            array.writeMany("--aarch64-enable-gisel-ldst-prelegal\x00");
        }
        if (cmd.aarch64_enable_global_isel_at_O) |aarch64_enable_global_isel_at_O| {
            array.writeMany("--aarch64-enable-global-isel-at-O\x00");
            array.writeFormat(fmt.ud64(aarch64_enable_global_isel_at_O));
            array.writeOne(0);
        }
        if (cmd.aarch64_enable_global_merge) {
            array.writeMany("--aarch64-enable-global-merge\x00");
        }
        if (cmd.aarch64_enable_ldst_opt) {
            array.writeMany("--aarch64-enable-ldst-opt\x00");
        }
        if (cmd.aarch64_enable_logical_imm) {
            array.writeMany("--aarch64-enable-logical-imm\x00");
        }
        if (cmd.aarch64_enable_loop_data_prefetch) {
            array.writeMany("--aarch64-enable-loop-data-prefetch\x00");
        }
        if (cmd.aarch64_enable_mcr) {
            array.writeMany("--aarch64-enable-mcr\x00");
        }
        if (cmd.aarch64_enable_mgather_combine) {
            array.writeMany("--aarch64-enable-mgather-combine\x00");
        }
        if (cmd.aarch64_enable_nonlazybind) {
            array.writeMany("--aarch64-enable-nonlazybind\x00");
        }
        if (cmd.aarch64_enable_promote_const) {
            array.writeMany("--aarch64-enable-promote-const\x00");
        }
        if (cmd.aarch64_enable_simd_scalar) {
            array.writeMany("--aarch64-enable-simd-scalar\x00");
        }
        if (cmd.aarch64_enable_stp_suppress) {
            array.writeMany("--aarch64-enable-stp-suppress\x00");
        }
        if (cmd.aarch64_enable_sve_intrinsic_opts) {
            array.writeMany("--aarch64-enable-sve-intrinsic-opts\x00");
        }
        if (cmd.aarch64_insert_extract_base_cost) |aarch64_insert_extract_base_cost| {
            array.writeMany("--aarch64-insert-extract-base-cost\x00");
            array.writeFormat(fmt.ud64(aarch64_insert_extract_base_cost));
            array.writeOne(0);
        }
        if (cmd.aarch64_load_store_renaming) {
            array.writeMany("--aarch64-load-store-renaming\x00");
        }
        if (cmd.aarch64_load_store_scan_limit) |aarch64_load_store_scan_limit| {
            array.writeMany("--aarch64-load-store-scan-limit\x00");
            array.writeFormat(fmt.ud64(aarch64_load_store_scan_limit));
            array.writeOne(0);
        }
        if (cmd.aarch64_mark_bti_property) {
            array.writeMany("--aarch64-mark-bti-property\x00");
        }
        if (cmd.aarch64_max_xors) |aarch64_max_xors| {
            array.writeMany("--aarch64-max-xors\x00");
            array.writeFormat(fmt.ud64(aarch64_max_xors));
            array.writeOne(0);
        }
        if (cmd.aarch64_neon_syntax) |aarch64_neon_syntax| {
            array.writeMany("--aarch64-neon-syntax\x00");
            array.writeMany(@tagName(aarch64_neon_syntax));
            array.writeOne(0);
        }
        if (cmd.aarch64_order_frame_objects) {
            array.writeMany("--aarch64-order-frame-objects\x00");
        }
        if (cmd.aarch64_redzone) {
            array.writeMany("--aarch64-redzone\x00");
        }
        if (cmd.aarch64_select_opt) {
            array.writeMany("--aarch64-select-opt\x00");
        }
        if (cmd.aarch64_simd_scalar_force_all) {
            array.writeMany("--aarch64-simd-scalar-force-all\x00");
        }
        if (cmd.aarch64_slh_loads) {
            array.writeMany("--aarch64-slh-loads\x00");
        }
        if (cmd.aarch64_stress_ccmp) {
            array.writeMany("--aarch64-stress-ccmp\x00");
        }
        if (cmd.aarch64_stress_promote_const) {
            array.writeMany("--aarch64-stress-promote-const\x00");
        }
        if (cmd.aarch64_sve_vector_bits_max) |aarch64_sve_vector_bits_max| {
            array.writeMany("--aarch64-sve-vector-bits-max\x00");
            array.writeFormat(fmt.ud64(aarch64_sve_vector_bits_max));
            array.writeOne(0);
        }
        if (cmd.aarch64_sve_vector_bits_min) |aarch64_sve_vector_bits_min| {
            array.writeMany("--aarch64-sve-vector-bits-min\x00");
            array.writeFormat(fmt.ud64(aarch64_sve_vector_bits_min));
            array.writeOne(0);
        }
        if (cmd.aarch64_tbz_offset_bits) |aarch64_tbz_offset_bits| {
            array.writeMany("--aarch64-tbz-offset-bits\x00");
            array.writeFormat(fmt.ud64(aarch64_tbz_offset_bits));
            array.writeOne(0);
        }
        if (cmd.aarch64_update_scan_limit) |aarch64_update_scan_limit| {
            array.writeMany("--aarch64-update-scan-limit\x00");
            array.writeFormat(fmt.ud64(aarch64_update_scan_limit));
            array.writeOne(0);
        }
        if (cmd.aarch64_use_aa) {
            array.writeMany("--aarch64-use-aa\x00");
        }
        if (cmd.aarch64_use_tbi) {
            array.writeMany("--aarch64-use-tbi\x00");
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_disable_rule) |aarch64o0prelegalizercombinerhelper_disable_rule| {
            array.writeMany("--aarch64o0prelegalizercombinerhelper-disable-rule\x00");
            array.writeMany(aarch64o0prelegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64o0prelegalizercombinerhelper_only_enable_rule) |aarch64o0prelegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--aarch64o0prelegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(aarch64o0prelegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64postlegalizercombinerhelper_disable_rule) |aarch64postlegalizercombinerhelper_disable_rule| {
            array.writeMany("--aarch64postlegalizercombinerhelper-disable-rule\x00");
            array.writeMany(aarch64postlegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64postlegalizercombinerhelper_only_enable_rule) |aarch64postlegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--aarch64postlegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(aarch64postlegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64postlegalizerloweringhelper_disable_rule) |aarch64postlegalizerloweringhelper_disable_rule| {
            array.writeMany("--aarch64postlegalizerloweringhelper-disable-rule\x00");
            array.writeMany(aarch64postlegalizerloweringhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64postlegalizerloweringhelper_only_enable_rule) |aarch64postlegalizerloweringhelper_only_enable_rule| {
            array.writeMany("--aarch64postlegalizerloweringhelper-only-enable-rule\x00");
            array.writeMany(aarch64postlegalizerloweringhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64prelegalizercombinerhelper_disable_rule) |aarch64prelegalizercombinerhelper_disable_rule| {
            array.writeMany("--aarch64prelegalizercombinerhelper-disable-rule\x00");
            array.writeMany(aarch64prelegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.aarch64prelegalizercombinerhelper_only_enable_rule) |aarch64prelegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--aarch64prelegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(aarch64prelegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.abort_on_max_devirt_iterations_reached) {
            array.writeMany("--abort-on-max-devirt-iterations-reached\x00");
        }
        if (cmd.accel_tables) |accel_tables| {
            array.writeMany("--accel-tables\x00");
            array.writeMany(@tagName(accel_tables));
            array.writeOne(0);
        }
        if (cmd.adce_remove_control_flow) {
            array.writeMany("--adce-remove-control-flow\x00");
        }
        if (cmd.adce_remove_loops) {
            array.writeMany("--adce-remove-loops\x00");
        }
        if (cmd.addr_sink_combine_base_gv) {
            array.writeMany("--addr-sink-combine-base-gv\x00");
        }
        if (cmd.addr_sink_combine_base_offs) {
            array.writeMany("--addr-sink-combine-base-offs\x00");
        }
        if (cmd.addr_sink_combine_base_reg) {
            array.writeMany("--addr-sink-combine-base-reg\x00");
        }
        if (cmd.addr_sink_combine_scaled_reg) {
            array.writeMany("--addr-sink-combine-scaled-reg\x00");
        }
        if (cmd.addr_sink_new_phis) {
            array.writeMany("--addr-sink-new-phis\x00");
        }
        if (cmd.addr_sink_new_select) {
            array.writeMany("--addr-sink-new-select\x00");
        }
        if (cmd.addr_sink_using_gep) {
            array.writeMany("--addr-sink-using-gep\x00");
        }
        if (cmd.addrsig) {
            array.writeMany("--addrsig\x00");
        }
        if (cmd.agg_antidep_debugdiv) |agg_antidep_debugdiv| {
            array.writeMany("--agg-antidep-debugdiv\x00");
            array.writeFormat(fmt.ud64(agg_antidep_debugdiv));
            array.writeOne(0);
        }
        if (cmd.agg_antidep_debugmod) |agg_antidep_debugmod| {
            array.writeMany("--agg-antidep-debugmod\x00");
            array.writeFormat(fmt.ud64(agg_antidep_debugmod));
            array.writeOne(0);
        }
        if (cmd.aggregate_extracted_args) {
            array.writeMany("--aggregate-extracted-args\x00");
        }
        if (cmd.aggressive_ext_opt) {
            array.writeMany("--aggressive-ext-opt\x00");
        }
        if (cmd.aggressive_instcombine_max_scan_instrs) |aggressive_instcombine_max_scan_instrs| {
            array.writeMany("--aggressive-instcombine-max-scan-instrs\x00");
            array.writeFormat(fmt.ud64(aggressive_instcombine_max_scan_instrs));
            array.writeOne(0);
        }
        if (cmd.aix_ssp_tb_bit) {
            array.writeMany("--aix-ssp-tb-bit\x00");
        }
        if (cmd.alias_set_saturation_threshold) |alias_set_saturation_threshold| {
            array.writeMany("--alias-set-saturation-threshold\x00");
            array.writeFormat(fmt.ud64(alias_set_saturation_threshold));
            array.writeOne(0);
        }
        if (cmd.align_all_blocks) |align_all_blocks| {
            array.writeMany("--align-all-blocks\x00");
            array.writeFormat(fmt.ud64(align_all_blocks));
            array.writeOne(0);
        }
        if (cmd.align_all_functions) |align_all_functions| {
            array.writeMany("--align-all-functions\x00");
            array.writeFormat(fmt.ud64(align_all_functions));
            array.writeOne(0);
        }
        if (cmd.align_all_nofallthru_blocks) |align_all_nofallthru_blocks| {
            array.writeMany("--align-all-nofallthru-blocks\x00");
            array.writeFormat(fmt.ud64(align_all_nofallthru_blocks));
            array.writeOne(0);
        }
        if (cmd.align_loops) |align_loops| {
            array.writeMany("--align-loops\x00");
            array.writeFormat(fmt.ud64(align_loops));
            array.writeOne(0);
        }
        if (cmd.align_neon_spills) {
            array.writeMany("--align-neon-spills\x00");
        }
        if (cmd.allow_arm_wlsloops) {
            array.writeMany("--allow-arm-wlsloops\x00");
        }
        if (cmd.allow_ginsert_as_artifact) {
            array.writeMany("--allow-ginsert-as-artifact\x00");
        }
        if (cmd.allow_unroll_and_jam) {
            array.writeMany("--allow-unroll-and-jam\x00");
        }
        if (cmd.amdgcn_skip_cache_invalidations) {
            array.writeMany("--amdgcn-skip-cache-invalidations\x00");
        }
        if (cmd.amdgpu_any_address_space_out_arguments) {
            array.writeMany("--amdgpu-any-address-space-out-arguments\x00");
        }
        if (cmd.amdgpu_assume_dynamic_stack_object_size) |amdgpu_assume_dynamic_stack_object_size| {
            array.writeMany("--amdgpu-assume-dynamic-stack-object-size\x00");
            array.writeFormat(fmt.ud64(amdgpu_assume_dynamic_stack_object_size));
            array.writeOne(0);
        }
        if (cmd.amdgpu_assume_external_call_stack_size) |amdgpu_assume_external_call_stack_size| {
            array.writeMany("--amdgpu-assume-external-call-stack-size\x00");
            array.writeFormat(fmt.ud64(amdgpu_assume_external_call_stack_size));
            array.writeOne(0);
        }
        if (cmd.amdgpu_atomic_optimizations) {
            array.writeMany("--amdgpu-atomic-optimizations\x00");
        }
        if (cmd.amdgpu_bypass_slow_div) {
            array.writeMany("--amdgpu-bypass-slow-div\x00");
        }
        if (cmd.amdgpu_dce_in_ra) {
            array.writeMany("--amdgpu-dce-in-ra\x00");
        }
        if (cmd.amdgpu_disable_loop_alignment) {
            array.writeMany("--amdgpu-disable-loop-alignment\x00");
        }
        if (cmd.amdgpu_disable_unclustred_high_rp_reschedule) {
            array.writeMany("--amdgpu-disable-unclustred-high-rp-reschedule\x00");
        }
        if (cmd.amdgpu_dpp_combine) {
            array.writeMany("--amdgpu-dpp-combine\x00");
        }
        if (cmd.amdgpu_dump_hsa_metadata) {
            array.writeMany("--amdgpu-dump-hsa-metadata\x00");
        }
        if (cmd.amdgpu_early_ifcvt) {
            array.writeMany("--amdgpu-early-ifcvt\x00");
        }
        if (cmd.amdgpu_early_inline_all) {
            array.writeMany("--amdgpu-early-inline-all\x00");
        }
        if (cmd.amdgpu_enable_delay_alu) {
            array.writeMany("--amdgpu-enable-delay-alu\x00");
        }
        if (cmd.amdgpu_enable_lds_replace_with_pointer) {
            array.writeMany("--amdgpu-enable-lds-replace-with-pointer\x00");
        }
        if (cmd.amdgpu_enable_lower_module_lds) {
            array.writeMany("--amdgpu-enable-lower-module-lds\x00");
        }
        if (cmd.amdgpu_enable_max_ilp_scheduling_strategy) {
            array.writeMany("--amdgpu-enable-max-ilp-scheduling-strategy\x00");
        }
        if (cmd.amdgpu_enable_merge_m0) {
            array.writeMany("--amdgpu-enable-merge-m0\x00");
        }
        if (cmd.amdgpu_enable_power_sched) {
            array.writeMany("--amdgpu-enable-power-sched\x00");
        }
        if (cmd.amdgpu_enable_pre_ra_optimizations) {
            array.writeMany("--amdgpu-enable-pre-ra-optimizations\x00");
        }
        if (cmd.amdgpu_enable_promote_kernel_arguments) {
            array.writeMany("--amdgpu-enable-promote-kernel-arguments\x00");
        }
        if (cmd.amdgpu_enable_structurizer_workarounds) {
            array.writeMany("--amdgpu-enable-structurizer-workarounds\x00");
        }
        if (cmd.amdgpu_enable_vopd) {
            array.writeMany("--amdgpu-enable-vopd\x00");
        }
        if (cmd.amdgpu_function_calls) {
            array.writeMany("--amdgpu-function-calls\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver) {
            array.writeMany("--amdgpu-igrouplp-exact-solver\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cost_heur) {
            array.writeMany("--amdgpu-igrouplp-exact-solver-cost-heur\x00");
        }
        if (cmd.amdgpu_igrouplp_exact_solver_cutoff) |amdgpu_igrouplp_exact_solver_cutoff| {
            array.writeMany("--amdgpu-igrouplp-exact-solver-cutoff\x00");
            array.writeFormat(fmt.ud64(amdgpu_igrouplp_exact_solver_cutoff));
            array.writeOne(0);
        }
        if (cmd.amdgpu_igrouplp_exact_solver_max_branches) |amdgpu_igrouplp_exact_solver_max_branches| {
            array.writeMany("--amdgpu-igrouplp-exact-solver-max-branches\x00");
            array.writeFormat(fmt.ud64(amdgpu_igrouplp_exact_solver_max_branches));
            array.writeOne(0);
        }
        if (cmd.amdgpu_indirect_access_weight) |amdgpu_indirect_access_weight| {
            array.writeMany("--amdgpu-indirect-access-weight\x00");
            array.writeFormat(fmt.ud64(amdgpu_indirect_access_weight));
            array.writeOne(0);
        }
        if (cmd.amdgpu_inline_arg_alloca_cost) |amdgpu_inline_arg_alloca_cost| {
            array.writeMany("--amdgpu-inline-arg-alloca-cost\x00");
            array.writeFormat(fmt.ud64(amdgpu_inline_arg_alloca_cost));
            array.writeOne(0);
        }
        if (cmd.amdgpu_inline_arg_alloca_cutoff) |amdgpu_inline_arg_alloca_cutoff| {
            array.writeMany("--amdgpu-inline-arg-alloca-cutoff\x00");
            array.writeFormat(fmt.ud64(amdgpu_inline_arg_alloca_cutoff));
            array.writeOne(0);
        }
        if (cmd.amdgpu_inline_max_bb) |amdgpu_inline_max_bb| {
            array.writeMany("--amdgpu-inline-max-bb\x00");
            array.writeFormat(fmt.ud64(amdgpu_inline_max_bb));
            array.writeOne(0);
        }
        if (cmd.amdgpu_internalize_symbols) {
            array.writeMany("--amdgpu-internalize-symbols\x00");
        }
        if (cmd.amdgpu_ir_lower_kernel_arguments) {
            array.writeMany("--amdgpu-ir-lower-kernel-arguments\x00");
        }
        if (cmd.amdgpu_large_stride_threshold) |amdgpu_large_stride_threshold| {
            array.writeMany("--amdgpu-large-stride-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_large_stride_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_large_stride_weight) |amdgpu_large_stride_weight| {
            array.writeMany("--amdgpu-large-stride-weight\x00");
            array.writeFormat(fmt.ud64(amdgpu_large_stride_weight));
            array.writeOne(0);
        }
        if (cmd.amdgpu_late_structurize) {
            array.writeMany("--amdgpu-late-structurize\x00");
        }
        if (cmd.amdgpu_limit_wave_threshold) |amdgpu_limit_wave_threshold| {
            array.writeMany("--amdgpu-limit-wave-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_limit_wave_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_load_store_vectorizer) {
            array.writeMany("--amdgpu-load-store-vectorizer\x00");
        }
        if (cmd.amdgpu_lower_module_lds_strategy) |amdgpu_lower_module_lds_strategy| {
            array.writeMany("--amdgpu-lower-module-lds-strategy\x00");
            array.writeMany(@tagName(amdgpu_lower_module_lds_strategy));
            array.writeOne(0);
        }
        if (cmd.amdgpu_max_memory_clause) |amdgpu_max_memory_clause| {
            array.writeMany("--amdgpu-max-memory-clause\x00");
            array.writeFormat(fmt.ud64(amdgpu_max_memory_clause));
            array.writeOne(0);
        }
        if (cmd.amdgpu_max_return_arg_num_regs) |amdgpu_max_return_arg_num_regs| {
            array.writeMany("--amdgpu-max-return-arg-num-regs\x00");
            array.writeFormat(fmt.ud64(amdgpu_max_return_arg_num_regs));
            array.writeOne(0);
        }
        if (cmd.amdgpu_mem_intrinsic_expand_size) |amdgpu_mem_intrinsic_expand_size| {
            array.writeMany("--amdgpu-mem-intrinsic-expand-size\x00");
            array.writeFormat(fmt.ud64(amdgpu_mem_intrinsic_expand_size));
            array.writeOne(0);
        }
        if (cmd.amdgpu_membound_threshold) |amdgpu_membound_threshold| {
            array.writeMany("--amdgpu-membound-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_membound_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_mfma_padding_ratio) |amdgpu_mfma_padding_ratio| {
            array.writeMany("--amdgpu-mfma-padding-ratio\x00");
            array.writeFormat(fmt.ud64(amdgpu_mfma_padding_ratio));
            array.writeOne(0);
        }
        if (cmd.amdgpu_mode_register) {
            array.writeMany("--amdgpu-mode-register\x00");
        }
        if (cmd.amdgpu_nsa_threshold) |amdgpu_nsa_threshold| {
            array.writeMany("--amdgpu-nsa-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_nsa_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_opt_exec_mask_pre_ra) {
            array.writeMany("--amdgpu-opt-exec-mask-pre-ra\x00");
        }
        if (cmd.amdgpu_opt_vgpr_liverange) {
            array.writeMany("--amdgpu-opt-vgpr-liverange\x00");
        }
        if (cmd.amdgpu_prelink) {
            array.writeMany("--amdgpu-prelink\x00");
        }
        if (cmd.amdgpu_promote_alloca_to_vector_limit) |amdgpu_promote_alloca_to_vector_limit| {
            array.writeMany("--amdgpu-promote-alloca-to-vector-limit\x00");
            array.writeFormat(fmt.ud64(amdgpu_promote_alloca_to_vector_limit));
            array.writeOne(0);
        }
        if (cmd.amdgpu_reassign_regs) {
            array.writeMany("--amdgpu-reassign-regs\x00");
        }
        if (cmd.amdgpu_scalar_ir_passes) {
            array.writeMany("--amdgpu-scalar-ir-passes\x00");
        }
        if (cmd.amdgpu_scalarize_global_loads) {
            array.writeMany("--amdgpu-scalarize-global-loads\x00");
        }
        if (cmd.amdgpu_schedule_metric_bias) |amdgpu_schedule_metric_bias| {
            array.writeMany("--amdgpu-schedule-metric-bias\x00");
            array.writeFormat(fmt.ud64(amdgpu_schedule_metric_bias));
            array.writeOne(0);
        }
        if (cmd.amdgpu_sdwa_peephole) {
            array.writeMany("--amdgpu-sdwa-peephole\x00");
        }
        if (cmd.amdgpu_set_wave_priority) {
            array.writeMany("--amdgpu-set-wave-priority\x00");
        }
        if (cmd.amdgpu_set_wave_priority_valu_insts_threshold) |amdgpu_set_wave_priority_valu_insts_threshold| {
            array.writeMany("--amdgpu-set-wave-priority-valu-insts-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_set_wave_priority_valu_insts_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_simplify_libcall) {
            array.writeMany("--amdgpu-simplify-libcall\x00");
        }
        if (cmd.amdgpu_skip_threshold) |amdgpu_skip_threshold| {
            array.writeMany("--amdgpu-skip-threshold\x00");
            array.writeFormat(fmt.ud64(amdgpu_skip_threshold));
            array.writeOne(0);
        }
        if (cmd.amdgpu_stress_function_calls) {
            array.writeMany("--amdgpu-stress-function-calls\x00");
        }
        if (cmd.amdgpu_super_align_lds_globals) {
            array.writeMany("--amdgpu-super-align-lds-globals\x00");
        }
        if (cmd.amdgpu_unroll_max_block_to_analyze) |amdgpu_unroll_max_block_to_analyze| {
            array.writeMany("--amdgpu-unroll-max-block-to-analyze\x00");
            array.writeFormat(fmt.ud64(amdgpu_unroll_max_block_to_analyze));
            array.writeOne(0);
        }
        if (cmd.amdgpu_unroll_runtime_local) {
            array.writeMany("--amdgpu-unroll-runtime-local\x00");
        }
        if (cmd.amdgpu_unroll_threshold_if) |amdgpu_unroll_threshold_if| {
            array.writeMany("--amdgpu-unroll-threshold-if\x00");
            array.writeFormat(fmt.ud64(amdgpu_unroll_threshold_if));
            array.writeOne(0);
        }
        if (cmd.amdgpu_unroll_threshold_local) |amdgpu_unroll_threshold_local| {
            array.writeMany("--amdgpu-unroll-threshold-local\x00");
            array.writeFormat(fmt.ud64(amdgpu_unroll_threshold_local));
            array.writeOne(0);
        }
        if (cmd.amdgpu_unroll_threshold_private) |amdgpu_unroll_threshold_private| {
            array.writeMany("--amdgpu-unroll-threshold-private\x00");
            array.writeFormat(fmt.ud64(amdgpu_unroll_threshold_private));
            array.writeOne(0);
        }
        if (cmd.amdgpu_use_aa_in_codegen) {
            array.writeMany("--amdgpu-use-aa-in-codegen\x00");
        }
        if (cmd.amdgpu_use_divergent_register_indexing) {
            array.writeMany("--amdgpu-use-divergent-register-indexing\x00");
        }
        if (cmd.amdgpu_use_legacy_divergence_analysis) {
            array.writeMany("--amdgpu-use-legacy-divergence-analysis\x00");
        }
        if (cmd.amdgpu_use_native) |amdgpu_use_native| {
            array.writeMany("--amdgpu-use-native\x00");
            array.writeMany(amdgpu_use_native);
            array.writeOne(0);
        }
        if (cmd.amdgpu_verify_hsa_metadata) {
            array.writeMany("--amdgpu-verify-hsa-metadata\x00");
        }
        if (cmd.amdgpu_vgpr_index_mode) {
            array.writeMany("--amdgpu-vgpr-index-mode\x00");
        }
        if (cmd.amdgpu_waitcnt_forcezero) {
            array.writeMany("--amdgpu-waitcnt-forcezero\x00");
        }
        if (cmd.amdgpupostlegalizercombinerhelper_disable_rule) |amdgpupostlegalizercombinerhelper_disable_rule| {
            array.writeMany("--amdgpupostlegalizercombinerhelper-disable-rule\x00");
            array.writeMany(amdgpupostlegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.amdgpupostlegalizercombinerhelper_only_enable_rule) |amdgpupostlegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--amdgpupostlegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(amdgpupostlegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.amdgpuprelegalizercombinerhelper_disable_rule) |amdgpuprelegalizercombinerhelper_disable_rule| {
            array.writeMany("--amdgpuprelegalizercombinerhelper-disable-rule\x00");
            array.writeMany(amdgpuprelegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.amdgpuprelegalizercombinerhelper_only_enable_rule) |amdgpuprelegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--amdgpuprelegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(amdgpuprelegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.amdgpuregbankcombinerhelper_disable_rule) |amdgpuregbankcombinerhelper_disable_rule| {
            array.writeMany("--amdgpuregbankcombinerhelper-disable-rule\x00");
            array.writeMany(amdgpuregbankcombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.amdgpuregbankcombinerhelper_only_enable_rule) |amdgpuregbankcombinerhelper_only_enable_rule| {
            array.writeMany("--amdgpuregbankcombinerhelper-only-enable-rule\x00");
            array.writeMany(amdgpuregbankcombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.amdhsa_code_object_version) |amdhsa_code_object_version| {
            array.writeMany("--amdhsa-code-object-version\x00");
            array.writeFormat(fmt.ud64(amdhsa_code_object_version));
            array.writeOne(0);
        }
        if (cmd.annotate_inline_phase) {
            array.writeMany("--annotate-inline-phase\x00");
        }
        if (cmd.annotate_sample_profile_inline_phase) {
            array.writeMany("--annotate-sample-profile-inline-phase\x00");
        }
        if (cmd.arc_opt_max_ptr_states) |arc_opt_max_ptr_states| {
            array.writeMany("--arc-opt-max-ptr-states\x00");
            array.writeFormat(fmt.ud64(arc_opt_max_ptr_states));
            array.writeOne(0);
        }
        if (cmd.arm_add_build_attributes) {
            array.writeMany("--arm-add-build-attributes\x00");
        }
        if (cmd.arm_adjust_jump_tables) {
            array.writeMany("--arm-adjust-jump-tables\x00");
        }
        if (cmd.arm_assume_itcm_bankconflict) {
            array.writeMany("--arm-assume-itcm-bankconflict\x00");
        }
        if (cmd.arm_assume_misaligned_load_store) {
            array.writeMany("--arm-assume-misaligned-load-store\x00");
        }
        if (cmd.arm_atomic_cfg_tidy) {
            array.writeMany("--arm-atomic-cfg-tidy\x00");
        }
        if (cmd.arm_constant_island_max_iteration) |arm_constant_island_max_iteration| {
            array.writeMany("--arm-constant-island-max-iteration\x00");
            array.writeFormat(fmt.ud64(arm_constant_island_max_iteration));
            array.writeOne(0);
        }
        if (cmd.arm_data_bank_mask) |arm_data_bank_mask| {
            array.writeMany("--arm-data-bank-mask\x00");
            array.writeFormat(fmt.ud64(arm_data_bank_mask));
            array.writeOne(0);
        }
        if (cmd.arm_disable_omit_dls) {
            array.writeMany("--arm-disable-omit-dls\x00");
        }
        if (cmd.arm_enable_merge_loopenddec) {
            array.writeMany("--arm-enable-merge-loopenddec\x00");
        }
        if (cmd.arm_enable_subreg_liveness) {
            array.writeMany("--arm-enable-subreg-liveness\x00");
        }
        if (cmd.arm_force_fast_isel) {
            array.writeMany("--arm-force-fast-isel\x00");
        }
        if (cmd.arm_global_merge) {
            array.writeMany("--arm-global-merge\x00");
        }
        if (cmd.arm_implicit_it) |arm_implicit_it| {
            array.writeMany("--arm-implicit-it\x00");
            array.writeMany(@tagName(arm_implicit_it));
            array.writeOne(0);
        }
        if (cmd.arm_interworking) {
            array.writeMany("--arm-interworking\x00");
        }
        if (cmd.arm_load_store_opt) {
            array.writeMany("--arm-load-store-opt\x00");
        }
        if (cmd.arm_loloops_disable_tailpred) {
            array.writeMany("--arm-loloops-disable-tailpred\x00");
        }
        if (cmd.arm_memtransfer_tploop) |arm_memtransfer_tploop| {
            array.writeMany("--arm-memtransfer-tploop\x00");
            array.writeMany(@tagName(arm_memtransfer_tploop));
            array.writeOne(0);
        }
        if (cmd.arm_parallel_dsp_load_limit) |arm_parallel_dsp_load_limit| {
            array.writeMany("--arm-parallel-dsp-load-limit\x00");
            array.writeFormat(fmt.ud64(arm_parallel_dsp_load_limit));
            array.writeOne(0);
        }
        if (cmd.arm_prera_ldst_opt_reorder_limit) |arm_prera_ldst_opt_reorder_limit| {
            array.writeMany("--arm-prera-ldst-opt-reorder-limit\x00");
            array.writeFormat(fmt.ud64(arm_prera_ldst_opt_reorder_limit));
            array.writeOne(0);
        }
        if (cmd.arm_promote_constant) {
            array.writeMany("--arm-promote-constant\x00");
        }
        if (cmd.arm_promote_constant_max_size) |arm_promote_constant_max_size| {
            array.writeMany("--arm-promote-constant-max-size\x00");
            array.writeFormat(fmt.ud64(arm_promote_constant_max_size));
            array.writeOne(0);
        }
        if (cmd.arm_promote_constant_max_total) |arm_promote_constant_max_total| {
            array.writeMany("--arm-promote-constant-max-total\x00");
            array.writeFormat(fmt.ud64(arm_promote_constant_max_total));
            array.writeOne(0);
        }
        if (cmd.arm_default_it) {
            array.writeMany("--arm-default-it\x00");
        }
        if (cmd.arm_restrict_it) {
            array.writeMany("--arm-restrict-it\x00");
        }
        if (cmd.arm_set_lr_predicate) {
            array.writeMany("--arm-set-lr-predicate\x00");
        }
        if (cmd.arm_synthesize_thumb_1_tbb) {
            array.writeMany("--arm-synthesize-thumb-1-tbb\x00");
        }
        if (cmd.arm_use_mulops) {
            array.writeMany("--arm-use-mulops\x00");
        }
        if (cmd.as_secure_log_file) |as_secure_log_file| {
            array.writeMany("--as-secure-log-file\x00");
            array.writeMany(as_secure_log_file);
            array.writeOne(0);
        }
        if (cmd.asan_always_slow_path) {
            array.writeMany("--asan-always-slow-path\x00");
        }
        if (cmd.asan_constructor_kind) |asan_constructor_kind| {
            array.writeMany("--asan-constructor-kind\x00");
            array.writeMany(@tagName(asan_constructor_kind));
            array.writeOne(0);
        }
        if (cmd.asan_debug) |asan_debug| {
            array.writeMany("--asan-debug\x00");
            array.writeFormat(fmt.ud64(asan_debug));
            array.writeOne(0);
        }
        if (cmd.asan_debug_func) |asan_debug_func| {
            array.writeMany("--asan-debug-func\x00");
            array.writeMany(asan_debug_func);
            array.writeOne(0);
        }
        if (cmd.asan_debug_max) |asan_debug_max| {
            array.writeMany("--asan-debug-max\x00");
            array.writeFormat(fmt.ud64(asan_debug_max));
            array.writeOne(0);
        }
        if (cmd.asan_debug_min) |asan_debug_min| {
            array.writeMany("--asan-debug-min\x00");
            array.writeFormat(fmt.ud64(asan_debug_min));
            array.writeOne(0);
        }
        if (cmd.asan_debug_stack) |asan_debug_stack| {
            array.writeMany("--asan-debug-stack\x00");
            array.writeFormat(fmt.ud64(asan_debug_stack));
            array.writeOne(0);
        }
        if (cmd.asan_destructor_kind) |asan_destructor_kind| {
            array.writeMany("--asan-destructor-kind\x00");
            array.writeMany(@tagName(asan_destructor_kind));
            array.writeOne(0);
        }
        if (cmd.asan_detect_invalid_pointer_cmp) {
            array.writeMany("--asan-detect-invalid-pointer-cmp\x00");
        }
        if (cmd.asan_detect_invalid_pointer_pair) {
            array.writeMany("--asan-detect-invalid-pointer-pair\x00");
        }
        if (cmd.asan_detect_invalid_pointer_sub) {
            array.writeMany("--asan-detect-invalid-pointer-sub\x00");
        }
        if (cmd.asan_force_dynamic_shadow) {
            array.writeMany("--asan-force-dynamic-shadow\x00");
        }
        if (cmd.asan_force_experiment) |asan_force_experiment| {
            array.writeMany("--asan-force-experiment\x00");
            array.writeFormat(fmt.ud64(asan_force_experiment));
            array.writeOne(0);
        }
        if (cmd.asan_globals) {
            array.writeMany("--asan-globals\x00");
        }
        if (cmd.asan_globals_live_support) {
            array.writeMany("--asan-globals-live-support\x00");
        }
        if (cmd.asan_guard_against_version_mismatch) {
            array.writeMany("--asan-guard-against-version-mismatch\x00");
        }
        if (cmd.asan_initialization_order) {
            array.writeMany("--asan-initialization-order\x00");
        }
        if (cmd.asan_instrument_atomics) {
            array.writeMany("--asan-instrument-atomics\x00");
        }
        if (cmd.asan_instrument_byval) {
            array.writeMany("--asan-instrument-byval\x00");
        }
        if (cmd.asan_instrument_dynamic_allocas) {
            array.writeMany("--asan-instrument-dynamic-allocas\x00");
        }
        if (cmd.asan_instrument_reads) {
            array.writeMany("--asan-instrument-reads\x00");
        }
        if (cmd.asan_instrument_writes) {
            array.writeMany("--asan-instrument-writes\x00");
        }
        if (cmd.asan_instrumentation_with_call_threshold) |asan_instrumentation_with_call_threshold| {
            array.writeMany("--asan-instrumentation-with-call-threshold\x00");
            array.writeFormat(fmt.ud64(asan_instrumentation_with_call_threshold));
            array.writeOne(0);
        }
        if (cmd.asan_kernel) {
            array.writeMany("--asan-kernel\x00");
        }
        if (cmd.asan_kernel_mem_intrinsic_prefix) {
            array.writeMany("--asan-kernel-mem-intrinsic-prefix\x00");
        }
        if (cmd.asan_mapping_offset) |asan_mapping_offset| {
            array.writeMany("--asan-mapping-offset\x00");
            array.writeFormat(fmt.ud64(asan_mapping_offset));
            array.writeOne(0);
        }
        if (cmd.asan_mapping_scale) |asan_mapping_scale| {
            array.writeMany("--asan-mapping-scale\x00");
            array.writeFormat(fmt.ud64(asan_mapping_scale));
            array.writeOne(0);
        }
        if (cmd.asan_max_inline_poisoning_size) |asan_max_inline_poisoning_size| {
            array.writeMany("--asan-max-inline-poisoning-size\x00");
            array.writeFormat(fmt.ud64(asan_max_inline_poisoning_size));
            array.writeOne(0);
        }
        if (cmd.asan_max_ins_per_bb) |asan_max_ins_per_bb| {
            array.writeMany("--asan-max-ins-per-bb\x00");
            array.writeFormat(fmt.ud64(asan_max_ins_per_bb));
            array.writeOne(0);
        }
        if (cmd.asan_memory_access_callback_prefix) |asan_memory_access_callback_prefix| {
            array.writeMany("--asan-memory-access-callback-prefix\x00");
            array.writeMany(asan_memory_access_callback_prefix);
            array.writeOne(0);
        }
        if (cmd.asan_opt) {
            array.writeMany("--asan-opt\x00");
        }
        if (cmd.asan_opt_globals) {
            array.writeMany("--asan-opt-globals\x00");
        }
        if (cmd.asan_opt_same_temp) {
            array.writeMany("--asan-opt-same-temp\x00");
        }
        if (cmd.asan_opt_stack) {
            array.writeMany("--asan-opt-stack\x00");
        }
        if (cmd.asan_optimize_callbacks) {
            array.writeMany("--asan-optimize-callbacks\x00");
        }
        if (cmd.asan_realign_stack) |asan_realign_stack| {
            array.writeMany("--asan-realign-stack\x00");
            array.writeFormat(fmt.ud64(asan_realign_stack));
            array.writeOne(0);
        }
        if (cmd.asan_recover) {
            array.writeMany("--asan-recover\x00");
        }
        if (cmd.asan_redzone_byval_args) {
            array.writeMany("--asan-redzone-byval-args\x00");
        }
        if (cmd.asan_skip_promotable_allocas) {
            array.writeMany("--asan-skip-promotable-allocas\x00");
        }
        if (cmd.asan_stack) {
            array.writeMany("--asan-stack\x00");
        }
        if (cmd.asan_stack_dynamic_alloca) {
            array.writeMany("--asan-stack-dynamic-alloca\x00");
        }
        if (cmd.asan_use_after_return) |asan_use_after_return| {
            array.writeMany("--asan-use-after-return\x00");
            array.writeMany(@tagName(asan_use_after_return));
            array.writeOne(0);
        }
        if (cmd.asan_use_after_scope) {
            array.writeMany("--asan-use-after-scope\x00");
        }
        if (cmd.asan_use_odr_indicator) {
            array.writeMany("--asan-use-odr-indicator\x00");
        }
        if (cmd.asan_use_private_alias) {
            array.writeMany("--asan-use-private-alias\x00");
        }
        if (cmd.asan_use_stack_safety) {
            array.writeMany("--asan-use-stack-safety\x00");
        }
        if (cmd.asan_with_comdat) {
            array.writeMany("--asan-with-comdat\x00");
        }
        if (cmd.asan_with_ifunc) {
            array.writeMany("--asan-with-ifunc\x00");
        }
        if (cmd.asan_with_ifunc_suppress_remat) {
            array.writeMany("--asan-with-ifunc-suppress-remat\x00");
        }
        if (cmd.asm_macro_max_nesting_depth) |asm_macro_max_nesting_depth| {
            array.writeMany("--asm-macro-max-nesting-depth\x00");
            array.writeFormat(fmt.ud64(asm_macro_max_nesting_depth));
            array.writeOne(0);
        }
        if (cmd.asm_show_inst) {
            array.writeMany("--asm-show-inst\x00");
        }
        if (cmd.asm_verbose) {
            array.writeMany("--asm-verbose\x00");
        }
        if (cmd.assume_preserve_all) {
            array.writeMany("--assume-preserve-all\x00");
        }
        if (cmd.atomic_counter_update_promoted) {
            array.writeMany("--atomic-counter-update-promoted\x00");
        }
        if (cmd.atomic_first_counter) {
            array.writeMany("--atomic-first-counter\x00");
        }
        if (cmd.attributor_allow_deep_wrappers) {
            array.writeMany("--attributor-allow-deep-wrappers\x00");
        }
        if (cmd.attributor_allow_shallow_wrappers) {
            array.writeMany("--attributor-allow-shallow-wrappers\x00");
        }
        if (cmd.attributor_annotate_decl_cs) {
            array.writeMany("--attributor-annotate-decl-cs\x00");
        }
        if (cmd.attributor_depgraph_dot_filename_prefix) |attributor_depgraph_dot_filename_prefix| {
            array.writeMany("--attributor-depgraph-dot-filename-prefix\x00");
            array.writeMany(attributor_depgraph_dot_filename_prefix);
            array.writeOne(0);
        }
        if (cmd.attributor_dump_dep_graph) {
            array.writeMany("--attributor-dump-dep-graph\x00");
        }
        if (cmd.attributor_enable) |attributor_enable| {
            array.writeMany("--attributor-enable\x00");
            array.writeMany(@tagName(attributor_enable));
            array.writeOne(0);
        }
        if (cmd.attributor_enable_call_site_specific_deduction) {
            array.writeMany("--attributor-enable-call-site-specific-deduction\x00");
        }
        if (cmd.attributor_manifest_internal) {
            array.writeMany("--attributor-manifest-internal\x00");
        }
        if (cmd.attributor_max_initialization_chain_length) |attributor_max_initialization_chain_length| {
            array.writeMany("--attributor-max-initialization-chain-length\x00");
            array.writeFormat(fmt.ud64(attributor_max_initialization_chain_length));
            array.writeOne(0);
        }
        if (cmd.attributor_max_iterations) |attributor_max_iterations| {
            array.writeMany("--attributor-max-iterations\x00");
            array.writeFormat(fmt.ud64(attributor_max_iterations));
            array.writeOne(0);
        }
        if (cmd.attributor_max_iterations_verify) {
            array.writeMany("--attributor-max-iterations-verify\x00");
        }
        if (cmd.attributor_max_potential_values) |attributor_max_potential_values| {
            array.writeMany("--attributor-max-potential-values\x00");
            array.writeFormat(fmt.ud64(attributor_max_potential_values));
            array.writeOne(0);
        }
        if (cmd.attributor_max_potential_values_iterations) |attributor_max_potential_values_iterations| {
            array.writeMany("--attributor-max-potential-values-iterations\x00");
            array.writeFormat(fmt.ud64(attributor_max_potential_values_iterations));
            array.writeOne(0);
        }
        if (cmd.attributor_print_call_graph) {
            array.writeMany("--attributor-print-call-graph\x00");
        }
        if (cmd.attributor_print_dep) {
            array.writeMany("--attributor-print-dep\x00");
        }
        if (cmd.attributor_simplify_all_loads) {
            array.writeMany("--attributor-simplify-all-loads\x00");
        }
        if (cmd.attributor_view_dep_graph) {
            array.writeMany("--attributor-view-dep-graph\x00");
        }
        if (cmd.available_load_scan_limit) |available_load_scan_limit| {
            array.writeMany("--available-load-scan-limit\x00");
            array.writeFormat(fmt.ud64(available_load_scan_limit));
            array.writeOne(0);
        }
        if (cmd.avoid_speculation) {
            array.writeMany("--avoid-speculation\x00");
        }
        if (cmd.basic_aa_recphi) {
            array.writeMany("--basic-aa-recphi\x00");
        }
        if (cmd.basic_aa_separate_storage) {
            array.writeMany("--basic-aa-separate-storage\x00");
        }
        if (cmd.bbsections_cold_text_prefix) |bbsections_cold_text_prefix| {
            array.writeMany("--bbsections-cold-text-prefix\x00");
            array.writeMany(bbsections_cold_text_prefix);
            array.writeOne(0);
        }
        if (cmd.bbsections_detect_source_drift) {
            array.writeMany("--bbsections-detect-source-drift\x00");
        }
        if (cmd.bbsections_guided_section_prefix) {
            array.writeMany("--bbsections-guided-section-prefix\x00");
        }
        if (cmd.binutils_version) |binutils_version| {
            array.writeMany("--binutils-version\x00");
            array.writeMany(binutils_version);
            array.writeOne(0);
        }
        if (cmd.bitcode_flush_threshold) |bitcode_flush_threshold| {
            array.writeMany("--bitcode-flush-threshold\x00");
            array.writeFormat(fmt.ud64(bitcode_flush_threshold));
            array.writeOne(0);
        }
        if (cmd.bitcode_mdindex_threshold) |bitcode_mdindex_threshold| {
            array.writeMany("--bitcode-mdindex-threshold\x00");
            array.writeFormat(fmt.ud64(bitcode_mdindex_threshold));
            array.writeOne(0);
        }
        if (cmd.block_freq_ratio_threshold) |block_freq_ratio_threshold| {
            array.writeMany("--block-freq-ratio-threshold\x00");
            array.writeFormat(fmt.ud64(block_freq_ratio_threshold));
            array.writeOne(0);
        }
        if (cmd.block_placement_exit_block_bias) |block_placement_exit_block_bias| {
            array.writeMany("--block-placement-exit-block-bias\x00");
            array.writeFormat(fmt.ud64(block_placement_exit_block_bias));
            array.writeOne(0);
        }
        if (cmd.bonus_inst_threshold) |bonus_inst_threshold| {
            array.writeMany("--bonus-inst-threshold\x00");
            array.writeFormat(fmt.ud64(bonus_inst_threshold));
            array.writeOne(0);
        }
        if (cmd.bounds_checking_single_trap) {
            array.writeMany("--bounds-checking-single-trap\x00");
        }
        if (cmd.bpf_disable_avoid_speculation) {
            array.writeMany("--bpf-disable-avoid-speculation\x00");
        }
        if (cmd.bpf_disable_serialize_icmp) {
            array.writeMany("--bpf-disable-serialize-icmp\x00");
        }
        if (cmd.bpf_expand_memcpy_in_order) {
            array.writeMany("--bpf-expand-memcpy-in-order\x00");
        }
        if (cmd.branch_fold_placement) {
            array.writeMany("--branch-fold-placement\x00");
        }
        if (cmd.branch_relax_asm_large) {
            array.writeMany("--branch-relax-asm-large\x00");
        }
        if (cmd.branch_relax_safety_buffer) |branch_relax_safety_buffer| {
            array.writeMany("--branch-relax-safety-buffer\x00");
            array.writeFormat(fmt.ud64(branch_relax_safety_buffer));
            array.writeOne(0);
        }
        if (cmd.break_anti_dependencies) |break_anti_dependencies| {
            array.writeMany("--break-anti-dependencies\x00");
            array.writeMany(break_anti_dependencies);
            array.writeOne(0);
        }
        if (cmd.cache_line_size) |cache_line_size| {
            array.writeMany("--cache-line-size\x00");
            array.writeFormat(fmt.ud64(cache_line_size));
            array.writeOne(0);
        }
        if (cmd.callgraph_dot_filename_prefix) |callgraph_dot_filename_prefix| {
            array.writeMany("--callgraph-dot-filename-prefix\x00");
            array.writeMany(callgraph_dot_filename_prefix);
            array.writeOne(0);
        }
        if (cmd.callgraph_heat_colors) {
            array.writeMany("--callgraph-heat-colors\x00");
        }
        if (cmd.callgraph_multigraph) {
            array.writeMany("--callgraph-multigraph\x00");
        }
        if (cmd.callgraph_show_weights) {
            array.writeMany("--callgraph-show-weights\x00");
        }
        if (cmd.callsite_splitting_duplication_threshold) |callsite_splitting_duplication_threshold| {
            array.writeMany("--callsite-splitting-duplication-threshold\x00");
            array.writeFormat(fmt.ud64(callsite_splitting_duplication_threshold));
            array.writeOne(0);
        }
        if (cmd.canon_nth_function) |canon_nth_function| {
            array.writeMany("--canon-nth-function\x00");
            array.writeFormat(fmt.ud64(canon_nth_function));
            array.writeOne(0);
        }
        if (cmd.canonicalize_icmp_predicates_to_unsigned) {
            array.writeMany("--canonicalize-icmp-predicates-to-unsigned\x00");
        }
        if (cmd.capture_tracking_max_uses_to_explore) |capture_tracking_max_uses_to_explore| {
            array.writeMany("--capture-tracking-max-uses-to-explore\x00");
            array.writeFormat(fmt.ud64(capture_tracking_max_uses_to_explore));
            array.writeOne(0);
        }
        if (cmd.cfg_dot_filename_prefix) |cfg_dot_filename_prefix| {
            array.writeMany("--cfg-dot-filename-prefix\x00");
            array.writeMany(cfg_dot_filename_prefix);
            array.writeOne(0);
        }
        if (cmd.cfg_func_name) |cfg_func_name| {
            array.writeMany("--cfg-func-name\x00");
            array.writeMany(cfg_func_name);
            array.writeOne(0);
        }
        if (cmd.cfg_heat_colors) {
            array.writeMany("--cfg-heat-colors\x00");
        }
        if (cmd.cfg_hide_cold_paths) |cfg_hide_cold_paths| {
            array.writeMany("--cfg-hide-cold-paths\x00");
            array.writeFormat(fmt.ud64(cfg_hide_cold_paths));
            array.writeOne(0);
        }
        if (cmd.cfg_hide_deoptimize_paths) {
            array.writeMany("--cfg-hide-deoptimize-paths\x00");
        }
        if (cmd.cfg_hide_unreachable_paths) {
            array.writeMany("--cfg-hide-unreachable-paths\x00");
        }
        if (cmd.cfg_raw_weights) {
            array.writeMany("--cfg-raw-weights\x00");
        }
        if (cmd.cfg_weights) {
            array.writeMany("--cfg-weights\x00");
        }
        if (cmd.cgp_freq_ratio_to_skip_merge) |cgp_freq_ratio_to_skip_merge| {
            array.writeMany("--cgp-freq-ratio-to-skip-merge\x00");
            array.writeFormat(fmt.ud64(cgp_freq_ratio_to_skip_merge));
            array.writeOne(0);
        }
        if (cmd.cgp_icmp_eq2icmp_st) {
            array.writeMany("--cgp-icmp-eq2icmp-st\x00");
        }
        if (cmd.cgp_optimize_phi_types) {
            array.writeMany("--cgp-optimize-phi-types\x00");
        }
        if (cmd.cgp_split_large_offset_gep) {
            array.writeMany("--cgp-split-large-offset-gep\x00");
        }
        if (cmd.cgp_type_promotion_merge) {
            array.writeMany("--cgp-type-promotion-merge\x00");
        }
        if (cmd.cgp_verify_bfi_updates) {
            array.writeMany("--cgp-verify-bfi-updates\x00");
        }
        if (cmd.cgpp_huge_func) |cgpp_huge_func| {
            array.writeMany("--cgpp-huge-func\x00");
            array.writeFormat(fmt.ud64(cgpp_huge_func));
            array.writeOne(0);
        }
        if (cmd.cgscc_inline_replay) {
            array.writeMany("--cgscc-inline-replay\x00");
        }
        if (cmd.cgscc_inline_replay_fallback) |cgscc_inline_replay_fallback| {
            array.writeMany("--cgscc-inline-replay-fallback\x00");
            array.writeMany(@tagName(cgscc_inline_replay_fallback));
            array.writeOne(0);
        }
        if (cmd.cgscc_inline_replay_format) |cgscc_inline_replay_format| {
            array.writeMany("--cgscc-inline-replay-format\x00");
            array.writeMany(@tagName(cgscc_inline_replay_format));
            array.writeOne(0);
        }
        if (cmd.cgscc_inline_replay_scope) |cgscc_inline_replay_scope| {
            array.writeMany("--cgscc-inline-replay-scope\x00");
            array.writeMany(@tagName(cgscc_inline_replay_scope));
            array.writeOne(0);
        }
        if (cmd.check_bfi_unknown_block_queries) {
            array.writeMany("--check-bfi-unknown-block-queries\x00");
        }
        if (cmd.check_early_avail) {
            array.writeMany("--check-early-avail\x00");
        }
        if (cmd.chr_bias_threshold) |chr_bias_threshold| {
            array.writeMany("--chr-bias-threshold\x00");
            array.writeFormat(fmt.ud64(chr_bias_threshold));
            array.writeOne(0);
        }
        if (cmd.chr_dup_threshold) |chr_dup_threshold| {
            array.writeMany("--chr-dup-threshold\x00");
            array.writeFormat(fmt.ud64(chr_dup_threshold));
            array.writeOne(0);
        }
        if (cmd.chr_function_list) |chr_function_list| {
            array.writeMany("--chr-function-list\x00");
            array.writeMany(chr_function_list);
            array.writeOne(0);
        }
        if (cmd.chr_merge_threshold) |chr_merge_threshold| {
            array.writeMany("--chr-merge-threshold\x00");
            array.writeFormat(fmt.ud64(chr_merge_threshold));
            array.writeOne(0);
        }
        if (cmd.chr_module_list) |chr_module_list| {
            array.writeMany("--chr-module-list\x00");
            array.writeMany(chr_module_list);
            array.writeOne(0);
        }
        if (cmd.code_model) |code_model| {
            array.writeMany("--code-model\x00");
            array.writeMany(@tagName(code_model));
            array.writeOne(0);
        }
        if (cmd.cold_branch_ratio) |cold_branch_ratio| {
            array.writeMany("--cold-branch-ratio\x00");
            array.writeFormat(fmt.ud64(cold_branch_ratio));
            array.writeOne(0);
        }
        if (cmd.cold_callsite_rel_freq) |cold_callsite_rel_freq| {
            array.writeMany("--cold-callsite-rel-freq\x00");
            array.writeFormat(fmt.ud64(cold_callsite_rel_freq));
            array.writeOne(0);
        }
        if (cmd.cold_operand_max_cost_multiplier) |cold_operand_max_cost_multiplier| {
            array.writeMany("--cold-operand-max-cost-multiplier\x00");
            array.writeFormat(fmt.ud64(cold_operand_max_cost_multiplier));
            array.writeOne(0);
        }
        if (cmd.cold_operand_threshold) |cold_operand_threshold| {
            array.writeMany("--cold-operand-threshold\x00");
            array.writeFormat(fmt.ud64(cold_operand_threshold));
            array.writeOne(0);
        }
        if (cmd.cold_synthetic_count) |cold_synthetic_count| {
            array.writeMany("--cold-synthetic-count\x00");
            array.writeFormat(fmt.ud64(cold_synthetic_count));
            array.writeOne(0);
        }
        if (cmd.coldcc_rel_freq) |coldcc_rel_freq| {
            array.writeMany("--coldcc-rel-freq\x00");
            array.writeFormat(fmt.ud64(coldcc_rel_freq));
            array.writeOne(0);
        }
        if (cmd.color) {
            array.writeMany("--color\x00");
        }
        if (cmd.combiner_global_alias_analysis) {
            array.writeMany("--combiner-global-alias-analysis\x00");
        }
        if (cmd.combiner_reduce_load_op_store_width) {
            array.writeMany("--combiner-reduce-load-op-store-width\x00");
        }
        if (cmd.combiner_shrink_load_replace_store_with_store) {
            array.writeMany("--combiner-shrink-load-replace-store-with-store\x00");
        }
        if (cmd.combiner_split_load_index) {
            array.writeMany("--combiner-split-load-index\x00");
        }
        if (cmd.combiner_store_merge_dependence_limit) |combiner_store_merge_dependence_limit| {
            array.writeMany("--combiner-store-merge-dependence-limit\x00");
            array.writeFormat(fmt.ud64(combiner_store_merge_dependence_limit));
            array.writeOne(0);
        }
        if (cmd.combiner_store_merging) {
            array.writeMany("--combiner-store-merging\x00");
        }
        if (cmd.combiner_stress_load_slicing) {
            array.writeMany("--combiner-stress-load-slicing\x00");
        }
        if (cmd.combiner_tokenfactor_inline_limit) |combiner_tokenfactor_inline_limit| {
            array.writeMany("--combiner-tokenfactor-inline-limit\x00");
            array.writeFormat(fmt.ud64(combiner_tokenfactor_inline_limit));
            array.writeOne(0);
        }
        if (cmd.combiner_use_tbaa) {
            array.writeMany("--combiner-use-tbaa\x00");
        }
        if (cmd.combiner_vector_fcopysign_extend_round) {
            array.writeMany("--combiner-vector-fcopysign-extend-round\x00");
        }
        if (cmd.commgep_const) {
            array.writeMany("--commgep-const\x00");
        }
        if (cmd.commgep_inv) {
            array.writeMany("--commgep-inv\x00");
        }
        if (cmd.commgep_speculate) {
            array.writeMany("--commgep-speculate\x00");
        }
        if (cmd.compile_time_mem_idiom_threshold) |compile_time_mem_idiom_threshold| {
            array.writeMany("--compile-time-mem-idiom-threshold\x00");
            array.writeFormat(fmt.ud64(compile_time_mem_idiom_threshold));
            array.writeOne(0);
        }
        if (cmd.compile_twice) {
            array.writeMany("--compile-twice\x00");
        }
        if (cmd.compute_dead) {
            array.writeMany("--compute-dead\x00");
        }
        if (cmd.consthoist_gep) {
            array.writeMany("--consthoist-gep\x00");
        }
        if (cmd.consthoist_min_num_to_rebase) |consthoist_min_num_to_rebase| {
            array.writeMany("--consthoist-min-num-to-rebase\x00");
            array.writeFormat(fmt.ud64(consthoist_min_num_to_rebase));
            array.writeOne(0);
        }
        if (cmd.consthoist_with_block_frequency) {
            array.writeMany("--consthoist-with-block-frequency\x00");
        }
        if (cmd.constraint_elimination_max_rows) |constraint_elimination_max_rows| {
            array.writeMany("--constraint-elimination-max-rows\x00");
            array.writeFormat(fmt.ud64(constraint_elimination_max_rows));
            array.writeOne(0);
        }
        if (cmd.cost_kind) |cost_kind| {
            array.writeMany("--cost-kind\x00");
            array.writeMany(@tagName(cost_kind));
            array.writeOne(0);
        }
        if (cmd.costmodel_reduxcost) {
            array.writeMany("--costmodel-reduxcost\x00");
        }
        if (cmd.crash_diagnostics_dir) |crash_diagnostics_dir| {
            array.writeMany("--crash-diagnostics-dir\x00");
            array.writeMany(crash_diagnostics_dir);
            array.writeOne(0);
        }
        if (cmd.crash_on_ppc_vsx_self_copy) {
            array.writeMany("--crash-on-ppc-vsx-self-copy\x00");
        }
        if (cmd.cs_profile_generate) {
            array.writeMany("--cs-profile-generate\x00");
        }
        if (cmd.cs_profile_path) |cs_profile_path| {
            array.writeMany("--cs-profile-path\x00");
            array.writeMany(cs_profile_path);
            array.writeOne(0);
        }
        if (cmd.csuses_threshold) |csuses_threshold| {
            array.writeMany("--csuses-threshold\x00");
            array.writeFormat(fmt.ud64(csuses_threshold));
            array.writeOne(0);
        }
        if (cmd.cvp_max_functions_per_value) |cvp_max_functions_per_value| {
            array.writeMany("--cvp-max-functions-per-value\x00");
            array.writeFormat(fmt.ud64(cvp_max_functions_per_value));
            array.writeOne(0);
        }
        if (cmd.da_delinearize) {
            array.writeMany("--da-delinearize\x00");
        }
        if (cmd.da_disable_delinearization_checks) {
            array.writeMany("--da-disable-delinearization-checks\x00");
        }
        if (cmd.da_miv_max_level_threshold) |da_miv_max_level_threshold| {
            array.writeMany("--da-miv-max-level-threshold\x00");
            array.writeFormat(fmt.ud64(da_miv_max_level_threshold));
            array.writeOne(0);
        }
        if (cmd.dag_dump_verbose) {
            array.writeMany("--dag-dump-verbose\x00");
        }
        if (cmd.dag_maps_huge_region) |dag_maps_huge_region| {
            array.writeMany("--dag-maps-huge-region\x00");
            array.writeFormat(fmt.ud64(dag_maps_huge_region));
            array.writeOne(0);
        }
        if (cmd.dag_maps_reduction_size) |dag_maps_reduction_size| {
            array.writeMany("--dag-maps-reduction-size\x00");
            array.writeFormat(fmt.ud64(dag_maps_reduction_size));
            array.writeOne(0);
        }
        if (cmd.data_sections) {
            array.writeMany("--data-sections\x00");
        }
        if (cmd.dataflow_edge_limit) |dataflow_edge_limit| {
            array.writeMany("--dataflow-edge-limit\x00");
            array.writeFormat(fmt.ud64(dataflow_edge_limit));
            array.writeOne(0);
        }
        if (cmd.ddg_pi_blocks) {
            array.writeMany("--ddg-pi-blocks\x00");
        }
        if (cmd.ddg_simplify) {
            array.writeMany("--ddg-simplify\x00");
        }
        if (cmd.debug_ata_max_blocks) |debug_ata_max_blocks| {
            array.writeMany("--debug-ata-max-blocks\x00");
            array.writeFormat(fmt.ud64(debug_ata_max_blocks));
            array.writeOne(0);
        }
        if (cmd.debug_counter) {
            array.writeMany("-debug-counter\x00");
        }
        if (cmd.debug_entry_values) {
            array.writeMany("--debug-entry-values\x00");
        }
        if (cmd.debug_info_correlate) {
            array.writeMany("--debug-info-correlate\x00");
        }
        if (cmd.debug_pass) |debug_pass| {
            array.writeMany("--debug-pass\x00");
            array.writeMany(@tagName(debug_pass));
            array.writeOne(0);
        }
        if (cmd.debugger_tune) |debugger_tune| {
            array.writeMany("--debugger-tune\x00");
            array.writeMany(@tagName(debugger_tune));
            array.writeOne(0);
        }
        if (cmd.debugify_and_strip_all_safe) {
            array.writeMany("--debugify-and-strip-all-safe\x00");
        }
        if (cmd.debugify_check_and_strip_all_safe) {
            array.writeMany("--debugify-check-and-strip-all-safe\x00");
        }
        if (cmd.debugify_func_limit) |debugify_func_limit| {
            array.writeMany("--debugify-func-limit\x00");
            array.writeFormat(fmt.ud64(debugify_func_limit));
            array.writeOne(0);
        }
        if (cmd.debugify_level) |debugify_level| {
            array.writeMany("--debugify-level\x00");
            array.writeMany(@tagName(debugify_level));
            array.writeOne(0);
        }
        if (cmd.debugify_quiet) {
            array.writeMany("--debugify-quiet\x00");
        }
        if (cmd.default_gcov_version) |default_gcov_version| {
            array.writeMany("--default-gcov-version\x00");
            array.writeMany(default_gcov_version);
            array.writeOne(0);
        }
        if (cmd.default_trip_count) |default_trip_count| {
            array.writeMany("--default-trip-count\x00");
            array.writeFormat(fmt.ud64(default_trip_count));
            array.writeOne(0);
        }
        if (cmd.demote_catchswitch_only) {
            array.writeMany("--demote-catchswitch-only\x00");
        }
        if (cmd.denormal_fp_math) |denormal_fp_math| {
            array.writeMany("--denormal-fp-math\x00");
            array.writeMany(@tagName(denormal_fp_math));
            array.writeOne(0);
        }
        if (cmd.denormal_fp_math_f32) |denormal_fp_math_f32| {
            array.writeMany("--denormal-fp-math-f32\x00");
            array.writeMany(@tagName(denormal_fp_math_f32));
            array.writeOne(0);
        }
        if (cmd.dfa_cost_threshold) |dfa_cost_threshold| {
            array.writeMany("--dfa-cost-threshold\x00");
            array.writeFormat(fmt.ud64(dfa_cost_threshold));
            array.writeOne(0);
        }
        if (cmd.dfa_hazard_rec) {
            array.writeMany("--dfa-hazard-rec\x00");
        }
        if (cmd.dfa_instr_limit) |dfa_instr_limit| {
            array.writeMany("--dfa-instr-limit\x00");
            array.writeFormat(fmt.ud64(dfa_instr_limit));
            array.writeOne(0);
        }
        if (cmd.dfa_jump_view_cfg_before) {
            array.writeMany("--dfa-jump-view-cfg-before\x00");
        }
        if (cmd.dfa_max_num_paths) |dfa_max_num_paths| {
            array.writeMany("--dfa-max-num-paths\x00");
            array.writeFormat(fmt.ud64(dfa_max_num_paths));
            array.writeOne(0);
        }
        if (cmd.dfa_max_path_length) |dfa_max_path_length| {
            array.writeMany("--dfa-max-path-length\x00");
            array.writeFormat(fmt.ud64(dfa_max_path_length));
            array.writeOne(0);
        }
        if (cmd.dfa_sched_reg_pressure_threshold) |dfa_sched_reg_pressure_threshold| {
            array.writeMany("--dfa-sched-reg-pressure-threshold\x00");
            array.writeFormat(fmt.ud64(dfa_sched_reg_pressure_threshold));
            array.writeOne(0);
        }
        if (cmd.dfsan_abilist) |dfsan_abilist| {
            array.writeMany("--dfsan-abilist\x00");
            array.writeMany(dfsan_abilist);
            array.writeOne(0);
        }
        if (cmd.dfsan_combine_offset_labels_on_gep) {
            array.writeMany("--dfsan-combine-offset-labels-on-gep\x00");
        }
        if (cmd.dfsan_combine_pointer_labels_on_load) {
            array.writeMany("--dfsan-combine-pointer-labels-on-load\x00");
        }
        if (cmd.dfsan_combine_pointer_labels_on_store) {
            array.writeMany("--dfsan-combine-pointer-labels-on-store\x00");
        }
        if (cmd.dfsan_combine_taint_lookup_table) |dfsan_combine_taint_lookup_table| {
            array.writeMany("--dfsan-combine-taint-lookup-table\x00");
            array.writeMany(dfsan_combine_taint_lookup_table);
            array.writeOne(0);
        }
        if (cmd.dfsan_conditional_callbacks) {
            array.writeMany("--dfsan-conditional-callbacks\x00");
        }
        if (cmd.dfsan_debug_nonzero_labels) {
            array.writeMany("--dfsan-debug-nonzero-labels\x00");
        }
        if (cmd.dfsan_event_callbacks) {
            array.writeMany("--dfsan-event-callbacks\x00");
        }
        if (cmd.dfsan_ignore_personality_routine) {
            array.writeMany("--dfsan-ignore-personality-routine\x00");
        }
        if (cmd.dfsan_instrument_with_call_threshold) |dfsan_instrument_with_call_threshold| {
            array.writeMany("--dfsan-instrument-with-call-threshold\x00");
            array.writeFormat(fmt.ud64(dfsan_instrument_with_call_threshold));
            array.writeOne(0);
        }
        if (cmd.dfsan_preserve_alignment) {
            array.writeMany("--dfsan-preserve-alignment\x00");
        }
        if (cmd.dfsan_reaches_function_callbacks) {
            array.writeMany("--dfsan-reaches-function-callbacks\x00");
        }
        if (cmd.dfsan_track_origins) |dfsan_track_origins| {
            array.writeMany("--dfsan-track-origins\x00");
            array.writeFormat(fmt.ud64(dfsan_track_origins));
            array.writeOne(0);
        }
        if (cmd.dfsan_track_select_control_flow) {
            array.writeMany("--dfsan-track-select-control-flow\x00");
        }
        if (cmd.disable_2addr_hack) {
            array.writeMany("--disable-2addr-hack\x00");
        }
        if (cmd.disable_a15_sd_optimization) {
            array.writeMany("--disable-a15-sd-optimization\x00");
        }
        if (cmd.disable_adv_copy_opt) {
            array.writeMany("--disable-adv-copy-opt\x00");
        }
        if (cmd.disable_advanced_peeling) {
            array.writeMany("--disable-advanced-peeling\x00");
        }
        if (cmd.disable_arm_loloops) {
            array.writeMany("--disable-arm-loloops\x00");
        }
        if (cmd.disable_arm_parallel_dsp) {
            array.writeMany("--disable-arm-parallel-dsp\x00");
        }
        if (cmd.disable_auto_paired_vec_st) {
            array.writeMany("--disable-auto-paired-vec-st\x00");
        }
        if (cmd.disable_basic_aa) {
            array.writeMany("--disable-basic-aa\x00");
        }
        if (cmd.disable_binop_extract_shuffle) {
            array.writeMany("--disable-binop-extract-shuffle\x00");
        }
        if (cmd.disable_bitcode_version_upgrade) {
            array.writeMany("--disable-bitcode-version-upgrade\x00");
        }
        if (cmd.disable_block_placement) {
            array.writeMany("--disable-block-placement\x00");
        }
        if (cmd.disable_bpf_peephole) {
            array.writeMany("--disable-bpf-peephole\x00");
        }
        if (cmd.disable_branch_fold) {
            array.writeMany("--disable-branch-fold\x00");
        }
        if (cmd.disable_cfi_fixup) {
            array.writeMany("--disable-cfi-fixup\x00");
        }
        if (cmd.disable_cgp) {
            array.writeMany("--disable-cgp\x00");
        }
        if (cmd.disable_cgp_branch_opts) {
            array.writeMany("--disable-cgp-branch-opts\x00");
        }
        if (cmd.disable_cgp_ext_ld_promotion) {
            array.writeMany("--disable-cgp-ext-ld-promotion\x00");
        }
        if (cmd.disable_cgp_gc_opts) {
            array.writeMany("--disable-cgp-gc-opts\x00");
        }
        if (cmd.disable_cgp_select2branch) {
            array.writeMany("--disable-cgp-select2branch\x00");
        }
        if (cmd.disable_cgp_store_extract) {
            array.writeMany("--disable-cgp-store-extract\x00");
        }
        if (cmd.disable_check_noreturn_call) {
            array.writeMany("--disable-check-noreturn-call\x00");
        }
        if (cmd.disable_chr) {
            array.writeMany("--disable-chr\x00");
        }
        if (cmd.disable_cleanups) {
            array.writeMany("--disable-cleanups\x00");
        }
        if (cmd.disable_complex_addr_modes) {
            array.writeMany("--disable-complex-addr-modes\x00");
        }
        if (cmd.disable_const64) {
            array.writeMany("--disable-const64\x00");
        }
        if (cmd.disable_constant_hoisting) {
            array.writeMany("--disable-constant-hoisting\x00");
        }
        if (cmd.disable_copyprop) {
            array.writeMany("--disable-copyprop\x00");
        }
        if (cmd.disable_debug_info_print) {
            array.writeMany("--disable-debug-info-print\x00");
        }
        if (cmd.disable_demotion) {
            array.writeMany("--disable-demotion\x00");
        }
        if (cmd.disable_dfa_sched) {
            array.writeMany("--disable-dfa-sched\x00");
        }
        if (cmd.disable_early_ifcvt) {
            array.writeMany("--disable-early-ifcvt\x00");
        }
        if (cmd.disable_early_taildup) {
            array.writeMany("--disable-early-taildup\x00");
        }
        if (cmd.disable_expand_reductions) {
            array.writeMany("--disable-expand-reductions\x00");
        }
        if (cmd.disable_gep_const_evaluation) {
            array.writeMany("--disable-gep-const-evaluation\x00");
        }
        if (cmd.disable_gisel_legality_check) {
            array.writeMany("--disable-gisel-legality-check\x00");
        }
        if (cmd.disable_hcp) {
            array.writeMany("--disable-hcp\x00");
        }
        if (cmd.disable_hexagon_amodeopt) {
            array.writeMany("--disable-hexagon-amodeopt\x00");
        }
        if (cmd.disable_hexagon_cfgopt) {
            array.writeMany("--disable-hexagon-cfgopt\x00");
        }
        if (cmd.disable_hexagon_dealloc_ret) {
            array.writeMany("--disable-hexagon-dealloc-ret\x00");
        }
        if (cmd.disable_hexagon_hwloops) {
            array.writeMany("--disable-hexagon-hwloops\x00");
        }
        if (cmd.disable_hexagon_misched) {
            array.writeMany("--disable-hexagon-misched\x00");
        }
        if (cmd.disable_hexagon_nv_schedule) {
            array.writeMany("--disable-hexagon-nv-schedule\x00");
        }
        if (cmd.disable_hexagon_opt_ext_to_64) {
            array.writeMany("--disable-hexagon-opt-ext-to-64\x00");
        }
        if (cmd.disable_hexagon_optszext) {
            array.writeMany("--disable-hexagon-optszext\x00");
        }
        if (cmd.disable_hexagon_peephole) {
            array.writeMany("--disable-hexagon-peephole\x00");
        }
        if (cmd.disable_hexagon_pnotp) {
            array.writeMany("--disable-hexagon-pnotp\x00");
        }
        if (cmd.disable_hexagon_shuffle) {
            array.writeMany("--disable-hexagon-shuffle\x00");
        }
        if (cmd.disable_hexagon_volatile_memcpy) {
            array.writeMany("--disable-hexagon-volatile-memcpy\x00");
        }
        if (cmd.disable_hoisting_to_hotter_blocks) |disable_hoisting_to_hotter_blocks| {
            array.writeMany("--disable-hoisting-to-hotter-blocks\x00");
            array.writeMany(@tagName(disable_hoisting_to_hotter_blocks));
            array.writeOne(0);
        }
        if (cmd.disable_hsdr) {
            array.writeMany("--disable-hsdr\x00");
        }
        if (cmd.disable_i2p_p2i_opt) {
            array.writeMany("--disable-i2p-p2i-opt\x00");
        }
        if (cmd.disable_icp) {
            array.writeMany("--disable-icp\x00");
        }
        if (cmd.disable_ifcvt_diamond) {
            array.writeMany("--disable-ifcvt-diamond\x00");
        }
        if (cmd.disable_ifcvt_forked_diamond) {
            array.writeMany("--disable-ifcvt-forked-diamond\x00");
        }
        if (cmd.disable_ifcvt_simple) {
            array.writeMany("--disable-ifcvt-simple\x00");
        }
        if (cmd.disable_ifcvt_simple_false) {
            array.writeMany("--disable-ifcvt-simple-false\x00");
        }
        if (cmd.disable_ifcvt_triangle) {
            array.writeMany("--disable-ifcvt-triangle\x00");
        }
        if (cmd.disable_ifcvt_triangle_false) {
            array.writeMany("--disable-ifcvt-triangle-false\x00");
        }
        if (cmd.disable_ifcvt_triangle_false_rev) {
            array.writeMany("--disable-ifcvt-triangle-false-rev\x00");
        }
        if (cmd.disable_ifcvt_triangle_rev) {
            array.writeMany("--disable-ifcvt-triangle-rev\x00");
        }
        if (cmd.disable_inlined_alloca_merging) {
            array.writeMany("--disable-inlined-alloca-merging\x00");
        }
        if (cmd.disable_interleaved_load_combine) {
            array.writeMany("--disable-interleaved-load-combine\x00");
        }
        if (cmd.disable_lanai_mem_alu_combiner) {
            array.writeMany("--disable-lanai-mem-alu-combiner\x00");
        }
        if (cmd.disable_layout_fsprofile_loader) {
            array.writeMany("--disable-layout-fsprofile-loader\x00");
        }
        if (cmd.disable_lftr) {
            array.writeMany("--disable-lftr\x00");
        }
        if (cmd.disable_licm_promotion) {
            array.writeMany("--disable-licm-promotion\x00");
        }
        if (cmd.disable_loop_level_heuristics) {
            array.writeMany("--disable-loop-level-heuristics\x00");
        }
        if (cmd.disable_lsr) {
            array.writeMany("--disable-lsr\x00");
        }
        if (cmd.disable_machine_cse) {
            array.writeMany("--disable-machine-cse\x00");
        }
        if (cmd.disable_machine_dce) {
            array.writeMany("--disable-machine-dce\x00");
        }
        if (cmd.disable_machine_licm) {
            array.writeMany("--disable-machine-licm\x00");
        }
        if (cmd.disable_machine_sink) {
            array.writeMany("--disable-machine-sink\x00");
        }
        if (cmd.disable_memcpy_idiom) {
            array.writeMany("--disable-memcpy-idiom\x00");
        }
        if (cmd.disable_memmove_idiom) {
            array.writeMany("--disable-memmove-idiom\x00");
        }
        if (cmd.disable_memop_opt) {
            array.writeMany("--disable-memop-opt\x00");
        }
        if (cmd.disable_merge_into_combines) {
            array.writeMany("--disable-merge-into-combines\x00");
        }
        if (cmd.disable_mergeicmps) {
            array.writeMany("--disable-mergeicmps\x00");
        }
        if (cmd.disable_mips_delay_filler) {
            array.writeMany("--disable-mips-delay-filler\x00");
        }
        if (cmd.disable_mips_df_backward_search) {
            array.writeMany("--disable-mips-df-backward-search\x00");
        }
        if (cmd.disable_mips_df_forward_search) {
            array.writeMany("--disable-mips-df-forward-search\x00");
        }
        if (cmd.disable_mips_df_succbb_search) {
            array.writeMany("--disable-mips-df-succbb-search\x00");
        }
        if (cmd.disable_mr_partial_inlining) {
            array.writeMany("--disable-mr-partial-inlining\x00");
        }
        if (cmd.disable_nofree_inference) {
            array.writeMany("--disable-nofree-inference\x00");
        }
        if (cmd.disable_non_allocatable_phys_copy_opt) {
            array.writeMany("--disable-non-allocatable-phys-copy-opt\x00");
        }
        if (cmd.disable_nounwind_inference) {
            array.writeMany("--disable-nounwind-inference\x00");
        }
        if (cmd.disable_nvjump) {
            array.writeMany("--disable-nvjump\x00");
        }
        if (cmd.disable_nvptx_load_store_vectorizer) {
            array.writeMany("--disable-nvptx-load-store-vectorizer\x00");
        }
        if (cmd.disable_nvptx_require_structured_cfg) {
            array.writeMany("--disable-nvptx-require-structured-cfg\x00");
        }
        if (cmd.disable_ondemand_mds_loading) {
            array.writeMany("--disable-ondemand-mds-loading\x00");
        }
        if (cmd.disable_packetizer) {
            array.writeMany("--disable-packetizer\x00");
        }
        if (cmd.disable_partial_inlining) {
            array.writeMany("--disable-partial-inlining\x00");
        }
        if (cmd.disable_partial_libcall_inlining) {
            array.writeMany("--disable-partial-libcall-inlining\x00");
        }
        if (cmd.disable_peephole) {
            array.writeMany("--disable-peephole\x00");
        }
        if (cmd.disable_phi_elim_edge_splitting) {
            array.writeMany("--disable-phi-elim-edge-splitting\x00");
        }
        if (cmd.disable_post_ra) {
            array.writeMany("--disable-post-ra\x00");
        }
        if (cmd.disable_postra_machine_licm) {
            array.writeMany("--disable-postra-machine-licm\x00");
        }
        if (cmd.disable_postra_machine_sink) {
            array.writeMany("--disable-postra-machine-sink\x00");
        }
        if (cmd.disable_ppc_cmp_opt) {
            array.writeMany("--disable-ppc-cmp-opt\x00");
        }
        if (cmd.disable_ppc_constant_hoisting) {
            array.writeMany("--disable-ppc-constant-hoisting\x00");
        }
        if (cmd.disable_ppc_ctrloop_analysis) {
            array.writeMany("--disable-ppc-ctrloop-analysis\x00");
        }
        if (cmd.disable_ppc_ctrloops) {
            array.writeMany("--disable-ppc-ctrloops\x00");
        }
        if (cmd.disable_ppc_ilp_pref) {
            array.writeMany("--disable-ppc-ilp-pref\x00");
        }
        if (cmd.disable_ppc_innermost_loop_align32) {
            array.writeMany("--disable-ppc-innermost-loop-align32\x00");
        }
        if (cmd.disable_ppc_instr_form_prep) {
            array.writeMany("--disable-ppc-instr-form-prep\x00");
        }
        if (cmd.disable_ppc_peephole) {
            array.writeMany("--disable-ppc-peephole\x00");
        }
        if (cmd.disable_ppc_preinc) {
            array.writeMany("--disable-ppc-preinc\x00");
        }
        if (cmd.disable_ppc_sched_addi_load) {
            array.writeMany("--disable-ppc-sched-addi-load\x00");
        }
        if (cmd.disable_ppc_sco) {
            array.writeMany("--disable-ppc-sco\x00");
        }
        if (cmd.disable_ppc_unaligned) {
            array.writeMany("--disable-ppc-unaligned\x00");
        }
        if (cmd.disable_ppc_vsx_fma_mutation) {
            array.writeMany("--disable-ppc-vsx-fma-mutation\x00");
        }
        if (cmd.disable_ppc_vsx_swap_removal) {
            array.writeMany("--disable-ppc-vsx-swap-removal\x00");
        }
        if (cmd.disable_preheader_prot) {
            array.writeMany("--disable-preheader-prot\x00");
        }
        if (cmd.disable_preinline) {
            array.writeMany("--disable-preinline\x00");
        }
        if (cmd.disable_promote_alloca_to_lds) {
            array.writeMany("--disable-promote-alloca-to-lds\x00");
        }
        if (cmd.disable_promote_alloca_to_vector) {
            array.writeMany("--disable-promote-alloca-to-vector\x00");
        }
        if (cmd.disable_ra_fsprofile_loader) {
            array.writeMany("--disable-ra-fsprofile-loader\x00");
        }
        if (cmd.disable_sample_loader_inlining) {
            array.writeMany("--disable-sample-loader-inlining\x00");
        }
        if (cmd.disable_sched_critical_path) {
            array.writeMany("--disable-sched-critical-path\x00");
        }
        if (cmd.disable_sched_cycles) {
            array.writeMany("--disable-sched-cycles\x00");
        }
        if (cmd.disable_sched_hazard) {
            array.writeMany("--disable-sched-hazard\x00");
        }
        if (cmd.disable_sched_height) {
            array.writeMany("--disable-sched-height\x00");
        }
        if (cmd.disable_sched_live_uses) {
            array.writeMany("--disable-sched-live-uses\x00");
        }
        if (cmd.disable_sched_physreg_join) {
            array.writeMany("--disable-sched-physreg-join\x00");
        }
        if (cmd.disable_sched_reg_pressure) {
            array.writeMany("--disable-sched-reg-pressure\x00");
        }
        if (cmd.disable_sched_stalls) {
            array.writeMany("--disable-sched-stalls\x00");
        }
        if (cmd.disable_sched_vrcycle) {
            array.writeMany("--disable-sched-vrcycle\x00");
        }
        if (cmd.disable_select_optimize) {
            array.writeMany("--disable-select-optimize\x00");
        }
        if (cmd.disable_separate_const_offset_from_gep) {
            array.writeMany("--disable-separate-const-offset-from-gep\x00");
        }
        if (cmd.disable_shifter_op) {
            array.writeMany("--disable-shifter-op\x00");
        }
        if (cmd.disable_simplify_libcalls) {
            array.writeMany("--disable-simplify-libcalls\x00");
        }
        if (cmd.disable_sparc_delay_filler) {
            array.writeMany("--disable-sparc-delay-filler\x00");
        }
        if (cmd.disable_sparc_leaf_proc) {
            array.writeMany("--disable-sparc-leaf-proc\x00");
        }
        if (cmd.disable_spill_fusing) {
            array.writeMany("--disable-spill-fusing\x00");
        }
        if (cmd.disable_spill_hoist) {
            array.writeMany("--disable-spill-hoist\x00");
        }
        if (cmd.disable_ssc) {
            array.writeMany("--disable-ssc\x00");
        }
        if (cmd.disable_store_widen) {
            array.writeMany("--disable-store-widen\x00");
        }
        if (cmd.disable_strictnode_mutation) {
            array.writeMany("--disable-strictnode-mutation\x00");
        }
        if (cmd.disable_symbolication) {
            array.writeMany("--disable-symbolication\x00");
        }
        if (cmd.disable_tail_calls) {
            array.writeMany("--disable-tail-calls\x00");
        }
        if (cmd.disable_tail_duplicate) {
            array.writeMany("--disable-tail-duplicate\x00");
        }
        if (cmd.disable_thinlto_funcattrs) {
            array.writeMany("--disable-thinlto-funcattrs\x00");
        }
        if (cmd.disable_type_promotion) {
            array.writeMany("--disable-type-promotion\x00");
        }
        if (cmd.disable_vecdbl_nv_stores) {
            array.writeMany("--disable-vecdbl-nv-stores\x00");
        }
        if (cmd.disable_vector_combine) {
            array.writeMany("--disable-vector-combine\x00");
        }
        if (cmd.disable_verify) {
            array.writeMany("--disable-verify\x00");
        }
        if (cmd.disable_vp) {
            array.writeMany("--disable-vp\x00");
        }
        if (cmd.disable_wasm_fallthrough_return_opt) {
            array.writeMany("--disable-wasm-fallthrough-return-opt\x00");
        }
        if (cmd.disable_whole_program_visibility) {
            array.writeMany("--disable-whole-program-visibility\x00");
        }
        if (cmd.disable_x86_domain_reassignment) {
            array.writeMany("--disable-x86-domain-reassignment\x00");
        }
        if (cmd.disable_x86_lea_opt) {
            array.writeMany("--disable-x86-lea-opt\x00");
        }
        if (cmd.discard_value_names) {
            array.writeMany("--discard-value-names\x00");
        }
        if (cmd.do_comdat_renaming) {
            array.writeMany("--do-comdat-renaming\x00");
        }
        if (cmd.do_counter_promotion) {
            array.writeMany("--do-counter-promotion\x00");
        }
        if (cmd.dom_conditions_max_uses) |dom_conditions_max_uses| {
            array.writeMany("--dom-conditions-max-uses\x00");
            array.writeFormat(fmt.ud64(dom_conditions_max_uses));
            array.writeOne(0);
        }
        if (cmd.dom_tree_reachability_max_bbs_to_explore) |dom_tree_reachability_max_bbs_to_explore| {
            array.writeMany("--dom-tree-reachability-max-bbs-to-explore\x00");
            array.writeFormat(fmt.ud64(dom_tree_reachability_max_bbs_to_explore));
            array.writeOne(0);
        }
        if (cmd.dot_cfg_after_color) |dot_cfg_after_color| {
            array.writeMany("--dot-cfg-after-color\x00");
            array.writeMany(dot_cfg_after_color);
            array.writeOne(0);
        }
        if (cmd.dot_cfg_before_color) |dot_cfg_before_color| {
            array.writeMany("--dot-cfg-before-color\x00");
            array.writeMany(dot_cfg_before_color);
            array.writeOne(0);
        }
        if (cmd.dot_cfg_common_color) |dot_cfg_common_color| {
            array.writeMany("--dot-cfg-common-color\x00");
            array.writeMany(dot_cfg_common_color);
            array.writeOne(0);
        }
        if (cmd.dot_cfg_dir) |dot_cfg_dir| {
            array.writeMany("--dot-cfg-dir\x00");
            array.writeMany(dot_cfg_dir);
            array.writeOne(0);
        }
        if (cmd.dot_ddg_filename_prefix) |dot_ddg_filename_prefix| {
            array.writeMany("--dot-ddg-filename-prefix\x00");
            array.writeMany(dot_ddg_filename_prefix);
            array.writeOne(0);
        }
        if (cmd.dot_ddg_only) {
            array.writeMany("--dot-ddg-only\x00");
        }
        if (cmd.dot_mcfg_only) {
            array.writeMany("--dot-mcfg-only\x00");
        }
        if (cmd.dse_memoryssa_defs_per_block_limit) |dse_memoryssa_defs_per_block_limit| {
            array.writeMany("--dse-memoryssa-defs-per-block-limit\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_defs_per_block_limit));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_otherbb_cost) |dse_memoryssa_otherbb_cost| {
            array.writeMany("--dse-memoryssa-otherbb-cost\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_otherbb_cost));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_partial_store_limit) |dse_memoryssa_partial_store_limit| {
            array.writeMany("--dse-memoryssa-partial-store-limit\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_partial_store_limit));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_path_check_limit) |dse_memoryssa_path_check_limit| {
            array.writeMany("--dse-memoryssa-path-check-limit\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_path_check_limit));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_samebb_cost) |dse_memoryssa_samebb_cost| {
            array.writeMany("--dse-memoryssa-samebb-cost\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_samebb_cost));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_scanlimit) |dse_memoryssa_scanlimit| {
            array.writeMany("--dse-memoryssa-scanlimit\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_scanlimit));
            array.writeOne(0);
        }
        if (cmd.dse_memoryssa_walklimit) |dse_memoryssa_walklimit| {
            array.writeMany("--dse-memoryssa-walklimit\x00");
            array.writeFormat(fmt.ud64(dse_memoryssa_walklimit));
            array.writeOne(0);
        }
        if (cmd.dse_optimize_memoryssa) {
            array.writeMany("--dse-optimize-memoryssa\x00");
        }
        if (cmd.dump_thin_cg_sccs) {
            array.writeMany("--dump-thin-cg-sccs\x00");
        }
        if (cmd.dwarf_directory) {
            array.writeMany("--dwarf-directory\x00");
        }
        if (cmd.dwarf_extended_loc) |dwarf_extended_loc| {
            array.writeMany("--dwarf-extended-loc\x00");
            array.writeMany(@tagName(dwarf_extended_loc));
            array.writeOne(0);
        }
        if (cmd.dwarf_inlined_strings) |dwarf_inlined_strings| {
            array.writeMany("--dwarf-inlined-strings\x00");
            array.writeMany(@tagName(dwarf_inlined_strings));
            array.writeOne(0);
        }
        if (cmd.dwarf_linkage_names) |dwarf_linkage_names| {
            array.writeMany("--dwarf-linkage-names\x00");
            array.writeMany(@tagName(dwarf_linkage_names));
            array.writeOne(0);
        }
        if (cmd.dwarf_op_convert) |dwarf_op_convert| {
            array.writeMany("--dwarf-op-convert\x00");
            array.writeMany(@tagName(dwarf_op_convert));
            array.writeOne(0);
        }
        if (cmd.dwarf_sections_as_references) |dwarf_sections_as_references| {
            array.writeMany("--dwarf-sections-as-references\x00");
            array.writeMany(@tagName(dwarf_sections_as_references));
            array.writeOne(0);
        }
        if (cmd.dwarf_version) |dwarf_version| {
            array.writeMany("--dwarf-version\x00");
            array.writeFormat(fmt.ud64(dwarf_version));
            array.writeOne(0);
        }
        if (cmd.dwarf64) {
            array.writeMany("--dwarf64\x00");
        }
        if (cmd.eagerly_invalidate_analyses) {
            array.writeMany("--eagerly-invalidate-analyses\x00");
        }
        if (cmd.early_ifcvt_limit) |early_ifcvt_limit| {
            array.writeMany("--early-ifcvt-limit\x00");
            array.writeFormat(fmt.ud64(early_ifcvt_limit));
            array.writeOne(0);
        }
        if (cmd.early_live_intervals) {
            array.writeMany("--early-live-intervals\x00");
        }
        if (cmd.earlycse_debug_hash) {
            array.writeMany("--earlycse-debug-hash\x00");
        }
        if (cmd.earlycse_mssa_optimization_cap) |earlycse_mssa_optimization_cap| {
            array.writeMany("--earlycse-mssa-optimization-cap\x00");
            array.writeFormat(fmt.ud64(earlycse_mssa_optimization_cap));
            array.writeOne(0);
        }
        if (cmd.eif_limit) |eif_limit| {
            array.writeMany("--eif-limit\x00");
            array.writeFormat(fmt.ud64(eif_limit));
            array.writeOne(0);
        }
        if (cmd.eif_no_loop_exit) {
            array.writeMany("--eif-no-loop-exit\x00");
        }
        if (cmd.emit_call_site_info) {
            array.writeMany("--emit-call-site-info\x00");
        }
        if (cmd.emit_dwarf_unwind) |emit_dwarf_unwind| {
            array.writeMany("--emit-dwarf-unwind\x00");
            array.writeMany(@tagName(emit_dwarf_unwind));
            array.writeOne(0);
        }
        if (cmd.emscripten_cxx_exceptions_allowed) |emscripten_cxx_exceptions_allowed| {
            array.writeMany("--emscripten-cxx-exceptions-allowed\x00");
            array.writeMany(emscripten_cxx_exceptions_allowed);
            array.writeOne(0);
        }
        if (cmd.emulate_old_livedebugvalues) {
            array.writeMany("--emulate-old-livedebugvalues\x00");
        }
        if (cmd.emulated_tls) {
            array.writeMany("--emulated-tls\x00");
        }
        if (cmd.enable_aa_sched_mi) {
            array.writeMany("--enable-aa-sched-mi\x00");
        }
        if (cmd.enable_acc_forwarding) {
            array.writeMany("--enable-acc-forwarding\x00");
        }
        if (cmd.enable_alu_forwarding) {
            array.writeMany("--enable-alu-forwarding\x00");
        }
        if (cmd.enable_amdgpu_aa) {
            array.writeMany("--enable-amdgpu-aa\x00");
        }
        if (cmd.enable_andcmp_sinking) {
            array.writeMany("--enable-andcmp-sinking\x00");
        }
        if (cmd.enable_approx_func_fp_math) {
            array.writeMany("--enable-approx-func-fp-math\x00");
        }
        if (cmd.enable_arm_3_addr_conv) {
            array.writeMany("--enable-arm-3-addr-conv\x00");
        }
        if (cmd.enable_arm_maskedgatscat) {
            array.writeMany("--enable-arm-maskedgatscat\x00");
        }
        if (cmd.enable_arm_maskedldst) {
            array.writeMany("--enable-arm-maskedldst\x00");
        }
        if (cmd.enable_block_placement_stats) {
            array.writeMany("--enable-block-placement-stats\x00");
        }
        if (cmd.enable_bsb_sched) {
            array.writeMany("--enable-bsb-sched\x00");
        }
        if (cmd.enable_chr) {
            array.writeMany("--enable-chr\x00");
        }
        if (cmd.enable_cold_section) {
            array.writeMany("--enable-cold-section\x00");
        }
        if (cmd.enable_coldcc_stress_test) {
            array.writeMany("--enable-coldcc-stress-test\x00");
        }
        if (cmd.enable_complex_deinterleaving) {
            array.writeMany("--enable-complex-deinterleaving\x00");
        }
        if (cmd.enable_cond_stores_vec) {
            array.writeMany("--enable-cond-stores-vec\x00");
        }
        if (cmd.enable_constraint_elimination) {
            array.writeMany("--enable-constraint-elimination\x00");
        }
        if (cmd.enable_cse_in_irtranslator) {
            array.writeMany("--enable-cse-in-irtranslator\x00");
        }
        if (cmd.enable_cse_in_legalizer) {
            array.writeMany("--enable-cse-in-legalizer\x00");
        }
        if (cmd.enable_cur_sched) {
            array.writeMany("--enable-cur-sched\x00");
        }
        if (cmd.enable_deferred_spilling) {
            array.writeMany("--enable-deferred-spilling\x00");
        }
        if (cmd.enable_dfa_jump_thread) {
            array.writeMany("--enable-dfa-jump-thread\x00");
        }
        if (cmd.enable_double_float_shrink) {
            array.writeMany("--enable-double-float-shrink\x00");
        }
        if (cmd.enable_dse_partial_overwrite_tracking) {
            array.writeMany("--enable-dse-partial-overwrite-tracking\x00");
        }
        if (cmd.enable_dse_partial_store_merging) {
            array.writeMany("--enable-dse-partial-store-merging\x00");
        }
        if (cmd.enable_emscripten_cxx_exceptions) {
            array.writeMany("--enable-emscripten-cxx-exceptions\x00");
        }
        if (cmd.enable_emscripten_sjlj) {
            array.writeMany("--enable-emscripten-sjlj\x00");
        }
        if (cmd.enable_epilogue_vectorization) {
            array.writeMany("--enable-epilogue-vectorization\x00");
        }
        if (cmd.enable_ext_tsp_block_placement) {
            array.writeMany("--enable-ext-tsp-block-placement\x00");
        }
        if (cmd.enable_falkor_hwpf_unroll_fix) {
            array.writeMany("--enable-falkor-hwpf-unroll-fix\x00");
        }
        if (cmd.enable_fixedwidth_autovec_in_streaming_mode) {
            array.writeMany("--enable-fixedwidth-autovec-in-streaming-mode\x00");
        }
        if (cmd.enable_fs_discriminator) {
            array.writeMany("--enable-fs-discriminator\x00");
        }
        if (cmd.enable_gen_insn) {
            array.writeMany("--enable-gen-insn\x00");
        }
        if (cmd.enable_global_analyses) {
            array.writeMany("--enable-global-analyses\x00");
        }
        if (cmd.enable_global_merge) {
            array.writeMany("--enable-global-merge\x00");
        }
        if (cmd.enable_gvn_hoist) {
            array.writeMany("--enable-gvn-hoist\x00");
        }
        if (cmd.enable_gvn_memdep) {
            array.writeMany("--enable-gvn-memdep\x00");
        }
        if (cmd.enable_gvn_sink) {
            array.writeMany("--enable-gvn-sink\x00");
        }
        if (cmd.enable_heap_to_stack_conversion) {
            array.writeMany("--enable-heap-to-stack-conversion\x00");
        }
        if (cmd.enable_hexagon_br_prob) {
            array.writeMany("--enable-hexagon-br-prob\x00");
        }
        if (cmd.enable_hexagon_sdnode_sched) {
            array.writeMany("--enable-hexagon-sdnode-sched\x00");
        }
        if (cmd.enable_hexagon_vector_print) {
            array.writeMany("--enable-hexagon-vector-print\x00");
        }
        if (cmd.enable_if_conversion) {
            array.writeMany("--enable-if-conversion\x00");
        }
        if (cmd.enable_implicit_null_checks) {
            array.writeMany("--enable-implicit-null-checks\x00");
        }
        if (cmd.enable_import_metadata) {
            array.writeMany("--enable-import-metadata\x00");
        }
        if (cmd.enable_ind_var_reg_heur) {
            array.writeMany("--enable-ind-var-reg-heur\x00");
        }
        if (cmd.enable_interleaved_mem_accesses) {
            array.writeMany("--enable-interleaved-mem-accesses\x00");
        }
        if (cmd.enable_ipra) {
            array.writeMany("--enable-ipra\x00");
        }
        if (cmd.enable_jmc_instrument) {
            array.writeMany("--enable-jmc-instrument\x00");
        }
        if (cmd.enable_knowledge_retention) {
            array.writeMany("--enable-knowledge-retention\x00");
        }
        if (cmd.enable_legalize_types_checking) {
            array.writeMany("--enable-legalize-types-checking\x00");
        }
        if (cmd.enable_linkonceodr_ir_outlining) {
            array.writeMany("--enable-linkonceodr-ir-outlining\x00");
        }
        if (cmd.enable_linkonceodr_outlining) {
            array.writeMany("--enable-linkonceodr-outlining\x00");
        }
        if (cmd.enable_load_in_loop_pre) {
            array.writeMany("--enable-load-in-loop-pre\x00");
        }
        if (cmd.enable_load_pre) {
            array.writeMany("--enable-load-pre\x00");
        }
        if (cmd.enable_loadstore_runtime_interleave) {
            array.writeMany("--enable-loadstore-runtime-interleave\x00");
        }
        if (cmd.enable_local_reassign) {
            array.writeMany("--enable-local-reassign\x00");
        }
        if (cmd.enable_loop_distribute) {
            array.writeMany("--enable-loop-distribute\x00");
        }
        if (cmd.enable_loop_flatten) {
            array.writeMany("--enable-loop-flatten\x00");
        }
        if (cmd.enable_loop_simplifycfg_term_folding) {
            array.writeMany("--enable-loop-simplifycfg-term-folding\x00");
        }
        if (cmd.enable_loopinterchange) {
            array.writeMany("--enable-loopinterchange\x00");
        }
        if (cmd.enable_lsr_phielim) {
            array.writeMany("--enable-lsr-phielim\x00");
        }
        if (cmd.enable_lto_internalization) {
            array.writeMany("--enable-lto-internalization\x00");
        }
        if (cmd.enable_machine_outliner) |enable_machine_outliner| {
            array.writeMany("--enable-machine-outliner\x00");
            array.writeMany(@tagName(enable_machine_outliner));
            array.writeOne(0);
        }
        if (cmd.enable_masked_interleaved_mem_accesses) {
            array.writeMany("--enable-masked-interleaved-mem-accesses\x00");
        }
        if (cmd.enable_matrix) {
            array.writeMany("--enable-matrix\x00");
        }
        if (cmd.enable_mem_access_versioning) {
            array.writeMany("--enable-mem-access-versioning\x00");
        }
        if (cmd.enable_mem_prof) {
            array.writeMany("--enable-mem-prof\x00");
        }
        if (cmd.enable_memcpy_dag_opt) {
            array.writeMany("--enable-memcpy-dag-opt\x00");
        }
        if (cmd.enable_memcpyopt_without_libcalls) {
            array.writeMany("--enable-memcpyopt-without-libcalls\x00");
        }
        if (cmd.enable_merge_functions) {
            array.writeMany("--enable-merge-functions\x00");
        }
        if (cmd.enable_misched) {
            array.writeMany("--enable-misched\x00");
        }
        if (cmd.enable_ml_inliner) |enable_ml_inliner| {
            array.writeMany("--enable-ml-inliner\x00");
            array.writeMany(@tagName(enable_ml_inliner));
            array.writeOne(0);
        }
        if (cmd.enable_module_inliner) {
            array.writeMany("--enable-module-inliner\x00");
        }
        if (cmd.enable_mve_interleave) {
            array.writeMany("--enable-mve-interleave\x00");
        }
        if (cmd.enable_name_compression) {
            array.writeMany("--enable-name-compression\x00");
        }
        if (cmd.enable_newgvn) {
            array.writeMany("--enable-newgvn\x00");
        }
        if (cmd.enable_no_infs_fp_math) {
            array.writeMany("--enable-no-infs-fp-math\x00");
        }
        if (cmd.enable_no_nans_fp_math) {
            array.writeMany("--enable-no-nans-fp-math\x00");
        }
        if (cmd.enable_no_rerun_simplification_pipeline) {
            array.writeMany("--enable-no-rerun-simplification-pipeline\x00");
        }
        if (cmd.enable_no_signed_zeros_fp_math) {
            array.writeMany("--enable-no-signed-zeros-fp-math\x00");
        }
        if (cmd.enable_no_trapping_fp_math) {
            array.writeMany("--enable-no-trapping-fp-math\x00");
        }
        if (cmd.enable_noalias_to_md_conversion) {
            array.writeMany("--enable-noalias-to-md-conversion\x00");
        }
        if (cmd.enable_nonnull_arg_prop) {
            array.writeMany("--enable-nonnull-arg-prop\x00");
        }
        if (cmd.enable_nontrivial_unswitch) {
            array.writeMany("--enable-nontrivial-unswitch\x00");
        }
        if (cmd.enable_npm_O3_nontrivial_unswitch) {
            array.writeMany("--enable-npm-O3-nontrivial-unswitch\x00");
        }
        if (cmd.enable_npm_pgo_inline_deferral) {
            array.writeMany("--enable-npm-pgo-inline-deferral\x00");
        }
        if (cmd.enable_npm_synthetic_counts) {
            array.writeMany("--enable-npm-synthetic-counts\x00");
        }
        if (cmd.enable_objc_arc_opts) {
            array.writeMany("--enable-objc-arc-opts\x00");
        }
        if (cmd.enable_order_file_instrumentation) {
            array.writeMany("--enable-order-file-instrumentation\x00");
        }
        if (cmd.enable_partial_inlining) {
            array.writeMany("--enable-partial-inlining\x00");
        }
        if (cmd.enable_patchpoint_liveness) {
            array.writeMany("--enable-patchpoint-liveness\x00");
        }
        if (cmd.enable_phi_of_ops) {
            array.writeMany("--enable-phi-of-ops\x00");
        }
        if (cmd.enable_pipeliner) {
            array.writeMany("--enable-pipeliner\x00");
        }
        if (cmd.enable_pipeliner_opt_size) {
            array.writeMany("--enable-pipeliner-opt-size\x00");
        }
        if (cmd.enable_post_misched) {
            array.writeMany("--enable-post-misched\x00");
        }
        if (cmd.enable_post_pgo_loop_rotation) {
            array.writeMany("--enable-post-pgo-loop-rotation\x00");
        }
        if (cmd.enable_ppc_branch_coalesce) {
            array.writeMany("--enable-ppc-branch-coalesce\x00");
        }
        if (cmd.enable_ppc_extra_toc_reg_deps) {
            array.writeMany("--enable-ppc-extra-toc-reg-deps\x00");
        }
        if (cmd.enable_ppc_gen_scalar_mass) {
            array.writeMany("--enable-ppc-gen-scalar-mass\x00");
        }
        if (cmd.enable_ppc_prefetching) {
            array.writeMany("--enable-ppc-prefetching\x00");
        }
        if (cmd.enable_pre) {
            array.writeMany("--enable-pre\x00");
        }
        if (cmd.enable_save_restore_long) {
            array.writeMany("--enable-save-restore-long\x00");
        }
        if (cmd.enable_scalable_autovec_in_streaming_mode) {
            array.writeMany("--enable-scalable-autovec-in-streaming-mode\x00");
        }
        if (cmd.enable_scc_inline_advisor_printing) {
            array.writeMany("--enable-scc-inline-advisor-printing\x00");
        }
        if (cmd.enable_scoped_noalias) {
            array.writeMany("--enable-scoped-noalias\x00");
        }
        if (cmd.enable_selectiondag_sp) {
            array.writeMany("--enable-selectiondag-sp\x00");
        }
        if (cmd.enable_shrink_wrap) {
            array.writeMany("--enable-shrink-wrap\x00");
        }
        if (cmd.enable_sign_dependent_rounding_fp_math) {
            array.writeMany("--enable-sign-dependent-rounding-fp-math\x00");
        }
        if (cmd.enable_split_backedge_in_load_pre) {
            array.writeMany("--enable-split-backedge-in-load-pre\x00");
        }
        if (cmd.enable_split_machine_functions) {
            array.writeMany("--enable-split-machine-functions\x00");
        }
        if (cmd.enable_stackovf_sanitizer) {
            array.writeMany("--enable-stackovf-sanitizer\x00");
        }
        if (cmd.enable_store_refinement) {
            array.writeMany("--enable-store-refinement\x00");
        }
        if (cmd.enable_subreg_liveness) {
            array.writeMany("--enable-subreg-liveness\x00");
        }
        if (cmd.enable_tail_merge) {
            array.writeMany("--enable-tail-merge\x00");
        }
        if (cmd.enable_tbaa) {
            array.writeMany("--enable-tbaa\x00");
        }
        if (cmd.enable_tc_latency_sched) {
            array.writeMany("--enable-tc-latency-sched\x00");
        }
        if (cmd.enable_timing_class_latency) {
            array.writeMany("--enable-timing-class-latency\x00");
        }
        if (cmd.enable_unroll_and_jam) {
            array.writeMany("--enable-unroll-and-jam\x00");
        }
        if (cmd.enable_unsafe_fp_math) {
            array.writeMany("--enable-unsafe-fp-math\x00");
        }
        if (cmd.enable_unsafe_globalsmodref_alias_results) {
            array.writeMany("--enable-unsafe-globalsmodref-alias-results\x00");
        }
        if (cmd.enable_unswitch_cost_multiplier) {
            array.writeMany("--enable-unswitch-cost-multiplier\x00");
        }
        if (cmd.enable_vfe) {
            array.writeMany("--enable-vfe\x00");
        }
        if (cmd.enable_vplan_native_path) {
            array.writeMany("--enable-vplan-native-path\x00");
        }
        if (cmd.enable_x86_scalar_amx) {
            array.writeMany("--enable-x86-scalar-amx\x00");
        }
        if (cmd.epilogue_vectorization_force_VF) |epilogue_vectorization_force_VF| {
            array.writeMany("--epilogue-vectorization-force-VF\x00");
            array.writeFormat(fmt.ud64(epilogue_vectorization_force_VF));
            array.writeOne(0);
        }
        if (cmd.epilogue_vectorization_minimum_VF) |epilogue_vectorization_minimum_VF| {
            array.writeMany("--epilogue-vectorization-minimum-VF\x00");
            array.writeFormat(fmt.ud64(epilogue_vectorization_minimum_VF));
            array.writeOne(0);
        }
        if (cmd.exception_model) |exception_model| {
            array.writeMany("--exception-model\x00");
            array.writeMany(@tagName(exception_model));
            array.writeOne(0);
        }
        if (cmd.exec_on_ir_change) |exec_on_ir_change| {
            array.writeMany("--exec-on-ir-change\x00");
            array.writeMany(exec_on_ir_change);
            array.writeOne(0);
        }
        if (cmd.exhaustive_register_search) {
            array.writeMany("--exhaustive-register-search\x00");
        }
        if (cmd.expand_all_fp_mlx) {
            array.writeMany("--expand-all-fp-mlx\x00");
        }
        if (cmd.expand_condsets_coa_limit) |expand_condsets_coa_limit| {
            array.writeMany("--expand-condsets-coa-limit\x00");
            array.writeFormat(fmt.ud64(expand_condsets_coa_limit));
            array.writeOne(0);
        }
        if (cmd.expand_condsets_tfr_limit) |expand_condsets_tfr_limit| {
            array.writeMany("--expand-condsets-tfr-limit\x00");
            array.writeFormat(fmt.ud64(expand_condsets_tfr_limit));
            array.writeOne(0);
        }
        if (cmd.expand_constant_exprs) {
            array.writeMany("--expand-constant-exprs\x00");
        }
        if (cmd.expand_div_rem_bits) |expand_div_rem_bits| {
            array.writeMany("--expand-div-rem-bits\x00");
            array.writeFormat(fmt.ud64(expand_div_rem_bits));
            array.writeOne(0);
        }
        if (cmd.expand_fp_convert_bits) |expand_fp_convert_bits| {
            array.writeMany("--expand-fp-convert-bits\x00");
            array.writeFormat(fmt.ud64(expand_fp_convert_bits));
            array.writeOne(0);
        }
        if (cmd.expand_limit) |expand_limit| {
            array.writeMany("--expand-limit\x00");
            array.writeFormat(fmt.ud64(expand_limit));
            array.writeOne(0);
        }
        if (cmd.expandvp_override_evl_transform) |expandvp_override_evl_transform| {
            array.writeMany("--expandvp-override-evl-transform\x00");
            array.writeMany(expandvp_override_evl_transform);
            array.writeOne(0);
        }
        if (cmd.expandvp_override_mask_transform) |expandvp_override_mask_transform| {
            array.writeMany("--expandvp-override-mask-transform\x00");
            array.writeMany(expandvp_override_mask_transform);
            array.writeOne(0);
        }
        if (cmd.experimental_debug_variable_locations) {
            array.writeMany("--experimental-debug-variable-locations\x00");
        }
        if (cmd.expose_ppc_andi_glue_bug) {
            array.writeMany("--expose-ppc-andi-glue-bug\x00");
        }
        if (cmd.ext_tsp_apply_without_profile) {
            array.writeMany("--ext-tsp-apply-without-profile\x00");
        }
        if (cmd.extra_vectorizer_passes) {
            array.writeMany("--extra-vectorizer-passes\x00");
        }
        if (cmd.extract_blocks_erase_funcs) {
            array.writeMany("--extract-blocks-erase-funcs\x00");
        }
        if (cmd.extract_blocks_file) |extract_blocks_file| {
            array.writeMany("--extract-blocks-file\x00");
            array.writeMany(extract_blocks_file);
            array.writeOne(0);
        }
        if (cmd.extract_cutoff) |extract_cutoff| {
            array.writeMany("--extract-cutoff\x00");
            array.writeFormat(fmt.ud64(extract_cutoff));
            array.writeOne(0);
        }
        if (cmd.extract_needand) {
            array.writeMany("--extract-needand\x00");
        }
        if (cmd.extract_nosr0) {
            array.writeMany("--extract-nosr0\x00");
        }
        if (cmd.fast_cluster_threshold) |fast_cluster_threshold| {
            array.writeMany("--fast-cluster-threshold\x00");
            array.writeFormat(fmt.ud64(fast_cluster_threshold));
            array.writeOne(0);
        }
        if (cmd.fast_isel) {
            array.writeMany("--fast-isel\x00");
        }
        if (cmd.fast_isel_abort) |fast_isel_abort| {
            array.writeMany("--fast-isel-abort\x00");
            array.writeFormat(fmt.ud64(fast_isel_abort));
            array.writeOne(0);
        }
        if (cmd.fast_isel_report_on_fallback) {
            array.writeMany("--fast-isel-report-on-fallback\x00");
        }
        if (cmd.fatal_warnings) {
            array.writeMany("--fatal-warnings\x00");
        }
        if (cmd.ffast_math) {
            array.writeMany("--ffast-math\x00");
        }
        if (cmd.filetype) |filetype| {
            array.writeMany("--filetype\x00");
            array.writeMany(@tagName(filetype));
            array.writeOne(0);
        }
        if (cmd.filter_passes) |filter_passes| {
            array.writeMany("--filter-passes\x00");
            array.writeMany(filter_passes);
            array.writeOne(0);
        }
        if (cmd.filter_print_funcs) |filter_print_funcs| {
            for (filter_print_funcs) |value| {
                array.writeMany("--filter-print-funcs\x00");
                array.writeMany(value);
                array.writeOne(0);
            }
        }
        if (cmd.fixup_allow_gcptr_in_csr) {
            array.writeMany("--fixup-allow-gcptr-in-csr\x00");
        }
        if (cmd.fixup_byte_word_insts) {
            array.writeMany("--fixup-byte-word-insts\x00");
        }
        if (cmd.fixup_max_csr_statepoints) |fixup_max_csr_statepoints| {
            array.writeMany("--fixup-max-csr-statepoints\x00");
            array.writeFormat(fmt.ud64(fixup_max_csr_statepoints));
            array.writeOne(0);
        }
        if (cmd.fixup_scs_enable_copy_propagation) {
            array.writeMany("--fixup-scs-enable-copy-propagation\x00");
        }
        if (cmd.fixup_scs_extend_slot_size) {
            array.writeMany("--fixup-scs-extend-slot-size\x00");
        }
        if (cmd.flat_loop_tripcount_threshold) |flat_loop_tripcount_threshold| {
            array.writeMany("--flat-loop-tripcount-threshold\x00");
            array.writeFormat(fmt.ud64(flat_loop_tripcount_threshold));
            array.writeOne(0);
        }
        if (cmd.flattened_profile_used) {
            array.writeMany("--flattened-profile-used\x00");
        }
        if (cmd.float_abi) |float_abi| {
            array.writeMany("--float-abi\x00");
            array.writeMany(@tagName(float_abi));
            array.writeOne(0);
        }
        if (cmd.float2int_max_integer_bw) |float2int_max_integer_bw| {
            array.writeMany("--float2int-max-integer-bw\x00");
            array.writeFormat(fmt.ud64(float2int_max_integer_bw));
            array.writeOne(0);
        }
        if (cmd.force_attribute) |force_attribute| {
            array.writeMany("--force-attribute\x00");
            array.writeMany(force_attribute);
            array.writeOne(0);
        }
        if (cmd.force_chr) {
            array.writeMany("--force-chr\x00");
        }
        if (cmd.force_dwarf_frame_section) {
            array.writeMany("--force-dwarf-frame-section\x00");
        }
        if (cmd.force_fast_cluster) {
            array.writeMany("--force-fast-cluster\x00");
        }
        if (cmd.force_function_specialization) {
            array.writeMany("--force-function-specialization\x00");
        }
        if (cmd.force_fuse_matrix) {
            array.writeMany("--force-fuse-matrix\x00");
        }
        if (cmd.force_hardware_loop_guard) {
            array.writeMany("--force-hardware-loop-guard\x00");
        }
        if (cmd.force_hardware_loop_phi) {
            array.writeMany("--force-hardware-loop-phi\x00");
        }
        if (cmd.force_hardware_loops) {
            array.writeMany("--force-hardware-loops\x00");
        }
        if (cmd.force_hvx_float) {
            array.writeMany("--force-hvx-float\x00");
        }
        if (cmd.force_import_all) {
            array.writeMany("--force-import-all\x00");
        }
        if (cmd.force_instr_ref_livedebugvalues) {
            array.writeMany("--force-instr-ref-livedebugvalues\x00");
        }
        if (cmd.force_legal_indexing) {
            array.writeMany("--force-legal-indexing\x00");
        }
        if (cmd.force_loop_cold_block) {
            array.writeMany("--force-loop-cold-block\x00");
        }
        if (cmd.force_mips_long_branch) {
            array.writeMany("--force-mips-long-branch\x00");
        }
        if (cmd.force_nested_hardware_loop) {
            array.writeMany("--force-nested-hardware-loop\x00");
        }
        if (cmd.force_ordered_reductions) {
            array.writeMany("--force-ordered-reductions\x00");
        }
        if (cmd.force_pgso) {
            array.writeMany("--force-pgso\x00");
        }
        if (cmd.force_precise_rotation_cost) {
            array.writeMany("--force-precise-rotation-cost\x00");
        }
        if (cmd.force_remove_attribute) |force_remove_attribute| {
            array.writeMany("--force-remove-attribute\x00");
            array.writeMany(force_remove_attribute);
            array.writeOne(0);
        }
        if (cmd.force_split_store) {
            array.writeMany("--force-split-store\x00");
        }
        if (cmd.force_streaming_compatible_sve) {
            array.writeMany("--force-streaming-compatible-sve\x00");
        }
        if (cmd.force_summary_edges_cold) |force_summary_edges_cold| {
            array.writeMany("--force-summary-edges-cold\x00");
            array.writeMany(@tagName(force_summary_edges_cold));
            array.writeOne(0);
        }
        if (cmd.force_target_instruction_cost) |force_target_instruction_cost| {
            array.writeMany("--force-target-instruction-cost\x00");
            array.writeFormat(fmt.ud64(force_target_instruction_cost));
            array.writeOne(0);
        }
        if (cmd.force_target_max_scalar_interleave) |force_target_max_scalar_interleave| {
            array.writeMany("--force-target-max-scalar-interleave\x00");
            array.writeFormat(fmt.ud64(force_target_max_scalar_interleave));
            array.writeOne(0);
        }
        if (cmd.force_target_max_vector_interleave) |force_target_max_vector_interleave| {
            array.writeMany("--force-target-max-vector-interleave\x00");
            array.writeFormat(fmt.ud64(force_target_max_vector_interleave));
            array.writeOne(0);
        }
        if (cmd.force_target_num_scalar_regs) |force_target_num_scalar_regs| {
            array.writeMany("--force-target-num-scalar-regs\x00");
            array.writeFormat(fmt.ud64(force_target_num_scalar_regs));
            array.writeOne(0);
        }
        if (cmd.force_target_num_vector_regs) |force_target_num_vector_regs| {
            array.writeMany("--force-target-num-vector-regs\x00");
            array.writeFormat(fmt.ud64(force_target_num_vector_regs));
            array.writeOne(0);
        }
        if (cmd.force_target_supports_scalable_vectors) {
            array.writeMany("--force-target-supports-scalable-vectors\x00");
        }
        if (cmd.force_vector_interleave) |force_vector_interleave| {
            array.writeMany("--force-vector-interleave\x00");
            array.writeFormat(fmt.ud64(force_vector_interleave));
            array.writeOne(0);
        }
        if (cmd.force_vector_width) |force_vector_width| {
            array.writeMany("--force-vector-width\x00");
            array.writeFormat(fmt.ud64(force_vector_width));
            array.writeOne(0);
        }
        if (cmd.force_widen_divrem_via_safe_divisor) {
            array.writeMany("--force-widen-divrem-via-safe-divisor\x00");
        }
        if (cmd.forget_scev_loop_unroll) {
            array.writeMany("--forget-scev-loop-unroll\x00");
        }
        if (cmd.forward_switch_cond) {
            array.writeMany("--forward-switch-cond\x00");
        }
        if (cmd.fp_contract) |fp_contract| {
            array.writeMany("--fp-contract\x00");
            array.writeMany(@tagName(fp_contract));
            array.writeOne(0);
        }
        if (cmd.frame_helper_size_threshold) |frame_helper_size_threshold| {
            array.writeMany("--frame-helper-size-threshold\x00");
            array.writeFormat(fmt.ud64(frame_helper_size_threshold));
            array.writeOne(0);
        }
        if (cmd.frame_pointer) |frame_pointer| {
            array.writeMany("--frame-pointer\x00");
            array.writeMany(@tagName(frame_pointer));
            array.writeOne(0);
        }
        if (cmd.freeze_loop_unswitch_cond) {
            array.writeMany("--freeze-loop-unswitch-cond\x00");
        }
        if (cmd.fs_no_final_discrim) {
            array.writeMany("--fs-no-final-discrim\x00");
        }
        if (cmd.fs_profile_debug_bw_threshold) |fs_profile_debug_bw_threshold| {
            array.writeMany("--fs-profile-debug-bw-threshold\x00");
            array.writeFormat(fmt.ud64(fs_profile_debug_bw_threshold));
            array.writeOne(0);
        }
        if (cmd.fs_profile_debug_prob_diff_threshold) |fs_profile_debug_prob_diff_threshold| {
            array.writeMany("--fs-profile-debug-prob-diff-threshold\x00");
            array.writeFormat(fmt.ud64(fs_profile_debug_prob_diff_threshold));
            array.writeOne(0);
        }
        if (cmd.fs_profile_file) |fs_profile_file| {
            array.writeMany("--fs-profile-file\x00");
            array.writeMany(fs_profile_file);
            array.writeOne(0);
        }
        if (cmd.fs_remapping_file) |fs_remapping_file| {
            array.writeMany("--fs-remapping-file\x00");
            array.writeMany(fs_remapping_file);
            array.writeOne(0);
        }
        if (cmd.fs_viewbfi_after) {
            array.writeMany("--fs-viewbfi-after\x00");
        }
        if (cmd.fs_viewbfi_before) {
            array.writeMany("--fs-viewbfi-before\x00");
        }
        if (cmd.func_specialization_avg_iters_cost) |func_specialization_avg_iters_cost| {
            array.writeMany("--func-specialization-avg-iters-cost\x00");
            array.writeFormat(fmt.ud64(func_specialization_avg_iters_cost));
            array.writeOne(0);
        }
        if (cmd.func_specialization_max_clones) |func_specialization_max_clones| {
            array.writeMany("--func-specialization-max-clones\x00");
            array.writeFormat(fmt.ud64(func_specialization_max_clones));
            array.writeOne(0);
        }
        if (cmd.func_specialization_max_iters) |func_specialization_max_iters| {
            array.writeMany("--func-specialization-max-iters\x00");
            array.writeFormat(fmt.ud64(func_specialization_max_iters));
            array.writeOne(0);
        }
        if (cmd.func_specialization_on_address) {
            array.writeMany("--func-specialization-on-address\x00");
        }
        if (cmd.func_specialization_size_threshold) |func_specialization_size_threshold| {
            array.writeMany("--func-specialization-size-threshold\x00");
            array.writeFormat(fmt.ud64(func_specialization_size_threshold));
            array.writeOne(0);
        }
        if (cmd.function_sections) {
            array.writeMany("--function-sections\x00");
        }
        if (cmd.function_specialization_for_literal_constant) {
            array.writeMany("--function-specialization-for-literal-constant\x00");
        }
        if (cmd.fuse_matrix) {
            array.writeMany("--fuse-matrix\x00");
        }
        if (cmd.fuse_matrix_tile_size) |fuse_matrix_tile_size| {
            array.writeMany("--fuse-matrix-tile-size\x00");
            array.writeFormat(fmt.ud64(fuse_matrix_tile_size));
            array.writeOne(0);
        }
        if (cmd.fuse_matrix_use_loops) {
            array.writeMany("--fuse-matrix-use-loops\x00");
        }
        if (cmd.gcov_atomic_counter) {
            array.writeMany("--gcov-atomic-counter\x00");
        }
        if (cmd.generate_arange_section) {
            array.writeMany("--generate-arange-section\x00");
        }
        if (cmd.generate_merged_base_profiles) {
            array.writeMany("--generate-merged-base-profiles\x00");
        }
        if (cmd.generate_type_units) {
            array.writeMany("--generate-type-units\x00");
        }
        if (cmd.global_isel) {
            array.writeMany("--global-isel\x00");
        }
        if (cmd.global_isel_abort) |global_isel_abort| {
            array.writeMany("--global-isel-abort\x00");
            array.writeMany(@tagName(global_isel_abort));
            array.writeOne(0);
        }
        if (cmd.global_merge_group_by_use) {
            array.writeMany("--global-merge-group-by-use\x00");
        }
        if (cmd.global_merge_ignore_single_use) {
            array.writeMany("--global-merge-ignore-single-use\x00");
        }
        if (cmd.global_merge_max_offset) |global_merge_max_offset| {
            array.writeMany("--global-merge-max-offset\x00");
            array.writeFormat(fmt.ud64(global_merge_max_offset));
            array.writeOne(0);
        }
        if (cmd.global_merge_on_const) {
            array.writeMany("--global-merge-on-const\x00");
        }
        if (cmd.global_merge_on_external) {
            array.writeMany("--global-merge-on-external\x00");
        }
        if (cmd.gpsize) |gpsize| {
            array.writeMany("--gpsize\x00");
            array.writeFormat(fmt.ud64(gpsize));
            array.writeOne(0);
        }
        if (cmd.greedy_regclass_priority_trumps_globalness) {
            array.writeMany("--greedy-regclass-priority-trumps-globalness\x00");
        }
        if (cmd.greedy_reverse_local_assignment) {
            array.writeMany("--greedy-reverse-local-assignment\x00");
        }
        if (cmd.grow_region_complexity_budget) |grow_region_complexity_budget| {
            array.writeMany("--grow-region-complexity-budget\x00");
            array.writeFormat(fmt.ud64(grow_region_complexity_budget));
            array.writeOne(0);
        }
        if (cmd.guard_widening_widen_branch_guards) {
            array.writeMany("--guard-widening-widen-branch-guards\x00");
        }
        if (cmd.guards_predicate_pass_branch_weight) |guards_predicate_pass_branch_weight| {
            array.writeMany("--guards-predicate-pass-branch-weight\x00");
            array.writeFormat(fmt.ud64(guards_predicate_pass_branch_weight));
            array.writeOne(0);
        }
        if (cmd.gvn_add_phi_translation) {
            array.writeMany("--gvn-add-phi-translation\x00");
        }
        if (cmd.gvn_hoist_max_bbs) |gvn_hoist_max_bbs| {
            array.writeMany("--gvn-hoist-max-bbs\x00");
            array.writeFormat(fmt.ud64(gvn_hoist_max_bbs));
            array.writeOne(0);
        }
        if (cmd.gvn_hoist_max_chain_length) |gvn_hoist_max_chain_length| {
            array.writeMany("--gvn-hoist-max-chain-length\x00");
            array.writeFormat(fmt.ud64(gvn_hoist_max_chain_length));
            array.writeOne(0);
        }
        if (cmd.gvn_hoist_max_depth) |gvn_hoist_max_depth| {
            array.writeMany("--gvn-hoist-max-depth\x00");
            array.writeFormat(fmt.ud64(gvn_hoist_max_depth));
            array.writeOne(0);
        }
        if (cmd.gvn_max_block_speculations) |gvn_max_block_speculations| {
            array.writeMany("--gvn-max-block-speculations\x00");
            array.writeFormat(fmt.ud64(gvn_max_block_speculations));
            array.writeOne(0);
        }
        if (cmd.gvn_max_hoisted) |gvn_max_hoisted| {
            array.writeMany("--gvn-max-hoisted\x00");
            array.writeFormat(fmt.ud64(gvn_max_hoisted));
            array.writeOne(0);
        }
        if (cmd.gvn_max_num_deps) |gvn_max_num_deps| {
            array.writeMany("--gvn-max-num-deps\x00");
            array.writeFormat(fmt.ud64(gvn_max_num_deps));
            array.writeOne(0);
        }
        if (cmd.gvn_max_num_visited_insts) |gvn_max_num_visited_insts| {
            array.writeMany("--gvn-max-num-visited-insts\x00");
            array.writeFormat(fmt.ud64(gvn_max_num_visited_insts));
            array.writeOne(0);
        }
        if (cmd.hardware_loop_counter_bitwidth) |hardware_loop_counter_bitwidth| {
            array.writeMany("--hardware-loop-counter-bitwidth\x00");
            array.writeFormat(fmt.ud64(hardware_loop_counter_bitwidth));
            array.writeOne(0);
        }
        if (cmd.hardware_loop_decrement) |hardware_loop_decrement| {
            array.writeMany("--hardware-loop-decrement\x00");
            array.writeFormat(fmt.ud64(hardware_loop_decrement));
            array.writeOne(0);
        }
        if (cmd.hash_based_counter_split) {
            array.writeMany("--hash-based-counter-split\x00");
        }
        if (cmd.help) {
            array.writeMany("--help\x00");
        }
        if (cmd.help_hidden) {
            array.writeMany("--help-hidden\x00");
        }
        if (cmd.help_list) {
            array.writeMany("--help-list\x00");
        }
        if (cmd.help_list_hidden) {
            array.writeMany("--help-list-hidden\x00");
        }
        if (cmd.hexagon_align_loads) {
            array.writeMany("--hexagon-align-loads\x00");
        }
        if (cmd.hexagon_amode_growth_limit) |hexagon_amode_growth_limit| {
            array.writeMany("--hexagon-amode-growth-limit\x00");
            array.writeFormat(fmt.ud64(hexagon_amode_growth_limit));
            array.writeOne(0);
        }
        if (cmd.hexagon_autohvx) {
            array.writeMany("--hexagon-autohvx\x00");
        }
        if (cmd.hexagon_bit) {
            array.writeMany("--hexagon-bit\x00");
        }
        if (cmd.hexagon_cext) {
            array.writeMany("--hexagon-cext\x00");
        }
        if (cmd.hexagon_cext_limit) |hexagon_cext_limit| {
            array.writeMany("--hexagon-cext-limit\x00");
            array.writeFormat(fmt.ud64(hexagon_cext_limit));
            array.writeOne(0);
        }
        if (cmd.hexagon_cext_threshold) |hexagon_cext_threshold| {
            array.writeMany("--hexagon-cext-threshold\x00");
            array.writeFormat(fmt.ud64(hexagon_cext_threshold));
            array.writeOne(0);
        }
        if (cmd.hexagon_check_bank_conflict) {
            array.writeMany("--hexagon-check-bank-conflict\x00");
        }
        if (cmd.hexagon_commgep) {
            array.writeMany("--hexagon-commgep\x00");
        }
        if (cmd.hexagon_disable_args_min_alignment) {
            array.writeMany("--hexagon-disable-args-min-alignment\x00");
        }
        if (cmd.hexagon_eif) {
            array.writeMany("--hexagon-eif\x00");
        }
        if (cmd.hexagon_emit_jt_text) {
            array.writeMany("--hexagon-emit-jt-text\x00");
        }
        if (cmd.hexagon_emit_jump_tables) {
            array.writeMany("--hexagon-emit-jump-tables\x00");
        }
        if (cmd.hexagon_emit_lookup_tables) {
            array.writeMany("--hexagon-emit-lookup-tables\x00");
        }
        if (cmd.hexagon_emit_lut_text) {
            array.writeMany("--hexagon-emit-lut-text\x00");
        }
        if (cmd.hexagon_enable_branch_prediction) {
            array.writeMany("--hexagon-enable-branch-prediction\x00");
        }
        if (cmd.hexagon_expand_condsets) {
            array.writeMany("--hexagon-expand-condsets\x00");
        }
        if (cmd.hexagon_extract) {
            array.writeMany("--hexagon-extract\x00");
        }
        if (cmd.hexagon_fp_elim) {
            array.writeMany("--hexagon-fp-elim\x00");
        }
        if (cmd.hexagon_frame_index_reuse_limit) |hexagon_frame_index_reuse_limit| {
            array.writeMany("--hexagon-frame-index-reuse-limit\x00");
            array.writeFormat(fmt.ud64(hexagon_frame_index_reuse_limit));
            array.writeOne(0);
        }
        if (cmd.hexagon_frame_index_search_range) |hexagon_frame_index_search_range| {
            array.writeMany("--hexagon-frame-index-search-range\x00");
            array.writeFormat(fmt.ud64(hexagon_frame_index_search_range));
            array.writeOne(0);
        }
        if (cmd.hexagon_gen_mux_threshold) |hexagon_gen_mux_threshold| {
            array.writeMany("--hexagon-gen-mux-threshold\x00");
            array.writeFormat(fmt.ud64(hexagon_gen_mux_threshold));
            array.writeOne(0);
        }
        if (cmd.hexagon_gen_pred) {
            array.writeMany("--hexagon-gen-pred\x00");
        }
        if (cmd.hexagon_hvx_widen) |hexagon_hvx_widen| {
            array.writeMany("--hexagon-hvx-widen\x00");
            array.writeFormat(fmt.ud64(hexagon_hvx_widen));
            array.writeOne(0);
        }
        if (cmd.hexagon_hwloop_preheader) {
            array.writeMany("--hexagon-hwloop-preheader\x00");
        }
        if (cmd.hexagon_initial_cfg_cleanup) {
            array.writeMany("--hexagon-initial-cfg-cleanup\x00");
        }
        if (cmd.hexagon_insert) {
            array.writeMany("--hexagon-insert\x00");
        }
        if (cmd.hexagon_instsimplify) {
            array.writeMany("--hexagon-instsimplify\x00");
        }
        if (cmd.hexagon_isel_su) {
            array.writeMany("--hexagon-isel-su\x00");
        }
        if (cmd.hexagon_long_calls) {
            array.writeMany("--hexagon-long-calls\x00");
        }
        if (cmd.hexagon_loop_prefetch) {
            array.writeMany("--hexagon-loop-prefetch\x00");
        }
        if (cmd.hexagon_loop_range) |hexagon_loop_range| {
            array.writeMany("--hexagon-loop-range\x00");
            array.writeFormat(fmt.ud64(hexagon_loop_range));
            array.writeOne(0);
        }
        if (cmd.hexagon_loop_resched) {
            array.writeMany("--hexagon-loop-resched\x00");
        }
        if (cmd.hexagon_masked_vmem) {
            array.writeMany("--hexagon-masked-vmem\x00");
        }
        if (cmd.hexagon_mux) {
            array.writeMany("--hexagon-mux\x00");
        }
        if (cmd.hexagon_noopt) {
            array.writeMany("--hexagon-noopt\x00");
        }
        if (cmd.hexagon_opt_spill) {
            array.writeMany("--hexagon-opt-spill\x00");
        }
        if (cmd.hexagon_opt_vextract) {
            array.writeMany("--hexagon-opt-vextract\x00");
        }
        if (cmd.hexagon_packetize_volatiles) {
            array.writeMany("--hexagon-packetize-volatiles\x00");
        }
        if (cmd.hexagon_pred_calls) {
            array.writeMany("--hexagon-pred-calls\x00");
        }
        if (cmd.hexagon_sched_inline_asm) {
            array.writeMany("--hexagon-sched-inline-asm\x00");
        }
        if (cmd.hexagon_shrink_frame) {
            array.writeMany("--hexagon-shrink-frame\x00");
        }
        if (cmd.hexagon_small_data_threshold) |hexagon_small_data_threshold| {
            array.writeMany("--hexagon-small-data-threshold\x00");
            array.writeFormat(fmt.ud64(hexagon_small_data_threshold));
            array.writeOne(0);
        }
        if (cmd.hexagon_statics_in_small_data) {
            array.writeMany("--hexagon-statics-in-small-data\x00");
        }
        if (cmd.hexagon_subreg_liveness) {
            array.writeMany("--hexagon-subreg-liveness\x00");
        }
        if (cmd.hexagon_vector_combine) {
            array.writeMany("--hexagon-vector-combine\x00");
        }
        if (cmd.hexagon_vextract_threshold) |hexagon_vextract_threshold| {
            array.writeMany("--hexagon-vextract-threshold\x00");
            array.writeFormat(fmt.ud64(hexagon_vextract_threshold));
            array.writeOne(0);
        }
        if (cmd.hexagon_vlcr_iteration_lim) |hexagon_vlcr_iteration_lim| {
            array.writeMany("--hexagon-vlcr-iteration-lim\x00");
            array.writeFormat(fmt.ud64(hexagon_vlcr_iteration_lim));
            array.writeOne(0);
        }
        if (cmd.hexbit_bitsplit) {
            array.writeMany("--hexbit-bitsplit\x00");
        }
        if (cmd.hexbit_extract) {
            array.writeMany("--hexbit-extract\x00");
        }
        if (cmd.hexbit_keep_tied) {
            array.writeMany("--hexbit-keep-tied\x00");
        }
        if (cmd.hexbit_max_bitsplit) |hexbit_max_bitsplit| {
            array.writeMany("--hexbit-max-bitsplit\x00");
            array.writeFormat(fmt.ud64(hexbit_max_bitsplit));
            array.writeOne(0);
        }
        if (cmd.hexbit_max_extract) |hexbit_max_extract| {
            array.writeMany("--hexbit-max-extract\x00");
            array.writeFormat(fmt.ud64(hexbit_max_extract));
            array.writeOne(0);
        }
        if (cmd.hexbit_registerset_limit) |hexbit_registerset_limit| {
            array.writeMany("--hexbit-registerset-limit\x00");
            array.writeFormat(fmt.ud64(hexbit_registerset_limit));
            array.writeOne(0);
        }
        if (cmd.hints_allow_reordering) {
            array.writeMany("--hints-allow-reordering\x00");
        }
        if (cmd.hlir_simplify_limit) |hlir_simplify_limit| {
            array.writeMany("--hlir-simplify-limit\x00");
            array.writeFormat(fmt.ud64(hlir_simplify_limit));
            array.writeOne(0);
        }
        if (cmd.hoist_cheap_insts) {
            array.writeMany("--hoist-cheap-insts\x00");
        }
        if (cmd.hoist_common_insts) {
            array.writeMany("--hoist-common-insts\x00");
        }
        if (cmd.hoist_const_stores) {
            array.writeMany("--hoist-const-stores\x00");
        }
        if (cmd.homogeneous_prolog_epilog) {
            array.writeMany("--homogeneous-prolog-epilog\x00");
        }
        if (cmd.hot_callsite_rel_freq) |hot_callsite_rel_freq| {
            array.writeMany("--hot-callsite-rel-freq\x00");
            array.writeFormat(fmt.ud64(hot_callsite_rel_freq));
            array.writeOne(0);
        }
        if (cmd.hot_callsite_threshold) |hot_callsite_threshold| {
            array.writeMany("--hot-callsite-threshold\x00");
            array.writeFormat(fmt.ud64(hot_callsite_threshold));
            array.writeOne(0);
        }
        if (cmd.hot_cold_split) {
            array.writeMany("--hot-cold-split\x00");
        }
        if (cmd.hot_cold_static_analysis) {
            array.writeMany("--hot-cold-static-analysis\x00");
        }
        if (cmd.hotcoldsplit_cold_section_name) |hotcoldsplit_cold_section_name| {
            array.writeMany("--hotcoldsplit-cold-section-name\x00");
            array.writeMany(hotcoldsplit_cold_section_name);
            array.writeOne(0);
        }
        if (cmd.hotcoldsplit_max_params) |hotcoldsplit_max_params| {
            array.writeMany("--hotcoldsplit-max-params\x00");
            array.writeFormat(fmt.ud64(hotcoldsplit_max_params));
            array.writeOne(0);
        }
        if (cmd.hotcoldsplit_threshold) |hotcoldsplit_threshold| {
            array.writeMany("--hotcoldsplit-threshold\x00");
            array.writeFormat(fmt.ud64(hotcoldsplit_threshold));
            array.writeOne(0);
        }
        if (cmd.hsdr_no_mem) {
            array.writeMany("--hsdr-no-mem\x00");
        }
        if (cmd.hsdr_split_all) {
            array.writeMany("--hsdr-split-all\x00");
        }
        if (cmd.huge_size_for_split) |huge_size_for_split| {
            array.writeMany("--huge-size-for-split\x00");
            array.writeFormat(fmt.ud64(huge_size_for_split));
            array.writeOne(0);
        }
        if (cmd.hwasan_experimental_use_page_aliases) {
            array.writeMany("--hwasan-experimental-use-page-aliases\x00");
        }
        if (cmd.hwasan_generate_tags_with_calls) {
            array.writeMany("--hwasan-generate-tags-with-calls\x00");
        }
        if (cmd.hwasan_globals) {
            array.writeMany("--hwasan-globals\x00");
        }
        if (cmd.hwasan_inline_all_checks) {
            array.writeMany("--hwasan-inline-all-checks\x00");
        }
        if (cmd.hwasan_instrument_atomics) {
            array.writeMany("--hwasan-instrument-atomics\x00");
        }
        if (cmd.hwasan_instrument_byval) {
            array.writeMany("--hwasan-instrument-byval\x00");
        }
        if (cmd.hwasan_instrument_landing_pads) {
            array.writeMany("--hwasan-instrument-landing-pads\x00");
        }
        if (cmd.hwasan_instrument_mem_intrinsics) {
            array.writeMany("--hwasan-instrument-mem-intrinsics\x00");
        }
        if (cmd.hwasan_instrument_personality_functions) {
            array.writeMany("--hwasan-instrument-personality-functions\x00");
        }
        if (cmd.hwasan_instrument_reads) {
            array.writeMany("--hwasan-instrument-reads\x00");
        }
        if (cmd.hwasan_instrument_stack) {
            array.writeMany("--hwasan-instrument-stack\x00");
        }
        if (cmd.hwasan_instrument_with_calls) {
            array.writeMany("--hwasan-instrument-with-calls\x00");
        }
        if (cmd.hwasan_instrument_writes) {
            array.writeMany("--hwasan-instrument-writes\x00");
        }
        if (cmd.hwasan_kernel) {
            array.writeMany("--hwasan-kernel\x00");
        }
        if (cmd.hwasan_kernel_mem_intrinsic_prefix) {
            array.writeMany("--hwasan-kernel-mem-intrinsic-prefix\x00");
        }
        if (cmd.hwasan_mapping_offset) |hwasan_mapping_offset| {
            array.writeMany("--hwasan-mapping-offset\x00");
            array.writeFormat(fmt.ud64(hwasan_mapping_offset));
            array.writeOne(0);
        }
        if (cmd.hwasan_match_all_tag) |hwasan_match_all_tag| {
            array.writeMany("--hwasan-match-all-tag\x00");
            array.writeFormat(fmt.ud64(hwasan_match_all_tag));
            array.writeOne(0);
        }
        if (cmd.hwasan_memory_access_callback_prefix) |hwasan_memory_access_callback_prefix| {
            array.writeMany("--hwasan-memory-access-callback-prefix\x00");
            array.writeMany(hwasan_memory_access_callback_prefix);
            array.writeOne(0);
        }
        if (cmd.hwasan_record_stack_history) |hwasan_record_stack_history| {
            array.writeMany("--hwasan-record-stack-history\x00");
            array.writeMany(@tagName(hwasan_record_stack_history));
            array.writeOne(0);
        }
        if (cmd.hwasan_recover) {
            array.writeMany("--hwasan-recover\x00");
        }
        if (cmd.hwasan_uar_retag_to_zero) {
            array.writeMany("--hwasan-uar-retag-to-zero\x00");
        }
        if (cmd.hwasan_use_after_scope) {
            array.writeMany("--hwasan-use-after-scope\x00");
        }
        if (cmd.hwasan_use_short_granules) {
            array.writeMany("--hwasan-use-short-granules\x00");
        }
        if (cmd.hwasan_use_stack_safety) {
            array.writeMany("--hwasan-use-stack-safety\x00");
        }
        if (cmd.hwasan_with_ifunc) {
            array.writeMany("--hwasan-with-ifunc\x00");
        }
        if (cmd.hwasan_with_tls) {
            array.writeMany("--hwasan-with-tls\x00");
        }
        if (cmd.hwloop_spec_preheader) {
            array.writeMany("--hwloop-spec-preheader\x00");
        }
        if (cmd.icp_call_only) {
            array.writeMany("--icp-call-only\x00");
        }
        if (cmd.icp_csskip) |icp_csskip| {
            array.writeMany("--icp-csskip\x00");
            array.writeFormat(fmt.ud64(icp_csskip));
            array.writeOne(0);
        }
        if (cmd.icp_cutoff) |icp_cutoff| {
            array.writeMany("--icp-cutoff\x00");
            array.writeFormat(fmt.ud64(icp_cutoff));
            array.writeOne(0);
        }
        if (cmd.icp_dumpafter) {
            array.writeMany("--icp-dumpafter\x00");
        }
        if (cmd.icp_invoke_only) {
            array.writeMany("--icp-invoke-only\x00");
        }
        if (cmd.icp_lto) {
            array.writeMany("--icp-lto\x00");
        }
        if (cmd.icp_max_annotations) |icp_max_annotations| {
            array.writeMany("--icp-max-annotations\x00");
            array.writeFormat(fmt.ud64(icp_max_annotations));
            array.writeOne(0);
        }
        if (cmd.icp_max_prom) |icp_max_prom| {
            array.writeMany("--icp-max-prom\x00");
            array.writeFormat(fmt.ud64(icp_max_prom));
            array.writeOne(0);
        }
        if (cmd.icp_remaining_percent_threshold) |icp_remaining_percent_threshold| {
            array.writeMany("--icp-remaining-percent-threshold\x00");
            array.writeFormat(fmt.ud64(icp_remaining_percent_threshold));
            array.writeOne(0);
        }
        if (cmd.icp_samplepgo) {
            array.writeMany("--icp-samplepgo\x00");
        }
        if (cmd.icp_total_percent_threshold) |icp_total_percent_threshold| {
            array.writeMany("--icp-total-percent-threshold\x00");
            array.writeFormat(fmt.ud64(icp_total_percent_threshold));
            array.writeOne(0);
        }
        if (cmd.ifcvt_branch_fold) {
            array.writeMany("--ifcvt-branch-fold\x00");
        }
        if (cmd.ifcvt_fn_start) |ifcvt_fn_start| {
            array.writeMany("--ifcvt-fn-start\x00");
            array.writeFormat(fmt.ud64(ifcvt_fn_start));
            array.writeOne(0);
        }
        if (cmd.ifcvt_fn_stop) |ifcvt_fn_stop| {
            array.writeMany("--ifcvt-fn-stop\x00");
            array.writeFormat(fmt.ud64(ifcvt_fn_stop));
            array.writeOne(0);
        }
        if (cmd.ifcvt_limit) |ifcvt_limit| {
            array.writeMany("--ifcvt-limit\x00");
            array.writeFormat(fmt.ud64(ifcvt_limit));
            array.writeOne(0);
        }
        if (cmd.ignore_bb_reg_pressure) {
            array.writeMany("--ignore-bb-reg-pressure\x00");
        }
        if (cmd.ignore_tti_inline_compatible) {
            array.writeMany("--ignore-tti-inline-compatible\x00");
        }
        if (cmd.ignore_xcoff_visibility) {
            array.writeMany("--ignore-xcoff-visibility\x00");
        }
        if (cmd.imp_null_check_page_size) |imp_null_check_page_size| {
            array.writeMany("--imp-null-check-page-size\x00");
            array.writeFormat(fmt.ud64(imp_null_check_page_size));
            array.writeOne(0);
        }
        if (cmd.imp_null_max_insts_to_consider) |imp_null_max_insts_to_consider| {
            array.writeMany("--imp-null-max-insts-to-consider\x00");
            array.writeFormat(fmt.ud64(imp_null_max_insts_to_consider));
            array.writeOne(0);
        }
        if (cmd.import_all_index) {
            array.writeMany("--import-all-index\x00");
        }
        if (cmd.import_cold_multiplier) |import_cold_multiplier| {
            array.writeMany("--import-cold-multiplier\x00");
            array.writeFormat(fmt.ud64(import_cold_multiplier));
            array.writeOne(0);
        }
        if (cmd.import_constants_with_refs) {
            array.writeMany("--import-constants-with-refs\x00");
        }
        if (cmd.import_critical_multiplier) |import_critical_multiplier| {
            array.writeMany("--import-critical-multiplier\x00");
            array.writeFormat(fmt.ud64(import_critical_multiplier));
            array.writeOne(0);
        }
        if (cmd.import_cutoff) |import_cutoff| {
            array.writeMany("--import-cutoff\x00");
            array.writeFormat(fmt.ud64(import_cutoff));
            array.writeOne(0);
        }
        if (cmd.import_full_type_definitions) {
            array.writeMany("--import-full-type-definitions\x00");
        }
        if (cmd.import_hot_evolution_factor) |import_hot_evolution_factor| {
            array.writeMany("--import-hot-evolution-factor\x00");
            array.writeFormat(fmt.ud64(import_hot_evolution_factor));
            array.writeOne(0);
        }
        if (cmd.import_hot_multiplier) |import_hot_multiplier| {
            array.writeMany("--import-hot-multiplier\x00");
            array.writeFormat(fmt.ud64(import_hot_multiplier));
            array.writeOne(0);
        }
        if (cmd.import_instr_evolution_factor) |import_instr_evolution_factor| {
            array.writeMany("--import-instr-evolution-factor\x00");
            array.writeFormat(fmt.ud64(import_instr_evolution_factor));
            array.writeOne(0);
        }
        if (cmd.import_instr_limit) |import_instr_limit| {
            array.writeMany("--import-instr-limit\x00");
            array.writeFormat(fmt.ud64(import_instr_limit));
            array.writeOne(0);
        }
        if (cmd.incremental_linker_compatible) {
            array.writeMany("--incremental-linker-compatible\x00");
        }
        if (cmd.indvars_post_increment_ranges) {
            array.writeMany("--indvars-post-increment-ranges\x00");
        }
        if (cmd.indvars_predicate_loops) {
            array.writeMany("--indvars-predicate-loops\x00");
        }
        if (cmd.indvars_widen_indvars) {
            array.writeMany("--indvars-widen-indvars\x00");
        }
        if (cmd.info_output_file) |info_output_file| {
            array.writeMany("--info-output-file\x00");
            array.writeMany(info_output_file);
            array.writeOne(0);
        }
        if (cmd.initial_synthetic_count) |initial_synthetic_count| {
            array.writeMany("--initial-synthetic-count\x00");
            array.writeFormat(fmt.ud64(initial_synthetic_count));
            array.writeOne(0);
        }
        if (cmd.inline_call_penalty) |inline_call_penalty| {
            array.writeMany("--inline-call-penalty\x00");
            array.writeFormat(fmt.ud64(inline_call_penalty));
            array.writeOne(0);
        }
        if (cmd.inline_caller_superset_nobuiltin) {
            array.writeMany("--inline-caller-superset-nobuiltin\x00");
        }
        if (cmd.inline_cold_callsite_threshold) |inline_cold_callsite_threshold| {
            array.writeMany("--inline-cold-callsite-threshold\x00");
            array.writeFormat(fmt.ud64(inline_cold_callsite_threshold));
            array.writeOne(0);
        }
        if (cmd.inline_cost_full) {
            array.writeMany("--inline-cost-full\x00");
        }
        if (cmd.inline_deferral) {
            array.writeMany("--inline-deferral\x00");
        }
        if (cmd.inline_deferral_scale) |inline_deferral_scale| {
            array.writeMany("--inline-deferral-scale\x00");
            array.writeFormat(fmt.ud64(inline_deferral_scale));
            array.writeOne(0);
        }
        if (cmd.inline_enable_cost_benefit_analysis) {
            array.writeMany("--inline-enable-cost-benefit-analysis\x00");
        }
        if (cmd.inline_instr_cost) |inline_instr_cost| {
            array.writeMany("--inline-instr-cost\x00");
            array.writeFormat(fmt.ud64(inline_instr_cost));
            array.writeOne(0);
        }
        if (cmd.inline_max_stacksize) |inline_max_stacksize| {
            array.writeMany("--inline-max-stacksize\x00");
            array.writeFormat(fmt.ud64(inline_max_stacksize));
            array.writeOne(0);
        }
        if (cmd.inline_memaccess_cost) |inline_memaccess_cost| {
            array.writeMany("--inline-memaccess-cost\x00");
            array.writeFormat(fmt.ud64(inline_memaccess_cost));
            array.writeOne(0);
        }
        if (cmd.inline_priority_mode) |inline_priority_mode| {
            array.writeMany("--inline-priority-mode\x00");
            array.writeMany(@tagName(inline_priority_mode));
            array.writeOne(0);
        }
        if (cmd.inline_remark_attribute) {
            array.writeMany("--inline-remark-attribute\x00");
        }
        if (cmd.inline_savings_multiplier) |inline_savings_multiplier| {
            array.writeMany("--inline-savings-multiplier\x00");
            array.writeFormat(fmt.ud64(inline_savings_multiplier));
            array.writeOne(0);
        }
        if (cmd.inline_size_allowance) |inline_size_allowance| {
            array.writeMany("--inline-size-allowance\x00");
            array.writeFormat(fmt.ud64(inline_size_allowance));
            array.writeOne(0);
        }
        if (cmd.inline_synthetic_count) |inline_synthetic_count| {
            array.writeMany("--inline-synthetic-count\x00");
            array.writeFormat(fmt.ud64(inline_synthetic_count));
            array.writeOne(0);
        }
        if (cmd.inline_threshold) |inline_threshold| {
            array.writeMany("--inline-threshold\x00");
            array.writeFormat(fmt.ud64(inline_threshold));
            array.writeOne(0);
        }
        if (cmd.inlinecold_threshold) |inlinecold_threshold| {
            array.writeMany("--inlinecold-threshold\x00");
            array.writeFormat(fmt.ud64(inlinecold_threshold));
            array.writeOne(0);
        }
        if (cmd.inlinedefault_threshold) |inlinedefault_threshold| {
            array.writeMany("--inlinedefault-threshold\x00");
            array.writeFormat(fmt.ud64(inlinedefault_threshold));
            array.writeOne(0);
        }
        if (cmd.inlinehint_threshold) |inlinehint_threshold| {
            array.writeMany("--inlinehint-threshold\x00");
            array.writeFormat(fmt.ud64(inlinehint_threshold));
            array.writeOne(0);
        }
        if (cmd.inliner_function_import_stats) |inliner_function_import_stats| {
            array.writeMany("--inliner-function-import-stats\x00");
            array.writeMany(@tagName(inliner_function_import_stats));
            array.writeOne(0);
        }
        if (cmd.insert_all0) {
            array.writeMany("--insert-all0\x00");
        }
        if (cmd.insert_const) {
            array.writeMany("--insert-const\x00");
        }
        if (cmd.insert_dist_cutoff) |insert_dist_cutoff| {
            array.writeMany("--insert-dist-cutoff\x00");
            array.writeFormat(fmt.ud64(insert_dist_cutoff));
            array.writeOne(0);
        }
        if (cmd.insert_has0) {
            array.writeMany("--insert-has0\x00");
        }
        if (cmd.insert_max_ifmap) |insert_max_ifmap| {
            array.writeMany("--insert-max-ifmap\x00");
            array.writeFormat(fmt.ud64(insert_max_ifmap));
            array.writeOne(0);
        }
        if (cmd.insert_max_orl) |insert_max_orl| {
            array.writeMany("--insert-max-orl\x00");
            array.writeFormat(fmt.ud64(insert_max_orl));
            array.writeOne(0);
        }
        if (cmd.insert_timing) {
            array.writeMany("--insert-timing\x00");
        }
        if (cmd.insert_timing_detail) {
            array.writeMany("--insert-timing-detail\x00");
        }
        if (cmd.insert_vreg_cutoff) |insert_vreg_cutoff| {
            array.writeMany("--insert-vreg-cutoff\x00");
            array.writeFormat(fmt.ud64(insert_vreg_cutoff));
            array.writeOne(0);
        }
        if (cmd.instcombine_code_sinking) {
            array.writeMany("--instcombine-code-sinking\x00");
        }
        if (cmd.instcombine_guard_widening_window) |instcombine_guard_widening_window| {
            array.writeMany("--instcombine-guard-widening-window\x00");
            array.writeFormat(fmt.ud64(instcombine_guard_widening_window));
            array.writeOne(0);
        }
        if (cmd.instcombine_infinite_loop_threshold) |instcombine_infinite_loop_threshold| {
            array.writeMany("--instcombine-infinite-loop-threshold\x00");
            array.writeFormat(fmt.ud64(instcombine_infinite_loop_threshold));
            array.writeOne(0);
        }
        if (cmd.instcombine_lower_dbg_declare) |instcombine_lower_dbg_declare| {
            array.writeMany("--instcombine-lower-dbg-declare\x00");
            array.writeFormat(fmt.ud64(instcombine_lower_dbg_declare));
            array.writeOne(0);
        }
        if (cmd.instcombine_max_copied_from_constant_users) |instcombine_max_copied_from_constant_users| {
            array.writeMany("--instcombine-max-copied-from-constant-users\x00");
            array.writeFormat(fmt.ud64(instcombine_max_copied_from_constant_users));
            array.writeOne(0);
        }
        if (cmd.instcombine_max_iterations) |instcombine_max_iterations| {
            array.writeMany("--instcombine-max-iterations\x00");
            array.writeFormat(fmt.ud64(instcombine_max_iterations));
            array.writeOne(0);
        }
        if (cmd.instcombine_max_num_phis) |instcombine_max_num_phis| {
            array.writeMany("--instcombine-max-num-phis\x00");
            array.writeFormat(fmt.ud64(instcombine_max_num_phis));
            array.writeOne(0);
        }
        if (cmd.instcombine_max_sink_users) |instcombine_max_sink_users| {
            array.writeMany("--instcombine-max-sink-users\x00");
            array.writeFormat(fmt.ud64(instcombine_max_sink_users));
            array.writeOne(0);
        }
        if (cmd.instcombine_maxarray_size) |instcombine_maxarray_size| {
            array.writeMany("--instcombine-maxarray-size\x00");
            array.writeFormat(fmt.ud64(instcombine_maxarray_size));
            array.writeOne(0);
        }
        if (cmd.instcombine_negator_enabled) {
            array.writeMany("--instcombine-negator-enabled\x00");
        }
        if (cmd.instcombine_negator_max_depth) |instcombine_negator_max_depth| {
            array.writeMany("--instcombine-negator-max-depth\x00");
            array.writeFormat(fmt.ud64(instcombine_negator_max_depth));
            array.writeOne(0);
        }
        if (cmd.instrprof_atomic_counter_update_all) {
            array.writeMany("--instrprof-atomic-counter-update-all\x00");
        }
        if (cmd.interleave_loops) {
            array.writeMany("--interleave-loops\x00");
        }
        if (cmd.interleave_small_loop_scalar_reduction) {
            array.writeMany("--interleave-small-loop-scalar-reduction\x00");
        }
        if (cmd.internalize_public_api_file) |internalize_public_api_file| {
            array.writeMany("--internalize-public-api-file\x00");
            array.writeMany(internalize_public_api_file);
            array.writeOne(0);
        }
        if (cmd.internalize_public_api_list) {
            array.writeMany("--internalize-public-api-list\x00");
        }
        if (cmd.interpreter_print_volatile) {
            array.writeMany("--interpreter-print-volatile\x00");
        }
        if (cmd.intra_scc_cost_multiplier) |intra_scc_cost_multiplier| {
            array.writeMany("--intra-scc-cost-multiplier\x00");
            array.writeFormat(fmt.ud64(intra_scc_cost_multiplier));
            array.writeOne(0);
        }
        if (cmd.ir_outliner) {
            array.writeMany("--ir-outliner\x00");
        }
        if (cmd.irce_allow_narrow_latch) {
            array.writeMany("--irce-allow-narrow-latch\x00");
        }
        if (cmd.irce_allow_unsigned_latch) {
            array.writeMany("--irce-allow-unsigned-latch\x00");
        }
        if (cmd.irce_loop_size_cutoff) |irce_loop_size_cutoff| {
            array.writeMany("--irce-loop-size-cutoff\x00");
            array.writeFormat(fmt.ud64(irce_loop_size_cutoff));
            array.writeOne(0);
        }
        if (cmd.irce_min_runtime_iterations) |irce_min_runtime_iterations| {
            array.writeMany("--irce-min-runtime-iterations\x00");
            array.writeFormat(fmt.ud64(irce_min_runtime_iterations));
            array.writeOne(0);
        }
        if (cmd.irce_print_changed_loops) {
            array.writeMany("--irce-print-changed-loops\x00");
        }
        if (cmd.irce_print_range_checks) {
            array.writeMany("--irce-print-range-checks\x00");
        }
        if (cmd.irce_skip_profitability_checks) {
            array.writeMany("--irce-skip-profitability-checks\x00");
        }
        if (cmd.isel_rebalance_addr) {
            array.writeMany("--isel-rebalance-addr\x00");
        }
        if (cmd.iterative_bfi_max_iterations_per_block) |iterative_bfi_max_iterations_per_block| {
            array.writeMany("--iterative-bfi-max-iterations-per-block\x00");
            array.writeFormat(fmt.ud64(iterative_bfi_max_iterations_per_block));
            array.writeOne(0);
        }
        if (cmd.iterative_bfi_precision) |iterative_bfi_precision| {
            array.writeMany("--iterative-bfi-precision\x00");
            array.writeFormat(fmt.ud64(iterative_bfi_precision));
            array.writeOne(0);
        }
        if (cmd.iterative_counter_promotion) {
            array.writeMany("--iterative-counter-promotion\x00");
        }
        if (cmd.join_globalcopies) {
            array.writeMany("--join-globalcopies\x00");
        }
        if (cmd.join_liveintervals) {
            array.writeMany("--join-liveintervals\x00");
        }
        if (cmd.join_splitedges) {
            array.writeMany("--join-splitedges\x00");
        }
        if (cmd.jump_inst_cost) |jump_inst_cost| {
            array.writeMany("--jump-inst-cost\x00");
            array.writeFormat(fmt.ud64(jump_inst_cost));
            array.writeOne(0);
        }
        if (cmd.jump_is_expensive) {
            array.writeMany("--jump-is-expensive\x00");
        }
        if (cmd.jump_table_density) |jump_table_density| {
            array.writeMany("--jump-table-density\x00");
            array.writeFormat(fmt.ud64(jump_table_density));
            array.writeOne(0);
        }
        if (cmd.jump_threading_across_loop_headers) {
            array.writeMany("--jump-threading-across-loop-headers\x00");
        }
        if (cmd.jump_threading_implication_search_threshold) |jump_threading_implication_search_threshold| {
            array.writeMany("--jump-threading-implication-search-threshold\x00");
            array.writeFormat(fmt.ud64(jump_threading_implication_search_threshold));
            array.writeOne(0);
        }
        if (cmd.jump_threading_phi_threshold) |jump_threading_phi_threshold| {
            array.writeMany("--jump-threading-phi-threshold\x00");
            array.writeFormat(fmt.ud64(jump_threading_phi_threshold));
            array.writeOne(0);
        }
        if (cmd.jump_threading_threshold) |jump_threading_threshold| {
            array.writeMany("--jump-threading-threshold\x00");
            array.writeFormat(fmt.ud64(jump_threading_threshold));
            array.writeOne(0);
        }
        if (cmd.keep_inline_advisor_for_printing) {
            array.writeMany("--keep-inline-advisor-for-printing\x00");
        }
        if (cmd.keep_loops) {
            array.writeMany("--keep-loops\x00");
        }
        if (cmd.lanai_constant_mul_threshold) |lanai_constant_mul_threshold| {
            array.writeMany("--lanai-constant-mul-threshold\x00");
            array.writeFormat(fmt.ud64(lanai_constant_mul_threshold));
            array.writeOne(0);
        }
        if (cmd.lanai_nop_delay_filler) {
            array.writeMany("--lanai-nop-delay-filler\x00");
        }
        if (cmd.lanai_ssection_threshold) |lanai_ssection_threshold| {
            array.writeMany("--lanai-ssection-threshold\x00");
            array.writeFormat(fmt.ud64(lanai_ssection_threshold));
            array.writeOne(0);
        }
        if (cmd.large_interval_freq_threshold) |large_interval_freq_threshold| {
            array.writeMany("--large-interval-freq-threshold\x00");
            array.writeFormat(fmt.ud64(large_interval_freq_threshold));
            array.writeOne(0);
        }
        if (cmd.large_interval_size_threshold) |large_interval_size_threshold| {
            array.writeMany("--large-interval-size-threshold\x00");
            array.writeFormat(fmt.ud64(large_interval_size_threshold));
            array.writeOne(0);
        }
        if (cmd.late_remat_update_threshold) |late_remat_update_threshold| {
            array.writeMany("--late-remat-update-threshold\x00");
            array.writeFormat(fmt.ud64(late_remat_update_threshold));
            array.writeOne(0);
        }
        if (cmd.lcr_max_depth) |lcr_max_depth| {
            array.writeMany("--lcr-max-depth\x00");
            array.writeFormat(fmt.ud64(lcr_max_depth));
            array.writeOne(0);
        }
        if (cmd.lcr_max_interf) |lcr_max_interf| {
            array.writeMany("--lcr-max-interf\x00");
            array.writeFormat(fmt.ud64(lcr_max_interf));
            array.writeOne(0);
        }
        if (cmd.ldstmemcpy_glue_max) |ldstmemcpy_glue_max| {
            array.writeMany("--ldstmemcpy-glue-max\x00");
            array.writeFormat(fmt.ud64(ldstmemcpy_glue_max));
            array.writeOne(0);
        }
        if (cmd.licm_control_flow_hoisting) {
            array.writeMany("--licm-control-flow-hoisting\x00");
        }
        if (cmd.licm_force_thread_model_single) {
            array.writeMany("--licm-force-thread-model-single\x00");
        }
        if (cmd.licm_max_num_uses_traversed) |licm_max_num_uses_traversed| {
            array.writeMany("--licm-max-num-uses-traversed\x00");
            array.writeFormat(fmt.ud64(licm_max_num_uses_traversed));
            array.writeOne(0);
        }
        if (cmd.licm_mssa_max_acc_promotion) |licm_mssa_max_acc_promotion| {
            array.writeMany("--licm-mssa-max-acc-promotion\x00");
            array.writeFormat(fmt.ud64(licm_mssa_max_acc_promotion));
            array.writeOne(0);
        }
        if (cmd.licm_mssa_optimization_cap) |licm_mssa_optimization_cap| {
            array.writeMany("--licm-mssa-optimization-cap\x00");
            array.writeFormat(fmt.ud64(licm_mssa_optimization_cap));
            array.writeOne(0);
        }
        if (cmd.licm_versioning_invariant_threshold) |licm_versioning_invariant_threshold| {
            array.writeMany("--licm-versioning-invariant-threshold\x00");
            array.writeFormat(fmt.ud64(licm_versioning_invariant_threshold));
            array.writeOne(0);
        }
        if (cmd.licm_versioning_max_depth_threshold) |licm_versioning_max_depth_threshold| {
            array.writeMany("--licm-versioning-max-depth-threshold\x00");
            array.writeFormat(fmt.ud64(licm_versioning_max_depth_threshold));
            array.writeOne(0);
        }
        if (cmd.likely_branch_weight) |likely_branch_weight| {
            array.writeMany("--likely-branch-weight\x00");
            array.writeFormat(fmt.ud64(likely_branch_weight));
            array.writeOne(0);
        }
        if (cmd.limit_float_precision) |limit_float_precision| {
            array.writeMany("--limit-float-precision\x00");
            array.writeFormat(fmt.ud64(limit_float_precision));
            array.writeOne(0);
        }
        if (cmd.live_debug_variables) {
            array.writeMany("--live-debug-variables\x00");
        }
        if (cmd.livedebugvalues_input_bb_limit) |livedebugvalues_input_bb_limit| {
            array.writeMany("--livedebugvalues-input-bb-limit\x00");
            array.writeFormat(fmt.ud64(livedebugvalues_input_bb_limit));
            array.writeOne(0);
        }
        if (cmd.livedebugvalues_input_dbg_value_limit) |livedebugvalues_input_dbg_value_limit| {
            array.writeMany("--livedebugvalues-input-dbg-value-limit\x00");
            array.writeFormat(fmt.ud64(livedebugvalues_input_dbg_value_limit));
            array.writeOne(0);
        }
        if (cmd.livedebugvalues_max_stack_slots) |livedebugvalues_max_stack_slots| {
            array.writeMany("--livedebugvalues-max-stack-slots\x00");
            array.writeFormat(fmt.ud64(livedebugvalues_max_stack_slots));
            array.writeOne(0);
        }
        if (cmd.load) |load| {
            array.writeMany("--load\x00");
            array.writeMany(load);
            array.writeOne(0);
        }
        if (cmd.locally_hot_callsite_threshold) |locally_hot_callsite_threshold| {
            array.writeMany("--locally-hot-callsite-threshold\x00");
            array.writeFormat(fmt.ud64(locally_hot_callsite_threshold));
            array.writeOne(0);
        }
        if (cmd.loongarch_check_zero_division) {
            array.writeMany("--loongarch-check-zero-division\x00");
        }
        if (cmd.loongarch_numeric_reg) {
            array.writeMany("--loongarch-numeric-reg\x00");
        }
        if (cmd.loop_deletion_enable_symbolic_execution) {
            array.writeMany("--loop-deletion-enable-symbolic-execution\x00");
        }
        if (cmd.loop_distribute_non_if_convertible) {
            array.writeMany("--loop-distribute-non-if-convertible\x00");
        }
        if (cmd.loop_distribute_scev_check_threshold) |loop_distribute_scev_check_threshold| {
            array.writeMany("--loop-distribute-scev-check-threshold\x00");
            array.writeFormat(fmt.ud64(loop_distribute_scev_check_threshold));
            array.writeOne(0);
        }
        if (cmd.loop_distribute_scev_check_threshold_with_pragma) |loop_distribute_scev_check_threshold_with_pragma| {
            array.writeMany("--loop-distribute-scev-check-threshold-with-pragma\x00");
            array.writeFormat(fmt.ud64(loop_distribute_scev_check_threshold_with_pragma));
            array.writeOne(0);
        }
        if (cmd.loop_distribute_verify) {
            array.writeMany("--loop-distribute-verify\x00");
        }
        if (cmd.loop_flatten_assume_no_overflow) {
            array.writeMany("--loop-flatten-assume-no-overflow\x00");
        }
        if (cmd.loop_flatten_cost_threshold) |loop_flatten_cost_threshold| {
            array.writeMany("--loop-flatten-cost-threshold\x00");
            array.writeFormat(fmt.ud64(loop_flatten_cost_threshold));
            array.writeOne(0);
        }
        if (cmd.loop_flatten_widen_iv) {
            array.writeMany("--loop-flatten-widen-iv\x00");
        }
        if (cmd.loop_fusion_dependence_analysis) |loop_fusion_dependence_analysis| {
            array.writeMany("--loop-fusion-dependence-analysis\x00");
            array.writeMany(@tagName(loop_fusion_dependence_analysis));
            array.writeOne(0);
        }
        if (cmd.loop_fusion_peel_max_count) |loop_fusion_peel_max_count| {
            array.writeMany("--loop-fusion-peel-max-count\x00");
            array.writeFormat(fmt.ud64(loop_fusion_peel_max_count));
            array.writeOne(0);
        }
        if (cmd.loop_interchange_threshold) |loop_interchange_threshold| {
            array.writeMany("--loop-interchange-threshold\x00");
            array.writeFormat(fmt.ud64(loop_interchange_threshold));
            array.writeOne(0);
        }
        if (cmd.loop_load_elimination_scev_check_threshold) |loop_load_elimination_scev_check_threshold| {
            array.writeMany("--loop-load-elimination-scev-check-threshold\x00");
            array.writeFormat(fmt.ud64(loop_load_elimination_scev_check_threshold));
            array.writeOne(0);
        }
        if (cmd.loop_predication_enable_count_down_loop) {
            array.writeMany("--loop-predication-enable-count-down-loop\x00");
        }
        if (cmd.loop_predication_enable_iv_truncation) {
            array.writeMany("--loop-predication-enable-iv-truncation\x00");
        }
        if (cmd.loop_predication_insert_assumes_of_predicated_guards_conditions) {
            array.writeMany("--loop-predication-insert-assumes-of-predicated-guards-conditions\x00");
        }
        if (cmd.loop_predication_latch_probability_scale) |loop_predication_latch_probability_scale| {
            array.writeMany("--loop-predication-latch-probability-scale\x00");
            array.writeFormat(fmt.ud64(loop_predication_latch_probability_scale));
            array.writeOne(0);
        }
        if (cmd.loop_predication_predicate_widenable_branches_to_deopt) {
            array.writeMany("--loop-predication-predicate-widenable-branches-to-deopt\x00");
        }
        if (cmd.loop_predication_skip_profitability_checks) {
            array.writeMany("--loop-predication-skip-profitability-checks\x00");
        }
        if (cmd.loop_prefetch_writes) {
            array.writeMany("--loop-prefetch-writes\x00");
        }
        if (cmd.loop_rotate_multi) {
            array.writeMany("--loop-rotate-multi\x00");
        }
        if (cmd.loop_to_cold_block_ratio) |loop_to_cold_block_ratio| {
            array.writeMany("--loop-to-cold-block-ratio\x00");
            array.writeFormat(fmt.ud64(loop_to_cold_block_ratio));
            array.writeOne(0);
        }
        if (cmd.loop_vectorize_with_block_frequency) {
            array.writeMany("--loop-vectorize-with-block-frequency\x00");
        }
        if (cmd.loop_version_annotate_no_alias) {
            array.writeMany("--loop-version-annotate-no-alias\x00");
        }
        if (cmd.lower_global_dtors_via_cxa_atexit) {
            array.writeMany("--lower-global-dtors-via-cxa-atexit\x00");
        }
        if (cmd.lower_interleaved_accesses) {
            array.writeMany("--lower-interleaved-accesses\x00");
        }
        if (cmd.lowertypetests_avoid_reuse) {
            array.writeMany("--lowertypetests-avoid-reuse\x00");
        }
        if (cmd.lowertypetests_drop_type_tests) {
            array.writeMany("--lowertypetests-drop-type-tests\x00");
        }
        if (cmd.lowertypetests_read_summary) |lowertypetests_read_summary| {
            array.writeMany("--lowertypetests-read-summary\x00");
            array.writeMany(lowertypetests_read_summary);
            array.writeOne(0);
        }
        if (cmd.lowertypetests_summary_action) |lowertypetests_summary_action| {
            array.writeMany("--lowertypetests-summary-action\x00");
            array.writeMany(@tagName(lowertypetests_summary_action));
            array.writeOne(0);
        }
        if (cmd.lowertypetests_write_summary) |lowertypetests_write_summary| {
            array.writeMany("--lowertypetests-write-summary\x00");
            array.writeMany(lowertypetests_write_summary);
            array.writeOne(0);
        }
        if (cmd.lsr_complexity_limit) |lsr_complexity_limit| {
            array.writeMany("--lsr-complexity-limit\x00");
            array.writeFormat(fmt.ud64(lsr_complexity_limit));
            array.writeOne(0);
        }
        if (cmd.lsr_drop_solution) {
            array.writeMany("--lsr-drop-solution\x00");
        }
        if (cmd.lsr_exp_narrow) {
            array.writeMany("--lsr-exp-narrow\x00");
        }
        if (cmd.lsr_filter_same_scaled_reg) {
            array.writeMany("--lsr-filter-same-scaled-reg\x00");
        }
        if (cmd.lsr_insns_cost) {
            array.writeMany("--lsr-insns-cost\x00");
        }
        if (cmd.lsr_preferred_addressing_mode) |lsr_preferred_addressing_mode| {
            array.writeMany("--lsr-preferred-addressing-mode\x00");
            array.writeMany(@tagName(lsr_preferred_addressing_mode));
            array.writeOne(0);
        }
        if (cmd.lsr_setupcost_depth_limit) |lsr_setupcost_depth_limit| {
            array.writeMany("--lsr-setupcost-depth-limit\x00");
            array.writeFormat(fmt.ud64(lsr_setupcost_depth_limit));
            array.writeOne(0);
        }
        if (cmd.lsr_term_fold) {
            array.writeMany("--lsr-term-fold\x00");
        }
        if (cmd.lto_aix_system_assembler) |lto_aix_system_assembler| {
            array.writeMany("--lto-aix-system-assembler\x00");
            array.writeMany(lto_aix_system_assembler);
            array.writeOne(0);
        }
        if (cmd.lto_discard_value_names) {
            array.writeMany("--lto-discard-value-names\x00");
        }
        if (cmd.lto_embed_bitcode) |lto_embed_bitcode| {
            array.writeMany("--lto-embed-bitcode\x00");
            array.writeMany(@tagName(lto_embed_bitcode));
            array.writeOne(0);
        }
        if (cmd.lto_pass_remarks_filter) |lto_pass_remarks_filter| {
            array.writeMany("--lto-pass-remarks-filter\x00");
            array.writeMany(lto_pass_remarks_filter);
            array.writeOne(0);
        }
        if (cmd.lto_pass_remarks_format) |lto_pass_remarks_format| {
            array.writeMany("--lto-pass-remarks-format\x00");
            array.writeMany(lto_pass_remarks_format);
            array.writeOne(0);
        }
        if (cmd.lto_pass_remarks_hotness_threshold) {
            array.writeMany("--lto-pass-remarks-hotness-threshold\x00");
        }
        if (cmd.lto_pass_remarks_output) |lto_pass_remarks_output| {
            array.writeMany("--lto-pass-remarks-output\x00");
            array.writeMany(lto_pass_remarks_output);
            array.writeOne(0);
        }
        if (cmd.lto_pass_remarks_with_hotness) {
            array.writeMany("--lto-pass-remarks-with-hotness\x00");
        }
        if (cmd.lto_stats_file) |lto_stats_file| {
            array.writeMany("--lto-stats-file\x00");
            array.writeMany(lto_stats_file);
            array.writeOne(0);
        }
        if (cmd.machine_combiner_dump_subst_intrs) {
            array.writeMany("--machine-combiner-dump-subst-intrs\x00");
        }
        if (cmd.machine_combiner_inc_threshold) |machine_combiner_inc_threshold| {
            array.writeMany("--machine-combiner-inc-threshold\x00");
            array.writeFormat(fmt.ud64(machine_combiner_inc_threshold));
            array.writeOne(0);
        }
        if (cmd.machine_combiner_verify_pattern_order) {
            array.writeMany("--machine-combiner-verify-pattern-order\x00");
        }
        if (cmd.machine_outliner_reruns) |machine_outliner_reruns| {
            array.writeMany("--machine-outliner-reruns\x00");
            array.writeFormat(fmt.ud64(machine_outliner_reruns));
            array.writeOne(0);
        }
        if (cmd.machine_sink_bfi) {
            array.writeMany("--machine-sink-bfi\x00");
        }
        if (cmd.machine_sink_cycle_limit) |machine_sink_cycle_limit| {
            array.writeMany("--machine-sink-cycle-limit\x00");
            array.writeFormat(fmt.ud64(machine_sink_cycle_limit));
            array.writeOne(0);
        }
        if (cmd.machine_sink_load_blocks_threshold) |machine_sink_load_blocks_threshold| {
            array.writeMany("--machine-sink-load-blocks-threshold\x00");
            array.writeFormat(fmt.ud64(machine_sink_load_blocks_threshold));
            array.writeOne(0);
        }
        if (cmd.machine_sink_load_instrs_threshold) |machine_sink_load_instrs_threshold| {
            array.writeMany("--machine-sink-load-instrs-threshold\x00");
            array.writeFormat(fmt.ud64(machine_sink_load_instrs_threshold));
            array.writeOne(0);
        }
        if (cmd.machine_sink_split) {
            array.writeMany("--machine-sink-split\x00");
        }
        if (cmd.machine_sink_split_probability_threshold) |machine_sink_split_probability_threshold| {
            array.writeMany("--machine-sink-split-probability-threshold\x00");
            array.writeFormat(fmt.ud64(machine_sink_split_probability_threshold));
            array.writeOne(0);
        }
        if (cmd.mandatory_inlining_first) {
            array.writeMany("--mandatory-inlining-first\x00");
        }
        if (cmd.march) |march| {
            array.writeMany("--march\x00");
            array.writeMany(march);
            array.writeOne(0);
        }
        if (cmd.mark_data_regions) {
            array.writeMany("--mark-data-regions\x00");
        }
        if (cmd.matrix_allow_contract) {
            array.writeMany("--matrix-allow-contract\x00");
        }
        if (cmd.matrix_default_layout) |matrix_default_layout| {
            array.writeMany("--matrix-default-layout\x00");
            array.writeMany(@tagName(matrix_default_layout));
            array.writeOne(0);
        }
        if (cmd.matrix_print_after_transpose_opt) {
            array.writeMany("--matrix-print-after-transpose-opt\x00");
        }
        if (cmd.max_booleans_in_control_flow_hub) |max_booleans_in_control_flow_hub| {
            array.writeMany("--max-booleans-in-control-flow-hub\x00");
            array.writeFormat(fmt.ud64(max_booleans_in_control_flow_hub));
            array.writeOne(0);
        }
        if (cmd.max_bytes_for_alignment) |max_bytes_for_alignment| {
            array.writeMany("--max-bytes-for-alignment\x00");
            array.writeFormat(fmt.ud64(max_bytes_for_alignment));
            array.writeOne(0);
        }
        if (cmd.max_counter_promotions) |max_counter_promotions| {
            array.writeMany("--max-counter-promotions\x00");
            array.writeFormat(fmt.ud64(max_counter_promotions));
            array.writeOne(0);
        }
        if (cmd.max_counter_promotions_per_loop) |max_counter_promotions_per_loop| {
            array.writeMany("--max-counter-promotions-per-loop\x00");
            array.writeFormat(fmt.ud64(max_counter_promotions_per_loop));
            array.writeOne(0);
        }
        if (cmd.max_deopt_or_unreachable_succ_check_depth) |max_deopt_or_unreachable_succ_check_depth| {
            array.writeMany("--max-deopt-or-unreachable-succ-check-depth\x00");
            array.writeFormat(fmt.ud64(max_deopt_or_unreachable_succ_check_depth));
            array.writeOne(0);
        }
        if (cmd.max_dependences) |max_dependences| {
            array.writeMany("--max-dependences\x00");
            array.writeFormat(fmt.ud64(max_dependences));
            array.writeOne(0);
        }
        if (cmd.max_forked_scev_depth) |max_forked_scev_depth| {
            array.writeMany("--max-forked-scev-depth\x00");
            array.writeFormat(fmt.ud64(max_forked_scev_depth));
            array.writeOne(0);
        }
        if (cmd.max_heap_to_stack_size) |max_heap_to_stack_size| {
            array.writeMany("--max-heap-to-stack-size\x00");
            array.writeFormat(fmt.ud64(max_heap_to_stack_size));
            array.writeOne(0);
        }
        if (cmd.max_hsdr) |max_hsdr| {
            array.writeMany("--max-hsdr\x00");
            array.writeFormat(fmt.ud64(max_hsdr));
            array.writeOne(0);
        }
        if (cmd.max_inst_checked_for_throw_during_inlining) |max_inst_checked_for_throw_during_inlining| {
            array.writeMany("--max-inst-checked-for-throw-during-inlining\x00");
            array.writeFormat(fmt.ud64(max_inst_checked_for_throw_during_inlining));
            array.writeOne(0);
        }
        if (cmd.max_interleave_group_factor) |max_interleave_group_factor| {
            array.writeMany("--max-interleave-group-factor\x00");
            array.writeFormat(fmt.ud64(max_interleave_group_factor));
            array.writeOne(0);
        }
        if (cmd.max_jump_table_size) |max_jump_table_size| {
            array.writeMany("--max-jump-table-size\x00");
            array.writeFormat(fmt.ud64(max_jump_table_size));
            array.writeOne(0);
        }
        if (cmd.max_loads_per_memcmp) |max_loads_per_memcmp| {
            array.writeMany("--max-loads-per-memcmp\x00");
            array.writeFormat(fmt.ud64(max_loads_per_memcmp));
            array.writeOne(0);
        }
        if (cmd.max_loads_per_memcmp_opt_size) |max_loads_per_memcmp_opt_size| {
            array.writeMany("--max-loads-per-memcmp-opt-size\x00");
            array.writeFormat(fmt.ud64(max_loads_per_memcmp_opt_size));
            array.writeOne(0);
        }
        if (cmd.max_nested_scalar_reduction_interleave) |max_nested_scalar_reduction_interleave| {
            array.writeMany("--max-nested-scalar-reduction-interleave\x00");
            array.writeFormat(fmt.ud64(max_nested_scalar_reduction_interleave));
            array.writeOne(0);
        }
        if (cmd.max_num_inline_blocks) |max_num_inline_blocks| {
            array.writeMany("--max-num-inline-blocks\x00");
            array.writeFormat(fmt.ud64(max_num_inline_blocks));
            array.writeOne(0);
        }
        if (cmd.max_num_inst_between_tfr_and_nv_store) |max_num_inst_between_tfr_and_nv_store| {
            array.writeMany("--max-num-inst-between-tfr-and-nv-store\x00");
            array.writeFormat(fmt.ud64(max_num_inst_between_tfr_and_nv_store));
            array.writeOne(0);
        }
        if (cmd.max_partial_inlining) |max_partial_inlining| {
            array.writeMany("--max-partial-inlining\x00");
            array.writeFormat(fmt.ud64(max_partial_inlining));
            array.writeOne(0);
        }
        if (cmd.max_prefetch_iters_ahead) |max_prefetch_iters_ahead| {
            array.writeMany("--max-prefetch-iters-ahead\x00");
            array.writeFormat(fmt.ud64(max_prefetch_iters_ahead));
            array.writeOne(0);
        }
        if (cmd.max_registers_for_gc_values) |max_registers_for_gc_values| {
            array.writeMany("--max-registers-for-gc-values\x00");
            array.writeFormat(fmt.ud64(max_registers_for_gc_values));
            array.writeOne(0);
        }
        if (cmd.max_sched_reorder) |max_sched_reorder| {
            array.writeMany("--max-sched-reorder\x00");
            array.writeFormat(fmt.ud64(max_sched_reorder));
            array.writeOne(0);
        }
        if (cmd.max_speculation_depth) |max_speculation_depth| {
            array.writeMany("--max-speculation-depth\x00");
            array.writeFormat(fmt.ud64(max_speculation_depth));
            array.writeOne(0);
        }
        if (cmd.max_store_memcpy) |max_store_memcpy| {
            array.writeMany("--max-store-memcpy\x00");
            array.writeFormat(fmt.ud64(max_store_memcpy));
            array.writeOne(0);
        }
        if (cmd.max_store_memcpy_Os) |max_store_memcpy_Os| {
            array.writeMany("--max-store-memcpy-Os\x00");
            array.writeFormat(fmt.ud64(max_store_memcpy_Os));
            array.writeOne(0);
        }
        if (cmd.max_store_memmove) |max_store_memmove| {
            array.writeMany("--max-store-memmove\x00");
            array.writeFormat(fmt.ud64(max_store_memmove));
            array.writeOne(0);
        }
        if (cmd.max_store_memmove_Os) |max_store_memmove_Os| {
            array.writeMany("--max-store-memmove-Os\x00");
            array.writeFormat(fmt.ud64(max_store_memmove_Os));
            array.writeOne(0);
        }
        if (cmd.max_store_memset) |max_store_memset| {
            array.writeMany("--max-store-memset\x00");
            array.writeFormat(fmt.ud64(max_store_memset));
            array.writeOne(0);
        }
        if (cmd.max_store_memset_Os) |max_store_memset_Os| {
            array.writeMany("--max-store-memset-Os\x00");
            array.writeFormat(fmt.ud64(max_store_memset_Os));
            array.writeOne(0);
        }
        if (cmd.max_switch_cases_per_result) |max_switch_cases_per_result| {
            array.writeMany("--max-switch-cases-per-result\x00");
            array.writeFormat(fmt.ud64(max_switch_cases_per_result));
            array.writeOne(0);
        }
        if (cmd.max_uses_for_sinking) |max_uses_for_sinking| {
            array.writeMany("--max-uses-for-sinking\x00");
            array.writeFormat(fmt.ud64(max_uses_for_sinking));
            array.writeOne(0);
        }
        if (cmd.mc_relax_all) {
            array.writeMany("--mc-relax-all\x00");
        }
        if (cmd.mcabac) {
            array.writeMany("--mcabac\x00");
        }
        if (cmd.mcfg_dot_filename_prefix) |mcfg_dot_filename_prefix| {
            array.writeMany("--mcfg-dot-filename-prefix\x00");
            array.writeMany(mcfg_dot_filename_prefix);
            array.writeOne(0);
        }
        if (cmd.mcfg_func_name) |mcfg_func_name| {
            array.writeMany("--mcfg-func-name\x00");
            array.writeMany(mcfg_func_name);
            array.writeOne(0);
        }
        if (cmd.mcp_use_is_copy_instr) {
            array.writeMany("--mcp-use-is-copy-instr\x00");
        }
        if (cmd.mcpu) |mcpu| {
            array.writeMany("--mcpu\x00");
            array.writeMany(mcpu);
            array.writeOne(0);
        }
        if (cmd.meabi) |meabi| {
            array.writeMany("--meabi\x00");
            array.writeMany(@tagName(meabi));
            array.writeOne(0);
        }
        if (cmd.mem_loc_frag_fill) {
            array.writeMany("--mem-loc-frag-fill\x00");
        }
        if (cmd.membedded_data) {
            array.writeMany("--membedded-data\x00");
        }
        if (cmd.memcmp_num_loads_per_block) |memcmp_num_loads_per_block| {
            array.writeMany("--memcmp-num-loads-per-block\x00");
            array.writeFormat(fmt.ud64(memcmp_num_loads_per_block));
            array.writeOne(0);
        }
        if (cmd.memdep_block_number_limit) |memdep_block_number_limit| {
            array.writeMany("--memdep-block-number-limit\x00");
            array.writeFormat(fmt.ud64(memdep_block_number_limit));
            array.writeOne(0);
        }
        if (cmd.memdep_block_scan_limit) |memdep_block_scan_limit| {
            array.writeMany("--memdep-block-scan-limit\x00");
            array.writeFormat(fmt.ud64(memdep_block_scan_limit));
            array.writeOne(0);
        }
        if (cmd.memop_max_annotations) |memop_max_annotations| {
            array.writeMany("--memop-max-annotations\x00");
            array.writeFormat(fmt.ud64(memop_max_annotations));
            array.writeOne(0);
        }
        if (cmd.memop_value_prof_max_opt_size) |memop_value_prof_max_opt_size| {
            array.writeMany("--memop-value-prof-max-opt-size\x00");
            array.writeFormat(fmt.ud64(memop_value_prof_max_opt_size));
            array.writeOne(0);
        }
        if (cmd.memory_check_merge_threshold) |memory_check_merge_threshold| {
            array.writeMany("--memory-check-merge-threshold\x00");
            array.writeFormat(fmt.ud64(memory_check_merge_threshold));
            array.writeOne(0);
        }
        if (cmd.memprof_accesses_per_byte_cold_threshold) |memprof_accesses_per_byte_cold_threshold| {
            array.writeMany("--memprof-accesses-per-byte-cold-threshold\x00");
            array.writeFormat(fmt.ud64(memprof_accesses_per_byte_cold_threshold));
            array.writeOne(0);
        }
        if (cmd.memprof_debug) |memprof_debug| {
            array.writeMany("--memprof-debug\x00");
            array.writeFormat(fmt.ud64(memprof_debug));
            array.writeOne(0);
        }
        if (cmd.memprof_debug_func) |memprof_debug_func| {
            array.writeMany("--memprof-debug-func\x00");
            array.writeMany(memprof_debug_func);
            array.writeOne(0);
        }
        if (cmd.memprof_debug_max) |memprof_debug_max| {
            array.writeMany("--memprof-debug-max\x00");
            array.writeFormat(fmt.ud64(memprof_debug_max));
            array.writeOne(0);
        }
        if (cmd.memprof_debug_min) |memprof_debug_min| {
            array.writeMany("--memprof-debug-min\x00");
            array.writeFormat(fmt.ud64(memprof_debug_min));
            array.writeOne(0);
        }
        if (cmd.memprof_guard_against_version_mismatch) {
            array.writeMany("--memprof-guard-against-version-mismatch\x00");
        }
        if (cmd.memprof_instrument_atomics) {
            array.writeMany("--memprof-instrument-atomics\x00");
        }
        if (cmd.memprof_instrument_reads) {
            array.writeMany("--memprof-instrument-reads\x00");
        }
        if (cmd.memprof_instrument_stack) {
            array.writeMany("--memprof-instrument-stack\x00");
        }
        if (cmd.memprof_instrument_writes) {
            array.writeMany("--memprof-instrument-writes\x00");
        }
        if (cmd.memprof_mapping_granularity) |memprof_mapping_granularity| {
            array.writeMany("--memprof-mapping-granularity\x00");
            array.writeFormat(fmt.ud64(memprof_mapping_granularity));
            array.writeOne(0);
        }
        if (cmd.memprof_mapping_scale) |memprof_mapping_scale| {
            array.writeMany("--memprof-mapping-scale\x00");
            array.writeFormat(fmt.ud64(memprof_mapping_scale));
            array.writeOne(0);
        }
        if (cmd.memprof_memory_access_callback_prefix) |memprof_memory_access_callback_prefix| {
            array.writeMany("--memprof-memory-access-callback-prefix\x00");
            array.writeMany(memprof_memory_access_callback_prefix);
            array.writeOne(0);
        }
        if (cmd.memprof_min_lifetime_cold_threshold) |memprof_min_lifetime_cold_threshold| {
            array.writeMany("--memprof-min-lifetime-cold-threshold\x00");
            array.writeFormat(fmt.ud64(memprof_min_lifetime_cold_threshold));
            array.writeOne(0);
        }
        if (cmd.memprof_use_callbacks) {
            array.writeMany("--memprof-use-callbacks\x00");
        }
        if (cmd.memssa_check_limit) |memssa_check_limit| {
            array.writeMany("--memssa-check-limit\x00");
            array.writeFormat(fmt.ud64(memssa_check_limit));
            array.writeOne(0);
        }
        if (cmd.mergefunc_preserve_debug_info) {
            array.writeMany("--mergefunc-preserve-debug-info\x00");
        }
        if (cmd.mergefunc_use_aliases) {
            array.writeMany("--mergefunc-use-aliases\x00");
        }
        if (cmd.mergefunc_verify) |mergefunc_verify| {
            array.writeMany("--mergefunc-verify\x00");
            array.writeFormat(fmt.ud64(mergefunc_verify));
            array.writeOne(0);
        }
        if (cmd.merror_missing_parenthesis) {
            array.writeMany("--merror-missing-parenthesis\x00");
        }
        if (cmd.merror_noncontigious_register) {
            array.writeMany("--merror-noncontigious-register\x00");
        }
        if (cmd.mextern_sdata) {
            array.writeMany("--mextern-sdata\x00");
        }
        if (cmd.mfix4300) {
            array.writeMany("--mfix4300\x00");
        }
        if (cmd.mfs_count_threshold) |mfs_count_threshold| {
            array.writeMany("--mfs-count-threshold\x00");
            array.writeFormat(fmt.ud64(mfs_count_threshold));
            array.writeOne(0);
        }
        if (cmd.mfs_psi_cutoff) |mfs_psi_cutoff| {
            array.writeMany("--mfs-psi-cutoff\x00");
            array.writeFormat(fmt.ud64(mfs_psi_cutoff));
            array.writeOne(0);
        }
        if (cmd.mfs_split_ehcode) {
            array.writeMany("--mfs-split-ehcode\x00");
        }
        if (cmd.mgpopt) {
            array.writeMany("--mgpopt\x00");
        }
        if (cmd.mhvx) |mhvx| {
            array.writeMany("--mhvx\x00");
            array.writeMany(@tagName(mhvx));
            array.writeOne(0);
        }
        if (cmd.mhvx_ieee_fp) {
            array.writeMany("--mhvx-ieee-fp\x00");
        }
        if (cmd.mhwmult) |mhwmult| {
            array.writeMany("--mhwmult\x00");
            array.writeMany(@tagName(mhwmult));
            array.writeOne(0);
        }
        if (cmd.min_block_execution) |min_block_execution| {
            array.writeMany("--min-block-execution\x00");
            array.writeFormat(fmt.ud64(min_block_execution));
            array.writeOne(0);
        }
        if (cmd.min_ctr_loop_threshold) |min_ctr_loop_threshold| {
            array.writeMany("--min-ctr-loop-threshold\x00");
            array.writeFormat(fmt.ud64(min_ctr_loop_threshold));
            array.writeOne(0);
        }
        if (cmd.min_jump_table_entries) |min_jump_table_entries| {
            array.writeMany("--min-jump-table-entries\x00");
            array.writeFormat(fmt.ud64(min_jump_table_entries));
            array.writeOne(0);
        }
        if (cmd.min_prefetch_stride) |min_prefetch_stride| {
            array.writeMany("--min-prefetch-stride\x00");
            array.writeFormat(fmt.ud64(min_prefetch_stride));
            array.writeOne(0);
        }
        if (cmd.min_region_size_ratio) |min_region_size_ratio| {
            array.writeMany("--min-region-size-ratio\x00");
            array.writeFormat(fmt.ud64(min_region_size_ratio));
            array.writeOne(0);
        }
        if (cmd.minimize_addr_in_v5) |minimize_addr_in_v5| {
            array.writeMany("--minimize-addr-in-v5\x00");
            array.writeMany(@tagName(minimize_addr_in_v5));
            array.writeOne(0);
        }
        if (cmd.minimum_jump_tables) |minimum_jump_tables| {
            array.writeMany("--minimum-jump-tables\x00");
            array.writeFormat(fmt.ud64(minimum_jump_tables));
            array.writeOne(0);
        }
        if (cmd.mips_align_constant_islands) {
            array.writeMany("--mips-align-constant-islands\x00");
        }
        if (cmd.mips_compact_branches) |mips_compact_branches| {
            array.writeMany("--mips-compact-branches\x00");
            array.writeMany(@tagName(mips_compact_branches));
            array.writeOne(0);
        }
        if (cmd.mips_constant_islands_no_load_relaxation) {
            array.writeMany("--mips-constant-islands-no-load-relaxation\x00");
        }
        if (cmd.mips_constant_islands_small_offset) |mips_constant_islands_small_offset| {
            array.writeMany("--mips-constant-islands-small-offset\x00");
            array.writeFormat(fmt.ud64(mips_constant_islands_small_offset));
            array.writeOne(0);
        }
        if (cmd.mips_erase_gp_opnd) {
            array.writeMany("--mips-erase-gp-opnd\x00");
        }
        if (cmd.mips_fix_global_base_reg) {
            array.writeMany("--mips-fix-global-base-reg\x00");
        }
        if (cmd.mips_jalr_reloc) {
            array.writeMany("--mips-jalr-reloc\x00");
        }
        if (cmd.mips_load_target_from_got) {
            array.writeMany("--mips-load-target-from-got\x00");
        }
        if (cmd.mips_mixed_16_32) {
            array.writeMany("--mips-mixed-16-32\x00");
        }
        if (cmd.mips_os16) {
            array.writeMany("--mips-os16\x00");
        }
        if (cmd.mips_round_section_sizes) {
            array.writeMany("--mips-round-section-sizes\x00");
        }
        if (cmd.mips_ssection_threshold) |mips_ssection_threshold| {
            array.writeMany("--mips-ssection-threshold\x00");
            array.writeFormat(fmt.ud64(mips_ssection_threshold));
            array.writeOne(0);
        }
        if (cmd.mips_tail_calls) {
            array.writeMany("--mips-tail-calls\x00");
        }
        if (cmd.mips16_constant_islands) {
            array.writeMany("--mips16-constant-islands\x00");
        }
        if (cmd.mips16_dont_expand_cond_pseudo) {
            array.writeMany("--mips16-dont-expand-cond-pseudo\x00");
        }
        if (cmd.mips16_hard_float) {
            array.writeMany("--mips16-hard-float\x00");
        }
        if (cmd.mips32_function_mask) |mips32_function_mask| {
            array.writeMany("--mips32-function-mask\x00");
            array.writeMany(mips32_function_mask);
            array.writeOne(0);
        }
        if (cmd.mipspostlegalizercombinerhelper_disable_rule) |mipspostlegalizercombinerhelper_disable_rule| {
            array.writeMany("--mipspostlegalizercombinerhelper-disable-rule\x00");
            array.writeMany(mipspostlegalizercombinerhelper_disable_rule);
            array.writeOne(0);
        }
        if (cmd.mipspostlegalizercombinerhelper_only_enable_rule) |mipspostlegalizercombinerhelper_only_enable_rule| {
            array.writeMany("--mipspostlegalizercombinerhelper-only-enable-rule\x00");
            array.writeMany(mipspostlegalizercombinerhelper_only_enable_rule);
            array.writeOne(0);
        }
        if (cmd.mir_debug_loc) {
            array.writeMany("--mir-debug-loc\x00");
        }
        if (cmd.mir_strip_debugify_only) {
            array.writeMany("--mir-strip-debugify-only\x00");
        }
        if (cmd.mir_vreg_namer_use_stable_hash) {
            array.writeMany("--mir-vreg-namer-use-stable-hash\x00");
        }
        if (cmd.misched) |misched| {
            array.writeMany("--misched\x00");
            array.writeMany(@tagName(misched));
            array.writeOne(0);
        }
        if (cmd.misched_bottomup) {
            array.writeMany("--misched-bottomup\x00");
        }
        if (cmd.misched_cluster) {
            array.writeMany("--misched-cluster\x00");
        }
        if (cmd.misched_cyclicpath) {
            array.writeMany("--misched-cyclicpath\x00");
        }
        if (cmd.misched_dcpl) {
            array.writeMany("--misched-dcpl\x00");
        }
        if (cmd.misched_fusion) {
            array.writeMany("--misched-fusion\x00");
        }
        if (cmd.misched_limit) |misched_limit| {
            array.writeMany("--misched-limit\x00");
            array.writeFormat(fmt.ud64(misched_limit));
            array.writeOne(0);
        }
        if (cmd.misched_postra) {
            array.writeMany("--misched-postra\x00");
        }
        if (cmd.misched_regpressure) {
            array.writeMany("--misched-regpressure\x00");
        }
        if (cmd.misched_topdown) {
            array.writeMany("--misched-topdown\x00");
        }
        if (cmd.misched_verbose_level) |misched_verbose_level| {
            array.writeMany("--misched-verbose-level\x00");
            array.writeFormat(fmt.ud64(misched_verbose_level));
            array.writeOne(0);
        }
        if (cmd.misexpect_tolerance) |misexpect_tolerance| {
            array.writeMany("--misexpect-tolerance\x00");
            array.writeFormat(fmt.ud64(misexpect_tolerance));
            array.writeOne(0);
        }
        if (cmd.misfetch_cost) |misfetch_cost| {
            array.writeMany("--misfetch-cost\x00");
            array.writeFormat(fmt.ud64(misfetch_cost));
            array.writeOne(0);
        }
        if (cmd.mispredict_default_rate) |mispredict_default_rate| {
            array.writeMany("--mispredict-default-rate\x00");
            array.writeFormat(fmt.ud64(mispredict_default_rate));
            array.writeOne(0);
        }
        if (cmd.ml_advisor_keep_fpi_cache) {
            array.writeMany("--ml-advisor-keep-fpi-cache\x00");
        }
        if (cmd.ml_advisor_size_increase_threshold) |ml_advisor_size_increase_threshold| {
            array.writeMany("--ml-advisor-size-increase-threshold\x00");
            array.writeFormat(fmt.ud64(ml_advisor_size_increase_threshold));
            array.writeOne(0);
        }
        if (cmd.mlocal_sdata) {
            array.writeMany("--mlocal-sdata\x00");
        }
        if (cmd.mno_check_zero_division) {
            array.writeMany("--mno-check-zero-division\x00");
        }
        if (cmd.mno_compound) {
            array.writeMany("--mno-compound\x00");
        }
        if (cmd.mno_fixup) {
            array.writeMany("--mno-fixup\x00");
        }
        if (cmd.mno_hvx) {
            array.writeMany("--mno-hvx\x00");
        }
        if (cmd.mno_ldc1_sdc1) {
            array.writeMany("--mno-ldc1-sdc1\x00");
        }
        if (cmd.mno_pairing) {
            array.writeMany("--mno-pairing\x00");
        }
        if (cmd.mno_sort_sda) {
            array.writeMany("--mno-sort-sda\x00");
        }
        if (cmd.module_summary_dot_file) |module_summary_dot_file| {
            array.writeMany("--module-summary-dot-file\x00");
            array.writeMany(module_summary_dot_file);
            array.writeOne(0);
        }
        if (cmd.moudle_inliner_top_priority_threshold) |moudle_inliner_top_priority_threshold| {
            array.writeMany("--moudle-inliner-top-priority-threshold\x00");
            array.writeFormat(fmt.ud64(moudle_inliner_top_priority_threshold));
            array.writeOne(0);
        }
        if (cmd.msan_and_mask) |msan_and_mask| {
            array.writeMany("--msan-and-mask\x00");
            array.writeFormat(fmt.ud64(msan_and_mask));
            array.writeOne(0);
        }
        if (cmd.msan_check_access_address) {
            array.writeMany("--msan-check-access-address\x00");
        }
        if (cmd.msan_check_constant_shadow) {
            array.writeMany("--msan-check-constant-shadow\x00");
        }
        if (cmd.msan_disable_checks) {
            array.writeMany("--msan-disable-checks\x00");
        }
        if (cmd.msan_disambiguate_warning_threshold) |msan_disambiguate_warning_threshold| {
            array.writeMany("--msan-disambiguate-warning-threshold\x00");
            array.writeFormat(fmt.ud64(msan_disambiguate_warning_threshold));
            array.writeOne(0);
        }
        if (cmd.msan_dump_strict_instructions) {
            array.writeMany("--msan-dump-strict-instructions\x00");
        }
        if (cmd.msan_eager_checks) {
            array.writeMany("--msan-eager-checks\x00");
        }
        if (cmd.msan_handle_asm_conservative) {
            array.writeMany("--msan-handle-asm-conservative\x00");
        }
        if (cmd.msan_handle_icmp) {
            array.writeMany("--msan-handle-icmp\x00");
        }
        if (cmd.msan_handle_icmp_exact) {
            array.writeMany("--msan-handle-icmp-exact\x00");
        }
        if (cmd.msan_handle_lifetime_intrinsics) {
            array.writeMany("--msan-handle-lifetime-intrinsics\x00");
        }
        if (cmd.msan_instrumentation_with_call_threshold) |msan_instrumentation_with_call_threshold| {
            array.writeMany("--msan-instrumentation-with-call-threshold\x00");
            array.writeFormat(fmt.ud64(msan_instrumentation_with_call_threshold));
            array.writeOne(0);
        }
        if (cmd.msan_keep_going) {
            array.writeMany("--msan-keep-going\x00");
        }
        if (cmd.msan_kernel) {
            array.writeMany("--msan-kernel\x00");
        }
        if (cmd.msan_origin_base) |msan_origin_base| {
            array.writeMany("--msan-origin-base\x00");
            array.writeFormat(fmt.ud64(msan_origin_base));
            array.writeOne(0);
        }
        if (cmd.msan_poison_stack) {
            array.writeMany("--msan-poison-stack\x00");
        }
        if (cmd.msan_poison_stack_pattern) |msan_poison_stack_pattern| {
            array.writeMany("--msan-poison-stack-pattern\x00");
            array.writeFormat(fmt.ud64(msan_poison_stack_pattern));
            array.writeOne(0);
        }
        if (cmd.msan_poison_stack_with_call) {
            array.writeMany("--msan-poison-stack-with-call\x00");
        }
        if (cmd.msan_poison_undef) {
            array.writeMany("--msan-poison-undef\x00");
        }
        if (cmd.msan_print_stack_names) {
            array.writeMany("--msan-print-stack-names\x00");
        }
        if (cmd.msan_shadow_base) |msan_shadow_base| {
            array.writeMany("--msan-shadow-base\x00");
            array.writeFormat(fmt.ud64(msan_shadow_base));
            array.writeOne(0);
        }
        if (cmd.msan_track_origins) |msan_track_origins| {
            array.writeMany("--msan-track-origins\x00");
            array.writeFormat(fmt.ud64(msan_track_origins));
            array.writeOne(0);
        }
        if (cmd.msan_with_comdat) {
            array.writeMany("--msan-with-comdat\x00");
        }
        if (cmd.msan_xor_mask) |msan_xor_mask| {
            array.writeMany("--msan-xor-mask\x00");
            array.writeFormat(fmt.ud64(msan_xor_mask));
            array.writeOne(0);
        }
        if (cmd.msp430_branch_select) {
            array.writeMany("--msp430-branch-select\x00");
        }
        if (cmd.msp430_no_legal_immediate) {
            array.writeMany("--msp430-no-legal-immediate\x00");
        }
        if (cmd.mtriple) |mtriple| {
            array.writeMany("--mtriple\x00");
            array.writeMany(mtriple);
            array.writeOne(0);
        }
        if (cmd.mul_constant_optimization) {
            array.writeMany("--mul-constant-optimization\x00");
        }
        if (cmd.mv5) {
            array.writeMany("--mv5\x00");
        }
        if (cmd.mv55) {
            array.writeMany("--mv55\x00");
        }
        if (cmd.mv60) {
            array.writeMany("--mv60\x00");
        }
        if (cmd.mv62) {
            array.writeMany("--mv62\x00");
        }
        if (cmd.mv65) {
            array.writeMany("--mv65\x00");
        }
        if (cmd.mv66) {
            array.writeMany("--mv66\x00");
        }
        if (cmd.mv67) {
            array.writeMany("--mv67\x00");
        }
        if (cmd.mv67t) {
            array.writeMany("--mv67t\x00");
        }
        if (cmd.mv68) {
            array.writeMany("--mv68\x00");
        }
        if (cmd.mv69) {
            array.writeMany("--mv69\x00");
        }
        if (cmd.mv71) {
            array.writeMany("--mv71\x00");
        }
        if (cmd.mv71t) {
            array.writeMany("--mv71t\x00");
        }
        if (cmd.mv73) {
            array.writeMany("--mv73\x00");
        }
        if (cmd.mve_max_interleave_factor) |mve_max_interleave_factor| {
            array.writeMany("--mve-max-interleave-factor\x00");
            array.writeFormat(fmt.ud64(mve_max_interleave_factor));
            array.writeOne(0);
        }
        if (cmd.mwarn_missing_parenthesis) {
            array.writeMany("--mwarn-missing-parenthesis\x00");
        }
        if (cmd.mwarn_noncontigious_register) {
            array.writeMany("--mwarn-noncontigious-register\x00");
        }
        if (cmd.mwarn_sign_mismatch) {
            array.writeMany("--mwarn-sign-mismatch\x00");
        }
        if (cmd.no_deprecated_warn) {
            array.writeMany("--no-deprecated-warn\x00");
        }
        if (cmd.no_discriminators) {
            array.writeMany("--no-discriminators\x00");
        }
        if (cmd.no_dwarf_ranges_section) {
            array.writeMany("--no-dwarf-ranges-section\x00");
        }
        if (cmd.no_integrated_as) {
            array.writeMany("--no-integrated-as\x00");
        }
        if (cmd.no_pgo_warn_mismatch) {
            array.writeMany("--no-pgo-warn-mismatch\x00");
        }
        if (cmd.no_pgo_warn_mismatch_comdat_weak) {
            array.writeMany("--no-pgo-warn-mismatch-comdat-weak\x00");
        }
        if (cmd.no_phi_elim_live_out_early_exit) {
            array.writeMany("--no-phi-elim-live-out-early-exit\x00");
        }
        if (cmd.no_stack_coloring) {
            array.writeMany("--no-stack-coloring\x00");
        }
        if (cmd.no_stack_slot_sharing) {
            array.writeMany("--no-stack-slot-sharing\x00");
        }
        if (cmd.no_type_check) {
            array.writeMany("--no-type-check\x00");
        }
        if (cmd.no_warn) {
            array.writeMany("--no-warn\x00");
        }
        if (cmd.no_warn_sample_unused) {
            array.writeMany("--no-warn-sample-unused\x00");
        }
        if (cmd.no_x86_call_frame_opt) {
            array.writeMany("--no-x86-call-frame-opt\x00");
        }
        if (cmd.no_xray_index) {
            array.writeMany("--no-xray-index\x00");
        }
        if (cmd.non_global_value_max_name_size) |non_global_value_max_name_size| {
            array.writeMany("--non-global-value-max-name-size\x00");
            array.writeFormat(fmt.ud64(non_global_value_max_name_size));
            array.writeOne(0);
        }
        if (cmd.nozero_initialized_in_bss) {
            array.writeMany("--nozero-initialized-in-bss\x00");
        }
        if (cmd.number_scavenger_slots) |number_scavenger_slots| {
            array.writeMany("--number-scavenger-slots\x00");
            array.writeFormat(fmt.ud64(number_scavenger_slots));
            array.writeOne(0);
        }
        if (cmd.nvj_count) |nvj_count| {
            array.writeMany("--nvj-count\x00");
            array.writeFormat(fmt.ud64(nvj_count));
            array.writeOne(0);
        }
        if (cmd.nvptx_fma_level) |nvptx_fma_level| {
            array.writeMany("--nvptx-fma-level\x00");
            array.writeFormat(fmt.ud64(nvptx_fma_level));
            array.writeOne(0);
        }
        if (cmd.nvptx_no_f16_math) {
            array.writeMany("--nvptx-no-f16-math\x00");
        }
        if (cmd.nvptx_prec_divf32) |nvptx_prec_divf32| {
            array.writeMany("--nvptx-prec-divf32\x00");
            array.writeFormat(fmt.ud64(nvptx_prec_divf32));
            array.writeOne(0);
        }
        if (cmd.nvptx_prec_sqrtf32) {
            array.writeMany("--nvptx-prec-sqrtf32\x00");
        }
        if (cmd.nvptx_sched4reg) {
            array.writeMany("--nvptx-sched4reg\x00");
        }
        if (cmd.nvptx_short_ptr) {
            array.writeMany("--nvptx-short-ptr\x00");
        }
        if (cmd.nvvm_intr_range_sm) |nvvm_intr_range_sm| {
            array.writeMany("--nvvm-intr-range-sm\x00");
            array.writeFormat(fmt.ud64(nvvm_intr_range_sm));
            array.writeOne(0);
        }
        if (cmd.nvvm_reflect_enable) {
            array.writeMany("--nvvm-reflect-enable\x00");
        }
        if (cmd.old_thumb2_ifcvt) {
            array.writeMany("--old-thumb2-ifcvt\x00");
        }
        if (cmd.only_nonnested_memmove_idiom) {
            array.writeMany("--only-nonnested-memmove-idiom\x00");
        }
        if (cmd.only_simple_regions) {
            array.writeMany("--only-simple-regions\x00");
        }
        if (cmd.opaque_pointers) {
            array.writeMany("--opaque-pointers\x00");
        }
        if (cmd.openmp_deduce_icv_values) {
            array.writeMany("--openmp-deduce-icv-values\x00");
        }
        if (cmd.openmp_hide_memory_transfer_latency) {
            array.writeMany("--openmp-hide-memory-transfer-latency\x00");
        }
        if (cmd.openmp_ir_builder_optimistic_attributes) {
            array.writeMany("--openmp-ir-builder-optimistic-attributes\x00");
        }
        if (cmd.openmp_ir_builder_unroll_threshold_factor) |openmp_ir_builder_unroll_threshold_factor| {
            array.writeMany("--openmp-ir-builder-unroll-threshold-factor\x00");
            array.writeFormat(fmt.ud64(openmp_ir_builder_unroll_threshold_factor));
            array.writeOne(0);
        }
        if (cmd.openmp_opt_disable) {
            array.writeMany("--openmp-opt-disable\x00");
        }
        if (cmd.openmp_opt_disable_barrier_elimination) {
            array.writeMany("--openmp-opt-disable-barrier-elimination\x00");
        }
        if (cmd.openmp_opt_disable_deglobalization) {
            array.writeMany("--openmp-opt-disable-deglobalization\x00");
        }
        if (cmd.openmp_opt_disable_folding) {
            array.writeMany("--openmp-opt-disable-folding\x00");
        }
        if (cmd.openmp_opt_disable_internalization) {
            array.writeMany("--openmp-opt-disable-internalization\x00");
        }
        if (cmd.openmp_opt_disable_spmdization) {
            array.writeMany("--openmp-opt-disable-spmdization\x00");
        }
        if (cmd.openmp_opt_disable_state_machine_rewrite) {
            array.writeMany("--openmp-opt-disable-state-machine-rewrite\x00");
        }
        if (cmd.openmp_opt_enable_merging) {
            array.writeMany("--openmp-opt-enable-merging\x00");
        }
        if (cmd.openmp_opt_inline_device) {
            array.writeMany("--openmp-opt-inline-device\x00");
        }
        if (cmd.openmp_opt_max_iterations) |openmp_opt_max_iterations| {
            array.writeMany("--openmp-opt-max-iterations\x00");
            array.writeFormat(fmt.ud64(openmp_opt_max_iterations));
            array.writeOne(0);
        }
        if (cmd.openmp_opt_print_module_after) {
            array.writeMany("--openmp-opt-print-module-after\x00");
        }
        if (cmd.openmp_opt_print_module_before) {
            array.writeMany("--openmp-opt-print-module-before\x00");
        }
        if (cmd.openmp_opt_shared_limit) |openmp_opt_shared_limit| {
            array.writeMany("--openmp-opt-shared-limit\x00");
            array.writeFormat(fmt.ud64(openmp_opt_shared_limit));
            array.writeOne(0);
        }
        if (cmd.openmp_opt_verbose_remarks) {
            array.writeMany("--openmp-opt-verbose-remarks\x00");
        }
        if (cmd.openmp_print_gpu_kernels) {
            array.writeMany("--openmp-print-gpu-kernels\x00");
        }
        if (cmd.openmp_print_icv_values) {
            array.writeMany("--openmp-print-icv-values\x00");
        }
        if (cmd.opt_bisect_limit) |opt_bisect_limit| {
            array.writeMany("--opt-bisect-limit\x00");
            array.writeFormat(fmt.ud64(opt_bisect_limit));
            array.writeOne(0);
        }
        if (cmd.opt_bisect_print_ir_path) |opt_bisect_print_ir_path| {
            array.writeMany("--opt-bisect-print-ir-path\x00");
            array.writeMany(opt_bisect_print_ir_path);
            array.writeOne(0);
        }
        if (cmd.optimize_regalloc) {
            array.writeMany("--optimize-regalloc\x00");
        }
        if (cmd.optsize_jump_table_density) |optsize_jump_table_density| {
            array.writeMany("--optsize-jump-table-density\x00");
            array.writeFormat(fmt.ud64(optsize_jump_table_density));
            array.writeOne(0);
        }
        if (cmd.orderfile_write_mapping) |orderfile_write_mapping| {
            array.writeMany("--orderfile-write-mapping\x00");
            array.writeMany(orderfile_write_mapping);
            array.writeOne(0);
        }
        if (cmd.outline_region_freq_percent) |outline_region_freq_percent| {
            array.writeMany("--outline-region-freq-percent\x00");
            array.writeFormat(fmt.ud64(outline_region_freq_percent));
            array.writeOne(0);
        }
        if (cmd.overwrite_existing_weights) {
            array.writeMany("--overwrite-existing-weights\x00");
        }
        if (cmd.partial_inlining_extra_penalty) |partial_inlining_extra_penalty| {
            array.writeMany("--partial-inlining-extra-penalty\x00");
            array.writeFormat(fmt.ud64(partial_inlining_extra_penalty));
            array.writeOne(0);
        }
        if (cmd.partial_profile) {
            array.writeMany("--partial-profile\x00");
        }
        if (cmd.partial_reg_update_clearance) |partial_reg_update_clearance| {
            array.writeMany("--partial-reg-update-clearance\x00");
            array.writeFormat(fmt.ud64(partial_reg_update_clearance));
            array.writeOne(0);
        }
        if (cmd.partial_sample_profile_working_set_size_scale_factor) |partial_sample_profile_working_set_size_scale_factor| {
            array.writeMany("--partial-sample-profile-working-set-size-scale-factor\x00");
            array.writeFormat(fmt.ud64(partial_sample_profile_working_set_size_scale_factor));
            array.writeOne(0);
        }
        if (cmd.partial_unrolling_threshold) |partial_unrolling_threshold| {
            array.writeMany("--partial-unrolling-threshold\x00");
            array.writeFormat(fmt.ud64(partial_unrolling_threshold));
            array.writeOne(0);
        }
        if (cmd.pass_remarks) |pass_remarks| {
            array.writeMany("--pass-remarks\x00");
            array.writeMany(pass_remarks);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_analysis) |pass_remarks_analysis| {
            array.writeMany("--pass-remarks-analysis\x00");
            array.writeMany(pass_remarks_analysis);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_filter) |pass_remarks_filter| {
            array.writeMany("--pass-remarks-filter\x00");
            array.writeMany(pass_remarks_filter);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_format) |pass_remarks_format| {
            array.writeMany("--pass-remarks-format\x00");
            array.writeMany(pass_remarks_format);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_hotness_threshold) {
            array.writeMany("--pass-remarks-hotness-threshold\x00");
        }
        if (cmd.pass_remarks_missed) |pass_remarks_missed| {
            array.writeMany("--pass-remarks-missed\x00");
            array.writeMany(pass_remarks_missed);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_output) |pass_remarks_output| {
            array.writeMany("--pass-remarks-output\x00");
            array.writeMany(pass_remarks_output);
            array.writeOne(0);
        }
        if (cmd.pass_remarks_with_hotness) {
            array.writeMany("--pass-remarks-with-hotness\x00");
        }
        if (cmd.pbqp_coalescing) {
            array.writeMany("--pbqp-coalescing\x00");
        }
        if (cmd.persist_profile_staleness) {
            array.writeMany("--persist-profile-staleness\x00");
        }
        if (cmd.pgo_critical_edge_threshold) |pgo_critical_edge_threshold| {
            array.writeMany("--pgo-critical-edge-threshold\x00");
            array.writeFormat(fmt.ud64(pgo_critical_edge_threshold));
            array.writeOne(0);
        }
        if (cmd.pgo_emit_branch_prob) {
            array.writeMany("--pgo-emit-branch-prob\x00");
        }
        if (cmd.pgo_fix_entry_count) {
            array.writeMany("--pgo-fix-entry-count\x00");
        }
        if (cmd.pgo_function_entry_coverage) {
            array.writeMany("--pgo-function-entry-coverage\x00");
        }
        if (cmd.pgo_function_size_threshold) |pgo_function_size_threshold| {
            array.writeMany("--pgo-function-size-threshold\x00");
            array.writeFormat(fmt.ud64(pgo_function_size_threshold));
            array.writeOne(0);
        }
        if (cmd.pgo_instr_memop) {
            array.writeMany("--pgo-instr-memop\x00");
        }
        if (cmd.pgo_instr_old_cfg_hashing) {
            array.writeMany("--pgo-instr-old-cfg-hashing\x00");
        }
        if (cmd.pgo_instr_select) {
            array.writeMany("--pgo-instr-select\x00");
        }
        if (cmd.pgo_instrument_entry) {
            array.writeMany("--pgo-instrument-entry\x00");
        }
        if (cmd.pgo_match_memprof) {
            array.writeMany("--pgo-match-memprof\x00");
        }
        if (cmd.pgo_memop_count_threshold) |pgo_memop_count_threshold| {
            array.writeMany("--pgo-memop-count-threshold\x00");
            array.writeFormat(fmt.ud64(pgo_memop_count_threshold));
            array.writeOne(0);
        }
        if (cmd.pgo_memop_max_version) |pgo_memop_max_version| {
            array.writeMany("--pgo-memop-max-version\x00");
            array.writeFormat(fmt.ud64(pgo_memop_max_version));
            array.writeOne(0);
        }
        if (cmd.pgo_memop_optimize_memcmp_bcmp) {
            array.writeMany("--pgo-memop-optimize-memcmp-bcmp\x00");
        }
        if (cmd.pgo_memop_percent_threshold) |pgo_memop_percent_threshold| {
            array.writeMany("--pgo-memop-percent-threshold\x00");
            array.writeFormat(fmt.ud64(pgo_memop_percent_threshold));
            array.writeOne(0);
        }
        if (cmd.pgo_memop_scale_count) {
            array.writeMany("--pgo-memop-scale-count\x00");
        }
        if (cmd.pgo_test_profile_file) |pgo_test_profile_file| {
            array.writeMany("--pgo-test-profile-file\x00");
            array.writeMany(pgo_test_profile_file);
            array.writeOne(0);
        }
        if (cmd.pgo_test_profile_remapping_file) |pgo_test_profile_remapping_file| {
            array.writeMany("--pgo-test-profile-remapping-file\x00");
            array.writeMany(pgo_test_profile_remapping_file);
            array.writeOne(0);
        }
        if (cmd.pgo_verify_bfi) {
            array.writeMany("--pgo-verify-bfi\x00");
        }
        if (cmd.pgo_verify_bfi_cutoff) |pgo_verify_bfi_cutoff| {
            array.writeMany("--pgo-verify-bfi-cutoff\x00");
            array.writeFormat(fmt.ud64(pgo_verify_bfi_cutoff));
            array.writeOne(0);
        }
        if (cmd.pgo_verify_bfi_ratio) |pgo_verify_bfi_ratio| {
            array.writeMany("--pgo-verify-bfi-ratio\x00");
            array.writeFormat(fmt.ud64(pgo_verify_bfi_ratio));
            array.writeOne(0);
        }
        if (cmd.pgo_verify_hot_bfi) {
            array.writeMany("--pgo-verify-hot-bfi\x00");
        }
        if (cmd.pgo_view_counts) |pgo_view_counts| {
            array.writeMany("--pgo-view-counts\x00");
            array.writeMany(@tagName(pgo_view_counts));
            array.writeOne(0);
        }
        if (cmd.pgo_view_raw_counts) |pgo_view_raw_counts| {
            array.writeMany("--pgo-view-raw-counts\x00");
            array.writeMany(@tagName(pgo_view_raw_counts));
            array.writeOne(0);
        }
        if (cmd.pgo_warn_misexpect) {
            array.writeMany("--pgo-warn-misexpect\x00");
        }
        if (cmd.pgo_warn_missing_function) {
            array.writeMany("--pgo-warn-missing-function\x00");
        }
        if (cmd.pgso) {
            array.writeMany("--pgso\x00");
        }
        if (cmd.pgso_cold_code_only) {
            array.writeMany("--pgso-cold-code-only\x00");
        }
        if (cmd.pgso_cold_code_only_for_instr_pgo) {
            array.writeMany("--pgso-cold-code-only-for-instr-pgo\x00");
        }
        if (cmd.pgso_cold_code_only_for_partial_sample_pgo) {
            array.writeMany("--pgso-cold-code-only-for-partial-sample-pgo\x00");
        }
        if (cmd.pgso_cold_code_only_for_sample_pgo) {
            array.writeMany("--pgso-cold-code-only-for-sample-pgo\x00");
        }
        if (cmd.pgso_cutoff_instr_prof) |pgso_cutoff_instr_prof| {
            array.writeMany("--pgso-cutoff-instr-prof\x00");
            array.writeFormat(fmt.ud64(pgso_cutoff_instr_prof));
            array.writeOne(0);
        }
        if (cmd.pgso_cutoff_sample_prof) |pgso_cutoff_sample_prof| {
            array.writeMany("--pgso-cutoff-sample-prof\x00");
            array.writeFormat(fmt.ud64(pgso_cutoff_sample_prof));
            array.writeOne(0);
        }
        if (cmd.pgso_lwss_only) {
            array.writeMany("--pgso-lwss-only\x00");
        }
        if (cmd.phi_elim_split_all_critical_edges) {
            array.writeMany("--phi-elim-split-all-critical-edges\x00");
        }
        if (cmd.phi_node_folding_threshold) |phi_node_folding_threshold| {
            array.writeMany("--phi-node-folding-threshold\x00");
            array.writeFormat(fmt.ud64(phi_node_folding_threshold));
            array.writeOne(0);
        }
        if (cmd.phicse_debug_hash) {
            array.writeMany("--phicse-debug-hash\x00");
        }
        if (cmd.phicse_num_phi_smallsize) |phicse_num_phi_smallsize| {
            array.writeMany("--phicse-num-phi-smallsize\x00");
            array.writeFormat(fmt.ud64(phicse_num_phi_smallsize));
            array.writeOne(0);
        }
        if (cmd.pi_force_live_exit_outline) {
            array.writeMany("--pi-force-live-exit-outline\x00");
        }
        if (cmd.pi_mark_coldcc) {
            array.writeMany("--pi-mark-coldcc\x00");
        }
        if (cmd.pipeliner_annotate_for_testing) {
            array.writeMany("--pipeliner-annotate-for-testing\x00");
        }
        if (cmd.pipeliner_dbg_res) {
            array.writeMany("--pipeliner-dbg-res\x00");
        }
        if (cmd.pipeliner_experimental_cg) {
            array.writeMany("--pipeliner-experimental-cg\x00");
        }
        if (cmd.pipeliner_force_ii) |pipeliner_force_ii| {
            array.writeMany("--pipeliner-force-ii\x00");
            array.writeFormat(fmt.ud64(pipeliner_force_ii));
            array.writeOne(0);
        }
        if (cmd.pipeliner_force_issue_width) |pipeliner_force_issue_width| {
            array.writeMany("--pipeliner-force-issue-width\x00");
            array.writeFormat(fmt.ud64(pipeliner_force_issue_width));
            array.writeOne(0);
        }
        if (cmd.pipeliner_max_mii) |pipeliner_max_mii| {
            array.writeMany("--pipeliner-max-mii\x00");
            array.writeFormat(fmt.ud64(pipeliner_max_mii));
            array.writeOne(0);
        }
        if (cmd.pipeliner_max_stages) |pipeliner_max_stages| {
            array.writeMany("--pipeliner-max-stages\x00");
            array.writeFormat(fmt.ud64(pipeliner_max_stages));
            array.writeOne(0);
        }
        if (cmd.pipeliner_prune_deps) {
            array.writeMany("--pipeliner-prune-deps\x00");
        }
        if (cmd.pipeliner_prune_loop_carried) {
            array.writeMany("--pipeliner-prune-loop-carried\x00");
        }
        if (cmd.pipeliner_show_mask) {
            array.writeMany("--pipeliner-show-mask\x00");
        }
        if (cmd.poison_checking_function_local) {
            array.writeMany("--poison-checking-function-local\x00");
        }
        if (cmd.post_RA_scheduler) {
            array.writeMany("--post-RA-scheduler\x00");
        }
        if (cmd.postra_sched_debugdiv) |postra_sched_debugdiv| {
            array.writeMany("--postra-sched-debugdiv\x00");
            array.writeFormat(fmt.ud64(postra_sched_debugdiv));
            array.writeOne(0);
        }
        if (cmd.postra_sched_debugmod) |postra_sched_debugmod| {
            array.writeMany("--postra-sched-debugmod\x00");
            array.writeFormat(fmt.ud64(postra_sched_debugmod));
            array.writeOne(0);
        }
        if (cmd.ppc_always_use_base_pointer) {
            array.writeMany("--ppc-always-use-base-pointer\x00");
        }
        if (cmd.ppc_asm_full_reg_names) {
            array.writeMany("--ppc-asm-full-reg-names\x00");
        }
        if (cmd.ppc_bit_perm_rewriter_stress_rotates) {
            array.writeMany("--ppc-bit-perm-rewriter-stress-rotates\x00");
        }
        if (cmd.ppc_chaincommon_max_vars) |ppc_chaincommon_max_vars| {
            array.writeMany("--ppc-chaincommon-max-vars\x00");
            array.writeFormat(fmt.ud64(ppc_chaincommon_max_vars));
            array.writeOne(0);
        }
        if (cmd.ppc_chaincommon_min_threshold) |ppc_chaincommon_min_threshold| {
            array.writeMany("--ppc-chaincommon-min-threshold\x00");
            array.writeFormat(fmt.ud64(ppc_chaincommon_min_threshold));
            array.writeOne(0);
        }
        if (cmd.ppc_convert_rr_to_ri) {
            array.writeMany("--ppc-convert-rr-to-ri\x00");
        }
        if (cmd.ppc_disable_non_volatile_cr) {
            array.writeMany("--ppc-disable-non-volatile-cr\x00");
        }
        if (cmd.ppc_disable_perfect_shuffle) {
            array.writeMany("--ppc-disable-perfect-shuffle\x00");
        }
        if (cmd.ppc_dispprep_min_threshold) |ppc_dispprep_min_threshold| {
            array.writeMany("--ppc-dispprep-min-threshold\x00");
            array.writeFormat(fmt.ud64(ppc_dispprep_min_threshold));
            array.writeOne(0);
        }
        if (cmd.ppc_dqprep_max_vars) |ppc_dqprep_max_vars| {
            array.writeMany("--ppc-dqprep-max-vars\x00");
            array.writeFormat(fmt.ud64(ppc_dqprep_max_vars));
            array.writeOne(0);
        }
        if (cmd.ppc_dsprep_max_vars) |ppc_dsprep_max_vars| {
            array.writeMany("--ppc-dsprep-max-vars\x00");
            array.writeFormat(fmt.ud64(ppc_dsprep_max_vars));
            array.writeOne(0);
        }
        if (cmd.ppc_eliminate_signext) {
            array.writeMany("--ppc-eliminate-signext\x00");
        }
        if (cmd.ppc_eliminate_zeroext) {
            array.writeMany("--ppc-eliminate-zeroext\x00");
        }
        if (cmd.ppc_enable_coldcc) {
            array.writeMany("--ppc-enable-coldcc\x00");
        }
        if (cmd.ppc_enable_gpr_to_vsr_spills) {
            array.writeMany("--ppc-enable-gpr-to-vsr-spills\x00");
        }
        if (cmd.ppc_enable_pe_vector_spills) {
            array.writeMany("--ppc-enable-pe-vector-spills\x00");
        }
        if (cmd.ppc_enable_pipeliner) {
            array.writeMany("--ppc-enable-pipeliner\x00");
        }
        if (cmd.ppc_fma_rp_factor) |ppc_fma_rp_factor| {
            array.writeMany("--ppc-fma-rp-factor\x00");
            array.writeFormat(fmt.ud64(ppc_fma_rp_factor));
            array.writeOne(0);
        }
        if (cmd.ppc_fma_rp_reduction) {
            array.writeMany("--ppc-fma-rp-reduction\x00");
        }
        if (cmd.ppc_formprep_chain_commoning) {
            array.writeMany("--ppc-formprep-chain-commoning\x00");
        }
        if (cmd.ppc_formprep_max_vars) |ppc_formprep_max_vars| {
            array.writeMany("--ppc-formprep-max-vars\x00");
            array.writeFormat(fmt.ud64(ppc_formprep_max_vars));
            array.writeOne(0);
        }
        if (cmd.ppc_formprep_prefer_update) {
            array.writeMany("--ppc-formprep-prefer-update\x00");
        }
        if (cmd.ppc_formprep_update_nonconst_inc) {
            array.writeMany("--ppc-formprep-update-nonconst-inc\x00");
        }
        if (cmd.ppc_gen_isel) {
            array.writeMany("--ppc-gen-isel\x00");
        }
        if (cmd.ppc_gep_opt) {
            array.writeMany("--ppc-gep-opt\x00");
        }
        if (cmd.ppc_gpr_icmps) |ppc_gpr_icmps| {
            array.writeMany("--ppc-gpr-icmps\x00");
            array.writeMany(@tagName(ppc_gpr_icmps));
            array.writeOne(0);
        }
        if (cmd.ppc_late_peephole) {
            array.writeMany("--ppc-late-peephole\x00");
        }
        if (cmd.ppc_lsr_no_insns_cost) {
            array.writeMany("--ppc-lsr-no-insns-cost\x00");
        }
        if (cmd.ppc_machine_combiner) {
            array.writeMany("--ppc-machine-combiner\x00");
        }
        if (cmd.ppc_max_crbit_spill_dist) |ppc_max_crbit_spill_dist| {
            array.writeMany("--ppc-max-crbit-spill-dist\x00");
            array.writeFormat(fmt.ud64(ppc_max_crbit_spill_dist));
            array.writeOne(0);
        }
        if (cmd.ppc_old_latency_calc) {
            array.writeMany("--ppc-old-latency-calc\x00");
        }
        if (cmd.ppc_opt_conditional_trap) {
            array.writeMany("--ppc-opt-conditional-trap\x00");
        }
        if (cmd.ppc_pcrel_linker_opt) {
            array.writeMany("--ppc-pcrel-linker-opt\x00");
        }
        if (cmd.ppc_postra_bias_addi) {
            array.writeMany("--ppc-postra-bias-addi\x00");
        }
        if (cmd.ppc_preinc_prep_max_vars) |ppc_preinc_prep_max_vars| {
            array.writeMany("--ppc-preinc-prep-max-vars\x00");
            array.writeFormat(fmt.ud64(ppc_preinc_prep_max_vars));
            array.writeOne(0);
        }
        if (cmd.ppc_quadword_atomics) {
            array.writeMany("--ppc-quadword-atomics\x00");
        }
        if (cmd.ppc_reduce_cr_logicals) {
            array.writeMany("--ppc-reduce-cr-logicals\x00");
        }
        if (cmd.ppc_reg_to_imm_fixed_point) {
            array.writeMany("--ppc-reg-to-imm-fixed-point\x00");
        }
        if (cmd.ppc_reg_with_percent_prefix) {
            array.writeMany("--ppc-reg-with-percent-prefix\x00");
        }
        if (cmd.ppc_set_dscr) |ppc_set_dscr| {
            array.writeMany("--ppc-set-dscr\x00");
            array.writeFormat(fmt.ud64(ppc_set_dscr));
            array.writeOne(0);
        }
        if (cmd.ppc_stack_ptr_caller_preserved) {
            array.writeMany("--ppc-stack-ptr-caller-preserved\x00");
        }
        if (cmd.ppc_tls_opt) {
            array.writeMany("--ppc-tls-opt\x00");
        }
        if (cmd.ppc_track_subreg_liveness) {
            array.writeMany("--ppc-track-subreg-liveness\x00");
        }
        if (cmd.ppc_use_absolute_jumptables) {
            array.writeMany("--ppc-use-absolute-jumptables\x00");
        }
        if (cmd.ppc_use_base_pointer) {
            array.writeMany("--ppc-use-base-pointer\x00");
        }
        if (cmd.ppc_use_bit_perm_rewriter) {
            array.writeMany("--ppc-use-bit-perm-rewriter\x00");
        }
        if (cmd.ppc_use_branch_hint) {
            array.writeMany("--ppc-use-branch-hint\x00");
        }
        if (cmd.ppc_vsr_nums_as_vr) {
            array.writeMany("--ppc-vsr-nums-as-vr\x00");
        }
        if (cmd.pragma_unroll_and_jam_threshold) |pragma_unroll_and_jam_threshold| {
            array.writeMany("--pragma-unroll-and-jam-threshold\x00");
            array.writeFormat(fmt.ud64(pragma_unroll_and_jam_threshold));
            array.writeOne(0);
        }
        if (cmd.pragma_unroll_threshold) |pragma_unroll_threshold| {
            array.writeMany("--pragma-unroll-threshold\x00");
            array.writeFormat(fmt.ud64(pragma_unroll_threshold));
            array.writeOne(0);
        }
        if (cmd.pragma_vectorize_scev_check_threshold) |pragma_vectorize_scev_check_threshold| {
            array.writeMany("--pragma-vectorize-scev-check-threshold\x00");
            array.writeFormat(fmt.ud64(pragma_vectorize_scev_check_threshold));
            array.writeOne(0);
        }
        if (cmd.pre_RA_sched) |pre_RA_sched| {
            array.writeMany("--pre-RA-sched\x00");
            array.writeMany(@tagName(pre_RA_sched));
            array.writeOne(0);
        }
        if (cmd.precise_rotation_cost) {
            array.writeMany("--precise-rotation-cost\x00");
        }
        if (cmd.prefer_inloop_reductions) {
            array.writeMany("--prefer-inloop-reductions\x00");
        }
        if (cmd.prefer_no_csel) {
            array.writeMany("--prefer-no-csel\x00");
        }
        if (cmd.prefer_predicate_over_epilogue) |prefer_predicate_over_epilogue| {
            array.writeMany("--prefer-predicate-over-epilogue\x00");
            array.writeMany(@tagName(prefer_predicate_over_epilogue));
            array.writeOne(0);
        }
        if (cmd.prefer_predicated_reduction_select) {
            array.writeMany("--prefer-predicated-reduction-select\x00");
        }
        if (cmd.prefetch_distance) |prefetch_distance| {
            array.writeMany("--prefetch-distance\x00");
            array.writeFormat(fmt.ud64(prefetch_distance));
            array.writeOne(0);
        }
        if (cmd.prefetch_hints_file) |prefetch_hints_file| {
            array.writeMany("--prefetch-hints-file\x00");
            array.writeMany(prefetch_hints_file);
            array.writeOne(0);
        }
        if (cmd.preinline_threshold) |preinline_threshold| {
            array.writeMany("--preinline-threshold\x00");
            array.writeFormat(fmt.ud64(preinline_threshold));
            array.writeOne(0);
        }
        if (cmd.preserve_alignment_assumptions_during_inlining) {
            array.writeMany("--preserve-alignment-assumptions-during-inlining\x00");
        }
        if (cmd.preserve_as_comments) {
            array.writeMany("--preserve-as-comments\x00");
        }
        if (cmd.print_after) |print_after| {
            array.writeMany("--print-after\x00");
            array.writeMany(print_after);
            array.writeOne(0);
        }
        if (cmd.print_after_all) {
            array.writeMany("--print-after-all\x00");
        }
        if (cmd.print_after_isel) {
            array.writeMany("--print-after-isel\x00");
        }
        if (cmd.print_all_options) {
            array.writeMany("--print-all-options\x00");
        }
        if (cmd.print_before) |print_before| {
            array.writeMany("--print-before\x00");
            array.writeMany(print_before);
            array.writeOne(0);
        }
        if (cmd.print_before_all) {
            array.writeMany("--print-before-all\x00");
        }
        if (cmd.print_before_changed) {
            array.writeMany("--print-before-changed\x00");
        }
        if (cmd.print_bfi) {
            array.writeMany("--print-bfi\x00");
        }
        if (cmd.print_bfi_func_name) |print_bfi_func_name| {
            array.writeMany("--print-bfi-func-name\x00");
            array.writeMany(print_bfi_func_name);
            array.writeOne(0);
        }
        if (cmd.print_bpi) {
            array.writeMany("--print-bpi\x00");
        }
        if (cmd.print_bpi_func_name) |print_bpi_func_name| {
            array.writeMany("--print-bpi-func-name\x00");
            array.writeMany(print_bpi_func_name);
            array.writeOne(0);
        }
        if (cmd.print_changed) |print_changed| {
            array.writeMany("--print-changed\x00");
            array.writeMany(@tagName(print_changed));
            array.writeOne(0);
        }
        if (cmd.print_changed_dot_path) |print_changed_dot_path| {
            array.writeMany("--print-changed-dot-path\x00");
            array.writeMany(print_changed_dot_path);
            array.writeOne(0);
        }
        if (cmd.print_debug_ata) {
            array.writeMany("--print-debug-ata\x00");
        }
        if (cmd.print_debug_counter) {
            array.writeMany("--print-debug-counter\x00");
        }
        if (cmd.print_failed_fuse_candidates) {
            array.writeMany("--print-failed-fuse-candidates\x00");
        }
        if (cmd.print_gc) {
            array.writeMany("--print-gc\x00");
        }
        if (cmd.print_import_failures) {
            array.writeMany("--print-import-failures\x00");
        }
        if (cmd.print_imports) {
            array.writeMany("--print-imports\x00");
        }
        if (cmd.print_instruction_comments) {
            array.writeMany("--print-instruction-comments\x00");
        }
        if (cmd.print_isel_input) {
            array.writeMany("--print-isel-input\x00");
        }
        if (cmd.print_lsr_output) {
            array.writeMany("--print-lsr-output\x00");
        }
        if (cmd.print_lvi_after_jump_threading) {
            array.writeMany("--print-lvi-after-jump-threading\x00");
        }
        if (cmd.print_machine_bfi) {
            array.writeMany("--print-machine-bfi\x00");
        }
        if (cmd.print_module_scope) {
            array.writeMany("--print-module-scope\x00");
        }
        if (cmd.print_on_crash) {
            array.writeMany("--print-on-crash\x00");
        }
        if (cmd.print_options) {
            array.writeMany("--print-options\x00");
        }
        if (cmd.print_pipeline_passes) {
            array.writeMany("--print-pipeline-passes\x00");
        }
        if (cmd.print_region_style) |print_region_style| {
            array.writeMany("--print-region-style\x00");
            array.writeMany(@tagName(print_region_style));
            array.writeOne(0);
        }
        if (cmd.print_regmask_num_regs) |print_regmask_num_regs| {
            array.writeMany("--print-regmask-num-regs\x00");
            array.writeFormat(fmt.ud64(print_regmask_num_regs));
            array.writeOne(0);
        }
        if (cmd.print_regusage) {
            array.writeMany("--print-regusage\x00");
        }
        if (cmd.print_slotindexes) {
            array.writeMany("--print-slotindexes\x00");
        }
        if (cmd.print_summary_global_ids) {
            array.writeMany("--print-summary-global-ids\x00");
        }
        if (cmd.procres_cost_lim) |procres_cost_lim| {
            array.writeMany("--procres-cost-lim\x00");
            array.writeFormat(fmt.ud64(procres_cost_lim));
            array.writeOne(0);
        }
        if (cmd.profile_accurate_for_symsinlist) {
            array.writeMany("--profile-accurate-for-symsinlist\x00");
        }
        if (cmd.profile_guided_section_prefix) {
            array.writeMany("--profile-guided-section-prefix\x00");
        }
        if (cmd.profile_isfs) {
            array.writeMany("--profile-isfs\x00");
        }
        if (cmd.profile_likely_prob) |profile_likely_prob| {
            array.writeMany("--profile-likely-prob\x00");
            array.writeFormat(fmt.ud64(profile_likely_prob));
            array.writeOne(0);
        }
        if (cmd.profile_sample_accurate) {
            array.writeMany("--profile-sample-accurate\x00");
        }
        if (cmd.profile_sample_block_accurate) {
            array.writeMany("--profile-sample-block-accurate\x00");
        }
        if (cmd.profile_summary_contextless) {
            array.writeMany("--profile-summary-contextless\x00");
        }
        if (cmd.profile_summary_cutoff_cold) |profile_summary_cutoff_cold| {
            array.writeMany("--profile-summary-cutoff-cold\x00");
            array.writeFormat(fmt.ud64(profile_summary_cutoff_cold));
            array.writeOne(0);
        }
        if (cmd.profile_summary_cutoff_hot) |profile_summary_cutoff_hot| {
            array.writeMany("--profile-summary-cutoff-hot\x00");
            array.writeFormat(fmt.ud64(profile_summary_cutoff_hot));
            array.writeOne(0);
        }
        if (cmd.profile_summary_huge_working_set_size_threshold) |profile_summary_huge_working_set_size_threshold| {
            array.writeMany("--profile-summary-huge-working-set-size-threshold\x00");
            array.writeFormat(fmt.ud64(profile_summary_huge_working_set_size_threshold));
            array.writeOne(0);
        }
        if (cmd.profile_summary_large_working_set_size_threshold) |profile_summary_large_working_set_size_threshold| {
            array.writeMany("--profile-summary-large-working-set-size-threshold\x00");
            array.writeFormat(fmt.ud64(profile_summary_large_working_set_size_threshold));
            array.writeOne(0);
        }
        if (cmd.profile_symbol_list_cutoff) |profile_symbol_list_cutoff| {
            array.writeMany("--profile-symbol-list-cutoff\x00");
            array.writeFormat(fmt.ud64(profile_symbol_list_cutoff));
            array.writeOne(0);
        }
        if (cmd.profile_unknown_in_special_section) {
            array.writeMany("--profile-unknown-in-special-section\x00");
        }
        if (cmd.propagate_attrs) {
            array.writeMany("--propagate-attrs\x00");
        }
        if (cmd.protect_from_escaped_allocas) {
            array.writeMany("--protect-from-escaped-allocas\x00");
        }
        if (cmd.r600_ir_structurize) {
            array.writeMany("--r600-ir-structurize\x00");
        }
        if (cmd.rafast_ignore_missing_defs) {
            array.writeMany("--rafast-ignore-missing-defs\x00");
        }
        if (cmd.rdf_dump) {
            array.writeMany("--rdf-dump\x00");
        }
        if (cmd.rdf_limit) |rdf_limit| {
            array.writeMany("--rdf-limit\x00");
            array.writeFormat(fmt.ud64(rdf_limit));
            array.writeOne(0);
        }
        if (cmd.rdf_liveness_max_rec) |rdf_liveness_max_rec| {
            array.writeMany("--rdf-liveness-max-rec\x00");
            array.writeFormat(fmt.ud64(rdf_liveness_max_rec));
            array.writeOne(0);
        }
        if (cmd.rdf_opt) {
            array.writeMany("--rdf-opt\x00");
        }
        if (cmd.reassociate_geps_verify_no_dead_code) {
            array.writeMany("--reassociate-geps-verify-no-dead-code\x00");
        }
        if (cmd.rebalance_only_imbal) {
            array.writeMany("--rebalance-only-imbal\x00");
        }
        if (cmd.rebalance_only_opt) {
            array.writeMany("--rebalance-only-opt\x00");
        }
        if (cmd.recurrence_chain_limit) |recurrence_chain_limit| {
            array.writeMany("--recurrence-chain-limit\x00");
            array.writeFormat(fmt.ud64(recurrence_chain_limit));
            array.writeOne(0);
        }
        if (cmd.recursive_inline_max_stacksize) |recursive_inline_max_stacksize| {
            array.writeMany("--recursive-inline-max-stacksize\x00");
            array.writeFormat(fmt.ud64(recursive_inline_max_stacksize));
            array.writeOne(0);
        }
        if (cmd.regalloc) |regalloc| {
            array.writeMany("--regalloc\x00");
            array.writeMany(@tagName(regalloc));
            array.writeOne(0);
        }
        if (cmd.regalloc_cheap_remat_weight) |regalloc_cheap_remat_weight| {
            array.writeMany("--regalloc-cheap-remat-weight\x00");
            array.writeFormat(fmt.ud64(regalloc_cheap_remat_weight));
            array.writeOne(0);
        }
        if (cmd.regalloc_copy_weight) |regalloc_copy_weight| {
            array.writeMany("--regalloc-copy-weight\x00");
            array.writeFormat(fmt.ud64(regalloc_copy_weight));
            array.writeOne(0);
        }
        if (cmd.regalloc_csr_first_time_cost) |regalloc_csr_first_time_cost| {
            array.writeMany("--regalloc-csr-first-time-cost\x00");
            array.writeFormat(fmt.ud64(regalloc_csr_first_time_cost));
            array.writeOne(0);
        }
        if (cmd.regalloc_enable_advisor) |regalloc_enable_advisor| {
            array.writeMany("--regalloc-enable-advisor\x00");
            array.writeMany(@tagName(regalloc_enable_advisor));
            array.writeOne(0);
        }
        if (cmd.regalloc_enable_priority_advisor) |regalloc_enable_priority_advisor| {
            array.writeMany("--regalloc-enable-priority-advisor\x00");
            array.writeMany(@tagName(regalloc_enable_priority_advisor));
            array.writeOne(0);
        }
        if (cmd.regalloc_eviction_max_interference_cutoff) |regalloc_eviction_max_interference_cutoff| {
            array.writeMany("--regalloc-eviction-max-interference-cutoff\x00");
            array.writeFormat(fmt.ud64(regalloc_eviction_max_interference_cutoff));
            array.writeOne(0);
        }
        if (cmd.regalloc_expensive_remat_weight) |regalloc_expensive_remat_weight| {
            array.writeMany("--regalloc-expensive-remat-weight\x00");
            array.writeFormat(fmt.ud64(regalloc_expensive_remat_weight));
            array.writeOne(0);
        }
        if (cmd.regalloc_load_weight) |regalloc_load_weight| {
            array.writeMany("--regalloc-load-weight\x00");
            array.writeFormat(fmt.ud64(regalloc_load_weight));
            array.writeOne(0);
        }
        if (cmd.regalloc_store_weight) |regalloc_store_weight| {
            array.writeMany("--regalloc-store-weight\x00");
            array.writeFormat(fmt.ud64(regalloc_store_weight));
            array.writeOne(0);
        }
        if (cmd.regbankselect_fast) {
            array.writeMany("--regbankselect-fast\x00");
        }
        if (cmd.regbankselect_greedy) {
            array.writeMany("--regbankselect-greedy\x00");
        }
        if (cmd.relax_elf_relocations) {
            array.writeMany("--relax-elf-relocations\x00");
        }
        if (cmd.relax_nv_checks) {
            array.writeMany("--relax-nv-checks\x00");
        }
        if (cmd.relocation_model) |relocation_model| {
            array.writeMany("--relocation-model\x00");
            array.writeMany(@tagName(relocation_model));
            array.writeOne(0);
        }
        if (cmd.remarks_section) {
            array.writeMany("--remarks-section\x00");
        }
        if (cmd.remat_pic_stub_load) {
            array.writeMany("--remat-pic-stub-load\x00");
        }
        if (cmd.rename_exclude_alias_prefixes) |rename_exclude_alias_prefixes| {
            array.writeMany("--rename-exclude-alias-prefixes\x00");
            array.writeMany(rename_exclude_alias_prefixes);
            array.writeOne(0);
        }
        if (cmd.rename_exclude_function_prefixes) |rename_exclude_function_prefixes| {
            array.writeMany("--rename-exclude-function-prefixes\x00");
            array.writeMany(rename_exclude_function_prefixes);
            array.writeOne(0);
        }
        if (cmd.rename_exclude_global_prefixes) |rename_exclude_global_prefixes| {
            array.writeMany("--rename-exclude-global-prefixes\x00");
            array.writeMany(rename_exclude_global_prefixes);
            array.writeOne(0);
        }
        if (cmd.rename_exclude_struct_prefixes) |rename_exclude_struct_prefixes| {
            array.writeMany("--rename-exclude-struct-prefixes\x00");
            array.writeMany(rename_exclude_struct_prefixes);
            array.writeOne(0);
        }
        if (cmd.renumber_blocks_before_view) {
            array.writeMany("--renumber-blocks-before-view\x00");
        }
        if (cmd.replexitval) |replexitval| {
            array.writeMany("--replexitval\x00");
            array.writeMany(@tagName(replexitval));
            array.writeOne(0);
        }
        if (cmd.report_profile_staleness) {
            array.writeMany("--report-profile-staleness\x00");
        }
        if (cmd.reroll_num_tolerated_failed_matches) |reroll_num_tolerated_failed_matches| {
            array.writeMany("--reroll-num-tolerated-failed-matches\x00");
            array.writeFormat(fmt.ud64(reroll_num_tolerated_failed_matches));
            array.writeOne(0);
        }
        if (cmd.reserve_regs_for_regalloc) |reserve_regs_for_regalloc| {
            array.writeMany("--reserve-regs-for-regalloc\x00");
            array.writeMany(reserve_regs_for_regalloc);
            array.writeOne(0);
        }
        if (cmd.restrict_statepoint_remat) {
            array.writeMany("--restrict-statepoint-remat\x00");
        }
        if (cmd.reverse_csr_restore_seq) {
            array.writeMany("--reverse-csr-restore-seq\x00");
        }
        if (cmd.rewrite_map_file) |rewrite_map_file| {
            array.writeMany("--rewrite-map-file\x00");
            array.writeMany(rewrite_map_file);
            array.writeOne(0);
        }
        if (cmd.rewrite_phi_limit) |rewrite_phi_limit| {
            array.writeMany("--rewrite-phi-limit\x00");
            array.writeFormat(fmt.ud64(rewrite_phi_limit));
            array.writeOne(0);
        }
        if (cmd.riscv_disable_insert_vsetvl_phi_opt) {
            array.writeMany("--riscv-disable-insert-vsetvl-phi-opt\x00");
        }
        if (cmd.riscv_disable_regalloc_hints) {
            array.writeMany("--riscv-disable-regalloc-hints\x00");
        }
        if (cmd.riscv_disable_sextw_removal) {
            array.writeMany("--riscv-disable-sextw-removal\x00");
        }
        if (cmd.riscv_disable_strip_w_suffix) {
            array.writeMany("--riscv-disable-strip-w-suffix\x00");
        }
        if (cmd.riscv_disable_using_constant_pool_for_large_ints) {
            array.writeMany("--riscv-disable-using-constant-pool-for-large-ints\x00");
        }
        if (cmd.riscv_enable_copyelim) {
            array.writeMany("--riscv-enable-copyelim\x00");
        }
        if (cmd.riscv_enable_global_merge) {
            array.writeMany("--riscv-enable-global-merge\x00");
        }
        if (cmd.riscv_enable_machine_combiner) {
            array.writeMany("--riscv-enable-machine-combiner\x00");
        }
        if (cmd.riscv_enable_subreg_liveness) {
            array.writeMany("--riscv-enable-subreg-liveness\x00");
        }
        if (cmd.riscv_insert_vsetvl_strict_asserts) {
            array.writeMany("--riscv-insert-vsetvl-strict-asserts\x00");
        }
        if (cmd.riscv_lower_ext_max_web_size) |riscv_lower_ext_max_web_size| {
            array.writeMany("--riscv-lower-ext-max-web-size\x00");
            array.writeFormat(fmt.ud64(riscv_lower_ext_max_web_size));
            array.writeOne(0);
        }
        if (cmd.riscv_lower_form_vw_w_with_splat) {
            array.writeMany("--riscv-lower-form-vw-w-with-splat\x00");
        }
        if (cmd.riscv_lower_fp_repeated_divisors) |riscv_lower_fp_repeated_divisors| {
            array.writeMany("--riscv-lower-fp-repeated-divisors\x00");
            array.writeFormat(fmt.ud64(riscv_lower_fp_repeated_divisors));
            array.writeOne(0);
        }
        if (cmd.riscv_max_build_ints_cost) |riscv_max_build_ints_cost| {
            array.writeMany("--riscv-max-build-ints-cost\x00");
            array.writeFormat(fmt.ud64(riscv_max_build_ints_cost));
            array.writeOne(0);
        }
        if (cmd.riscv_no_aliases) {
            array.writeMany("--riscv-no-aliases\x00");
        }
        if (cmd.riscv_prefer_whole_register_move) {
            array.writeMany("--riscv-prefer-whole-register-move\x00");
        }
        if (cmd.riscv_v_fixed_length_vector_lmul_max) |riscv_v_fixed_length_vector_lmul_max| {
            array.writeMany("--riscv-v-fixed-length-vector-lmul-max\x00");
            array.writeFormat(fmt.ud64(riscv_v_fixed_length_vector_lmul_max));
            array.writeOne(0);
        }
        if (cmd.riscv_v_register_bit_width_lmul) |riscv_v_register_bit_width_lmul| {
            array.writeMany("--riscv-v-register-bit-width-lmul\x00");
            array.writeFormat(fmt.ud64(riscv_v_register_bit_width_lmul));
            array.writeOne(0);
        }
        if (cmd.riscv_v_slp_max_vf) |riscv_v_slp_max_vf| {
            array.writeMany("--riscv-v-slp-max-vf\x00");
            array.writeFormat(fmt.ud64(riscv_v_slp_max_vf));
            array.writeOne(0);
        }
        if (cmd.riscv_v_vector_bits_max) |riscv_v_vector_bits_max| {
            array.writeMany("--riscv-v-vector-bits-max\x00");
            array.writeFormat(fmt.ud64(riscv_v_vector_bits_max));
            array.writeOne(0);
        }
        if (cmd.riscv_v_vector_bits_min) |riscv_v_vector_bits_min| {
            array.writeMany("--riscv-v-vector-bits-min\x00");
            array.writeFormat(fmt.ud64(riscv_v_vector_bits_min));
            array.writeOne(0);
        }
        if (cmd.rotation_max_header_size) |rotation_max_header_size| {
            array.writeMany("--rotation-max-header-size\x00");
            array.writeFormat(fmt.ud64(rotation_max_header_size));
            array.writeOne(0);
        }
        if (cmd.rotation_prepare_for_lto) {
            array.writeMany("--rotation-prepare-for-lto\x00");
        }
        if (cmd.rs4gc_allow_statepoint_with_no_deopt_info) {
            array.writeMany("--rs4gc-allow-statepoint-with-no-deopt-info\x00");
        }
        if (cmd.rs4gc_clobber_non_live) {
            array.writeMany("--rs4gc-clobber-non-live\x00");
        }
        if (cmd.rs4gc_remat_derived_at_uses) {
            array.writeMany("--rs4gc-remat-derived-at-uses\x00");
        }
        if (cmd.run_pass) |run_pass| {
            array.writeMany("--run-pass\x00");
            array.writeMany(run_pass);
            array.writeOne(0);
        }
        if (cmd.runtime_check_per_loop_load_elim) |runtime_check_per_loop_load_elim| {
            array.writeMany("--runtime-check-per-loop-load-elim\x00");
            array.writeFormat(fmt.ud64(runtime_check_per_loop_load_elim));
            array.writeOne(0);
        }
        if (cmd.runtime_counter_relocation) {
            array.writeMany("--runtime-counter-relocation\x00");
        }
        if (cmd.runtime_mem_idiom_threshold) |runtime_mem_idiom_threshold| {
            array.writeMany("--runtime-mem-idiom-threshold\x00");
            array.writeFormat(fmt.ud64(runtime_mem_idiom_threshold));
            array.writeOne(0);
        }
        if (cmd.runtime_memory_check_threshold) |runtime_memory_check_threshold| {
            array.writeMany("--runtime-memory-check-threshold\x00");
            array.writeFormat(fmt.ud64(runtime_memory_check_threshold));
            array.writeOne(0);
        }
        if (cmd.safe_stack_coloring) {
            array.writeMany("--safe-stack-coloring\x00");
        }
        if (cmd.safe_stack_layout) {
            array.writeMany("--safe-stack-layout\x00");
        }
        if (cmd.safepoint_ir_verifier_print_only) {
            array.writeMany("--safepoint-ir-verifier-print-only\x00");
        }
        if (cmd.safestack_use_pointer_address) {
            array.writeMany("--safestack-use-pointer-address\x00");
        }
        if (cmd.sample_profile_check_record_coverage) |sample_profile_check_record_coverage| {
            array.writeMany("--sample-profile-check-record-coverage\x00");
            array.writeFormat(fmt.ud64(sample_profile_check_record_coverage));
            array.writeOne(0);
        }
        if (cmd.sample_profile_check_sample_coverage) |sample_profile_check_sample_coverage| {
            array.writeMany("--sample-profile-check-sample-coverage\x00");
            array.writeFormat(fmt.ud64(sample_profile_check_sample_coverage));
            array.writeOne(0);
        }
        if (cmd.sample_profile_cold_inline_threshold) |sample_profile_cold_inline_threshold| {
            array.writeMany("--sample-profile-cold-inline-threshold\x00");
            array.writeFormat(fmt.ud64(sample_profile_cold_inline_threshold));
            array.writeOne(0);
        }
        if (cmd.sample_profile_even_flow_distribution) {
            array.writeMany("--sample-profile-even-flow-distribution\x00");
        }
        if (cmd.sample_profile_file) |sample_profile_file| {
            array.writeMany("--sample-profile-file\x00");
            array.writeMany(sample_profile_file);
            array.writeOne(0);
        }
        if (cmd.sample_profile_hot_inline_threshold) |sample_profile_hot_inline_threshold| {
            array.writeMany("--sample-profile-hot-inline-threshold\x00");
            array.writeFormat(fmt.ud64(sample_profile_hot_inline_threshold));
            array.writeOne(0);
        }
        if (cmd.sample_profile_icp_max_prom) |sample_profile_icp_max_prom| {
            array.writeMany("--sample-profile-icp-max-prom\x00");
            array.writeFormat(fmt.ud64(sample_profile_icp_max_prom));
            array.writeOne(0);
        }
        if (cmd.sample_profile_icp_relative_hotness) |sample_profile_icp_relative_hotness| {
            array.writeMany("--sample-profile-icp-relative-hotness\x00");
            array.writeFormat(fmt.ud64(sample_profile_icp_relative_hotness));
            array.writeOne(0);
        }
        if (cmd.sample_profile_icp_relative_hotness_skip) |sample_profile_icp_relative_hotness_skip| {
            array.writeMany("--sample-profile-icp-relative-hotness-skip\x00");
            array.writeFormat(fmt.ud64(sample_profile_icp_relative_hotness_skip));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_growth_limit) |sample_profile_inline_growth_limit| {
            array.writeMany("--sample-profile-inline-growth-limit\x00");
            array.writeFormat(fmt.ud64(sample_profile_inline_growth_limit));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_limit_max) |sample_profile_inline_limit_max| {
            array.writeMany("--sample-profile-inline-limit-max\x00");
            array.writeFormat(fmt.ud64(sample_profile_inline_limit_max));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_limit_min) |sample_profile_inline_limit_min| {
            array.writeMany("--sample-profile-inline-limit-min\x00");
            array.writeFormat(fmt.ud64(sample_profile_inline_limit_min));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_replay) |sample_profile_inline_replay| {
            array.writeMany("--sample-profile-inline-replay\x00");
            array.writeMany(sample_profile_inline_replay);
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_replay_fallback) |sample_profile_inline_replay_fallback| {
            array.writeMany("--sample-profile-inline-replay-fallback\x00");
            array.writeMany(@tagName(sample_profile_inline_replay_fallback));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_replay_format) |sample_profile_inline_replay_format| {
            array.writeMany("--sample-profile-inline-replay-format\x00");
            array.writeMany(@tagName(sample_profile_inline_replay_format));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_replay_scope) |sample_profile_inline_replay_scope| {
            array.writeMany("--sample-profile-inline-replay-scope\x00");
            array.writeMany(@tagName(sample_profile_inline_replay_scope));
            array.writeOne(0);
        }
        if (cmd.sample_profile_inline_size) {
            array.writeMany("--sample-profile-inline-size\x00");
        }
        if (cmd.sample_profile_join_islands) {
            array.writeMany("--sample-profile-join-islands\x00");
        }
        if (cmd.sample_profile_max_propagate_iterations) |sample_profile_max_propagate_iterations| {
            array.writeMany("--sample-profile-max-propagate-iterations\x00");
            array.writeFormat(fmt.ud64(sample_profile_max_propagate_iterations));
            array.writeOne(0);
        }
        if (cmd.sample_profile_merge_inlinee) {
            array.writeMany("--sample-profile-merge-inlinee\x00");
        }
        if (cmd.sample_profile_prioritized_inline) {
            array.writeMany("--sample-profile-prioritized-inline\x00");
        }
        if (cmd.sample_profile_profi_cost_block_dec) |sample_profile_profi_cost_block_dec| {
            array.writeMany("--sample-profile-profi-cost-block-dec\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_dec));
            array.writeOne(0);
        }
        if (cmd.sample_profile_profi_cost_block_entry_dec) |sample_profile_profi_cost_block_entry_dec| {
            array.writeMany("--sample-profile-profi-cost-block-entry-dec\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_entry_dec));
            array.writeOne(0);
        }
        if (cmd.sample_profile_profi_cost_block_entry_inc) |sample_profile_profi_cost_block_entry_inc| {
            array.writeMany("--sample-profile-profi-cost-block-entry-inc\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_entry_inc));
            array.writeOne(0);
        }
        if (cmd.sample_profile_profi_cost_block_inc) |sample_profile_profi_cost_block_inc| {
            array.writeMany("--sample-profile-profi-cost-block-inc\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_inc));
            array.writeOne(0);
        }
        if (cmd.sample_profile_profi_cost_block_unknown_inc) |sample_profile_profi_cost_block_unknown_inc| {
            array.writeMany("--sample-profile-profi-cost-block-unknown-inc\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_unknown_inc));
            array.writeOne(0);
        }
        if (cmd.sample_profile_profi_cost_block_zero_inc) |sample_profile_profi_cost_block_zero_inc| {
            array.writeMany("--sample-profile-profi-cost-block-zero-inc\x00");
            array.writeFormat(fmt.ud64(sample_profile_profi_cost_block_zero_inc));
            array.writeOne(0);
        }
        if (cmd.sample_profile_rebalance_unknown) {
            array.writeMany("--sample-profile-rebalance-unknown\x00");
        }
        if (cmd.sample_profile_recursive_inline) {
            array.writeMany("--sample-profile-recursive-inline\x00");
        }
        if (cmd.sample_profile_remapping_file) |sample_profile_remapping_file| {
            array.writeMany("--sample-profile-remapping-file\x00");
            array.writeMany(sample_profile_remapping_file);
            array.writeOne(0);
        }
        if (cmd.sample_profile_top_down_load) {
            array.writeMany("--sample-profile-top-down-load\x00");
        }
        if (cmd.sample_profile_use_preinliner) {
            array.writeMany("--sample-profile-use-preinliner\x00");
        }
        if (cmd.sample_profile_use_profi) {
            array.writeMany("--sample-profile-use-profi\x00");
        }
        if (cmd.sanitizer_coverage_control_flow) {
            array.writeMany("--sanitizer-coverage-control-flow\x00");
        }
        if (cmd.sanitizer_coverage_inline_8bit_counters) {
            array.writeMany("--sanitizer-coverage-inline-8bit-counters\x00");
        }
        if (cmd.sanitizer_coverage_inline_bool_flag) {
            array.writeMany("--sanitizer-coverage-inline-bool-flag\x00");
        }
        if (cmd.sanitizer_coverage_level) |sanitizer_coverage_level| {
            array.writeMany("--sanitizer-coverage-level\x00");
            array.writeFormat(fmt.ud64(sanitizer_coverage_level));
            array.writeOne(0);
        }
        if (cmd.sanitizer_coverage_pc_table) {
            array.writeMany("--sanitizer-coverage-pc-table\x00");
        }
        if (cmd.sanitizer_coverage_prune_blocks) {
            array.writeMany("--sanitizer-coverage-prune-blocks\x00");
        }
        if (cmd.sanitizer_coverage_stack_depth) {
            array.writeMany("--sanitizer-coverage-stack-depth\x00");
        }
        if (cmd.sanitizer_coverage_trace_compares) {
            array.writeMany("--sanitizer-coverage-trace-compares\x00");
        }
        if (cmd.sanitizer_coverage_trace_divs) {
            array.writeMany("--sanitizer-coverage-trace-divs\x00");
        }
        if (cmd.sanitizer_coverage_trace_geps) {
            array.writeMany("--sanitizer-coverage-trace-geps\x00");
        }
        if (cmd.sanitizer_coverage_trace_loads) {
            array.writeMany("--sanitizer-coverage-trace-loads\x00");
        }
        if (cmd.sanitizer_coverage_trace_pc) {
            array.writeMany("--sanitizer-coverage-trace-pc\x00");
        }
        if (cmd.sanitizer_coverage_trace_pc_guard) {
            array.writeMany("--sanitizer-coverage-trace-pc-guard\x00");
        }
        if (cmd.sanitizer_coverage_trace_stores) {
            array.writeMany("--sanitizer-coverage-trace-stores\x00");
        }
        if (cmd.sanitizer_metadata_atomics) {
            array.writeMany("--sanitizer-metadata-atomics\x00");
        }
        if (cmd.sanitizer_metadata_covered) {
            array.writeMany("--sanitizer-metadata-covered\x00");
        }
        if (cmd.sanitizer_metadata_uar) {
            array.writeMany("--sanitizer-metadata-uar\x00");
        }
        if (cmd.sanitizer_metadata_weak_callbacks) {
            array.writeMany("--sanitizer-metadata-weak-callbacks\x00");
        }
        if (cmd.scalable_vectorization) |scalable_vectorization| {
            array.writeMany("--scalable-vectorization\x00");
            array.writeMany(@tagName(scalable_vectorization));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_classify_expressions) {
            array.writeMany("--scalar-evolution-classify-expressions\x00");
        }
        if (cmd.scalar_evolution_finite_loop) {
            array.writeMany("--scalar-evolution-finite-loop\x00");
        }
        if (cmd.scalar_evolution_huge_expr_threshold) |scalar_evolution_huge_expr_threshold| {
            array.writeMany("--scalar-evolution-huge-expr-threshold\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_huge_expr_threshold));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_add_rec_size) |scalar_evolution_max_add_rec_size| {
            array.writeMany("--scalar-evolution-max-add-rec-size\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_add_rec_size));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_arith_depth) |scalar_evolution_max_arith_depth| {
            array.writeMany("--scalar-evolution-max-arith-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_arith_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_cast_depth) |scalar_evolution_max_cast_depth| {
            array.writeMany("--scalar-evolution-max-cast-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_cast_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_constant_evolving_depth) |scalar_evolution_max_constant_evolving_depth| {
            array.writeMany("--scalar-evolution-max-constant-evolving-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_constant_evolving_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_scc_analysis_depth) |scalar_evolution_max_scc_analysis_depth| {
            array.writeMany("--scalar-evolution-max-scc-analysis-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_scc_analysis_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_scev_compare_depth) |scalar_evolution_max_scev_compare_depth| {
            array.writeMany("--scalar-evolution-max-scev-compare-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_scev_compare_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_scev_operations_implication_depth) |scalar_evolution_max_scev_operations_implication_depth| {
            array.writeMany("--scalar-evolution-max-scev-operations-implication-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_scev_operations_implication_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_max_value_compare_depth) |scalar_evolution_max_value_compare_depth| {
            array.writeMany("--scalar-evolution-max-value-compare-depth\x00");
            array.writeFormat(fmt.ud64(scalar_evolution_max_value_compare_depth));
            array.writeOne(0);
        }
        if (cmd.scalar_evolution_use_context_for_no_wrap_flag_strenghening) {
            array.writeMany("--scalar-evolution-use-context-for-no-wrap-flag-strenghening\x00");
        }
        if (cmd.scalar_evolution_use_expensive_range_sharpening) {
            array.writeMany("--scalar-evolution-use-expensive-range-sharpening\x00");
        }
        if (cmd.scalarize_load_store) {
            array.writeMany("--scalarize-load-store\x00");
        }
        if (cmd.scalarize_variable_insert_extract) {
            array.writeMany("--scalarize-variable-insert-extract\x00");
        }
        if (cmd.scale_partial_sample_profile_working_set_size) {
            array.writeMany("--scale-partial-sample-profile-working-set-size\x00");
        }
        if (cmd.scev_addops_inline_threshold) |scev_addops_inline_threshold| {
            array.writeMany("--scev-addops-inline-threshold\x00");
            array.writeFormat(fmt.ud64(scev_addops_inline_threshold));
            array.writeOne(0);
        }
        if (cmd.scev_cheap_expansion_budget) |scev_cheap_expansion_budget| {
            array.writeMany("--scev-cheap-expansion-budget\x00");
            array.writeFormat(fmt.ud64(scev_cheap_expansion_budget));
            array.writeOne(0);
        }
        if (cmd.scev_mulops_inline_threshold) |scev_mulops_inline_threshold| {
            array.writeMany("--scev-mulops-inline-threshold\x00");
            array.writeFormat(fmt.ud64(scev_mulops_inline_threshold));
            array.writeOne(0);
        }
        if (cmd.scev_range_iter_threshold) |scev_range_iter_threshold| {
            array.writeMany("--scev-range-iter-threshold\x00");
            array.writeFormat(fmt.ud64(scev_range_iter_threshold));
            array.writeOne(0);
        }
        if (cmd.scev_verify_ir) {
            array.writeMany("--scev-verify-ir\x00");
        }
        if (cmd.sched_avg_ipc) |sched_avg_ipc| {
            array.writeMany("--sched-avg-ipc\x00");
            array.writeFormat(fmt.ud64(sched_avg_ipc));
            array.writeOne(0);
        }
        if (cmd.sched_high_latency_cycles) |sched_high_latency_cycles| {
            array.writeMany("--sched-high-latency-cycles\x00");
            array.writeFormat(fmt.ud64(sched_high_latency_cycles));
            array.writeOne(0);
        }
        if (cmd.sched_preds_closer) {
            array.writeMany("--sched-preds-closer\x00");
        }
        if (cmd.sched_retval_optimization) {
            array.writeMany("--sched-retval-optimization\x00");
        }
        if (cmd.scheditins) {
            array.writeMany("--scheditins\x00");
        }
        if (cmd.schedmodel) {
            array.writeMany("--schedmodel\x00");
        }
        if (cmd.schedule_ppc_vsx_fma_mutation_early) {
            array.writeMany("--schedule-ppc-vsx-fma-mutation-early\x00");
        }
        if (cmd.select_opti_loop_cycle_gain_threshold) |select_opti_loop_cycle_gain_threshold| {
            array.writeMany("--select-opti-loop-cycle-gain-threshold\x00");
            array.writeFormat(fmt.ud64(select_opti_loop_cycle_gain_threshold));
            array.writeOne(0);
        }
        if (cmd.select_opti_loop_gradient_gain_threshold) |select_opti_loop_gradient_gain_threshold| {
            array.writeMany("--select-opti-loop-gradient-gain-threshold\x00");
            array.writeFormat(fmt.ud64(select_opti_loop_gradient_gain_threshold));
            array.writeOne(0);
        }
        if (cmd.select_opti_loop_relative_gain_threshold) |select_opti_loop_relative_gain_threshold| {
            array.writeMany("--select-opti-loop-relative-gain-threshold\x00");
            array.writeFormat(fmt.ud64(select_opti_loop_relative_gain_threshold));
            array.writeOne(0);
        }
        if (cmd.sgpr_regalloc) |sgpr_regalloc| {
            array.writeMany("--sgpr-regalloc\x00");
            array.writeMany(@tagName(sgpr_regalloc));
            array.writeOne(0);
        }
        if (cmd.show_fs_branchprob) {
            array.writeMany("--show-fs-branchprob\x00");
        }
        if (cmd.show_mc_encoding) {
            array.writeMany("--show-mc-encoding\x00");
        }
        if (cmd.shrink_frame_limit) |shrink_frame_limit| {
            array.writeMany("--shrink-frame-limit\x00");
            array.writeFormat(fmt.ud64(shrink_frame_limit));
            array.writeOne(0);
        }
        if (cmd.simple_loop_unswitch_drop_non_trivial_implicit_null_checks) {
            array.writeMany("--simple-loop-unswitch-drop-non-trivial-implicit-null-checks\x00");
        }
        if (cmd.simple_loop_unswitch_guards) {
            array.writeMany("--simple-loop-unswitch-guards\x00");
        }
        if (cmd.simple_loop_unswitch_memoryssa_threshold) |simple_loop_unswitch_memoryssa_threshold| {
            array.writeMany("--simple-loop-unswitch-memoryssa-threshold\x00");
            array.writeFormat(fmt.ud64(simple_loop_unswitch_memoryssa_threshold));
            array.writeOne(0);
        }
        if (cmd.simplify_mir) {
            array.writeMany("--simplify-mir\x00");
        }
        if (cmd.simplifycfg_branch_fold_common_dest_vector_multiplier) |simplifycfg_branch_fold_common_dest_vector_multiplier| {
            array.writeMany("--simplifycfg-branch-fold-common-dest-vector-multiplier\x00");
            array.writeFormat(fmt.ud64(simplifycfg_branch_fold_common_dest_vector_multiplier));
            array.writeOne(0);
        }
        if (cmd.simplifycfg_branch_fold_threshold) |simplifycfg_branch_fold_threshold| {
            array.writeMany("--simplifycfg-branch-fold-threshold\x00");
            array.writeFormat(fmt.ud64(simplifycfg_branch_fold_threshold));
            array.writeOne(0);
        }
        if (cmd.simplifycfg_hoist_common) {
            array.writeMany("--simplifycfg-hoist-common\x00");
        }
        if (cmd.simplifycfg_hoist_common_skip_limit) |simplifycfg_hoist_common_skip_limit| {
            array.writeMany("--simplifycfg-hoist-common-skip-limit\x00");
            array.writeFormat(fmt.ud64(simplifycfg_hoist_common_skip_limit));
            array.writeOne(0);
        }
        if (cmd.simplifycfg_hoist_cond_stores) {
            array.writeMany("--simplifycfg-hoist-cond-stores\x00");
        }
        if (cmd.simplifycfg_max_small_block_size) |simplifycfg_max_small_block_size| {
            array.writeMany("--simplifycfg-max-small-block-size\x00");
            array.writeFormat(fmt.ud64(simplifycfg_max_small_block_size));
            array.writeOne(0);
        }
        if (cmd.simplifycfg_merge_compatible_invokes) {
            array.writeMany("--simplifycfg-merge-compatible-invokes\x00");
        }
        if (cmd.simplifycfg_merge_cond_stores) {
            array.writeMany("--simplifycfg-merge-cond-stores\x00");
        }
        if (cmd.simplifycfg_merge_cond_stores_aggressively) {
            array.writeMany("--simplifycfg-merge-cond-stores-aggressively\x00");
        }
        if (cmd.simplifycfg_require_and_preserve_domtree) {
            array.writeMany("--simplifycfg-require-and-preserve-domtree\x00");
        }
        if (cmd.simplifycfg_sink_common) {
            array.writeMany("--simplifycfg-sink-common\x00");
        }
        if (cmd.sink_common_insts) {
            array.writeMany("--sink-common-insts\x00");
        }
        if (cmd.sink_freq_percent_threshold) |sink_freq_percent_threshold| {
            array.writeMany("--sink-freq-percent-threshold\x00");
            array.writeFormat(fmt.ud64(sink_freq_percent_threshold));
            array.writeOne(0);
        }
        if (cmd.sink_insts_to_avoid_spills) {
            array.writeMany("--sink-insts-to-avoid-spills\x00");
        }
        if (cmd.skip_mips_long_branch) {
            array.writeMany("--skip-mips-long-branch\x00");
        }
        if (cmd.skip_ret_exit_block) {
            array.writeMany("--skip-ret-exit-block\x00");
        }
        if (cmd.slot1_store_slot0_load) {
            array.writeMany("--slot1-store-slot0-load\x00");
        }
        if (cmd.slp_max_look_ahead_depth) |slp_max_look_ahead_depth| {
            array.writeMany("--slp-max-look-ahead-depth\x00");
            array.writeFormat(fmt.ud64(slp_max_look_ahead_depth));
            array.writeOne(0);
        }
        if (cmd.slp_max_reg_size) |slp_max_reg_size| {
            array.writeMany("--slp-max-reg-size\x00");
            array.writeFormat(fmt.ud64(slp_max_reg_size));
            array.writeOne(0);
        }
        if (cmd.slp_max_root_look_ahead_depth) |slp_max_root_look_ahead_depth| {
            array.writeMany("--slp-max-root-look-ahead-depth\x00");
            array.writeFormat(fmt.ud64(slp_max_root_look_ahead_depth));
            array.writeOne(0);
        }
        if (cmd.slp_max_store_lookup) |slp_max_store_lookup| {
            array.writeMany("--slp-max-store-lookup\x00");
            array.writeFormat(fmt.ud64(slp_max_store_lookup));
            array.writeOne(0);
        }
        if (cmd.slp_max_vf) |slp_max_vf| {
            array.writeMany("--slp-max-vf\x00");
            array.writeFormat(fmt.ud64(slp_max_vf));
            array.writeOne(0);
        }
        if (cmd.slp_min_reg_size) |slp_min_reg_size| {
            array.writeMany("--slp-min-reg-size\x00");
            array.writeFormat(fmt.ud64(slp_min_reg_size));
            array.writeOne(0);
        }
        if (cmd.slp_min_tree_size) |slp_min_tree_size| {
            array.writeMany("--slp-min-tree-size\x00");
            array.writeFormat(fmt.ud64(slp_min_tree_size));
            array.writeOne(0);
        }
        if (cmd.slp_recursion_max_depth) |slp_recursion_max_depth| {
            array.writeMany("--slp-recursion-max-depth\x00");
            array.writeFormat(fmt.ud64(slp_recursion_max_depth));
            array.writeOne(0);
        }
        if (cmd.slp_schedule_budget) |slp_schedule_budget| {
            array.writeMany("--slp-schedule-budget\x00");
            array.writeFormat(fmt.ud64(slp_schedule_budget));
            array.writeOne(0);
        }
        if (cmd.slp_threshold) |slp_threshold| {
            array.writeMany("--slp-threshold\x00");
            array.writeFormat(fmt.ud64(slp_threshold));
            array.writeOne(0);
        }
        if (cmd.slp_vectorize_hor) {
            array.writeMany("--slp-vectorize-hor\x00");
        }
        if (cmd.slp_vectorize_hor_store) {
            array.writeMany("--slp-vectorize-hor-store\x00");
        }
        if (cmd.small_loop_cost) |small_loop_cost| {
            array.writeMany("--small-loop-cost\x00");
            array.writeFormat(fmt.ud64(small_loop_cost));
            array.writeOne(0);
        }
        if (cmd.sort_profiled_scc_member) {
            array.writeMany("--sort-profiled-scc-member\x00");
        }
        if (cmd.sort_timers) {
            array.writeMany("--sort-timers\x00");
        }
        if (cmd.sparc_bpcc_offset_bits) |sparc_bpcc_offset_bits| {
            array.writeMany("--sparc-bpcc-offset-bits\x00");
            array.writeFormat(fmt.ud64(sparc_bpcc_offset_bits));
            array.writeOne(0);
        }
        if (cmd.sparc_enable_branch_relax) {
            array.writeMany("--sparc-enable-branch-relax\x00");
        }
        if (cmd.sparc_reserve_app_registers) {
            array.writeMany("--sparc-reserve-app-registers\x00");
        }
        if (cmd.spec_exec_max_not_hoisted) |spec_exec_max_not_hoisted| {
            array.writeMany("--spec-exec-max-not-hoisted\x00");
            array.writeFormat(fmt.ud64(spec_exec_max_not_hoisted));
            array.writeOne(0);
        }
        if (cmd.spec_exec_max_speculation_cost) |spec_exec_max_speculation_cost| {
            array.writeMany("--spec-exec-max-speculation-cost\x00");
            array.writeFormat(fmt.ud64(spec_exec_max_speculation_cost));
            array.writeOne(0);
        }
        if (cmd.spec_exec_only_if_divergent_target) {
            array.writeMany("--spec-exec-only-if-divergent-target\x00");
        }
        if (cmd.speculate_one_expensive_inst) {
            array.writeMany("--speculate-one-expensive-inst\x00");
        }
        if (cmd.speculative_counter_promotion_max_exiting) |speculative_counter_promotion_max_exiting| {
            array.writeMany("--speculative-counter-promotion-max-exiting\x00");
            array.writeFormat(fmt.ud64(speculative_counter_promotion_max_exiting));
            array.writeOne(0);
        }
        if (cmd.speculative_counter_promotion_to_loop) {
            array.writeMany("--speculative-counter-promotion-to-loop\x00");
        }
        if (cmd.spill_func_threshold) |spill_func_threshold| {
            array.writeMany("--spill-func-threshold\x00");
            array.writeFormat(fmt.ud64(spill_func_threshold));
            array.writeOne(0);
        }
        if (cmd.spill_func_threshold_Os) |spill_func_threshold_Os| {
            array.writeMany("--spill-func-threshold-Os\x00");
            array.writeFormat(fmt.ud64(spill_func_threshold_Os));
            array.writeOne(0);
        }
        if (cmd.split_dwarf_cross_cu_references) {
            array.writeMany("--split-dwarf-cross-cu-references\x00");
        }
        if (cmd.split_dwarf_file) |split_dwarf_file| {
            array.writeMany("--split-dwarf-file\x00");
            array.writeMany(split_dwarf_file);
            array.writeOne(0);
        }
        if (cmd.split_dwarf_output) |split_dwarf_output| {
            array.writeMany("--split-dwarf-output\x00");
            array.writeMany(split_dwarf_output);
            array.writeOne(0);
        }
        if (cmd.split_machine_functions) {
            array.writeMany("--split-machine-functions\x00");
        }
        if (cmd.split_spill_mode) |split_spill_mode| {
            array.writeMany("--split-spill-mode\x00");
            array.writeMany(@tagName(split_spill_mode));
            array.writeOne(0);
        }
        if (cmd.spp_all_backedges) {
            array.writeMany("--spp-all-backedges\x00");
        }
        if (cmd.spp_counted_loop_trip_width) |spp_counted_loop_trip_width| {
            array.writeMany("--spp-counted-loop-trip-width\x00");
            array.writeFormat(fmt.ud64(spp_counted_loop_trip_width));
            array.writeOne(0);
        }
        if (cmd.spp_no_backedge) {
            array.writeMany("--spp-no-backedge\x00");
        }
        if (cmd.spp_no_call) {
            array.writeMany("--spp-no-call\x00");
        }
        if (cmd.spp_no_entry) {
            array.writeMany("--spp-no-entry\x00");
        }
        if (cmd.spp_print_base_pointers) {
            array.writeMany("--spp-print-base-pointers\x00");
        }
        if (cmd.spp_print_liveset) {
            array.writeMany("--spp-print-liveset\x00");
        }
        if (cmd.spp_print_liveset_size) {
            array.writeMany("--spp-print-liveset-size\x00");
        }
        if (cmd.spp_rematerialization_threshold) |spp_rematerialization_threshold| {
            array.writeMany("--spp-rematerialization-threshold\x00");
            array.writeFormat(fmt.ud64(spp_rematerialization_threshold));
            array.writeOne(0);
        }
        if (cmd.spp_split_backedge) {
            array.writeMany("--spp-split-backedge\x00");
        }
        if (cmd.sroa_strict_inbounds) {
            array.writeMany("--sroa-strict-inbounds\x00");
        }
        if (cmd.ssc_dce_limit) |ssc_dce_limit| {
            array.writeMany("--ssc-dce-limit\x00");
            array.writeFormat(fmt.ud64(ssc_dce_limit));
            array.writeOne(0);
        }
        if (cmd.stack_safety_max_iterations) |stack_safety_max_iterations| {
            array.writeMany("--stack-safety-max-iterations\x00");
            array.writeFormat(fmt.ud64(stack_safety_max_iterations));
            array.writeOne(0);
        }
        if (cmd.stack_safety_print) {
            array.writeMany("--stack-safety-print\x00");
        }
        if (cmd.stack_safety_run) {
            array.writeMany("--stack-safety-run\x00");
        }
        if (cmd.stack_size_section) {
            array.writeMany("--stack-size-section\x00");
        }
        if (cmd.stack_symbol_ordering) {
            array.writeMany("--stack-symbol-ordering\x00");
        }
        if (cmd.stack_tagging_first_slot_opt) {
            array.writeMany("--stack-tagging-first-slot-opt\x00");
        }
        if (cmd.stack_tagging_merge_init) {
            array.writeMany("--stack-tagging-merge-init\x00");
        }
        if (cmd.stack_tagging_merge_init_scan_limit) |stack_tagging_merge_init_scan_limit| {
            array.writeMany("--stack-tagging-merge-init-scan-limit\x00");
            array.writeFormat(fmt.ud64(stack_tagging_merge_init_scan_limit));
            array.writeOne(0);
        }
        if (cmd.stack_tagging_merge_init_size_limit) |stack_tagging_merge_init_size_limit| {
            array.writeMany("--stack-tagging-merge-init-size-limit\x00");
            array.writeFormat(fmt.ud64(stack_tagging_merge_init_size_limit));
            array.writeOne(0);
        }
        if (cmd.stack_tagging_merge_settag) {
            array.writeMany("--stack-tagging-merge-settag\x00");
        }
        if (cmd.stack_tagging_unchecked_ld_st) |stack_tagging_unchecked_ld_st| {
            array.writeMany("--stack-tagging-unchecked-ld-st\x00");
            array.writeMany(@tagName(stack_tagging_unchecked_ld_st));
            array.writeOne(0);
        }
        if (cmd.stack_tagging_use_stack_safety) {
            array.writeMany("--stack-tagging-use-stack-safety\x00");
        }
        if (cmd.stackcoloring_lifetime_start_on_first_use) {
            array.writeMany("--stackcoloring-lifetime-start-on-first-use\x00");
        }
        if (cmd.stackmap_version) |stackmap_version| {
            array.writeMany("--stackmap-version\x00");
            array.writeFormat(fmt.ud64(stackmap_version));
            array.writeOne(0);
        }
        if (cmd.stackrealign) {
            array.writeMany("--stackrealign\x00");
        }
        if (cmd.start_after) |start_after| {
            array.writeMany("--start-after\x00");
            array.writeMany(start_after);
            array.writeOne(0);
        }
        if (cmd.start_before) |start_before| {
            array.writeMany("--start-before\x00");
            array.writeMany(start_before);
            array.writeOne(0);
        }
        if (cmd.static_func_full_module_prefix) {
            array.writeMany("--static-func-full-module-prefix\x00");
        }
        if (cmd.static_func_strip_dirname_prefix) |static_func_strip_dirname_prefix| {
            array.writeMany("--static-func-strip-dirname-prefix\x00");
            array.writeFormat(fmt.ud64(static_func_strip_dirname_prefix));
            array.writeOne(0);
        }
        if (cmd.static_likely_prob) |static_likely_prob| {
            array.writeMany("--static-likely-prob\x00");
            array.writeFormat(fmt.ud64(static_likely_prob));
            array.writeOne(0);
        }
        if (cmd.stats) {
            array.writeMany("--stats\x00");
        }
        if (cmd.stats_json) {
            array.writeMany("--stats-json\x00");
        }
        if (cmd.stop_after) |stop_after| {
            array.writeMany("--stop-after\x00");
            array.writeMany(stop_after);
            array.writeOne(0);
        }
        if (cmd.stop_before) |stop_before| {
            array.writeMany("--stop-before\x00");
            array.writeMany(stop_before);
            array.writeOne(0);
        }
        if (cmd.store_to_load_forwarding_conflict_detection) {
            array.writeMany("--store-to-load-forwarding-conflict-detection\x00");
        }
        if (cmd.stress_cgp_ext_ld_promotion) {
            array.writeMany("--stress-cgp-ext-ld-promotion\x00");
        }
        if (cmd.stress_cgp_store_extract) {
            array.writeMany("--stress-cgp-store-extract\x00");
        }
        if (cmd.stress_early_ifcvt) {
            array.writeMany("--stress-early-ifcvt\x00");
        }
        if (cmd.stress_regalloc) |stress_regalloc| {
            array.writeMany("--stress-regalloc\x00");
            array.writeFormat(fmt.ud64(stress_regalloc));
            array.writeOne(0);
        }
        if (cmd.strict_dwarf) {
            array.writeMany("--strict-dwarf\x00");
        }
        if (cmd.structurizecfg_relaxed_uniform_regions) {
            array.writeMany("--structurizecfg-relaxed-uniform-regions\x00");
        }
        if (cmd.structurizecfg_skip_uniform_regions) {
            array.writeMany("--structurizecfg-skip-uniform-regions\x00");
        }
        if (cmd.summary_file) |summary_file| {
            array.writeMany("--summary-file\x00");
            array.writeMany(summary_file);
            array.writeOne(0);
        }
        if (cmd.sve_gather_overhead) |sve_gather_overhead| {
            array.writeMany("--sve-gather-overhead\x00");
            array.writeFormat(fmt.ud64(sve_gather_overhead));
            array.writeOne(0);
        }
        if (cmd.sve_scatter_overhead) |sve_scatter_overhead| {
            array.writeMany("--sve-scatter-overhead\x00");
            array.writeFormat(fmt.ud64(sve_scatter_overhead));
            array.writeOne(0);
        }
        if (cmd.sve_tail_folding) |sve_tail_folding| {
            array.writeMany("--sve-tail-folding\x00");
            array.writeMany(sve_tail_folding);
            array.writeOne(0);
        }
        if (cmd.swift_async_fp) |swift_async_fp| {
            array.writeMany("--swift-async-fp\x00");
            array.writeMany(@tagName(swift_async_fp));
            array.writeOne(0);
        }
        if (cmd.switch_peel_threshold) |switch_peel_threshold| {
            array.writeMany("--switch-peel-threshold\x00");
            array.writeFormat(fmt.ud64(switch_peel_threshold));
            array.writeOne(0);
        }
        if (cmd.switch_range_to_icmp) {
            array.writeMany("--switch-range-to-icmp\x00");
        }
        if (cmd.switch_to_lookup) {
            array.writeMany("--switch-to-lookup\x00");
        }
        if (cmd.systemz_subreg_liveness) {
            array.writeMany("--systemz-subreg-liveness\x00");
        }
        if (cmd.t2_reduce_limit) |t2_reduce_limit| {
            array.writeMany("--t2-reduce-limit\x00");
            array.writeFormat(fmt.ud64(t2_reduce_limit));
            array.writeOne(0);
        }
        if (cmd.t2_reduce_limit2) |t2_reduce_limit2| {
            array.writeMany("--t2-reduce-limit2\x00");
            array.writeFormat(fmt.ud64(t2_reduce_limit2));
            array.writeOne(0);
        }
        if (cmd.t2_reduce_limit3) |t2_reduce_limit3| {
            array.writeMany("--t2-reduce-limit3\x00");
            array.writeFormat(fmt.ud64(t2_reduce_limit3));
            array.writeOne(0);
        }
        if (cmd.tail_dup_indirect_size) |tail_dup_indirect_size| {
            array.writeMany("--tail-dup-indirect-size\x00");
            array.writeFormat(fmt.ud64(tail_dup_indirect_size));
            array.writeOne(0);
        }
        if (cmd.tail_dup_limit) |tail_dup_limit| {
            array.writeMany("--tail-dup-limit\x00");
            array.writeFormat(fmt.ud64(tail_dup_limit));
            array.writeOne(0);
        }
        if (cmd.tail_dup_placement) {
            array.writeMany("--tail-dup-placement\x00");
        }
        if (cmd.tail_dup_placement_aggressive_threshold) |tail_dup_placement_aggressive_threshold| {
            array.writeMany("--tail-dup-placement-aggressive-threshold\x00");
            array.writeFormat(fmt.ud64(tail_dup_placement_aggressive_threshold));
            array.writeOne(0);
        }
        if (cmd.tail_dup_placement_penalty) |tail_dup_placement_penalty| {
            array.writeMany("--tail-dup-placement-penalty\x00");
            array.writeFormat(fmt.ud64(tail_dup_placement_penalty));
            array.writeOne(0);
        }
        if (cmd.tail_dup_placement_threshold) |tail_dup_placement_threshold| {
            array.writeMany("--tail-dup-placement-threshold\x00");
            array.writeFormat(fmt.ud64(tail_dup_placement_threshold));
            array.writeOne(0);
        }
        if (cmd.tail_dup_profile_percent_threshold) |tail_dup_profile_percent_threshold| {
            array.writeMany("--tail-dup-profile-percent-threshold\x00");
            array.writeFormat(fmt.ud64(tail_dup_profile_percent_threshold));
            array.writeOne(0);
        }
        if (cmd.tail_dup_size) |tail_dup_size| {
            array.writeMany("--tail-dup-size\x00");
            array.writeFormat(fmt.ud64(tail_dup_size));
            array.writeOne(0);
        }
        if (cmd.tail_dup_verify) {
            array.writeMany("--tail-dup-verify\x00");
        }
        if (cmd.tail_merge_size) |tail_merge_size| {
            array.writeMany("--tail-merge-size\x00");
            array.writeFormat(fmt.ud64(tail_merge_size));
            array.writeOne(0);
        }
        if (cmd.tail_merge_threshold) |tail_merge_threshold| {
            array.writeMany("--tail-merge-threshold\x00");
            array.writeFormat(fmt.ud64(tail_merge_threshold));
            array.writeOne(0);
        }
        if (cmd.tail_predication) |tail_predication| {
            array.writeMany("--tail-predication\x00");
            array.writeMany(@tagName(tail_predication));
            array.writeOne(0);
        }
        if (cmd.tailcallopt) {
            array.writeMany("--tailcallopt\x00");
        }
        if (cmd.target_abi) |target_abi| {
            array.writeMany("--target-abi\x00");
            array.writeMany(target_abi);
            array.writeOne(0);
        }
        if (cmd.temporal_reuse_threshold) |temporal_reuse_threshold| {
            array.writeMany("--temporal-reuse-threshold\x00");
            array.writeFormat(fmt.ud64(temporal_reuse_threshold));
            array.writeOne(0);
        }
        if (cmd.terminal_rule) {
            array.writeMany("--terminal-rule\x00");
        }
        if (cmd.tfutils_use_simplelogger) {
            array.writeMany("--tfutils-use-simplelogger\x00");
        }
        if (cmd.thinlto_assume_merged) {
            array.writeMany("--thinlto-assume-merged\x00");
        }
        if (cmd.thinlto_synthesize_entry_counts) {
            array.writeMany("--thinlto-synthesize-entry-counts\x00");
        }
        if (cmd.thread_model) |thread_model| {
            array.writeMany("--thread-model\x00");
            array.writeMany(@tagName(thread_model));
            array.writeOne(0);
        }
        if (cmd.threads) |threads| {
            array.writeMany("--threads\x00");
            array.writeFormat(fmt.ud64(threads));
            array.writeOne(0);
        }
        if (cmd.time_compilations) |time_compilations| {
            array.writeMany("--time-compilations\x00");
            array.writeFormat(fmt.ud64(time_compilations));
            array.writeOne(0);
        }
        if (cmd.time_passes) {
            array.writeMany("--time-passes\x00");
        }
        if (cmd.time_passes_per_run) {
            array.writeMany("--time-passes-per-run\x00");
        }
        if (cmd.time_trace) {
            array.writeMany("--time-trace\x00");
        }
        if (cmd.time_trace_file) |time_trace_file| {
            array.writeMany("--time-trace-file\x00");
            array.writeMany(time_trace_file);
            array.writeOne(0);
        }
        if (cmd.time_trace_granularity) |time_trace_granularity| {
            array.writeMany("--time-trace-granularity\x00");
            array.writeFormat(fmt.ud64(time_trace_granularity));
            array.writeOne(0);
        }
        if (cmd.tiny_trip_count_interleave_threshold) |tiny_trip_count_interleave_threshold| {
            array.writeMany("--tiny-trip-count-interleave-threshold\x00");
            array.writeFormat(fmt.ud64(tiny_trip_count_interleave_threshold));
            array.writeOne(0);
        }
        if (cmd.tls_load_hoist) {
            array.writeMany("--tls-load-hoist\x00");
        }
        if (cmd.tls_size) |tls_size| {
            array.writeMany("--tls-size\x00");
            array.writeFormat(fmt.ud64(tls_size));
            array.writeOne(0);
        }
        if (cmd.trace_gv_placement) {
            array.writeMany("--trace-gv-placement\x00");
        }
        if (cmd.trace_hex_vector_stores_only) {
            array.writeMany("--trace-hex-vector-stores-only\x00");
        }
        if (cmd.track_memory) {
            array.writeMany("--track-memory\x00");
        }
        if (cmd.trap_func) |trap_func| {
            array.writeMany("--trap-func\x00");
            array.writeMany(trap_func);
            array.writeOne(0);
        }
        if (cmd.trap_unreachable) {
            array.writeMany("--trap-unreachable\x00");
        }
        if (cmd.treat_scalable_fixed_error_as_warning) {
            array.writeMany("--treat-scalable-fixed-error-as-warning\x00");
        }
        if (cmd.triangle_chain_count) |triangle_chain_count| {
            array.writeMany("--triangle-chain-count\x00");
            array.writeFormat(fmt.ud64(triangle_chain_count));
            array.writeOne(0);
        }
        if (cmd.trim_var_locs) {
            array.writeMany("--trim-var-locs\x00");
        }
        if (cmd.tsan_compound_read_before_write) {
            array.writeMany("--tsan-compound-read-before-write\x00");
        }
        if (cmd.tsan_distinguish_volatile) {
            array.writeMany("--tsan-distinguish-volatile\x00");
        }
        if (cmd.tsan_handle_cxx_exceptions) {
            array.writeMany("--tsan-handle-cxx-exceptions\x00");
        }
        if (cmd.tsan_instrument_atomics) {
            array.writeMany("--tsan-instrument-atomics\x00");
        }
        if (cmd.tsan_instrument_func_entry_exit) {
            array.writeMany("--tsan-instrument-func-entry-exit\x00");
        }
        if (cmd.tsan_instrument_memintrinsics) {
            array.writeMany("--tsan-instrument-memintrinsics\x00");
        }
        if (cmd.tsan_instrument_memory_accesses) {
            array.writeMany("--tsan-instrument-memory-accesses\x00");
        }
        if (cmd.tsan_instrument_read_before_write) {
            array.writeMany("--tsan-instrument-read-before-write\x00");
        }
        if (cmd.two_entry_phi_node_folding_threshold) |two_entry_phi_node_folding_threshold| {
            array.writeMany("--two-entry-phi-node-folding-threshold\x00");
            array.writeFormat(fmt.ud64(two_entry_phi_node_folding_threshold));
            array.writeOne(0);
        }
        if (cmd.twoaddr_reschedule) {
            array.writeMany("--twoaddr-reschedule\x00");
        }
        if (cmd.type_based_intrinsic_cost) {
            array.writeMany("--type-based-intrinsic-cost\x00");
        }
        if (cmd.undef_reg_clearance) |undef_reg_clearance| {
            array.writeMany("--undef-reg-clearance\x00");
            array.writeFormat(fmt.ud64(undef_reg_clearance));
            array.writeOne(0);
        }
        if (cmd.unique_basic_block_section_names) {
            array.writeMany("--unique-basic-block-section-names\x00");
        }
        if (cmd.unique_section_names) {
            array.writeMany("--unique-section-names\x00");
        }
        if (cmd.unlikely_branch_weight) |unlikely_branch_weight| {
            array.writeMany("--unlikely-branch-weight\x00");
            array.writeFormat(fmt.ud64(unlikely_branch_weight));
            array.writeOne(0);
        }
        if (cmd.unroll_allow_loop_nests_peeling) {
            array.writeMany("--unroll-allow-loop-nests-peeling\x00");
        }
        if (cmd.unroll_allow_partial) {
            array.writeMany("--unroll-allow-partial\x00");
        }
        if (cmd.unroll_allow_peeling) {
            array.writeMany("--unroll-allow-peeling\x00");
        }
        if (cmd.unroll_allow_remainder) {
            array.writeMany("--unroll-allow-remainder\x00");
        }
        if (cmd.unroll_and_jam_count) |unroll_and_jam_count| {
            array.writeMany("--unroll-and-jam-count\x00");
            array.writeFormat(fmt.ud64(unroll_and_jam_count));
            array.writeOne(0);
        }
        if (cmd.unroll_and_jam_threshold) |unroll_and_jam_threshold| {
            array.writeMany("--unroll-and-jam-threshold\x00");
            array.writeFormat(fmt.ud64(unroll_and_jam_threshold));
            array.writeOne(0);
        }
        if (cmd.unroll_count) |unroll_count| {
            array.writeMany("--unroll-count\x00");
            array.writeFormat(fmt.ud64(unroll_count));
            array.writeOne(0);
        }
        if (cmd.unroll_force_peel_count) |unroll_force_peel_count| {
            array.writeMany("--unroll-force-peel-count\x00");
            array.writeFormat(fmt.ud64(unroll_force_peel_count));
            array.writeOne(0);
        }
        if (cmd.unroll_full_max_count) |unroll_full_max_count| {
            array.writeMany("--unroll-full-max-count\x00");
            array.writeFormat(fmt.ud64(unroll_full_max_count));
            array.writeOne(0);
        }
        if (cmd.unroll_max_count) |unroll_max_count| {
            array.writeMany("--unroll-max-count\x00");
            array.writeFormat(fmt.ud64(unroll_max_count));
            array.writeOne(0);
        }
        if (cmd.unroll_max_iteration_count_to_analyze) |unroll_max_iteration_count_to_analyze| {
            array.writeMany("--unroll-max-iteration-count-to-analyze\x00");
            array.writeFormat(fmt.ud64(unroll_max_iteration_count_to_analyze));
            array.writeOne(0);
        }
        if (cmd.unroll_max_percent_threshold_boost) |unroll_max_percent_threshold_boost| {
            array.writeMany("--unroll-max-percent-threshold-boost\x00");
            array.writeFormat(fmt.ud64(unroll_max_percent_threshold_boost));
            array.writeOne(0);
        }
        if (cmd.unroll_max_upperbound) |unroll_max_upperbound| {
            array.writeMany("--unroll-max-upperbound\x00");
            array.writeFormat(fmt.ud64(unroll_max_upperbound));
            array.writeOne(0);
        }
        if (cmd.unroll_optsize_threshold) |unroll_optsize_threshold| {
            array.writeMany("--unroll-optsize-threshold\x00");
            array.writeFormat(fmt.ud64(unroll_optsize_threshold));
            array.writeOne(0);
        }
        if (cmd.unroll_partial_threshold) |unroll_partial_threshold| {
            array.writeMany("--unroll-partial-threshold\x00");
            array.writeFormat(fmt.ud64(unroll_partial_threshold));
            array.writeOne(0);
        }
        if (cmd.unroll_peel_count) |unroll_peel_count| {
            array.writeMany("--unroll-peel-count\x00");
            array.writeFormat(fmt.ud64(unroll_peel_count));
            array.writeOne(0);
        }
        if (cmd.unroll_peel_max_count) |unroll_peel_max_count| {
            array.writeMany("--unroll-peel-max-count\x00");
            array.writeFormat(fmt.ud64(unroll_peel_max_count));
            array.writeOne(0);
        }
        if (cmd.unroll_remainder) {
            array.writeMany("--unroll-remainder\x00");
        }
        if (cmd.unroll_revisit_child_loops) {
            array.writeMany("--unroll-revisit-child-loops\x00");
        }
        if (cmd.unroll_runtime) {
            array.writeMany("--unroll-runtime\x00");
        }
        if (cmd.unroll_runtime_epilog) {
            array.writeMany("--unroll-runtime-epilog\x00");
        }
        if (cmd.unroll_runtime_multi_exit) {
            array.writeMany("--unroll-runtime-multi-exit\x00");
        }
        if (cmd.unroll_runtime_other_exit_predictable) {
            array.writeMany("--unroll-runtime-other-exit-predictable\x00");
        }
        if (cmd.unroll_threshold) |unroll_threshold| {
            array.writeMany("--unroll-threshold\x00");
            array.writeFormat(fmt.ud64(unroll_threshold));
            array.writeOne(0);
        }
        if (cmd.unroll_threshold_aggressive) |unroll_threshold_aggressive| {
            array.writeMany("--unroll-threshold-aggressive\x00");
            array.writeFormat(fmt.ud64(unroll_threshold_aggressive));
            array.writeOne(0);
        }
        if (cmd.unroll_threshold_default) |unroll_threshold_default| {
            array.writeMany("--unroll-threshold-default\x00");
            array.writeFormat(fmt.ud64(unroll_threshold_default));
            array.writeOne(0);
        }
        if (cmd.unroll_verify_domtree) {
            array.writeMany("--unroll-verify-domtree\x00");
        }
        if (cmd.unroll_verify_loopinfo) {
            array.writeMany("--unroll-verify-loopinfo\x00");
        }
        if (cmd.unswitch_num_initial_unscaled_candidates) |unswitch_num_initial_unscaled_candidates| {
            array.writeMany("--unswitch-num-initial-unscaled-candidates\x00");
            array.writeFormat(fmt.ud64(unswitch_num_initial_unscaled_candidates));
            array.writeOne(0);
        }
        if (cmd.unswitch_siblings_toplevel_div) |unswitch_siblings_toplevel_div| {
            array.writeMany("--unswitch-siblings-toplevel-div\x00");
            array.writeFormat(fmt.ud64(unswitch_siblings_toplevel_div));
            array.writeOne(0);
        }
        if (cmd.unswitch_threshold) |unswitch_threshold| {
            array.writeMany("--unswitch-threshold\x00");
            array.writeFormat(fmt.ud64(unswitch_threshold));
            array.writeOne(0);
        }
        if (cmd.update_pseudo_probe) {
            array.writeMany("--update-pseudo-probe\x00");
        }
        if (cmd.update_return_attrs) {
            array.writeMany("--update-return-attrs\x00");
        }
        if (cmd.use_ctors) {
            array.writeMany("--use-ctors\x00");
        }
        if (cmd.use_dbg_addr) {
            array.writeMany("--use-dbg-addr\x00");
        }
        if (cmd.use_dereferenceable_at_point_semantics) |use_dereferenceable_at_point_semantics| {
            array.writeMany("--use-dereferenceable-at-point-semantics\x00");
            array.writeFormat(fmt.ud64(use_dereferenceable_at_point_semantics));
            array.writeOne(0);
        }
        if (cmd.use_dwarf_ranges_base_address_specifier) {
            array.writeMany("--use-dwarf-ranges-base-address-specifier\x00");
        }
        if (cmd.use_gnu_debug_macro) {
            array.writeMany("--use-gnu-debug-macro\x00");
        }
        if (cmd.use_gpu_divergence_analysis) {
            array.writeMany("--use-gpu-divergence-analysis\x00");
        }
        if (cmd.use_iterative_bfi_inference) {
            array.writeMany("--use-iterative-bfi-inference\x00");
        }
        if (cmd.use_leb128_directives) {
            array.writeMany("--use-leb128-directives\x00");
        }
        if (cmd.use_lir_code_size_heurs) {
            array.writeMany("--use-lir-code-size-heurs\x00");
        }
        if (cmd.use_mbpi) {
            array.writeMany("--use-mbpi\x00");
        }
        if (cmd.use_newer_candidate) {
            array.writeMany("--use-newer-candidate\x00");
        }
        if (cmd.use_noalias_intrinsic_during_inlining) {
            array.writeMany("--use-noalias-intrinsic-during-inlining\x00");
        }
        if (cmd.use_profiled_call_graph) {
            array.writeMany("--use-profiled-call-graph\x00");
        }
        if (cmd.use_registers_for_deopt_values) {
            array.writeMany("--use-registers-for-deopt-values\x00");
        }
        if (cmd.use_registers_for_gc_values_in_landing_pad) {
            array.writeMany("--use-registers-for-gc-values-in-landing-pad\x00");
        }
        if (cmd.use_segment_set_for_physregs) {
            array.writeMany("--use-segment-set-for-physregs\x00");
        }
        if (cmd.use_source_filename_for_promoted_locals) {
            array.writeMany("--use-source-filename-for-promoted-locals\x00");
        }
        if (cmd.use_tbaa_in_sched_mi) {
            array.writeMany("--use-tbaa-in-sched-mi\x00");
        }
        if (cmd.use_unknown_locations) |use_unknown_locations| {
            array.writeMany("--use-unknown-locations\x00");
            array.writeMany(@tagName(use_unknown_locations));
            array.writeOne(0);
        }
        if (cmd.vec_extabi) {
            array.writeMany("--vec-extabi\x00");
        }
        if (cmd.vector_combine_max_scan_instrs) |vector_combine_max_scan_instrs| {
            array.writeMany("--vector-combine-max-scan-instrs\x00");
            array.writeFormat(fmt.ud64(vector_combine_max_scan_instrs));
            array.writeOne(0);
        }
        if (cmd.vector_library) |vector_library| {
            array.writeMany("--vector-library\x00");
            array.writeMany(@tagName(vector_library));
            array.writeOne(0);
        }
        if (cmd.vectorize_loops) {
            array.writeMany("--vectorize-loops\x00");
        }
        if (cmd.vectorize_memory_check_threshold) |vectorize_memory_check_threshold| {
            array.writeMany("--vectorize-memory-check-threshold\x00");
            array.writeFormat(fmt.ud64(vectorize_memory_check_threshold));
            array.writeOne(0);
        }
        if (cmd.vectorize_num_stores_pred) |vectorize_num_stores_pred| {
            array.writeMany("--vectorize-num-stores-pred\x00");
            array.writeFormat(fmt.ud64(vectorize_num_stores_pred));
            array.writeOne(0);
        }
        if (cmd.vectorize_scev_check_threshold) |vectorize_scev_check_threshold| {
            array.writeMany("--vectorize-scev-check-threshold\x00");
            array.writeFormat(fmt.ud64(vectorize_scev_check_threshold));
            array.writeOne(0);
        }
        if (cmd.vectorize_slp) {
            array.writeMany("--vectorize-slp\x00");
        }
        if (cmd.vectorizer_maximize_bandwidth) {
            array.writeMany("--vectorizer-maximize-bandwidth\x00");
        }
        if (cmd.vectorizer_min_trip_count) |vectorizer_min_trip_count| {
            array.writeMany("--vectorizer-min-trip-count\x00");
            array.writeFormat(fmt.ud64(vectorizer_min_trip_count));
            array.writeOne(0);
        }
        if (cmd.verify_arm_pseudo_expand) {
            array.writeMany("--verify-arm-pseudo-expand\x00");
        }
        if (cmd.verify_assumption_cache) {
            array.writeMany("--verify-assumption-cache\x00");
        }
        if (cmd.verify_cfg_preserved) {
            array.writeMany("--verify-cfg-preserved\x00");
        }
        if (cmd.verify_cfiinstrs) {
            array.writeMany("--verify-cfiinstrs\x00");
        }
        if (cmd.verify_coalescing) {
            array.writeMany("--verify-coalescing\x00");
        }
        if (cmd.verify_dom_info) {
            array.writeMany("--verify-dom-info\x00");
        }
        if (cmd.verify_indvars) {
            array.writeMany("--verify-indvars\x00");
        }
        if (cmd.verify_loop_info) {
            array.writeMany("--verify-loop-info\x00");
        }
        if (cmd.verify_loop_lcssa) {
            array.writeMany("--verify-loop-lcssa\x00");
        }
        if (cmd.verify_machine_dom_info) {
            array.writeMany("--verify-machine-dom-info\x00");
        }
        if (cmd.verify_machineinstrs) {
            array.writeMany("--verify-machineinstrs\x00");
        }
        if (cmd.verify_memoryssa) {
            array.writeMany("--verify-memoryssa\x00");
        }
        if (cmd.verify_misched) {
            array.writeMany("--verify-misched\x00");
        }
        if (cmd.verify_noalias_scope_decl_dom) {
            array.writeMany("--verify-noalias-scope-decl-dom\x00");
        }
        if (cmd.verify_predicateinfo) {
            array.writeMany("--verify-predicateinfo\x00");
        }
        if (cmd.verify_pseudo_probe) {
            array.writeMany("--verify-pseudo-probe\x00");
        }
        if (cmd.verify_pseudo_probe_funcs) |verify_pseudo_probe_funcs| {
            array.writeMany("--verify-pseudo-probe-funcs\x00");
            array.writeMany(verify_pseudo_probe_funcs);
            array.writeOne(0);
        }
        if (cmd.verify_regalloc) {
            array.writeMany("--verify-regalloc\x00");
        }
        if (cmd.verify_region_info) {
            array.writeMany("--verify-region-info\x00");
        }
        if (cmd.verify_scev) {
            array.writeMany("--verify-scev\x00");
        }
        if (cmd.verify_scev_maps) {
            array.writeMany("--verify-scev-maps\x00");
        }
        if (cmd.verify_scev_strict) {
            array.writeMany("--verify-scev-strict\x00");
        }
        if (cmd.version) {
            array.writeMany("--version\x00");
        }
        if (cmd.vgpr_regalloc) |vgpr_regalloc| {
            array.writeMany("--vgpr-regalloc\x00");
            array.writeMany(@tagName(vgpr_regalloc));
            array.writeOne(0);
        }
        if (cmd.view_bfi_func_name) |view_bfi_func_name| {
            array.writeMany("--view-bfi-func-name\x00");
            array.writeMany(view_bfi_func_name);
            array.writeOne(0);
        }
        if (cmd.view_block_freq_propagation_dags) |view_block_freq_propagation_dags| {
            array.writeMany("--view-block-freq-propagation-dags\x00");
            array.writeMany(@tagName(view_block_freq_propagation_dags));
            array.writeOne(0);
        }
        if (cmd.view_block_layout_with_bfi) |view_block_layout_with_bfi| {
            array.writeMany("--view-block-layout-with-bfi\x00");
            array.writeMany(@tagName(view_block_layout_with_bfi));
            array.writeOne(0);
        }
        if (cmd.view_edge_bundles) {
            array.writeMany("--view-edge-bundles\x00");
        }
        if (cmd.view_hot_freq_percent) |view_hot_freq_percent| {
            array.writeMany("--view-hot-freq-percent\x00");
            array.writeFormat(fmt.ud64(view_hot_freq_percent));
            array.writeOne(0);
        }
        if (cmd.view_machine_block_freq_propagation_dags) |view_machine_block_freq_propagation_dags| {
            array.writeMany("--view-machine-block-freq-propagation-dags\x00");
            array.writeMany(@tagName(view_machine_block_freq_propagation_dags));
            array.writeOne(0);
        }
        if (cmd.view_slp_tree) {
            array.writeMany("--view-slp-tree\x00");
        }
        if (cmd.vliw_misched_reg_pressure) |vliw_misched_reg_pressure| {
            array.writeMany("--vliw-misched-reg-pressure\x00");
            array.writeFormat(fmt.ud64(vliw_misched_reg_pressure));
            array.writeOne(0);
        }
        if (cmd.vp_counters_per_site) |vp_counters_per_site| {
            array.writeMany("--vp-counters-per-site\x00");
            array.writeFormat(fmt.ud64(vp_counters_per_site));
            array.writeOne(0);
        }
        if (cmd.vp_static_alloc) {
            array.writeMany("--vp-static-alloc\x00");
        }
        if (cmd.vplan_build_stress_test) {
            array.writeMany("--vplan-build-stress-test\x00");
        }
        if (cmd.vplan_print_in_dot_format) {
            array.writeMany("--vplan-print-in-dot-format\x00");
        }
        if (cmd.vplan_verify_hcfg) {
            array.writeMany("--vplan-verify-hcfg\x00");
        }
        if (cmd.wasm_disable_explicit_locals) {
            array.writeMany("--wasm-disable-explicit-locals\x00");
        }
        if (cmd.wasm_enable_eh) {
            array.writeMany("--wasm-enable-eh\x00");
        }
        if (cmd.wasm_enable_sjlj) {
            array.writeMany("--wasm-enable-sjlj\x00");
        }
        if (cmd.wasm_keep_registers) {
            array.writeMany("--wasm-keep-registers\x00");
        }
        if (cmd.whole_program_visibility) {
            array.writeMany("--whole-program-visibility\x00");
        }
        if (cmd.wholeprogramdevirt_branch_funnel_threshold) |wholeprogramdevirt_branch_funnel_threshold| {
            array.writeMany("--wholeprogramdevirt-branch-funnel-threshold\x00");
            array.writeFormat(fmt.ud64(wholeprogramdevirt_branch_funnel_threshold));
            array.writeOne(0);
        }
        if (cmd.wholeprogramdevirt_check) |wholeprogramdevirt_check| {
            array.writeMany("--wholeprogramdevirt-check\x00");
            array.writeMany(@tagName(wholeprogramdevirt_check));
            array.writeOne(0);
        }
        if (cmd.wholeprogramdevirt_print_index_based) {
            array.writeMany("--wholeprogramdevirt-print-index-based\x00");
        }
        if (cmd.wholeprogramdevirt_read_summary) |wholeprogramdevirt_read_summary| {
            array.writeMany("--wholeprogramdevirt-read-summary\x00");
            array.writeMany(wholeprogramdevirt_read_summary);
            array.writeOne(0);
        }
        if (cmd.wholeprogramdevirt_skip) |wholeprogramdevirt_skip| {
            array.writeMany("--wholeprogramdevirt-skip\x00");
            array.writeMany(wholeprogramdevirt_skip);
            array.writeOne(0);
        }
        if (cmd.wholeprogramdevirt_summary_action) |wholeprogramdevirt_summary_action| {
            array.writeMany("--wholeprogramdevirt-summary-action\x00");
            array.writeMany(@tagName(wholeprogramdevirt_summary_action));
            array.writeOne(0);
        }
        if (cmd.wholeprogramdevirt_write_summary) |wholeprogramdevirt_write_summary| {
            array.writeMany("--wholeprogramdevirt-write-summary\x00");
            array.writeMany(wholeprogramdevirt_write_summary);
            array.writeOne(0);
        }
        if (cmd.write_relbf_to_summary) {
            array.writeMany("--write-relbf-to-summary\x00");
        }
        if (cmd.x86_align_branch) |x86_align_branch| {
            array.writeMany("--x86-align-branch\x00");
            array.writeMany(x86_align_branch);
            array.writeOne(0);
        }
        if (cmd.x86_align_branch_boundary) |x86_align_branch_boundary| {
            array.writeMany("--x86-align-branch-boundary\x00");
            array.writeFormat(fmt.ud64(x86_align_branch_boundary));
            array.writeOne(0);
        }
        if (cmd.x86_and_imm_shrink) {
            array.writeMany("--x86-and-imm-shrink\x00");
        }
        if (cmd.x86_asm_syntax) |x86_asm_syntax| {
            array.writeMany("--x86-asm-syntax\x00");
            array.writeMany(@tagName(x86_asm_syntax));
            array.writeOne(0);
        }
        if (cmd.x86_branches_within_32B_boundaries) {
            array.writeMany("--x86-branches-within-32B-boundaries\x00");
        }
        if (cmd.x86_bypass_prefetch_instructions) {
            array.writeMany("--x86-bypass-prefetch-instructions\x00");
        }
        if (cmd.x86_cmov_converter) {
            array.writeMany("--x86-cmov-converter\x00");
        }
        if (cmd.x86_cmov_converter_force_all) {
            array.writeMany("--x86-cmov-converter-force-all\x00");
        }
        if (cmd.x86_cmov_converter_force_mem_operand) {
            array.writeMany("--x86-cmov-converter-force-mem-operand\x00");
        }
        if (cmd.x86_cmov_converter_threshold) |x86_cmov_converter_threshold| {
            array.writeMany("--x86-cmov-converter-threshold\x00");
            array.writeFormat(fmt.ud64(x86_cmov_converter_threshold));
            array.writeOne(0);
        }
        if (cmd.x86_disable_avoid_SFB) {
            array.writeMany("--x86-disable-avoid-SFB\x00");
        }
        if (cmd.x86_discriminate_memops) {
            array.writeMany("--x86-discriminate-memops\x00");
        }
        if (cmd.x86_early_ifcvt) {
            array.writeMany("--x86-early-ifcvt\x00");
        }
        if (cmd.x86_experimental_lvi_inline_asm_hardening) {
            array.writeMany("--x86-experimental-lvi-inline-asm-hardening\x00");
        }
        if (cmd.x86_experimental_pref_innermost_loop_alignment) |x86_experimental_pref_innermost_loop_alignment| {
            array.writeMany("--x86-experimental-pref-innermost-loop-alignment\x00");
            array.writeFormat(fmt.ud64(x86_experimental_pref_innermost_loop_alignment));
            array.writeOne(0);
        }
        if (cmd.x86_experimental_unordered_atomic_isel) {
            array.writeMany("--x86-experimental-unordered-atomic-isel\x00");
        }
        if (cmd.x86_indirect_branch_tracking) {
            array.writeMany("--x86-indirect-branch-tracking\x00");
        }
        if (cmd.x86_lvi_load_dot) {
            array.writeMany("--x86-lvi-load-dot\x00");
        }
        if (cmd.x86_lvi_load_dot_only) {
            array.writeMany("--x86-lvi-load-dot-only\x00");
        }
        if (cmd.x86_lvi_load_dot_verify) {
            array.writeMany("--x86-lvi-load-dot-verify\x00");
        }
        if (cmd.x86_lvi_load_no_cbranch) {
            array.writeMany("--x86-lvi-load-no-cbranch\x00");
        }
        if (cmd.x86_lvi_load_opt_plugin) |x86_lvi_load_opt_plugin| {
            array.writeMany("--x86-lvi-load-opt-plugin\x00");
            array.writeMany(x86_lvi_load_opt_plugin);
            array.writeOne(0);
        }
        if (cmd.x86_machine_combiner) {
            array.writeMany("--x86-machine-combiner\x00");
        }
        if (cmd.x86_pad_for_align) {
            array.writeMany("--x86-pad-for-align\x00");
        }
        if (cmd.x86_pad_for_branch_align) {
            array.writeMany("--x86-pad-for-branch-align\x00");
        }
        if (cmd.x86_pad_max_prefix_size) |x86_pad_max_prefix_size| {
            array.writeMany("--x86-pad-max-prefix-size\x00");
            array.writeFormat(fmt.ud64(x86_pad_max_prefix_size));
            array.writeOne(0);
        }
        if (cmd.x86_promote_anyext_load) {
            array.writeMany("--x86-promote-anyext-load\x00");
        }
        if (cmd.x86_seses_enable_without_lvi_cfi) {
            array.writeMany("--x86-seses-enable-without-lvi-cfi\x00");
        }
        if (cmd.x86_seses_omit_branch_lfences) {
            array.writeMany("--x86-seses-omit-branch-lfences\x00");
        }
        if (cmd.x86_seses_one_lfence_per_bb) {
            array.writeMany("--x86-seses-one-lfence-per-bb\x00");
        }
        if (cmd.x86_seses_only_lfence_non_const) {
            array.writeMany("--x86-seses-only-lfence-non-const\x00");
        }
        if (cmd.x86_sfb_inspection_limit) |x86_sfb_inspection_limit| {
            array.writeMany("--x86-sfb-inspection-limit\x00");
            array.writeFormat(fmt.ud64(x86_sfb_inspection_limit));
            array.writeOne(0);
        }
        if (cmd.x86_slh_fence_call_and_ret) {
            array.writeMany("--x86-slh-fence-call-and-ret\x00");
        }
        if (cmd.x86_slh_indirect) {
            array.writeMany("--x86-slh-indirect\x00");
        }
        if (cmd.x86_slh_ip) {
            array.writeMany("--x86-slh-ip\x00");
        }
        if (cmd.x86_slh_lfence) {
            array.writeMany("--x86-slh-lfence\x00");
        }
        if (cmd.x86_slh_loads) {
            array.writeMany("--x86-slh-loads\x00");
        }
        if (cmd.x86_slh_post_load) {
            array.writeMany("--x86-slh-post-load\x00");
        }
        if (cmd.x86_speculative_load_hardening) {
            array.writeMany("--x86-speculative-load-hardening\x00");
        }
        if (cmd.x86_tile_ra) {
            array.writeMany("--x86-tile-ra\x00");
        }
        if (cmd.x86_use_base_pointer) {
            array.writeMany("--x86-use-base-pointer\x00");
        }
        if (cmd.x86_use_fsrm_for_memcpy) {
            array.writeMany("--x86-use-fsrm-for-memcpy\x00");
        }
        if (cmd.x86_use_vzeroupper) {
            array.writeMany("--x86-use-vzeroupper\x00");
        }
        if (cmd.xcoff_traceback_table) {
            array.writeMany("--xcoff-traceback-table\x00");
        }
        if (cmd.xcore_max_threads) |xcore_max_threads| {
            array.writeMany("--xcore-max-threads\x00");
            array.writeFormat(fmt.ud64(xcore_max_threads));
            array.writeOne(0);
        }
    }
    pub fn formatParseArgs(cmd: *LLCCommand, allocator: *types.Allocator, args: [][*:0]u8) void {
        @setRuntimeSafety(builtin.is_safe);
        var args_idx: usize = 0;
        while (args_idx != args.len) : (args_idx +%= 1) {
            var arg: [:0]u8 = mem.terminate(args[args_idx], 0);
            if (mem.testEqualString("--aarch64-a57-fp-load-balancing-force-all", arg)) {
                cmd.aarch64_a57_fp_load_balancing_force_all = true;
            } else if (mem.testEqualString("--aarch64-a57-fp-load-balancing-override", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_a57_fp_load_balancing_override = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-bcc-offset-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_bcc_offset_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-cbz-offset-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_cbz_offset_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-ccmp-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_ccmp_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-early-ifcvt", arg)) {
                cmd.aarch64_early_ifcvt = true;
            } else if (mem.testEqualString("--aarch64-elf-ldtls-generation", arg)) {
                cmd.aarch64_elf_ldtls_generation = true;
            } else if (mem.testEqualString("--aarch64-enable-atomic-cfg-tidy", arg)) {
                cmd.aarch64_enable_atomic_cfg_tidy = true;
            } else if (mem.testEqualString("--aarch64-enable-branch-relax", arg)) {
                cmd.aarch64_enable_branch_relax = true;
            } else if (mem.testEqualString("--aarch64-enable-branch-targets", arg)) {
                cmd.aarch64_enable_branch_targets = true;
            } else if (mem.testEqualString("--aarch64-enable-ccmp", arg)) {
                cmd.aarch64_enable_ccmp = true;
            } else if (mem.testEqualString("--aarch64-enable-collect-loh", arg)) {
                cmd.aarch64_enable_collect_loh = true;
            } else if (mem.testEqualString("--aarch64-enable-compress-jump-tables", arg)) {
                cmd.aarch64_enable_compress_jump_tables = true;
            } else if (mem.testEqualString("--aarch64-enable-cond-br-tune", arg)) {
                cmd.aarch64_enable_cond_br_tune = true;
            } else if (mem.testEqualString("--aarch64-enable-condopt", arg)) {
                cmd.aarch64_enable_condopt = true;
            } else if (mem.testEqualString("--aarch64-enable-copy-propagation", arg)) {
                cmd.aarch64_enable_copy_propagation = true;
            } else if (mem.testEqualString("--aarch64-enable-copyelim", arg)) {
                cmd.aarch64_enable_copyelim = true;
            } else if (mem.testEqualString("--aarch64-enable-dead-defs", arg)) {
                cmd.aarch64_enable_dead_defs = true;
            } else if (mem.testEqualString("--aarch64-enable-early-ifcvt", arg)) {
                cmd.aarch64_enable_early_ifcvt = true;
            } else if (mem.testEqualString("--aarch64-enable-falkor-hwpf-fix", arg)) {
                cmd.aarch64_enable_falkor_hwpf_fix = true;
            } else if (mem.testEqualString("--aarch64-enable-gep-opt", arg)) {
                cmd.aarch64_enable_gep_opt = true;
            } else if (mem.testEqualString("--aarch64-enable-gisel-ldst-postlegal", arg)) {
                cmd.aarch64_enable_gisel_ldst_postlegal = true;
            } else if (mem.testEqualString("--aarch64-enable-gisel-ldst-prelegal", arg)) {
                cmd.aarch64_enable_gisel_ldst_prelegal = true;
            } else if (mem.testEqualString("--aarch64-enable-global-isel-at-O", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_enable_global_isel_at_O = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-enable-global-merge", arg)) {
                cmd.aarch64_enable_global_merge = true;
            } else if (mem.testEqualString("--aarch64-enable-ldst-opt", arg)) {
                cmd.aarch64_enable_ldst_opt = true;
            } else if (mem.testEqualString("--aarch64-enable-logical-imm", arg)) {
                cmd.aarch64_enable_logical_imm = true;
            } else if (mem.testEqualString("--aarch64-enable-loop-data-prefetch", arg)) {
                cmd.aarch64_enable_loop_data_prefetch = true;
            } else if (mem.testEqualString("--aarch64-enable-mcr", arg)) {
                cmd.aarch64_enable_mcr = true;
            } else if (mem.testEqualString("--aarch64-enable-mgather-combine", arg)) {
                cmd.aarch64_enable_mgather_combine = true;
            } else if (mem.testEqualString("--aarch64-enable-nonlazybind", arg)) {
                cmd.aarch64_enable_nonlazybind = true;
            } else if (mem.testEqualString("--aarch64-enable-promote-const", arg)) {
                cmd.aarch64_enable_promote_const = true;
            } else if (mem.testEqualString("--aarch64-enable-simd-scalar", arg)) {
                cmd.aarch64_enable_simd_scalar = true;
            } else if (mem.testEqualString("--aarch64-enable-stp-suppress", arg)) {
                cmd.aarch64_enable_stp_suppress = true;
            } else if (mem.testEqualString("--aarch64-enable-sve-intrinsic-opts", arg)) {
                cmd.aarch64_enable_sve_intrinsic_opts = true;
            } else if (mem.testEqualString("--aarch64-insert-extract-base-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_insert_extract_base_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-load-store-renaming", arg)) {
                cmd.aarch64_load_store_renaming = true;
            } else if (mem.testEqualString("--aarch64-load-store-scan-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_load_store_scan_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-mark-bti-property", arg)) {
                cmd.aarch64_mark_bti_property = true;
            } else if (mem.testEqualString("--aarch64-max-xors", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_max_xors = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-order-frame-objects", arg)) {
                cmd.aarch64_order_frame_objects = true;
            } else if (mem.testEqualString("--aarch64-redzone", arg)) {
                cmd.aarch64_redzone = true;
            } else if (mem.testEqualString("--aarch64-select-opt", arg)) {
                cmd.aarch64_select_opt = true;
            } else if (mem.testEqualString("--aarch64-simd-scalar-force-all", arg)) {
                cmd.aarch64_simd_scalar_force_all = true;
            } else if (mem.testEqualString("--aarch64-slh-loads", arg)) {
                cmd.aarch64_slh_loads = true;
            } else if (mem.testEqualString("--aarch64-stress-ccmp", arg)) {
                cmd.aarch64_stress_ccmp = true;
            } else if (mem.testEqualString("--aarch64-stress-promote-const", arg)) {
                cmd.aarch64_stress_promote_const = true;
            } else if (mem.testEqualString("--aarch64-sve-vector-bits-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_sve_vector_bits_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-sve-vector-bits-min", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_sve_vector_bits_min = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-tbz-offset-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_tbz_offset_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-update-scan-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64_update_scan_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64-use-aa", arg)) {
                cmd.aarch64_use_aa = true;
            } else if (mem.testEqualString("--aarch64-use-tbi", arg)) {
                cmd.aarch64_use_tbi = true;
            } else if (mem.testEqualString("--aarch64o0prelegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64o0prelegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64o0prelegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64o0prelegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64postlegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64postlegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64postlegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64postlegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64postlegalizerloweringhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64postlegalizerloweringhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64postlegalizerloweringhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64postlegalizerloweringhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64prelegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64prelegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aarch64prelegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aarch64prelegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--abort-on-max-devirt-iterations-reached", arg)) {
                cmd.abort_on_max_devirt_iterations_reached = true;
            } else if (mem.testEqualString("--adce-remove-control-flow", arg)) {
                cmd.adce_remove_control_flow = true;
            } else if (mem.testEqualString("--adce-remove-loops", arg)) {
                cmd.adce_remove_loops = true;
            } else if (mem.testEqualString("--addr-sink-combine-base-gv", arg)) {
                cmd.addr_sink_combine_base_gv = true;
            } else if (mem.testEqualString("--addr-sink-combine-base-offs", arg)) {
                cmd.addr_sink_combine_base_offs = true;
            } else if (mem.testEqualString("--addr-sink-combine-base-reg", arg)) {
                cmd.addr_sink_combine_base_reg = true;
            } else if (mem.testEqualString("--addr-sink-combine-scaled-reg", arg)) {
                cmd.addr_sink_combine_scaled_reg = true;
            } else if (mem.testEqualString("--addr-sink-new-phis", arg)) {
                cmd.addr_sink_new_phis = true;
            } else if (mem.testEqualString("--addr-sink-new-select", arg)) {
                cmd.addr_sink_new_select = true;
            } else if (mem.testEqualString("--addr-sink-using-gep", arg)) {
                cmd.addr_sink_using_gep = true;
            } else if (mem.testEqualString("--addrsig", arg)) {
                cmd.addrsig = true;
            } else if (mem.testEqualString("--agg-antidep-debugdiv", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.agg_antidep_debugdiv = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--agg-antidep-debugmod", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.agg_antidep_debugmod = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aggregate-extracted-args", arg)) {
                cmd.aggregate_extracted_args = true;
            } else if (mem.testEqualString("--aggressive-ext-opt", arg)) {
                cmd.aggressive_ext_opt = true;
            } else if (mem.testEqualString("--aggressive-instcombine-max-scan-instrs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.aggressive_instcombine_max_scan_instrs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--aix-ssp-tb-bit", arg)) {
                cmd.aix_ssp_tb_bit = true;
            } else if (mem.testEqualString("--alias-set-saturation-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.alias_set_saturation_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--align-all-blocks", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.align_all_blocks = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--align-all-functions", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.align_all_functions = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--align-all-nofallthru-blocks", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.align_all_nofallthru_blocks = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--align-loops", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.align_loops = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--align-neon-spills", arg)) {
                cmd.align_neon_spills = true;
            } else if (mem.testEqualString("--allow-arm-wlsloops", arg)) {
                cmd.allow_arm_wlsloops = true;
            } else if (mem.testEqualString("--allow-ginsert-as-artifact", arg)) {
                cmd.allow_ginsert_as_artifact = true;
            } else if (mem.testEqualString("--allow-unroll-and-jam", arg)) {
                cmd.allow_unroll_and_jam = true;
            } else if (mem.testEqualString("--amdgcn-skip-cache-invalidations", arg)) {
                cmd.amdgcn_skip_cache_invalidations = true;
            } else if (mem.testEqualString("--amdgpu-any-address-space-out-arguments", arg)) {
                cmd.amdgpu_any_address_space_out_arguments = true;
            } else if (mem.testEqualString("--amdgpu-assume-dynamic-stack-object-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_assume_dynamic_stack_object_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-assume-external-call-stack-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_assume_external_call_stack_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-atomic-optimizations", arg)) {
                cmd.amdgpu_atomic_optimizations = true;
            } else if (mem.testEqualString("--amdgpu-bypass-slow-div", arg)) {
                cmd.amdgpu_bypass_slow_div = true;
            } else if (mem.testEqualString("--amdgpu-dce-in-ra", arg)) {
                cmd.amdgpu_dce_in_ra = true;
            } else if (mem.testEqualString("--amdgpu-disable-loop-alignment", arg)) {
                cmd.amdgpu_disable_loop_alignment = true;
            } else if (mem.testEqualString("--amdgpu-disable-unclustred-high-rp-reschedule", arg)) {
                cmd.amdgpu_disable_unclustred_high_rp_reschedule = true;
            } else if (mem.testEqualString("--amdgpu-dpp-combine", arg)) {
                cmd.amdgpu_dpp_combine = true;
            } else if (mem.testEqualString("--amdgpu-dump-hsa-metadata", arg)) {
                cmd.amdgpu_dump_hsa_metadata = true;
            } else if (mem.testEqualString("--amdgpu-early-ifcvt", arg)) {
                cmd.amdgpu_early_ifcvt = true;
            } else if (mem.testEqualString("--amdgpu-early-inline-all", arg)) {
                cmd.amdgpu_early_inline_all = true;
            } else if (mem.testEqualString("--amdgpu-enable-delay-alu", arg)) {
                cmd.amdgpu_enable_delay_alu = true;
            } else if (mem.testEqualString("--amdgpu-enable-lds-replace-with-pointer", arg)) {
                cmd.amdgpu_enable_lds_replace_with_pointer = true;
            } else if (mem.testEqualString("--amdgpu-enable-lower-module-lds", arg)) {
                cmd.amdgpu_enable_lower_module_lds = true;
            } else if (mem.testEqualString("--amdgpu-enable-max-ilp-scheduling-strategy", arg)) {
                cmd.amdgpu_enable_max_ilp_scheduling_strategy = true;
            } else if (mem.testEqualString("--amdgpu-enable-merge-m0", arg)) {
                cmd.amdgpu_enable_merge_m0 = true;
            } else if (mem.testEqualString("--amdgpu-enable-power-sched", arg)) {
                cmd.amdgpu_enable_power_sched = true;
            } else if (mem.testEqualString("--amdgpu-enable-pre-ra-optimizations", arg)) {
                cmd.amdgpu_enable_pre_ra_optimizations = true;
            } else if (mem.testEqualString("--amdgpu-enable-promote-kernel-arguments", arg)) {
                cmd.amdgpu_enable_promote_kernel_arguments = true;
            } else if (mem.testEqualString("--amdgpu-enable-structurizer-workarounds", arg)) {
                cmd.amdgpu_enable_structurizer_workarounds = true;
            } else if (mem.testEqualString("--amdgpu-enable-vopd", arg)) {
                cmd.amdgpu_enable_vopd = true;
            } else if (mem.testEqualString("--amdgpu-function-calls", arg)) {
                cmd.amdgpu_function_calls = true;
            } else if (mem.testEqualString("--amdgpu-igrouplp-exact-solver", arg)) {
                cmd.amdgpu_igrouplp_exact_solver = true;
            } else if (mem.testEqualString("--amdgpu-igrouplp-exact-solver-cost-heur", arg)) {
                cmd.amdgpu_igrouplp_exact_solver_cost_heur = true;
            } else if (mem.testEqualString("--amdgpu-igrouplp-exact-solver-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_igrouplp_exact_solver_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-igrouplp-exact-solver-max-branches", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_igrouplp_exact_solver_max_branches = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-indirect-access-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_indirect_access_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-inline-arg-alloca-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_inline_arg_alloca_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-inline-arg-alloca-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_inline_arg_alloca_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-inline-max-bb", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_inline_max_bb = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-internalize-symbols", arg)) {
                cmd.amdgpu_internalize_symbols = true;
            } else if (mem.testEqualString("--amdgpu-ir-lower-kernel-arguments", arg)) {
                cmd.amdgpu_ir_lower_kernel_arguments = true;
            } else if (mem.testEqualString("--amdgpu-large-stride-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_large_stride_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-large-stride-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_large_stride_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-late-structurize", arg)) {
                cmd.amdgpu_late_structurize = true;
            } else if (mem.testEqualString("--amdgpu-limit-wave-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_limit_wave_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-load-store-vectorizer", arg)) {
                cmd.amdgpu_load_store_vectorizer = true;
            } else if (mem.testEqualString("--amdgpu-max-memory-clause", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_max_memory_clause = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-max-return-arg-num-regs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_max_return_arg_num_regs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-mem-intrinsic-expand-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_mem_intrinsic_expand_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-membound-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_membound_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-mfma-padding-ratio", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_mfma_padding_ratio = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-mode-register", arg)) {
                cmd.amdgpu_mode_register = true;
            } else if (mem.testEqualString("--amdgpu-nsa-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_nsa_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-opt-exec-mask-pre-ra", arg)) {
                cmd.amdgpu_opt_exec_mask_pre_ra = true;
            } else if (mem.testEqualString("--amdgpu-opt-vgpr-liverange", arg)) {
                cmd.amdgpu_opt_vgpr_liverange = true;
            } else if (mem.testEqualString("--amdgpu-prelink", arg)) {
                cmd.amdgpu_prelink = true;
            } else if (mem.testEqualString("--amdgpu-promote-alloca-to-vector-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_promote_alloca_to_vector_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-reassign-regs", arg)) {
                cmd.amdgpu_reassign_regs = true;
            } else if (mem.testEqualString("--amdgpu-scalar-ir-passes", arg)) {
                cmd.amdgpu_scalar_ir_passes = true;
            } else if (mem.testEqualString("--amdgpu-scalarize-global-loads", arg)) {
                cmd.amdgpu_scalarize_global_loads = true;
            } else if (mem.testEqualString("--amdgpu-schedule-metric-bias", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_schedule_metric_bias = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-sdwa-peephole", arg)) {
                cmd.amdgpu_sdwa_peephole = true;
            } else if (mem.testEqualString("--amdgpu-set-wave-priority", arg)) {
                cmd.amdgpu_set_wave_priority = true;
            } else if (mem.testEqualString("--amdgpu-set-wave-priority-valu-insts-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_set_wave_priority_valu_insts_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-simplify-libcall", arg)) {
                cmd.amdgpu_simplify_libcall = true;
            } else if (mem.testEqualString("--amdgpu-skip-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_skip_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-stress-function-calls", arg)) {
                cmd.amdgpu_stress_function_calls = true;
            } else if (mem.testEqualString("--amdgpu-super-align-lds-globals", arg)) {
                cmd.amdgpu_super_align_lds_globals = true;
            } else if (mem.testEqualString("--amdgpu-unroll-max-block-to-analyze", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_unroll_max_block_to_analyze = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-unroll-runtime-local", arg)) {
                cmd.amdgpu_unroll_runtime_local = true;
            } else if (mem.testEqualString("--amdgpu-unroll-threshold-if", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_unroll_threshold_if = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-unroll-threshold-local", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_unroll_threshold_local = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-unroll-threshold-private", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_unroll_threshold_private = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-use-aa-in-codegen", arg)) {
                cmd.amdgpu_use_aa_in_codegen = true;
            } else if (mem.testEqualString("--amdgpu-use-divergent-register-indexing", arg)) {
                cmd.amdgpu_use_divergent_register_indexing = true;
            } else if (mem.testEqualString("--amdgpu-use-legacy-divergence-analysis", arg)) {
                cmd.amdgpu_use_legacy_divergence_analysis = true;
            } else if (mem.testEqualString("--amdgpu-use-native", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpu_use_native = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpu-verify-hsa-metadata", arg)) {
                cmd.amdgpu_verify_hsa_metadata = true;
            } else if (mem.testEqualString("--amdgpu-vgpr-index-mode", arg)) {
                cmd.amdgpu_vgpr_index_mode = true;
            } else if (mem.testEqualString("--amdgpu-waitcnt-forcezero", arg)) {
                cmd.amdgpu_waitcnt_forcezero = true;
            } else if (mem.testEqualString("--amdgpupostlegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpupostlegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpupostlegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpupostlegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpuprelegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpuprelegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpuprelegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpuprelegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpuregbankcombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpuregbankcombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdgpuregbankcombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdgpuregbankcombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--amdhsa-code-object-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.amdhsa_code_object_version = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--annotate-inline-phase", arg)) {
                cmd.annotate_inline_phase = true;
            } else if (mem.testEqualString("--annotate-sample-profile-inline-phase", arg)) {
                cmd.annotate_sample_profile_inline_phase = true;
            } else if (mem.testEqualString("--arc-opt-max-ptr-states", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arc_opt_max_ptr_states = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-add-build-attributes", arg)) {
                cmd.arm_add_build_attributes = true;
            } else if (mem.testEqualString("--arm-adjust-jump-tables", arg)) {
                cmd.arm_adjust_jump_tables = true;
            } else if (mem.testEqualString("--arm-assume-itcm-bankconflict", arg)) {
                cmd.arm_assume_itcm_bankconflict = true;
            } else if (mem.testEqualString("--arm-assume-misaligned-load-store", arg)) {
                cmd.arm_assume_misaligned_load_store = true;
            } else if (mem.testEqualString("--arm-atomic-cfg-tidy", arg)) {
                cmd.arm_atomic_cfg_tidy = true;
            } else if (mem.testEqualString("--arm-constant-island-max-iteration", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_constant_island_max_iteration = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-data-bank-mask", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_data_bank_mask = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-disable-omit-dls", arg)) {
                cmd.arm_disable_omit_dls = true;
            } else if (mem.testEqualString("--arm-enable-merge-loopenddec", arg)) {
                cmd.arm_enable_merge_loopenddec = true;
            } else if (mem.testEqualString("--arm-enable-subreg-liveness", arg)) {
                cmd.arm_enable_subreg_liveness = true;
            } else if (mem.testEqualString("--arm-force-fast-isel", arg)) {
                cmd.arm_force_fast_isel = true;
            } else if (mem.testEqualString("--arm-global-merge", arg)) {
                cmd.arm_global_merge = true;
            } else if (mem.testEqualString("--arm-interworking", arg)) {
                cmd.arm_interworking = true;
            } else if (mem.testEqualString("--arm-load-store-opt", arg)) {
                cmd.arm_load_store_opt = true;
            } else if (mem.testEqualString("--arm-loloops-disable-tailpred", arg)) {
                cmd.arm_loloops_disable_tailpred = true;
            } else if (mem.testEqualString("--arm-parallel-dsp-load-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_parallel_dsp_load_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-prera-ldst-opt-reorder-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_prera_ldst_opt_reorder_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-promote-constant", arg)) {
                cmd.arm_promote_constant = true;
            } else if (mem.testEqualString("--arm-promote-constant-max-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_promote_constant_max_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-promote-constant-max-total", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.arm_promote_constant_max_total = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--arm-default-it", arg)) {
                cmd.arm_default_it = true;
            } else if (mem.testEqualString("--arm-restrict-it", arg)) {
                cmd.arm_restrict_it = true;
            } else if (mem.testEqualString("--arm-set-lr-predicate", arg)) {
                cmd.arm_set_lr_predicate = true;
            } else if (mem.testEqualString("--arm-synthesize-thumb-1-tbb", arg)) {
                cmd.arm_synthesize_thumb_1_tbb = true;
            } else if (mem.testEqualString("--arm-use-mulops", arg)) {
                cmd.arm_use_mulops = true;
            } else if (mem.testEqualString("--as-secure-log-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.as_secure_log_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-always-slow-path", arg)) {
                cmd.asan_always_slow_path = true;
            } else if (mem.testEqualString("--asan-debug", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_debug = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-debug-func", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_debug_func = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-debug-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_debug_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-debug-min", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_debug_min = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-debug-stack", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_debug_stack = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-detect-invalid-pointer-cmp", arg)) {
                cmd.asan_detect_invalid_pointer_cmp = true;
            } else if (mem.testEqualString("--asan-detect-invalid-pointer-pair", arg)) {
                cmd.asan_detect_invalid_pointer_pair = true;
            } else if (mem.testEqualString("--asan-detect-invalid-pointer-sub", arg)) {
                cmd.asan_detect_invalid_pointer_sub = true;
            } else if (mem.testEqualString("--asan-force-dynamic-shadow", arg)) {
                cmd.asan_force_dynamic_shadow = true;
            } else if (mem.testEqualString("--asan-force-experiment", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_force_experiment = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-globals", arg)) {
                cmd.asan_globals = true;
            } else if (mem.testEqualString("--asan-globals-live-support", arg)) {
                cmd.asan_globals_live_support = true;
            } else if (mem.testEqualString("--asan-guard-against-version-mismatch", arg)) {
                cmd.asan_guard_against_version_mismatch = true;
            } else if (mem.testEqualString("--asan-initialization-order", arg)) {
                cmd.asan_initialization_order = true;
            } else if (mem.testEqualString("--asan-instrument-atomics", arg)) {
                cmd.asan_instrument_atomics = true;
            } else if (mem.testEqualString("--asan-instrument-byval", arg)) {
                cmd.asan_instrument_byval = true;
            } else if (mem.testEqualString("--asan-instrument-dynamic-allocas", arg)) {
                cmd.asan_instrument_dynamic_allocas = true;
            } else if (mem.testEqualString("--asan-instrument-reads", arg)) {
                cmd.asan_instrument_reads = true;
            } else if (mem.testEqualString("--asan-instrument-writes", arg)) {
                cmd.asan_instrument_writes = true;
            } else if (mem.testEqualString("--asan-instrumentation-with-call-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_instrumentation_with_call_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-kernel", arg)) {
                cmd.asan_kernel = true;
            } else if (mem.testEqualString("--asan-kernel-mem-intrinsic-prefix", arg)) {
                cmd.asan_kernel_mem_intrinsic_prefix = true;
            } else if (mem.testEqualString("--asan-mapping-offset", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_mapping_offset = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-mapping-scale", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_mapping_scale = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-max-inline-poisoning-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_max_inline_poisoning_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-max-ins-per-bb", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_max_ins_per_bb = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-memory-access-callback-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_memory_access_callback_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-opt", arg)) {
                cmd.asan_opt = true;
            } else if (mem.testEqualString("--asan-opt-globals", arg)) {
                cmd.asan_opt_globals = true;
            } else if (mem.testEqualString("--asan-opt-same-temp", arg)) {
                cmd.asan_opt_same_temp = true;
            } else if (mem.testEqualString("--asan-opt-stack", arg)) {
                cmd.asan_opt_stack = true;
            } else if (mem.testEqualString("--asan-optimize-callbacks", arg)) {
                cmd.asan_optimize_callbacks = true;
            } else if (mem.testEqualString("--asan-realign-stack", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asan_realign_stack = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asan-recover", arg)) {
                cmd.asan_recover = true;
            } else if (mem.testEqualString("--asan-redzone-byval-args", arg)) {
                cmd.asan_redzone_byval_args = true;
            } else if (mem.testEqualString("--asan-skip-promotable-allocas", arg)) {
                cmd.asan_skip_promotable_allocas = true;
            } else if (mem.testEqualString("--asan-stack", arg)) {
                cmd.asan_stack = true;
            } else if (mem.testEqualString("--asan-stack-dynamic-alloca", arg)) {
                cmd.asan_stack_dynamic_alloca = true;
            } else if (mem.testEqualString("--asan-use-after-scope", arg)) {
                cmd.asan_use_after_scope = true;
            } else if (mem.testEqualString("--asan-use-odr-indicator", arg)) {
                cmd.asan_use_odr_indicator = true;
            } else if (mem.testEqualString("--asan-use-private-alias", arg)) {
                cmd.asan_use_private_alias = true;
            } else if (mem.testEqualString("--asan-use-stack-safety", arg)) {
                cmd.asan_use_stack_safety = true;
            } else if (mem.testEqualString("--asan-with-comdat", arg)) {
                cmd.asan_with_comdat = true;
            } else if (mem.testEqualString("--asan-with-ifunc", arg)) {
                cmd.asan_with_ifunc = true;
            } else if (mem.testEqualString("--asan-with-ifunc-suppress-remat", arg)) {
                cmd.asan_with_ifunc_suppress_remat = true;
            } else if (mem.testEqualString("--asm-macro-max-nesting-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.asm_macro_max_nesting_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--asm-show-inst", arg)) {
                cmd.asm_show_inst = true;
            } else if (mem.testEqualString("--asm-verbose", arg)) {
                cmd.asm_verbose = true;
            } else if (mem.testEqualString("--assume-preserve-all", arg)) {
                cmd.assume_preserve_all = true;
            } else if (mem.testEqualString("--atomic-counter-update-promoted", arg)) {
                cmd.atomic_counter_update_promoted = true;
            } else if (mem.testEqualString("--atomic-first-counter", arg)) {
                cmd.atomic_first_counter = true;
            } else if (mem.testEqualString("--attributor-allow-deep-wrappers", arg)) {
                cmd.attributor_allow_deep_wrappers = true;
            } else if (mem.testEqualString("--attributor-allow-shallow-wrappers", arg)) {
                cmd.attributor_allow_shallow_wrappers = true;
            } else if (mem.testEqualString("--attributor-annotate-decl-cs", arg)) {
                cmd.attributor_annotate_decl_cs = true;
            } else if (mem.testEqualString("--attributor-depgraph-dot-filename-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.attributor_depgraph_dot_filename_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--attributor-dump-dep-graph", arg)) {
                cmd.attributor_dump_dep_graph = true;
            } else if (mem.testEqualString("--attributor-enable-call-site-specific-deduction", arg)) {
                cmd.attributor_enable_call_site_specific_deduction = true;
            } else if (mem.testEqualString("--attributor-manifest-internal", arg)) {
                cmd.attributor_manifest_internal = true;
            } else if (mem.testEqualString("--attributor-max-initialization-chain-length", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.attributor_max_initialization_chain_length = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--attributor-max-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.attributor_max_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--attributor-max-iterations-verify", arg)) {
                cmd.attributor_max_iterations_verify = true;
            } else if (mem.testEqualString("--attributor-max-potential-values", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.attributor_max_potential_values = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--attributor-max-potential-values-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.attributor_max_potential_values_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--attributor-print-call-graph", arg)) {
                cmd.attributor_print_call_graph = true;
            } else if (mem.testEqualString("--attributor-print-dep", arg)) {
                cmd.attributor_print_dep = true;
            } else if (mem.testEqualString("--attributor-simplify-all-loads", arg)) {
                cmd.attributor_simplify_all_loads = true;
            } else if (mem.testEqualString("--attributor-view-dep-graph", arg)) {
                cmd.attributor_view_dep_graph = true;
            } else if (mem.testEqualString("--available-load-scan-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.available_load_scan_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--avoid-speculation", arg)) {
                cmd.avoid_speculation = true;
            } else if (mem.testEqualString("--basic-aa-recphi", arg)) {
                cmd.basic_aa_recphi = true;
            } else if (mem.testEqualString("--basic-aa-separate-storage", arg)) {
                cmd.basic_aa_separate_storage = true;
            } else if (mem.testEqualString("--bbsections-cold-text-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.bbsections_cold_text_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--bbsections-detect-source-drift", arg)) {
                cmd.bbsections_detect_source_drift = true;
            } else if (mem.testEqualString("--bbsections-guided-section-prefix", arg)) {
                cmd.bbsections_guided_section_prefix = true;
            } else if (mem.testEqualString("--binutils-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.binutils_version = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--bitcode-flush-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.bitcode_flush_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--bitcode-mdindex-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.bitcode_mdindex_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--block-freq-ratio-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.block_freq_ratio_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--block-placement-exit-block-bias", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.block_placement_exit_block_bias = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--bonus-inst-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.bonus_inst_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--bounds-checking-single-trap", arg)) {
                cmd.bounds_checking_single_trap = true;
            } else if (mem.testEqualString("--bpf-disable-avoid-speculation", arg)) {
                cmd.bpf_disable_avoid_speculation = true;
            } else if (mem.testEqualString("--bpf-disable-serialize-icmp", arg)) {
                cmd.bpf_disable_serialize_icmp = true;
            } else if (mem.testEqualString("--bpf-expand-memcpy-in-order", arg)) {
                cmd.bpf_expand_memcpy_in_order = true;
            } else if (mem.testEqualString("--branch-fold-placement", arg)) {
                cmd.branch_fold_placement = true;
            } else if (mem.testEqualString("--branch-relax-asm-large", arg)) {
                cmd.branch_relax_asm_large = true;
            } else if (mem.testEqualString("--branch-relax-safety-buffer", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.branch_relax_safety_buffer = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--break-anti-dependencies", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.break_anti_dependencies = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cache-line-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cache_line_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--callgraph-dot-filename-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.callgraph_dot_filename_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--callgraph-heat-colors", arg)) {
                cmd.callgraph_heat_colors = true;
            } else if (mem.testEqualString("--callgraph-multigraph", arg)) {
                cmd.callgraph_multigraph = true;
            } else if (mem.testEqualString("--callgraph-show-weights", arg)) {
                cmd.callgraph_show_weights = true;
            } else if (mem.testEqualString("--callsite-splitting-duplication-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.callsite_splitting_duplication_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--canon-nth-function", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.canon_nth_function = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--canonicalize-icmp-predicates-to-unsigned", arg)) {
                cmd.canonicalize_icmp_predicates_to_unsigned = true;
            } else if (mem.testEqualString("--capture-tracking-max-uses-to-explore", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.capture_tracking_max_uses_to_explore = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cfg-dot-filename-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cfg_dot_filename_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cfg-func-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cfg_func_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cfg-heat-colors", arg)) {
                cmd.cfg_heat_colors = true;
            } else if (mem.testEqualString("--cfg-hide-cold-paths", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cfg_hide_cold_paths = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cfg-hide-deoptimize-paths", arg)) {
                cmd.cfg_hide_deoptimize_paths = true;
            } else if (mem.testEqualString("--cfg-hide-unreachable-paths", arg)) {
                cmd.cfg_hide_unreachable_paths = true;
            } else if (mem.testEqualString("--cfg-raw-weights", arg)) {
                cmd.cfg_raw_weights = true;
            } else if (mem.testEqualString("--cfg-weights", arg)) {
                cmd.cfg_weights = true;
            } else if (mem.testEqualString("--cgp-freq-ratio-to-skip-merge", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cgp_freq_ratio_to_skip_merge = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cgp-icmp-eq2icmp-st", arg)) {
                cmd.cgp_icmp_eq2icmp_st = true;
            } else if (mem.testEqualString("--cgp-optimize-phi-types", arg)) {
                cmd.cgp_optimize_phi_types = true;
            } else if (mem.testEqualString("--cgp-split-large-offset-gep", arg)) {
                cmd.cgp_split_large_offset_gep = true;
            } else if (mem.testEqualString("--cgp-type-promotion-merge", arg)) {
                cmd.cgp_type_promotion_merge = true;
            } else if (mem.testEqualString("--cgp-verify-bfi-updates", arg)) {
                cmd.cgp_verify_bfi_updates = true;
            } else if (mem.testEqualString("--cgpp-huge-func", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cgpp_huge_func = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cgscc-inline-replay", arg)) {
                cmd.cgscc_inline_replay = true;
            } else if (mem.testEqualString("--check-bfi-unknown-block-queries", arg)) {
                cmd.check_bfi_unknown_block_queries = true;
            } else if (mem.testEqualString("--check-early-avail", arg)) {
                cmd.check_early_avail = true;
            } else if (mem.testEqualString("--chr-bias-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.chr_bias_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--chr-dup-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.chr_dup_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--chr-function-list", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.chr_function_list = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--chr-merge-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.chr_merge_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--chr-module-list", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.chr_module_list = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cold-branch-ratio", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cold_branch_ratio = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cold-callsite-rel-freq", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cold_callsite_rel_freq = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cold-operand-max-cost-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cold_operand_max_cost_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cold-operand-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cold_operand_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cold-synthetic-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cold_synthetic_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--coldcc-rel-freq", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.coldcc_rel_freq = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--color", arg)) {
                cmd.color = true;
            } else if (mem.testEqualString("--combiner-global-alias-analysis", arg)) {
                cmd.combiner_global_alias_analysis = true;
            } else if (mem.testEqualString("--combiner-reduce-load-op-store-width", arg)) {
                cmd.combiner_reduce_load_op_store_width = true;
            } else if (mem.testEqualString("--combiner-shrink-load-replace-store-with-store", arg)) {
                cmd.combiner_shrink_load_replace_store_with_store = true;
            } else if (mem.testEqualString("--combiner-split-load-index", arg)) {
                cmd.combiner_split_load_index = true;
            } else if (mem.testEqualString("--combiner-store-merge-dependence-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.combiner_store_merge_dependence_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--combiner-store-merging", arg)) {
                cmd.combiner_store_merging = true;
            } else if (mem.testEqualString("--combiner-stress-load-slicing", arg)) {
                cmd.combiner_stress_load_slicing = true;
            } else if (mem.testEqualString("--combiner-tokenfactor-inline-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.combiner_tokenfactor_inline_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--combiner-use-tbaa", arg)) {
                cmd.combiner_use_tbaa = true;
            } else if (mem.testEqualString("--combiner-vector-fcopysign-extend-round", arg)) {
                cmd.combiner_vector_fcopysign_extend_round = true;
            } else if (mem.testEqualString("--commgep-const", arg)) {
                cmd.commgep_const = true;
            } else if (mem.testEqualString("--commgep-inv", arg)) {
                cmd.commgep_inv = true;
            } else if (mem.testEqualString("--commgep-speculate", arg)) {
                cmd.commgep_speculate = true;
            } else if (mem.testEqualString("--compile-time-mem-idiom-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.compile_time_mem_idiom_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--compile-twice", arg)) {
                cmd.compile_twice = true;
            } else if (mem.testEqualString("--compute-dead", arg)) {
                cmd.compute_dead = true;
            } else if (mem.testEqualString("--consthoist-gep", arg)) {
                cmd.consthoist_gep = true;
            } else if (mem.testEqualString("--consthoist-min-num-to-rebase", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.consthoist_min_num_to_rebase = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--consthoist-with-block-frequency", arg)) {
                cmd.consthoist_with_block_frequency = true;
            } else if (mem.testEqualString("--constraint-elimination-max-rows", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.constraint_elimination_max_rows = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--costmodel-reduxcost", arg)) {
                cmd.costmodel_reduxcost = true;
            } else if (mem.testEqualString("--crash-diagnostics-dir", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.crash_diagnostics_dir = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--crash-on-ppc-vsx-self-copy", arg)) {
                cmd.crash_on_ppc_vsx_self_copy = true;
            } else if (mem.testEqualString("--cs-profile-generate", arg)) {
                cmd.cs_profile_generate = true;
            } else if (mem.testEqualString("--cs-profile-path", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cs_profile_path = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--csuses-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.csuses_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--cvp-max-functions-per-value", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.cvp_max_functions_per_value = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--da-delinearize", arg)) {
                cmd.da_delinearize = true;
            } else if (mem.testEqualString("--da-disable-delinearization-checks", arg)) {
                cmd.da_disable_delinearization_checks = true;
            } else if (mem.testEqualString("--da-miv-max-level-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.da_miv_max_level_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dag-dump-verbose", arg)) {
                cmd.dag_dump_verbose = true;
            } else if (mem.testEqualString("--dag-maps-huge-region", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dag_maps_huge_region = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dag-maps-reduction-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dag_maps_reduction_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--data-sections", arg)) {
                cmd.data_sections = true;
            } else if (mem.testEqualString("--dataflow-edge-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dataflow_edge_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ddg-pi-blocks", arg)) {
                cmd.ddg_pi_blocks = true;
            } else if (mem.testEqualString("--ddg-simplify", arg)) {
                cmd.ddg_simplify = true;
            } else if (mem.testEqualString("--debug-ata-max-blocks", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.debug_ata_max_blocks = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("-debug-counter", arg)) {
                cmd.debug_counter = true;
            } else if (mem.testEqualString("--debug-entry-values", arg)) {
                cmd.debug_entry_values = true;
            } else if (mem.testEqualString("--debug-info-correlate", arg)) {
                cmd.debug_info_correlate = true;
            } else if (mem.testEqualString("--debugify-and-strip-all-safe", arg)) {
                cmd.debugify_and_strip_all_safe = true;
            } else if (mem.testEqualString("--debugify-check-and-strip-all-safe", arg)) {
                cmd.debugify_check_and_strip_all_safe = true;
            } else if (mem.testEqualString("--debugify-func-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.debugify_func_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--debugify-quiet", arg)) {
                cmd.debugify_quiet = true;
            } else if (mem.testEqualString("--default-gcov-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.default_gcov_version = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--default-trip-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.default_trip_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--demote-catchswitch-only", arg)) {
                cmd.demote_catchswitch_only = true;
            } else if (mem.testEqualString("--dfa-cost-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfa_cost_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfa-hazard-rec", arg)) {
                cmd.dfa_hazard_rec = true;
            } else if (mem.testEqualString("--dfa-instr-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfa_instr_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfa-jump-view-cfg-before", arg)) {
                cmd.dfa_jump_view_cfg_before = true;
            } else if (mem.testEqualString("--dfa-max-num-paths", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfa_max_num_paths = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfa-max-path-length", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfa_max_path_length = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfa-sched-reg-pressure-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfa_sched_reg_pressure_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfsan-abilist", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfsan_abilist = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfsan-combine-offset-labels-on-gep", arg)) {
                cmd.dfsan_combine_offset_labels_on_gep = true;
            } else if (mem.testEqualString("--dfsan-combine-pointer-labels-on-load", arg)) {
                cmd.dfsan_combine_pointer_labels_on_load = true;
            } else if (mem.testEqualString("--dfsan-combine-pointer-labels-on-store", arg)) {
                cmd.dfsan_combine_pointer_labels_on_store = true;
            } else if (mem.testEqualString("--dfsan-combine-taint-lookup-table", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfsan_combine_taint_lookup_table = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfsan-conditional-callbacks", arg)) {
                cmd.dfsan_conditional_callbacks = true;
            } else if (mem.testEqualString("--dfsan-debug-nonzero-labels", arg)) {
                cmd.dfsan_debug_nonzero_labels = true;
            } else if (mem.testEqualString("--dfsan-event-callbacks", arg)) {
                cmd.dfsan_event_callbacks = true;
            } else if (mem.testEqualString("--dfsan-ignore-personality-routine", arg)) {
                cmd.dfsan_ignore_personality_routine = true;
            } else if (mem.testEqualString("--dfsan-instrument-with-call-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfsan_instrument_with_call_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfsan-preserve-alignment", arg)) {
                cmd.dfsan_preserve_alignment = true;
            } else if (mem.testEqualString("--dfsan-reaches-function-callbacks", arg)) {
                cmd.dfsan_reaches_function_callbacks = true;
            } else if (mem.testEqualString("--dfsan-track-origins", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dfsan_track_origins = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dfsan-track-select-control-flow", arg)) {
                cmd.dfsan_track_select_control_flow = true;
            } else if (mem.testEqualString("--disable-2addr-hack", arg)) {
                cmd.disable_2addr_hack = true;
            } else if (mem.testEqualString("--disable-a15-sd-optimization", arg)) {
                cmd.disable_a15_sd_optimization = true;
            } else if (mem.testEqualString("--disable-adv-copy-opt", arg)) {
                cmd.disable_adv_copy_opt = true;
            } else if (mem.testEqualString("--disable-advanced-peeling", arg)) {
                cmd.disable_advanced_peeling = true;
            } else if (mem.testEqualString("--disable-arm-loloops", arg)) {
                cmd.disable_arm_loloops = true;
            } else if (mem.testEqualString("--disable-arm-parallel-dsp", arg)) {
                cmd.disable_arm_parallel_dsp = true;
            } else if (mem.testEqualString("--disable-auto-paired-vec-st", arg)) {
                cmd.disable_auto_paired_vec_st = true;
            } else if (mem.testEqualString("--disable-basic-aa", arg)) {
                cmd.disable_basic_aa = true;
            } else if (mem.testEqualString("--disable-binop-extract-shuffle", arg)) {
                cmd.disable_binop_extract_shuffle = true;
            } else if (mem.testEqualString("--disable-bitcode-version-upgrade", arg)) {
                cmd.disable_bitcode_version_upgrade = true;
            } else if (mem.testEqualString("--disable-block-placement", arg)) {
                cmd.disable_block_placement = true;
            } else if (mem.testEqualString("--disable-bpf-peephole", arg)) {
                cmd.disable_bpf_peephole = true;
            } else if (mem.testEqualString("--disable-branch-fold", arg)) {
                cmd.disable_branch_fold = true;
            } else if (mem.testEqualString("--disable-cfi-fixup", arg)) {
                cmd.disable_cfi_fixup = true;
            } else if (mem.testEqualString("--disable-cgp", arg)) {
                cmd.disable_cgp = true;
            } else if (mem.testEqualString("--disable-cgp-branch-opts", arg)) {
                cmd.disable_cgp_branch_opts = true;
            } else if (mem.testEqualString("--disable-cgp-ext-ld-promotion", arg)) {
                cmd.disable_cgp_ext_ld_promotion = true;
            } else if (mem.testEqualString("--disable-cgp-gc-opts", arg)) {
                cmd.disable_cgp_gc_opts = true;
            } else if (mem.testEqualString("--disable-cgp-select2branch", arg)) {
                cmd.disable_cgp_select2branch = true;
            } else if (mem.testEqualString("--disable-cgp-store-extract", arg)) {
                cmd.disable_cgp_store_extract = true;
            } else if (mem.testEqualString("--disable-check-noreturn-call", arg)) {
                cmd.disable_check_noreturn_call = true;
            } else if (mem.testEqualString("--disable-chr", arg)) {
                cmd.disable_chr = true;
            } else if (mem.testEqualString("--disable-cleanups", arg)) {
                cmd.disable_cleanups = true;
            } else if (mem.testEqualString("--disable-complex-addr-modes", arg)) {
                cmd.disable_complex_addr_modes = true;
            } else if (mem.testEqualString("--disable-const64", arg)) {
                cmd.disable_const64 = true;
            } else if (mem.testEqualString("--disable-constant-hoisting", arg)) {
                cmd.disable_constant_hoisting = true;
            } else if (mem.testEqualString("--disable-copyprop", arg)) {
                cmd.disable_copyprop = true;
            } else if (mem.testEqualString("--disable-debug-info-print", arg)) {
                cmd.disable_debug_info_print = true;
            } else if (mem.testEqualString("--disable-demotion", arg)) {
                cmd.disable_demotion = true;
            } else if (mem.testEqualString("--disable-dfa-sched", arg)) {
                cmd.disable_dfa_sched = true;
            } else if (mem.testEqualString("--disable-early-ifcvt", arg)) {
                cmd.disable_early_ifcvt = true;
            } else if (mem.testEqualString("--disable-early-taildup", arg)) {
                cmd.disable_early_taildup = true;
            } else if (mem.testEqualString("--disable-expand-reductions", arg)) {
                cmd.disable_expand_reductions = true;
            } else if (mem.testEqualString("--disable-gep-const-evaluation", arg)) {
                cmd.disable_gep_const_evaluation = true;
            } else if (mem.testEqualString("--disable-gisel-legality-check", arg)) {
                cmd.disable_gisel_legality_check = true;
            } else if (mem.testEqualString("--disable-hcp", arg)) {
                cmd.disable_hcp = true;
            } else if (mem.testEqualString("--disable-hexagon-amodeopt", arg)) {
                cmd.disable_hexagon_amodeopt = true;
            } else if (mem.testEqualString("--disable-hexagon-cfgopt", arg)) {
                cmd.disable_hexagon_cfgopt = true;
            } else if (mem.testEqualString("--disable-hexagon-dealloc-ret", arg)) {
                cmd.disable_hexagon_dealloc_ret = true;
            } else if (mem.testEqualString("--disable-hexagon-hwloops", arg)) {
                cmd.disable_hexagon_hwloops = true;
            } else if (mem.testEqualString("--disable-hexagon-misched", arg)) {
                cmd.disable_hexagon_misched = true;
            } else if (mem.testEqualString("--disable-hexagon-nv-schedule", arg)) {
                cmd.disable_hexagon_nv_schedule = true;
            } else if (mem.testEqualString("--disable-hexagon-opt-ext-to-64", arg)) {
                cmd.disable_hexagon_opt_ext_to_64 = true;
            } else if (mem.testEqualString("--disable-hexagon-optszext", arg)) {
                cmd.disable_hexagon_optszext = true;
            } else if (mem.testEqualString("--disable-hexagon-peephole", arg)) {
                cmd.disable_hexagon_peephole = true;
            } else if (mem.testEqualString("--disable-hexagon-pnotp", arg)) {
                cmd.disable_hexagon_pnotp = true;
            } else if (mem.testEqualString("--disable-hexagon-shuffle", arg)) {
                cmd.disable_hexagon_shuffle = true;
            } else if (mem.testEqualString("--disable-hexagon-volatile-memcpy", arg)) {
                cmd.disable_hexagon_volatile_memcpy = true;
            } else if (mem.testEqualString("--disable-hsdr", arg)) {
                cmd.disable_hsdr = true;
            } else if (mem.testEqualString("--disable-i2p-p2i-opt", arg)) {
                cmd.disable_i2p_p2i_opt = true;
            } else if (mem.testEqualString("--disable-icp", arg)) {
                cmd.disable_icp = true;
            } else if (mem.testEqualString("--disable-ifcvt-diamond", arg)) {
                cmd.disable_ifcvt_diamond = true;
            } else if (mem.testEqualString("--disable-ifcvt-forked-diamond", arg)) {
                cmd.disable_ifcvt_forked_diamond = true;
            } else if (mem.testEqualString("--disable-ifcvt-simple", arg)) {
                cmd.disable_ifcvt_simple = true;
            } else if (mem.testEqualString("--disable-ifcvt-simple-false", arg)) {
                cmd.disable_ifcvt_simple_false = true;
            } else if (mem.testEqualString("--disable-ifcvt-triangle", arg)) {
                cmd.disable_ifcvt_triangle = true;
            } else if (mem.testEqualString("--disable-ifcvt-triangle-false", arg)) {
                cmd.disable_ifcvt_triangle_false = true;
            } else if (mem.testEqualString("--disable-ifcvt-triangle-false-rev", arg)) {
                cmd.disable_ifcvt_triangle_false_rev = true;
            } else if (mem.testEqualString("--disable-ifcvt-triangle-rev", arg)) {
                cmd.disable_ifcvt_triangle_rev = true;
            } else if (mem.testEqualString("--disable-inlined-alloca-merging", arg)) {
                cmd.disable_inlined_alloca_merging = true;
            } else if (mem.testEqualString("--disable-interleaved-load-combine", arg)) {
                cmd.disable_interleaved_load_combine = true;
            } else if (mem.testEqualString("--disable-lanai-mem-alu-combiner", arg)) {
                cmd.disable_lanai_mem_alu_combiner = true;
            } else if (mem.testEqualString("--disable-layout-fsprofile-loader", arg)) {
                cmd.disable_layout_fsprofile_loader = true;
            } else if (mem.testEqualString("--disable-lftr", arg)) {
                cmd.disable_lftr = true;
            } else if (mem.testEqualString("--disable-licm-promotion", arg)) {
                cmd.disable_licm_promotion = true;
            } else if (mem.testEqualString("--disable-loop-level-heuristics", arg)) {
                cmd.disable_loop_level_heuristics = true;
            } else if (mem.testEqualString("--disable-lsr", arg)) {
                cmd.disable_lsr = true;
            } else if (mem.testEqualString("--disable-machine-cse", arg)) {
                cmd.disable_machine_cse = true;
            } else if (mem.testEqualString("--disable-machine-dce", arg)) {
                cmd.disable_machine_dce = true;
            } else if (mem.testEqualString("--disable-machine-licm", arg)) {
                cmd.disable_machine_licm = true;
            } else if (mem.testEqualString("--disable-machine-sink", arg)) {
                cmd.disable_machine_sink = true;
            } else if (mem.testEqualString("--disable-memcpy-idiom", arg)) {
                cmd.disable_memcpy_idiom = true;
            } else if (mem.testEqualString("--disable-memmove-idiom", arg)) {
                cmd.disable_memmove_idiom = true;
            } else if (mem.testEqualString("--disable-memop-opt", arg)) {
                cmd.disable_memop_opt = true;
            } else if (mem.testEqualString("--disable-merge-into-combines", arg)) {
                cmd.disable_merge_into_combines = true;
            } else if (mem.testEqualString("--disable-mergeicmps", arg)) {
                cmd.disable_mergeicmps = true;
            } else if (mem.testEqualString("--disable-mips-delay-filler", arg)) {
                cmd.disable_mips_delay_filler = true;
            } else if (mem.testEqualString("--disable-mips-df-backward-search", arg)) {
                cmd.disable_mips_df_backward_search = true;
            } else if (mem.testEqualString("--disable-mips-df-forward-search", arg)) {
                cmd.disable_mips_df_forward_search = true;
            } else if (mem.testEqualString("--disable-mips-df-succbb-search", arg)) {
                cmd.disable_mips_df_succbb_search = true;
            } else if (mem.testEqualString("--disable-mr-partial-inlining", arg)) {
                cmd.disable_mr_partial_inlining = true;
            } else if (mem.testEqualString("--disable-nofree-inference", arg)) {
                cmd.disable_nofree_inference = true;
            } else if (mem.testEqualString("--disable-non-allocatable-phys-copy-opt", arg)) {
                cmd.disable_non_allocatable_phys_copy_opt = true;
            } else if (mem.testEqualString("--disable-nounwind-inference", arg)) {
                cmd.disable_nounwind_inference = true;
            } else if (mem.testEqualString("--disable-nvjump", arg)) {
                cmd.disable_nvjump = true;
            } else if (mem.testEqualString("--disable-nvptx-load-store-vectorizer", arg)) {
                cmd.disable_nvptx_load_store_vectorizer = true;
            } else if (mem.testEqualString("--disable-nvptx-require-structured-cfg", arg)) {
                cmd.disable_nvptx_require_structured_cfg = true;
            } else if (mem.testEqualString("--disable-ondemand-mds-loading", arg)) {
                cmd.disable_ondemand_mds_loading = true;
            } else if (mem.testEqualString("--disable-packetizer", arg)) {
                cmd.disable_packetizer = true;
            } else if (mem.testEqualString("--disable-partial-inlining", arg)) {
                cmd.disable_partial_inlining = true;
            } else if (mem.testEqualString("--disable-partial-libcall-inlining", arg)) {
                cmd.disable_partial_libcall_inlining = true;
            } else if (mem.testEqualString("--disable-peephole", arg)) {
                cmd.disable_peephole = true;
            } else if (mem.testEqualString("--disable-phi-elim-edge-splitting", arg)) {
                cmd.disable_phi_elim_edge_splitting = true;
            } else if (mem.testEqualString("--disable-post-ra", arg)) {
                cmd.disable_post_ra = true;
            } else if (mem.testEqualString("--disable-postra-machine-licm", arg)) {
                cmd.disable_postra_machine_licm = true;
            } else if (mem.testEqualString("--disable-postra-machine-sink", arg)) {
                cmd.disable_postra_machine_sink = true;
            } else if (mem.testEqualString("--disable-ppc-cmp-opt", arg)) {
                cmd.disable_ppc_cmp_opt = true;
            } else if (mem.testEqualString("--disable-ppc-constant-hoisting", arg)) {
                cmd.disable_ppc_constant_hoisting = true;
            } else if (mem.testEqualString("--disable-ppc-ctrloop-analysis", arg)) {
                cmd.disable_ppc_ctrloop_analysis = true;
            } else if (mem.testEqualString("--disable-ppc-ctrloops", arg)) {
                cmd.disable_ppc_ctrloops = true;
            } else if (mem.testEqualString("--disable-ppc-ilp-pref", arg)) {
                cmd.disable_ppc_ilp_pref = true;
            } else if (mem.testEqualString("--disable-ppc-innermost-loop-align32", arg)) {
                cmd.disable_ppc_innermost_loop_align32 = true;
            } else if (mem.testEqualString("--disable-ppc-instr-form-prep", arg)) {
                cmd.disable_ppc_instr_form_prep = true;
            } else if (mem.testEqualString("--disable-ppc-peephole", arg)) {
                cmd.disable_ppc_peephole = true;
            } else if (mem.testEqualString("--disable-ppc-preinc", arg)) {
                cmd.disable_ppc_preinc = true;
            } else if (mem.testEqualString("--disable-ppc-sched-addi-load", arg)) {
                cmd.disable_ppc_sched_addi_load = true;
            } else if (mem.testEqualString("--disable-ppc-sco", arg)) {
                cmd.disable_ppc_sco = true;
            } else if (mem.testEqualString("--disable-ppc-unaligned", arg)) {
                cmd.disable_ppc_unaligned = true;
            } else if (mem.testEqualString("--disable-ppc-vsx-fma-mutation", arg)) {
                cmd.disable_ppc_vsx_fma_mutation = true;
            } else if (mem.testEqualString("--disable-ppc-vsx-swap-removal", arg)) {
                cmd.disable_ppc_vsx_swap_removal = true;
            } else if (mem.testEqualString("--disable-preheader-prot", arg)) {
                cmd.disable_preheader_prot = true;
            } else if (mem.testEqualString("--disable-preinline", arg)) {
                cmd.disable_preinline = true;
            } else if (mem.testEqualString("--disable-promote-alloca-to-lds", arg)) {
                cmd.disable_promote_alloca_to_lds = true;
            } else if (mem.testEqualString("--disable-promote-alloca-to-vector", arg)) {
                cmd.disable_promote_alloca_to_vector = true;
            } else if (mem.testEqualString("--disable-ra-fsprofile-loader", arg)) {
                cmd.disable_ra_fsprofile_loader = true;
            } else if (mem.testEqualString("--disable-sample-loader-inlining", arg)) {
                cmd.disable_sample_loader_inlining = true;
            } else if (mem.testEqualString("--disable-sched-critical-path", arg)) {
                cmd.disable_sched_critical_path = true;
            } else if (mem.testEqualString("--disable-sched-cycles", arg)) {
                cmd.disable_sched_cycles = true;
            } else if (mem.testEqualString("--disable-sched-hazard", arg)) {
                cmd.disable_sched_hazard = true;
            } else if (mem.testEqualString("--disable-sched-height", arg)) {
                cmd.disable_sched_height = true;
            } else if (mem.testEqualString("--disable-sched-live-uses", arg)) {
                cmd.disable_sched_live_uses = true;
            } else if (mem.testEqualString("--disable-sched-physreg-join", arg)) {
                cmd.disable_sched_physreg_join = true;
            } else if (mem.testEqualString("--disable-sched-reg-pressure", arg)) {
                cmd.disable_sched_reg_pressure = true;
            } else if (mem.testEqualString("--disable-sched-stalls", arg)) {
                cmd.disable_sched_stalls = true;
            } else if (mem.testEqualString("--disable-sched-vrcycle", arg)) {
                cmd.disable_sched_vrcycle = true;
            } else if (mem.testEqualString("--disable-select-optimize", arg)) {
                cmd.disable_select_optimize = true;
            } else if (mem.testEqualString("--disable-separate-const-offset-from-gep", arg)) {
                cmd.disable_separate_const_offset_from_gep = true;
            } else if (mem.testEqualString("--disable-shifter-op", arg)) {
                cmd.disable_shifter_op = true;
            } else if (mem.testEqualString("--disable-simplify-libcalls", arg)) {
                cmd.disable_simplify_libcalls = true;
            } else if (mem.testEqualString("--disable-sparc-delay-filler", arg)) {
                cmd.disable_sparc_delay_filler = true;
            } else if (mem.testEqualString("--disable-sparc-leaf-proc", arg)) {
                cmd.disable_sparc_leaf_proc = true;
            } else if (mem.testEqualString("--disable-spill-fusing", arg)) {
                cmd.disable_spill_fusing = true;
            } else if (mem.testEqualString("--disable-spill-hoist", arg)) {
                cmd.disable_spill_hoist = true;
            } else if (mem.testEqualString("--disable-ssc", arg)) {
                cmd.disable_ssc = true;
            } else if (mem.testEqualString("--disable-store-widen", arg)) {
                cmd.disable_store_widen = true;
            } else if (mem.testEqualString("--disable-strictnode-mutation", arg)) {
                cmd.disable_strictnode_mutation = true;
            } else if (mem.testEqualString("--disable-symbolication", arg)) {
                cmd.disable_symbolication = true;
            } else if (mem.testEqualString("--disable-tail-calls", arg)) {
                cmd.disable_tail_calls = true;
            } else if (mem.testEqualString("--disable-tail-duplicate", arg)) {
                cmd.disable_tail_duplicate = true;
            } else if (mem.testEqualString("--disable-thinlto-funcattrs", arg)) {
                cmd.disable_thinlto_funcattrs = true;
            } else if (mem.testEqualString("--disable-type-promotion", arg)) {
                cmd.disable_type_promotion = true;
            } else if (mem.testEqualString("--disable-vecdbl-nv-stores", arg)) {
                cmd.disable_vecdbl_nv_stores = true;
            } else if (mem.testEqualString("--disable-vector-combine", arg)) {
                cmd.disable_vector_combine = true;
            } else if (mem.testEqualString("--disable-verify", arg)) {
                cmd.disable_verify = true;
            } else if (mem.testEqualString("--disable-vp", arg)) {
                cmd.disable_vp = true;
            } else if (mem.testEqualString("--disable-wasm-fallthrough-return-opt", arg)) {
                cmd.disable_wasm_fallthrough_return_opt = true;
            } else if (mem.testEqualString("--disable-whole-program-visibility", arg)) {
                cmd.disable_whole_program_visibility = true;
            } else if (mem.testEqualString("--disable-x86-domain-reassignment", arg)) {
                cmd.disable_x86_domain_reassignment = true;
            } else if (mem.testEqualString("--disable-x86-lea-opt", arg)) {
                cmd.disable_x86_lea_opt = true;
            } else if (mem.testEqualString("--discard-value-names", arg)) {
                cmd.discard_value_names = true;
            } else if (mem.testEqualString("--do-comdat-renaming", arg)) {
                cmd.do_comdat_renaming = true;
            } else if (mem.testEqualString("--do-counter-promotion", arg)) {
                cmd.do_counter_promotion = true;
            } else if (mem.testEqualString("--dom-conditions-max-uses", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dom_conditions_max_uses = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dom-tree-reachability-max-bbs-to-explore", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dom_tree_reachability_max_bbs_to_explore = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-cfg-after-color", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dot_cfg_after_color = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-cfg-before-color", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dot_cfg_before_color = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-cfg-common-color", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dot_cfg_common_color = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-cfg-dir", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dot_cfg_dir = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-ddg-filename-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dot_ddg_filename_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dot-ddg-only", arg)) {
                cmd.dot_ddg_only = true;
            } else if (mem.testEqualString("--dot-mcfg-only", arg)) {
                cmd.dot_mcfg_only = true;
            } else if (mem.testEqualString("--dse-memoryssa-defs-per-block-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_defs_per_block_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-otherbb-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_otherbb_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-partial-store-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_partial_store_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-path-check-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_path_check_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-samebb-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_samebb_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-scanlimit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_scanlimit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-memoryssa-walklimit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dse_memoryssa_walklimit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dse-optimize-memoryssa", arg)) {
                cmd.dse_optimize_memoryssa = true;
            } else if (mem.testEqualString("--dump-thin-cg-sccs", arg)) {
                cmd.dump_thin_cg_sccs = true;
            } else if (mem.testEqualString("--dwarf-directory", arg)) {
                cmd.dwarf_directory = true;
            } else if (mem.testEqualString("--dwarf-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.dwarf_version = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--dwarf64", arg)) {
                cmd.dwarf64 = true;
            } else if (mem.testEqualString("--eagerly-invalidate-analyses", arg)) {
                cmd.eagerly_invalidate_analyses = true;
            } else if (mem.testEqualString("--early-ifcvt-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.early_ifcvt_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--early-live-intervals", arg)) {
                cmd.early_live_intervals = true;
            } else if (mem.testEqualString("--earlycse-debug-hash", arg)) {
                cmd.earlycse_debug_hash = true;
            } else if (mem.testEqualString("--earlycse-mssa-optimization-cap", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.earlycse_mssa_optimization_cap = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--eif-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.eif_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--eif-no-loop-exit", arg)) {
                cmd.eif_no_loop_exit = true;
            } else if (mem.testEqualString("--emit-call-site-info", arg)) {
                cmd.emit_call_site_info = true;
            } else if (mem.testEqualString("--emscripten-cxx-exceptions-allowed", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.emscripten_cxx_exceptions_allowed = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--emulate-old-livedebugvalues", arg)) {
                cmd.emulate_old_livedebugvalues = true;
            } else if (mem.testEqualString("--emulated-tls", arg)) {
                cmd.emulated_tls = true;
            } else if (mem.testEqualString("--enable-aa-sched-mi", arg)) {
                cmd.enable_aa_sched_mi = true;
            } else if (mem.testEqualString("--enable-acc-forwarding", arg)) {
                cmd.enable_acc_forwarding = true;
            } else if (mem.testEqualString("--enable-alu-forwarding", arg)) {
                cmd.enable_alu_forwarding = true;
            } else if (mem.testEqualString("--enable-amdgpu-aa", arg)) {
                cmd.enable_amdgpu_aa = true;
            } else if (mem.testEqualString("--enable-andcmp-sinking", arg)) {
                cmd.enable_andcmp_sinking = true;
            } else if (mem.testEqualString("--enable-approx-func-fp-math", arg)) {
                cmd.enable_approx_func_fp_math = true;
            } else if (mem.testEqualString("--enable-arm-3-addr-conv", arg)) {
                cmd.enable_arm_3_addr_conv = true;
            } else if (mem.testEqualString("--enable-arm-maskedgatscat", arg)) {
                cmd.enable_arm_maskedgatscat = true;
            } else if (mem.testEqualString("--enable-arm-maskedldst", arg)) {
                cmd.enable_arm_maskedldst = true;
            } else if (mem.testEqualString("--enable-block-placement-stats", arg)) {
                cmd.enable_block_placement_stats = true;
            } else if (mem.testEqualString("--enable-bsb-sched", arg)) {
                cmd.enable_bsb_sched = true;
            } else if (mem.testEqualString("--enable-chr", arg)) {
                cmd.enable_chr = true;
            } else if (mem.testEqualString("--enable-cold-section", arg)) {
                cmd.enable_cold_section = true;
            } else if (mem.testEqualString("--enable-coldcc-stress-test", arg)) {
                cmd.enable_coldcc_stress_test = true;
            } else if (mem.testEqualString("--enable-complex-deinterleaving", arg)) {
                cmd.enable_complex_deinterleaving = true;
            } else if (mem.testEqualString("--enable-cond-stores-vec", arg)) {
                cmd.enable_cond_stores_vec = true;
            } else if (mem.testEqualString("--enable-constraint-elimination", arg)) {
                cmd.enable_constraint_elimination = true;
            } else if (mem.testEqualString("--enable-cse-in-irtranslator", arg)) {
                cmd.enable_cse_in_irtranslator = true;
            } else if (mem.testEqualString("--enable-cse-in-legalizer", arg)) {
                cmd.enable_cse_in_legalizer = true;
            } else if (mem.testEqualString("--enable-cur-sched", arg)) {
                cmd.enable_cur_sched = true;
            } else if (mem.testEqualString("--enable-deferred-spilling", arg)) {
                cmd.enable_deferred_spilling = true;
            } else if (mem.testEqualString("--enable-dfa-jump-thread", arg)) {
                cmd.enable_dfa_jump_thread = true;
            } else if (mem.testEqualString("--enable-double-float-shrink", arg)) {
                cmd.enable_double_float_shrink = true;
            } else if (mem.testEqualString("--enable-dse-partial-overwrite-tracking", arg)) {
                cmd.enable_dse_partial_overwrite_tracking = true;
            } else if (mem.testEqualString("--enable-dse-partial-store-merging", arg)) {
                cmd.enable_dse_partial_store_merging = true;
            } else if (mem.testEqualString("--enable-emscripten-cxx-exceptions", arg)) {
                cmd.enable_emscripten_cxx_exceptions = true;
            } else if (mem.testEqualString("--enable-emscripten-sjlj", arg)) {
                cmd.enable_emscripten_sjlj = true;
            } else if (mem.testEqualString("--enable-epilogue-vectorization", arg)) {
                cmd.enable_epilogue_vectorization = true;
            } else if (mem.testEqualString("--enable-ext-tsp-block-placement", arg)) {
                cmd.enable_ext_tsp_block_placement = true;
            } else if (mem.testEqualString("--enable-falkor-hwpf-unroll-fix", arg)) {
                cmd.enable_falkor_hwpf_unroll_fix = true;
            } else if (mem.testEqualString("--enable-fixedwidth-autovec-in-streaming-mode", arg)) {
                cmd.enable_fixedwidth_autovec_in_streaming_mode = true;
            } else if (mem.testEqualString("--enable-fs-discriminator", arg)) {
                cmd.enable_fs_discriminator = true;
            } else if (mem.testEqualString("--enable-gen-insn", arg)) {
                cmd.enable_gen_insn = true;
            } else if (mem.testEqualString("--enable-global-analyses", arg)) {
                cmd.enable_global_analyses = true;
            } else if (mem.testEqualString("--enable-global-merge", arg)) {
                cmd.enable_global_merge = true;
            } else if (mem.testEqualString("--enable-gvn-hoist", arg)) {
                cmd.enable_gvn_hoist = true;
            } else if (mem.testEqualString("--enable-gvn-memdep", arg)) {
                cmd.enable_gvn_memdep = true;
            } else if (mem.testEqualString("--enable-gvn-sink", arg)) {
                cmd.enable_gvn_sink = true;
            } else if (mem.testEqualString("--enable-heap-to-stack-conversion", arg)) {
                cmd.enable_heap_to_stack_conversion = true;
            } else if (mem.testEqualString("--enable-hexagon-br-prob", arg)) {
                cmd.enable_hexagon_br_prob = true;
            } else if (mem.testEqualString("--enable-hexagon-sdnode-sched", arg)) {
                cmd.enable_hexagon_sdnode_sched = true;
            } else if (mem.testEqualString("--enable-hexagon-vector-print", arg)) {
                cmd.enable_hexagon_vector_print = true;
            } else if (mem.testEqualString("--enable-if-conversion", arg)) {
                cmd.enable_if_conversion = true;
            } else if (mem.testEqualString("--enable-implicit-null-checks", arg)) {
                cmd.enable_implicit_null_checks = true;
            } else if (mem.testEqualString("--enable-import-metadata", arg)) {
                cmd.enable_import_metadata = true;
            } else if (mem.testEqualString("--enable-ind-var-reg-heur", arg)) {
                cmd.enable_ind_var_reg_heur = true;
            } else if (mem.testEqualString("--enable-interleaved-mem-accesses", arg)) {
                cmd.enable_interleaved_mem_accesses = true;
            } else if (mem.testEqualString("--enable-ipra", arg)) {
                cmd.enable_ipra = true;
            } else if (mem.testEqualString("--enable-jmc-instrument", arg)) {
                cmd.enable_jmc_instrument = true;
            } else if (mem.testEqualString("--enable-knowledge-retention", arg)) {
                cmd.enable_knowledge_retention = true;
            } else if (mem.testEqualString("--enable-legalize-types-checking", arg)) {
                cmd.enable_legalize_types_checking = true;
            } else if (mem.testEqualString("--enable-linkonceodr-ir-outlining", arg)) {
                cmd.enable_linkonceodr_ir_outlining = true;
            } else if (mem.testEqualString("--enable-linkonceodr-outlining", arg)) {
                cmd.enable_linkonceodr_outlining = true;
            } else if (mem.testEqualString("--enable-load-in-loop-pre", arg)) {
                cmd.enable_load_in_loop_pre = true;
            } else if (mem.testEqualString("--enable-load-pre", arg)) {
                cmd.enable_load_pre = true;
            } else if (mem.testEqualString("--enable-loadstore-runtime-interleave", arg)) {
                cmd.enable_loadstore_runtime_interleave = true;
            } else if (mem.testEqualString("--enable-local-reassign", arg)) {
                cmd.enable_local_reassign = true;
            } else if (mem.testEqualString("--enable-loop-distribute", arg)) {
                cmd.enable_loop_distribute = true;
            } else if (mem.testEqualString("--enable-loop-flatten", arg)) {
                cmd.enable_loop_flatten = true;
            } else if (mem.testEqualString("--enable-loop-simplifycfg-term-folding", arg)) {
                cmd.enable_loop_simplifycfg_term_folding = true;
            } else if (mem.testEqualString("--enable-loopinterchange", arg)) {
                cmd.enable_loopinterchange = true;
            } else if (mem.testEqualString("--enable-lsr-phielim", arg)) {
                cmd.enable_lsr_phielim = true;
            } else if (mem.testEqualString("--enable-lto-internalization", arg)) {
                cmd.enable_lto_internalization = true;
            } else if (mem.testEqualString("--enable-masked-interleaved-mem-accesses", arg)) {
                cmd.enable_masked_interleaved_mem_accesses = true;
            } else if (mem.testEqualString("--enable-matrix", arg)) {
                cmd.enable_matrix = true;
            } else if (mem.testEqualString("--enable-mem-access-versioning", arg)) {
                cmd.enable_mem_access_versioning = true;
            } else if (mem.testEqualString("--enable-mem-prof", arg)) {
                cmd.enable_mem_prof = true;
            } else if (mem.testEqualString("--enable-memcpy-dag-opt", arg)) {
                cmd.enable_memcpy_dag_opt = true;
            } else if (mem.testEqualString("--enable-memcpyopt-without-libcalls", arg)) {
                cmd.enable_memcpyopt_without_libcalls = true;
            } else if (mem.testEqualString("--enable-merge-functions", arg)) {
                cmd.enable_merge_functions = true;
            } else if (mem.testEqualString("--enable-misched", arg)) {
                cmd.enable_misched = true;
            } else if (mem.testEqualString("--enable-module-inliner", arg)) {
                cmd.enable_module_inliner = true;
            } else if (mem.testEqualString("--enable-mve-interleave", arg)) {
                cmd.enable_mve_interleave = true;
            } else if (mem.testEqualString("--enable-name-compression", arg)) {
                cmd.enable_name_compression = true;
            } else if (mem.testEqualString("--enable-newgvn", arg)) {
                cmd.enable_newgvn = true;
            } else if (mem.testEqualString("--enable-no-infs-fp-math", arg)) {
                cmd.enable_no_infs_fp_math = true;
            } else if (mem.testEqualString("--enable-no-nans-fp-math", arg)) {
                cmd.enable_no_nans_fp_math = true;
            } else if (mem.testEqualString("--enable-no-rerun-simplification-pipeline", arg)) {
                cmd.enable_no_rerun_simplification_pipeline = true;
            } else if (mem.testEqualString("--enable-no-signed-zeros-fp-math", arg)) {
                cmd.enable_no_signed_zeros_fp_math = true;
            } else if (mem.testEqualString("--enable-no-trapping-fp-math", arg)) {
                cmd.enable_no_trapping_fp_math = true;
            } else if (mem.testEqualString("--enable-noalias-to-md-conversion", arg)) {
                cmd.enable_noalias_to_md_conversion = true;
            } else if (mem.testEqualString("--enable-nonnull-arg-prop", arg)) {
                cmd.enable_nonnull_arg_prop = true;
            } else if (mem.testEqualString("--enable-nontrivial-unswitch", arg)) {
                cmd.enable_nontrivial_unswitch = true;
            } else if (mem.testEqualString("--enable-npm-O3-nontrivial-unswitch", arg)) {
                cmd.enable_npm_O3_nontrivial_unswitch = true;
            } else if (mem.testEqualString("--enable-npm-pgo-inline-deferral", arg)) {
                cmd.enable_npm_pgo_inline_deferral = true;
            } else if (mem.testEqualString("--enable-npm-synthetic-counts", arg)) {
                cmd.enable_npm_synthetic_counts = true;
            } else if (mem.testEqualString("--enable-objc-arc-opts", arg)) {
                cmd.enable_objc_arc_opts = true;
            } else if (mem.testEqualString("--enable-order-file-instrumentation", arg)) {
                cmd.enable_order_file_instrumentation = true;
            } else if (mem.testEqualString("--enable-partial-inlining", arg)) {
                cmd.enable_partial_inlining = true;
            } else if (mem.testEqualString("--enable-patchpoint-liveness", arg)) {
                cmd.enable_patchpoint_liveness = true;
            } else if (mem.testEqualString("--enable-phi-of-ops", arg)) {
                cmd.enable_phi_of_ops = true;
            } else if (mem.testEqualString("--enable-pipeliner", arg)) {
                cmd.enable_pipeliner = true;
            } else if (mem.testEqualString("--enable-pipeliner-opt-size", arg)) {
                cmd.enable_pipeliner_opt_size = true;
            } else if (mem.testEqualString("--enable-post-misched", arg)) {
                cmd.enable_post_misched = true;
            } else if (mem.testEqualString("--enable-post-pgo-loop-rotation", arg)) {
                cmd.enable_post_pgo_loop_rotation = true;
            } else if (mem.testEqualString("--enable-ppc-branch-coalesce", arg)) {
                cmd.enable_ppc_branch_coalesce = true;
            } else if (mem.testEqualString("--enable-ppc-extra-toc-reg-deps", arg)) {
                cmd.enable_ppc_extra_toc_reg_deps = true;
            } else if (mem.testEqualString("--enable-ppc-gen-scalar-mass", arg)) {
                cmd.enable_ppc_gen_scalar_mass = true;
            } else if (mem.testEqualString("--enable-ppc-prefetching", arg)) {
                cmd.enable_ppc_prefetching = true;
            } else if (mem.testEqualString("--enable-pre", arg)) {
                cmd.enable_pre = true;
            } else if (mem.testEqualString("--enable-save-restore-long", arg)) {
                cmd.enable_save_restore_long = true;
            } else if (mem.testEqualString("--enable-scalable-autovec-in-streaming-mode", arg)) {
                cmd.enable_scalable_autovec_in_streaming_mode = true;
            } else if (mem.testEqualString("--enable-scc-inline-advisor-printing", arg)) {
                cmd.enable_scc_inline_advisor_printing = true;
            } else if (mem.testEqualString("--enable-scoped-noalias", arg)) {
                cmd.enable_scoped_noalias = true;
            } else if (mem.testEqualString("--enable-selectiondag-sp", arg)) {
                cmd.enable_selectiondag_sp = true;
            } else if (mem.testEqualString("--enable-shrink-wrap", arg)) {
                cmd.enable_shrink_wrap = true;
            } else if (mem.testEqualString("--enable-sign-dependent-rounding-fp-math", arg)) {
                cmd.enable_sign_dependent_rounding_fp_math = true;
            } else if (mem.testEqualString("--enable-split-backedge-in-load-pre", arg)) {
                cmd.enable_split_backedge_in_load_pre = true;
            } else if (mem.testEqualString("--enable-split-machine-functions", arg)) {
                cmd.enable_split_machine_functions = true;
            } else if (mem.testEqualString("--enable-stackovf-sanitizer", arg)) {
                cmd.enable_stackovf_sanitizer = true;
            } else if (mem.testEqualString("--enable-store-refinement", arg)) {
                cmd.enable_store_refinement = true;
            } else if (mem.testEqualString("--enable-subreg-liveness", arg)) {
                cmd.enable_subreg_liveness = true;
            } else if (mem.testEqualString("--enable-tail-merge", arg)) {
                cmd.enable_tail_merge = true;
            } else if (mem.testEqualString("--enable-tbaa", arg)) {
                cmd.enable_tbaa = true;
            } else if (mem.testEqualString("--enable-tc-latency-sched", arg)) {
                cmd.enable_tc_latency_sched = true;
            } else if (mem.testEqualString("--enable-timing-class-latency", arg)) {
                cmd.enable_timing_class_latency = true;
            } else if (mem.testEqualString("--enable-unroll-and-jam", arg)) {
                cmd.enable_unroll_and_jam = true;
            } else if (mem.testEqualString("--enable-unsafe-fp-math", arg)) {
                cmd.enable_unsafe_fp_math = true;
            } else if (mem.testEqualString("--enable-unsafe-globalsmodref-alias-results", arg)) {
                cmd.enable_unsafe_globalsmodref_alias_results = true;
            } else if (mem.testEqualString("--enable-unswitch-cost-multiplier", arg)) {
                cmd.enable_unswitch_cost_multiplier = true;
            } else if (mem.testEqualString("--enable-vfe", arg)) {
                cmd.enable_vfe = true;
            } else if (mem.testEqualString("--enable-vplan-native-path", arg)) {
                cmd.enable_vplan_native_path = true;
            } else if (mem.testEqualString("--enable-x86-scalar-amx", arg)) {
                cmd.enable_x86_scalar_amx = true;
            } else if (mem.testEqualString("--epilogue-vectorization-force-VF", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.epilogue_vectorization_force_VF = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--epilogue-vectorization-minimum-VF", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.epilogue_vectorization_minimum_VF = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--exec-on-ir-change", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.exec_on_ir_change = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--exhaustive-register-search", arg)) {
                cmd.exhaustive_register_search = true;
            } else if (mem.testEqualString("--expand-all-fp-mlx", arg)) {
                cmd.expand_all_fp_mlx = true;
            } else if (mem.testEqualString("--expand-condsets-coa-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expand_condsets_coa_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expand-condsets-tfr-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expand_condsets_tfr_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expand-constant-exprs", arg)) {
                cmd.expand_constant_exprs = true;
            } else if (mem.testEqualString("--expand-div-rem-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expand_div_rem_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expand-fp-convert-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expand_fp_convert_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expand-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expand_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expandvp-override-evl-transform", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expandvp_override_evl_transform = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--expandvp-override-mask-transform", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.expandvp_override_mask_transform = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--experimental-debug-variable-locations", arg)) {
                cmd.experimental_debug_variable_locations = true;
            } else if (mem.testEqualString("--expose-ppc-andi-glue-bug", arg)) {
                cmd.expose_ppc_andi_glue_bug = true;
            } else if (mem.testEqualString("--ext-tsp-apply-without-profile", arg)) {
                cmd.ext_tsp_apply_without_profile = true;
            } else if (mem.testEqualString("--extra-vectorizer-passes", arg)) {
                cmd.extra_vectorizer_passes = true;
            } else if (mem.testEqualString("--extract-blocks-erase-funcs", arg)) {
                cmd.extract_blocks_erase_funcs = true;
            } else if (mem.testEqualString("--extract-blocks-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.extract_blocks_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--extract-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.extract_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--extract-needand", arg)) {
                cmd.extract_needand = true;
            } else if (mem.testEqualString("--extract-nosr0", arg)) {
                cmd.extract_nosr0 = true;
            } else if (mem.testEqualString("--fast-cluster-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fast_cluster_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fast-isel", arg)) {
                cmd.fast_isel = true;
            } else if (mem.testEqualString("--fast-isel-abort", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fast_isel_abort = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fast-isel-report-on-fallback", arg)) {
                cmd.fast_isel_report_on_fallback = true;
            } else if (mem.testEqualString("--fatal-warnings", arg)) {
                cmd.fatal_warnings = true;
            } else if (mem.testEqualString("--ffast-math", arg)) {
                cmd.ffast_math = true;
            } else if (mem.testEqualString("--filter-passes", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.filter_passes = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--filter-print-funcs", arg)) {
                args_idx +%= 1;
                if (args_idx == args.len) {
                    return;
                }
                arg = mem.terminate(args[args_idx], 0);
                if (cmd.filter_print_funcs) |src| {
                    const dest: [*][]const u8 = @ptrFromInt(allocator.allocateRaw(16 *% (src.len +% 1), 8));
                    @memcpy(dest, src);
                    dest[src.len] = arg;
                    cmd.filter_print_funcs = dest[0 .. src.len +% 1];
                } else {
                    const dest: [*][]const u8 = @ptrFromInt(allocator.allocateRaw(16, 8));
                    dest[0] = arg;
                    cmd.filter_print_funcs = dest[0..1];
                }
            } else if (mem.testEqualString("--fixup-allow-gcptr-in-csr", arg)) {
                cmd.fixup_allow_gcptr_in_csr = true;
            } else if (mem.testEqualString("--fixup-byte-word-insts", arg)) {
                cmd.fixup_byte_word_insts = true;
            } else if (mem.testEqualString("--fixup-max-csr-statepoints", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fixup_max_csr_statepoints = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fixup-scs-enable-copy-propagation", arg)) {
                cmd.fixup_scs_enable_copy_propagation = true;
            } else if (mem.testEqualString("--fixup-scs-extend-slot-size", arg)) {
                cmd.fixup_scs_extend_slot_size = true;
            } else if (mem.testEqualString("--flat-loop-tripcount-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.flat_loop_tripcount_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--flattened-profile-used", arg)) {
                cmd.flattened_profile_used = true;
            } else if (mem.testEqualString("--float2int-max-integer-bw", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.float2int_max_integer_bw = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-attribute", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_attribute = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-chr", arg)) {
                cmd.force_chr = true;
            } else if (mem.testEqualString("--force-dwarf-frame-section", arg)) {
                cmd.force_dwarf_frame_section = true;
            } else if (mem.testEqualString("--force-fast-cluster", arg)) {
                cmd.force_fast_cluster = true;
            } else if (mem.testEqualString("--force-function-specialization", arg)) {
                cmd.force_function_specialization = true;
            } else if (mem.testEqualString("--force-fuse-matrix", arg)) {
                cmd.force_fuse_matrix = true;
            } else if (mem.testEqualString("--force-hardware-loop-guard", arg)) {
                cmd.force_hardware_loop_guard = true;
            } else if (mem.testEqualString("--force-hardware-loop-phi", arg)) {
                cmd.force_hardware_loop_phi = true;
            } else if (mem.testEqualString("--force-hardware-loops", arg)) {
                cmd.force_hardware_loops = true;
            } else if (mem.testEqualString("--force-hvx-float", arg)) {
                cmd.force_hvx_float = true;
            } else if (mem.testEqualString("--force-import-all", arg)) {
                cmd.force_import_all = true;
            } else if (mem.testEqualString("--force-instr-ref-livedebugvalues", arg)) {
                cmd.force_instr_ref_livedebugvalues = true;
            } else if (mem.testEqualString("--force-legal-indexing", arg)) {
                cmd.force_legal_indexing = true;
            } else if (mem.testEqualString("--force-loop-cold-block", arg)) {
                cmd.force_loop_cold_block = true;
            } else if (mem.testEqualString("--force-mips-long-branch", arg)) {
                cmd.force_mips_long_branch = true;
            } else if (mem.testEqualString("--force-nested-hardware-loop", arg)) {
                cmd.force_nested_hardware_loop = true;
            } else if (mem.testEqualString("--force-ordered-reductions", arg)) {
                cmd.force_ordered_reductions = true;
            } else if (mem.testEqualString("--force-pgso", arg)) {
                cmd.force_pgso = true;
            } else if (mem.testEqualString("--force-precise-rotation-cost", arg)) {
                cmd.force_precise_rotation_cost = true;
            } else if (mem.testEqualString("--force-remove-attribute", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_remove_attribute = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-split-store", arg)) {
                cmd.force_split_store = true;
            } else if (mem.testEqualString("--force-streaming-compatible-sve", arg)) {
                cmd.force_streaming_compatible_sve = true;
            } else if (mem.testEqualString("--force-target-instruction-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_target_instruction_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-target-max-scalar-interleave", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_target_max_scalar_interleave = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-target-max-vector-interleave", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_target_max_vector_interleave = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-target-num-scalar-regs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_target_num_scalar_regs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-target-num-vector-regs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_target_num_vector_regs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-target-supports-scalable-vectors", arg)) {
                cmd.force_target_supports_scalable_vectors = true;
            } else if (mem.testEqualString("--force-vector-interleave", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_vector_interleave = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-vector-width", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.force_vector_width = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--force-widen-divrem-via-safe-divisor", arg)) {
                cmd.force_widen_divrem_via_safe_divisor = true;
            } else if (mem.testEqualString("--forget-scev-loop-unroll", arg)) {
                cmd.forget_scev_loop_unroll = true;
            } else if (mem.testEqualString("--forward-switch-cond", arg)) {
                cmd.forward_switch_cond = true;
            } else if (mem.testEqualString("--frame-helper-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.frame_helper_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--freeze-loop-unswitch-cond", arg)) {
                cmd.freeze_loop_unswitch_cond = true;
            } else if (mem.testEqualString("--fs-no-final-discrim", arg)) {
                cmd.fs_no_final_discrim = true;
            } else if (mem.testEqualString("--fs-profile-debug-bw-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fs_profile_debug_bw_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fs-profile-debug-prob-diff-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fs_profile_debug_prob_diff_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fs-profile-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fs_profile_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fs-remapping-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fs_remapping_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fs-viewbfi-after", arg)) {
                cmd.fs_viewbfi_after = true;
            } else if (mem.testEqualString("--fs-viewbfi-before", arg)) {
                cmd.fs_viewbfi_before = true;
            } else if (mem.testEqualString("--func-specialization-avg-iters-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.func_specialization_avg_iters_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--func-specialization-max-clones", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.func_specialization_max_clones = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--func-specialization-max-iters", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.func_specialization_max_iters = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--func-specialization-on-address", arg)) {
                cmd.func_specialization_on_address = true;
            } else if (mem.testEqualString("--func-specialization-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.func_specialization_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--function-sections", arg)) {
                cmd.function_sections = true;
            } else if (mem.testEqualString("--function-specialization-for-literal-constant", arg)) {
                cmd.function_specialization_for_literal_constant = true;
            } else if (mem.testEqualString("--fuse-matrix", arg)) {
                cmd.fuse_matrix = true;
            } else if (mem.testEqualString("--fuse-matrix-tile-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.fuse_matrix_tile_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--fuse-matrix-use-loops", arg)) {
                cmd.fuse_matrix_use_loops = true;
            } else if (mem.testEqualString("--gcov-atomic-counter", arg)) {
                cmd.gcov_atomic_counter = true;
            } else if (mem.testEqualString("--generate-arange-section", arg)) {
                cmd.generate_arange_section = true;
            } else if (mem.testEqualString("--generate-merged-base-profiles", arg)) {
                cmd.generate_merged_base_profiles = true;
            } else if (mem.testEqualString("--generate-type-units", arg)) {
                cmd.generate_type_units = true;
            } else if (mem.testEqualString("--global-isel", arg)) {
                cmd.global_isel = true;
            } else if (mem.testEqualString("--global-merge-group-by-use", arg)) {
                cmd.global_merge_group_by_use = true;
            } else if (mem.testEqualString("--global-merge-ignore-single-use", arg)) {
                cmd.global_merge_ignore_single_use = true;
            } else if (mem.testEqualString("--global-merge-max-offset", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.global_merge_max_offset = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--global-merge-on-const", arg)) {
                cmd.global_merge_on_const = true;
            } else if (mem.testEqualString("--global-merge-on-external", arg)) {
                cmd.global_merge_on_external = true;
            } else if (mem.testEqualString("--gpsize", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gpsize = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--greedy-regclass-priority-trumps-globalness", arg)) {
                cmd.greedy_regclass_priority_trumps_globalness = true;
            } else if (mem.testEqualString("--greedy-reverse-local-assignment", arg)) {
                cmd.greedy_reverse_local_assignment = true;
            } else if (mem.testEqualString("--grow-region-complexity-budget", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.grow_region_complexity_budget = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--guard-widening-widen-branch-guards", arg)) {
                cmd.guard_widening_widen_branch_guards = true;
            } else if (mem.testEqualString("--guards-predicate-pass-branch-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.guards_predicate_pass_branch_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-add-phi-translation", arg)) {
                cmd.gvn_add_phi_translation = true;
            } else if (mem.testEqualString("--gvn-hoist-max-bbs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_hoist_max_bbs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-hoist-max-chain-length", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_hoist_max_chain_length = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-hoist-max-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_hoist_max_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-max-block-speculations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_max_block_speculations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-max-hoisted", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_max_hoisted = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-max-num-deps", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_max_num_deps = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--gvn-max-num-visited-insts", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.gvn_max_num_visited_insts = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hardware-loop-counter-bitwidth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hardware_loop_counter_bitwidth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hardware-loop-decrement", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hardware_loop_decrement = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hash-based-counter-split", arg)) {
                cmd.hash_based_counter_split = true;
            } else if (mem.testEqualString("--help", arg)) {
                cmd.help = true;
            } else if (mem.testEqualString("--help-hidden", arg)) {
                cmd.help_hidden = true;
            } else if (mem.testEqualString("--help-list", arg)) {
                cmd.help_list = true;
            } else if (mem.testEqualString("--help-list-hidden", arg)) {
                cmd.help_list_hidden = true;
            } else if (mem.testEqualString("--hexagon-align-loads", arg)) {
                cmd.hexagon_align_loads = true;
            } else if (mem.testEqualString("--hexagon-amode-growth-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_amode_growth_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-autohvx", arg)) {
                cmd.hexagon_autohvx = true;
            } else if (mem.testEqualString("--hexagon-bit", arg)) {
                cmd.hexagon_bit = true;
            } else if (mem.testEqualString("--hexagon-cext", arg)) {
                cmd.hexagon_cext = true;
            } else if (mem.testEqualString("--hexagon-cext-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_cext_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-cext-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_cext_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-check-bank-conflict", arg)) {
                cmd.hexagon_check_bank_conflict = true;
            } else if (mem.testEqualString("--hexagon-commgep", arg)) {
                cmd.hexagon_commgep = true;
            } else if (mem.testEqualString("--hexagon-disable-args-min-alignment", arg)) {
                cmd.hexagon_disable_args_min_alignment = true;
            } else if (mem.testEqualString("--hexagon-eif", arg)) {
                cmd.hexagon_eif = true;
            } else if (mem.testEqualString("--hexagon-emit-jt-text", arg)) {
                cmd.hexagon_emit_jt_text = true;
            } else if (mem.testEqualString("--hexagon-emit-jump-tables", arg)) {
                cmd.hexagon_emit_jump_tables = true;
            } else if (mem.testEqualString("--hexagon-emit-lookup-tables", arg)) {
                cmd.hexagon_emit_lookup_tables = true;
            } else if (mem.testEqualString("--hexagon-emit-lut-text", arg)) {
                cmd.hexagon_emit_lut_text = true;
            } else if (mem.testEqualString("--hexagon-enable-branch-prediction", arg)) {
                cmd.hexagon_enable_branch_prediction = true;
            } else if (mem.testEqualString("--hexagon-expand-condsets", arg)) {
                cmd.hexagon_expand_condsets = true;
            } else if (mem.testEqualString("--hexagon-extract", arg)) {
                cmd.hexagon_extract = true;
            } else if (mem.testEqualString("--hexagon-fp-elim", arg)) {
                cmd.hexagon_fp_elim = true;
            } else if (mem.testEqualString("--hexagon-frame-index-reuse-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_frame_index_reuse_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-frame-index-search-range", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_frame_index_search_range = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-gen-mux-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_gen_mux_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-gen-pred", arg)) {
                cmd.hexagon_gen_pred = true;
            } else if (mem.testEqualString("--hexagon-hvx-widen", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_hvx_widen = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-hwloop-preheader", arg)) {
                cmd.hexagon_hwloop_preheader = true;
            } else if (mem.testEqualString("--hexagon-initial-cfg-cleanup", arg)) {
                cmd.hexagon_initial_cfg_cleanup = true;
            } else if (mem.testEqualString("--hexagon-insert", arg)) {
                cmd.hexagon_insert = true;
            } else if (mem.testEqualString("--hexagon-instsimplify", arg)) {
                cmd.hexagon_instsimplify = true;
            } else if (mem.testEqualString("--hexagon-isel-su", arg)) {
                cmd.hexagon_isel_su = true;
            } else if (mem.testEqualString("--hexagon-long-calls", arg)) {
                cmd.hexagon_long_calls = true;
            } else if (mem.testEqualString("--hexagon-loop-prefetch", arg)) {
                cmd.hexagon_loop_prefetch = true;
            } else if (mem.testEqualString("--hexagon-loop-range", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_loop_range = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-loop-resched", arg)) {
                cmd.hexagon_loop_resched = true;
            } else if (mem.testEqualString("--hexagon-masked-vmem", arg)) {
                cmd.hexagon_masked_vmem = true;
            } else if (mem.testEqualString("--hexagon-mux", arg)) {
                cmd.hexagon_mux = true;
            } else if (mem.testEqualString("--hexagon-noopt", arg)) {
                cmd.hexagon_noopt = true;
            } else if (mem.testEqualString("--hexagon-opt-spill", arg)) {
                cmd.hexagon_opt_spill = true;
            } else if (mem.testEqualString("--hexagon-opt-vextract", arg)) {
                cmd.hexagon_opt_vextract = true;
            } else if (mem.testEqualString("--hexagon-packetize-volatiles", arg)) {
                cmd.hexagon_packetize_volatiles = true;
            } else if (mem.testEqualString("--hexagon-pred-calls", arg)) {
                cmd.hexagon_pred_calls = true;
            } else if (mem.testEqualString("--hexagon-sched-inline-asm", arg)) {
                cmd.hexagon_sched_inline_asm = true;
            } else if (mem.testEqualString("--hexagon-shrink-frame", arg)) {
                cmd.hexagon_shrink_frame = true;
            } else if (mem.testEqualString("--hexagon-small-data-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_small_data_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-statics-in-small-data", arg)) {
                cmd.hexagon_statics_in_small_data = true;
            } else if (mem.testEqualString("--hexagon-subreg-liveness", arg)) {
                cmd.hexagon_subreg_liveness = true;
            } else if (mem.testEqualString("--hexagon-vector-combine", arg)) {
                cmd.hexagon_vector_combine = true;
            } else if (mem.testEqualString("--hexagon-vextract-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_vextract_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexagon-vlcr-iteration-lim", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexagon_vlcr_iteration_lim = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexbit-bitsplit", arg)) {
                cmd.hexbit_bitsplit = true;
            } else if (mem.testEqualString("--hexbit-extract", arg)) {
                cmd.hexbit_extract = true;
            } else if (mem.testEqualString("--hexbit-keep-tied", arg)) {
                cmd.hexbit_keep_tied = true;
            } else if (mem.testEqualString("--hexbit-max-bitsplit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexbit_max_bitsplit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexbit-max-extract", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexbit_max_extract = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hexbit-registerset-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hexbit_registerset_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hints-allow-reordering", arg)) {
                cmd.hints_allow_reordering = true;
            } else if (mem.testEqualString("--hlir-simplify-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hlir_simplify_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hoist-cheap-insts", arg)) {
                cmd.hoist_cheap_insts = true;
            } else if (mem.testEqualString("--hoist-common-insts", arg)) {
                cmd.hoist_common_insts = true;
            } else if (mem.testEqualString("--hoist-const-stores", arg)) {
                cmd.hoist_const_stores = true;
            } else if (mem.testEqualString("--homogeneous-prolog-epilog", arg)) {
                cmd.homogeneous_prolog_epilog = true;
            } else if (mem.testEqualString("--hot-callsite-rel-freq", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hot_callsite_rel_freq = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hot-callsite-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hot_callsite_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hot-cold-split", arg)) {
                cmd.hot_cold_split = true;
            } else if (mem.testEqualString("--hot-cold-static-analysis", arg)) {
                cmd.hot_cold_static_analysis = true;
            } else if (mem.testEqualString("--hotcoldsplit-cold-section-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hotcoldsplit_cold_section_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hotcoldsplit-max-params", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hotcoldsplit_max_params = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hotcoldsplit-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hotcoldsplit_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hsdr-no-mem", arg)) {
                cmd.hsdr_no_mem = true;
            } else if (mem.testEqualString("--hsdr-split-all", arg)) {
                cmd.hsdr_split_all = true;
            } else if (mem.testEqualString("--huge-size-for-split", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.huge_size_for_split = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hwasan-experimental-use-page-aliases", arg)) {
                cmd.hwasan_experimental_use_page_aliases = true;
            } else if (mem.testEqualString("--hwasan-generate-tags-with-calls", arg)) {
                cmd.hwasan_generate_tags_with_calls = true;
            } else if (mem.testEqualString("--hwasan-globals", arg)) {
                cmd.hwasan_globals = true;
            } else if (mem.testEqualString("--hwasan-inline-all-checks", arg)) {
                cmd.hwasan_inline_all_checks = true;
            } else if (mem.testEqualString("--hwasan-instrument-atomics", arg)) {
                cmd.hwasan_instrument_atomics = true;
            } else if (mem.testEqualString("--hwasan-instrument-byval", arg)) {
                cmd.hwasan_instrument_byval = true;
            } else if (mem.testEqualString("--hwasan-instrument-landing-pads", arg)) {
                cmd.hwasan_instrument_landing_pads = true;
            } else if (mem.testEqualString("--hwasan-instrument-mem-intrinsics", arg)) {
                cmd.hwasan_instrument_mem_intrinsics = true;
            } else if (mem.testEqualString("--hwasan-instrument-personality-functions", arg)) {
                cmd.hwasan_instrument_personality_functions = true;
            } else if (mem.testEqualString("--hwasan-instrument-reads", arg)) {
                cmd.hwasan_instrument_reads = true;
            } else if (mem.testEqualString("--hwasan-instrument-stack", arg)) {
                cmd.hwasan_instrument_stack = true;
            } else if (mem.testEqualString("--hwasan-instrument-with-calls", arg)) {
                cmd.hwasan_instrument_with_calls = true;
            } else if (mem.testEqualString("--hwasan-instrument-writes", arg)) {
                cmd.hwasan_instrument_writes = true;
            } else if (mem.testEqualString("--hwasan-kernel", arg)) {
                cmd.hwasan_kernel = true;
            } else if (mem.testEqualString("--hwasan-kernel-mem-intrinsic-prefix", arg)) {
                cmd.hwasan_kernel_mem_intrinsic_prefix = true;
            } else if (mem.testEqualString("--hwasan-mapping-offset", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hwasan_mapping_offset = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hwasan-match-all-tag", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hwasan_match_all_tag = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hwasan-memory-access-callback-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.hwasan_memory_access_callback_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--hwasan-recover", arg)) {
                cmd.hwasan_recover = true;
            } else if (mem.testEqualString("--hwasan-uar-retag-to-zero", arg)) {
                cmd.hwasan_uar_retag_to_zero = true;
            } else if (mem.testEqualString("--hwasan-use-after-scope", arg)) {
                cmd.hwasan_use_after_scope = true;
            } else if (mem.testEqualString("--hwasan-use-short-granules", arg)) {
                cmd.hwasan_use_short_granules = true;
            } else if (mem.testEqualString("--hwasan-use-stack-safety", arg)) {
                cmd.hwasan_use_stack_safety = true;
            } else if (mem.testEqualString("--hwasan-with-ifunc", arg)) {
                cmd.hwasan_with_ifunc = true;
            } else if (mem.testEqualString("--hwasan-with-tls", arg)) {
                cmd.hwasan_with_tls = true;
            } else if (mem.testEqualString("--hwloop-spec-preheader", arg)) {
                cmd.hwloop_spec_preheader = true;
            } else if (mem.testEqualString("--icp-call-only", arg)) {
                cmd.icp_call_only = true;
            } else if (mem.testEqualString("--icp-csskip", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_csskip = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--icp-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--icp-dumpafter", arg)) {
                cmd.icp_dumpafter = true;
            } else if (mem.testEqualString("--icp-invoke-only", arg)) {
                cmd.icp_invoke_only = true;
            } else if (mem.testEqualString("--icp-lto", arg)) {
                cmd.icp_lto = true;
            } else if (mem.testEqualString("--icp-max-annotations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_max_annotations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--icp-max-prom", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_max_prom = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--icp-remaining-percent-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_remaining_percent_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--icp-samplepgo", arg)) {
                cmd.icp_samplepgo = true;
            } else if (mem.testEqualString("--icp-total-percent-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.icp_total_percent_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ifcvt-branch-fold", arg)) {
                cmd.ifcvt_branch_fold = true;
            } else if (mem.testEqualString("--ifcvt-fn-start", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ifcvt_fn_start = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ifcvt-fn-stop", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ifcvt_fn_stop = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ifcvt-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ifcvt_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ignore-bb-reg-pressure", arg)) {
                cmd.ignore_bb_reg_pressure = true;
            } else if (mem.testEqualString("--ignore-tti-inline-compatible", arg)) {
                cmd.ignore_tti_inline_compatible = true;
            } else if (mem.testEqualString("--ignore-xcoff-visibility", arg)) {
                cmd.ignore_xcoff_visibility = true;
            } else if (mem.testEqualString("--imp-null-check-page-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.imp_null_check_page_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--imp-null-max-insts-to-consider", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.imp_null_max_insts_to_consider = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-all-index", arg)) {
                cmd.import_all_index = true;
            } else if (mem.testEqualString("--import-cold-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_cold_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-constants-with-refs", arg)) {
                cmd.import_constants_with_refs = true;
            } else if (mem.testEqualString("--import-critical-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_critical_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-full-type-definitions", arg)) {
                cmd.import_full_type_definitions = true;
            } else if (mem.testEqualString("--import-hot-evolution-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_hot_evolution_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-hot-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_hot_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-instr-evolution-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_instr_evolution_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--import-instr-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.import_instr_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--incremental-linker-compatible", arg)) {
                cmd.incremental_linker_compatible = true;
            } else if (mem.testEqualString("--indvars-post-increment-ranges", arg)) {
                cmd.indvars_post_increment_ranges = true;
            } else if (mem.testEqualString("--indvars-predicate-loops", arg)) {
                cmd.indvars_predicate_loops = true;
            } else if (mem.testEqualString("--indvars-widen-indvars", arg)) {
                cmd.indvars_widen_indvars = true;
            } else if (mem.testEqualString("--info-output-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.info_output_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--initial-synthetic-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.initial_synthetic_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-call-penalty", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_call_penalty = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-caller-superset-nobuiltin", arg)) {
                cmd.inline_caller_superset_nobuiltin = true;
            } else if (mem.testEqualString("--inline-cold-callsite-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_cold_callsite_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-cost-full", arg)) {
                cmd.inline_cost_full = true;
            } else if (mem.testEqualString("--inline-deferral", arg)) {
                cmd.inline_deferral = true;
            } else if (mem.testEqualString("--inline-deferral-scale", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_deferral_scale = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-enable-cost-benefit-analysis", arg)) {
                cmd.inline_enable_cost_benefit_analysis = true;
            } else if (mem.testEqualString("--inline-instr-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_instr_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-max-stacksize", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_max_stacksize = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-memaccess-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_memaccess_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-remark-attribute", arg)) {
                cmd.inline_remark_attribute = true;
            } else if (mem.testEqualString("--inline-savings-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_savings_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-size-allowance", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_size_allowance = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-synthetic-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_synthetic_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inlinecold-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inlinecold_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inlinedefault-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inlinedefault_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--inlinehint-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.inlinehint_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--insert-all0", arg)) {
                cmd.insert_all0 = true;
            } else if (mem.testEqualString("--insert-const", arg)) {
                cmd.insert_const = true;
            } else if (mem.testEqualString("--insert-dist-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.insert_dist_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--insert-has0", arg)) {
                cmd.insert_has0 = true;
            } else if (mem.testEqualString("--insert-max-ifmap", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.insert_max_ifmap = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--insert-max-orl", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.insert_max_orl = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--insert-timing", arg)) {
                cmd.insert_timing = true;
            } else if (mem.testEqualString("--insert-timing-detail", arg)) {
                cmd.insert_timing_detail = true;
            } else if (mem.testEqualString("--insert-vreg-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.insert_vreg_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-code-sinking", arg)) {
                cmd.instcombine_code_sinking = true;
            } else if (mem.testEqualString("--instcombine-guard-widening-window", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_guard_widening_window = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-infinite-loop-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_infinite_loop_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-lower-dbg-declare", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_lower_dbg_declare = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-max-copied-from-constant-users", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_max_copied_from_constant_users = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-max-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_max_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-max-num-phis", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_max_num_phis = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-max-sink-users", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_max_sink_users = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-maxarray-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_maxarray_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instcombine-negator-enabled", arg)) {
                cmd.instcombine_negator_enabled = true;
            } else if (mem.testEqualString("--instcombine-negator-max-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.instcombine_negator_max_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--instrprof-atomic-counter-update-all", arg)) {
                cmd.instrprof_atomic_counter_update_all = true;
            } else if (mem.testEqualString("--interleave-loops", arg)) {
                cmd.interleave_loops = true;
            } else if (mem.testEqualString("--interleave-small-loop-scalar-reduction", arg)) {
                cmd.interleave_small_loop_scalar_reduction = true;
            } else if (mem.testEqualString("--internalize-public-api-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.internalize_public_api_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--internalize-public-api-list", arg)) {
                cmd.internalize_public_api_list = true;
            } else if (mem.testEqualString("--interpreter-print-volatile", arg)) {
                cmd.interpreter_print_volatile = true;
            } else if (mem.testEqualString("--intra-scc-cost-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.intra_scc_cost_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ir-outliner", arg)) {
                cmd.ir_outliner = true;
            } else if (mem.testEqualString("--irce-allow-narrow-latch", arg)) {
                cmd.irce_allow_narrow_latch = true;
            } else if (mem.testEqualString("--irce-allow-unsigned-latch", arg)) {
                cmd.irce_allow_unsigned_latch = true;
            } else if (mem.testEqualString("--irce-loop-size-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.irce_loop_size_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--irce-min-runtime-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.irce_min_runtime_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--irce-print-changed-loops", arg)) {
                cmd.irce_print_changed_loops = true;
            } else if (mem.testEqualString("--irce-print-range-checks", arg)) {
                cmd.irce_print_range_checks = true;
            } else if (mem.testEqualString("--irce-skip-profitability-checks", arg)) {
                cmd.irce_skip_profitability_checks = true;
            } else if (mem.testEqualString("--isel-rebalance-addr", arg)) {
                cmd.isel_rebalance_addr = true;
            } else if (mem.testEqualString("--iterative-bfi-max-iterations-per-block", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.iterative_bfi_max_iterations_per_block = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--iterative-bfi-precision", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.iterative_bfi_precision = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--iterative-counter-promotion", arg)) {
                cmd.iterative_counter_promotion = true;
            } else if (mem.testEqualString("--join-globalcopies", arg)) {
                cmd.join_globalcopies = true;
            } else if (mem.testEqualString("--join-liveintervals", arg)) {
                cmd.join_liveintervals = true;
            } else if (mem.testEqualString("--join-splitedges", arg)) {
                cmd.join_splitedges = true;
            } else if (mem.testEqualString("--jump-inst-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.jump_inst_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--jump-is-expensive", arg)) {
                cmd.jump_is_expensive = true;
            } else if (mem.testEqualString("--jump-table-density", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.jump_table_density = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--jump-threading-across-loop-headers", arg)) {
                cmd.jump_threading_across_loop_headers = true;
            } else if (mem.testEqualString("--jump-threading-implication-search-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.jump_threading_implication_search_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--jump-threading-phi-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.jump_threading_phi_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--jump-threading-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.jump_threading_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--keep-inline-advisor-for-printing", arg)) {
                cmd.keep_inline_advisor_for_printing = true;
            } else if (mem.testEqualString("--keep-loops", arg)) {
                cmd.keep_loops = true;
            } else if (mem.testEqualString("--lanai-constant-mul-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lanai_constant_mul_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lanai-nop-delay-filler", arg)) {
                cmd.lanai_nop_delay_filler = true;
            } else if (mem.testEqualString("--lanai-ssection-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lanai_ssection_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--large-interval-freq-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.large_interval_freq_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--large-interval-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.large_interval_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--late-remat-update-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.late_remat_update_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lcr-max-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lcr_max_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lcr-max-interf", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lcr_max_interf = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ldstmemcpy-glue-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ldstmemcpy_glue_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--licm-control-flow-hoisting", arg)) {
                cmd.licm_control_flow_hoisting = true;
            } else if (mem.testEqualString("--licm-force-thread-model-single", arg)) {
                cmd.licm_force_thread_model_single = true;
            } else if (mem.testEqualString("--licm-max-num-uses-traversed", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.licm_max_num_uses_traversed = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--licm-mssa-max-acc-promotion", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.licm_mssa_max_acc_promotion = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--licm-mssa-optimization-cap", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.licm_mssa_optimization_cap = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--licm-versioning-invariant-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.licm_versioning_invariant_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--licm-versioning-max-depth-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.licm_versioning_max_depth_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--likely-branch-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.likely_branch_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--limit-float-precision", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.limit_float_precision = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--live-debug-variables", arg)) {
                cmd.live_debug_variables = true;
            } else if (mem.testEqualString("--livedebugvalues-input-bb-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.livedebugvalues_input_bb_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--livedebugvalues-input-dbg-value-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.livedebugvalues_input_dbg_value_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--livedebugvalues-max-stack-slots", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.livedebugvalues_max_stack_slots = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--load", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.load = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--locally-hot-callsite-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.locally_hot_callsite_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loongarch-check-zero-division", arg)) {
                cmd.loongarch_check_zero_division = true;
            } else if (mem.testEqualString("--loongarch-numeric-reg", arg)) {
                cmd.loongarch_numeric_reg = true;
            } else if (mem.testEqualString("--loop-deletion-enable-symbolic-execution", arg)) {
                cmd.loop_deletion_enable_symbolic_execution = true;
            } else if (mem.testEqualString("--loop-distribute-non-if-convertible", arg)) {
                cmd.loop_distribute_non_if_convertible = true;
            } else if (mem.testEqualString("--loop-distribute-scev-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_distribute_scev_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-distribute-scev-check-threshold-with-pragma", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_distribute_scev_check_threshold_with_pragma = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-distribute-verify", arg)) {
                cmd.loop_distribute_verify = true;
            } else if (mem.testEqualString("--loop-flatten-assume-no-overflow", arg)) {
                cmd.loop_flatten_assume_no_overflow = true;
            } else if (mem.testEqualString("--loop-flatten-cost-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_flatten_cost_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-flatten-widen-iv", arg)) {
                cmd.loop_flatten_widen_iv = true;
            } else if (mem.testEqualString("--loop-fusion-peel-max-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_fusion_peel_max_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-interchange-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_interchange_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-load-elimination-scev-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_load_elimination_scev_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-predication-enable-count-down-loop", arg)) {
                cmd.loop_predication_enable_count_down_loop = true;
            } else if (mem.testEqualString("--loop-predication-enable-iv-truncation", arg)) {
                cmd.loop_predication_enable_iv_truncation = true;
            } else if (mem.testEqualString("--loop-predication-insert-assumes-of-predicated-guards-conditions", arg)) {
                cmd.loop_predication_insert_assumes_of_predicated_guards_conditions = true;
            } else if (mem.testEqualString("--loop-predication-latch-probability-scale", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_predication_latch_probability_scale = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-predication-predicate-widenable-branches-to-deopt", arg)) {
                cmd.loop_predication_predicate_widenable_branches_to_deopt = true;
            } else if (mem.testEqualString("--loop-predication-skip-profitability-checks", arg)) {
                cmd.loop_predication_skip_profitability_checks = true;
            } else if (mem.testEqualString("--loop-prefetch-writes", arg)) {
                cmd.loop_prefetch_writes = true;
            } else if (mem.testEqualString("--loop-rotate-multi", arg)) {
                cmd.loop_rotate_multi = true;
            } else if (mem.testEqualString("--loop-to-cold-block-ratio", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.loop_to_cold_block_ratio = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--loop-vectorize-with-block-frequency", arg)) {
                cmd.loop_vectorize_with_block_frequency = true;
            } else if (mem.testEqualString("--loop-version-annotate-no-alias", arg)) {
                cmd.loop_version_annotate_no_alias = true;
            } else if (mem.testEqualString("--lower-global-dtors-via-cxa-atexit", arg)) {
                cmd.lower_global_dtors_via_cxa_atexit = true;
            } else if (mem.testEqualString("--lower-interleaved-accesses", arg)) {
                cmd.lower_interleaved_accesses = true;
            } else if (mem.testEqualString("--lowertypetests-avoid-reuse", arg)) {
                cmd.lowertypetests_avoid_reuse = true;
            } else if (mem.testEqualString("--lowertypetests-drop-type-tests", arg)) {
                cmd.lowertypetests_drop_type_tests = true;
            } else if (mem.testEqualString("--lowertypetests-read-summary", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lowertypetests_read_summary = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lowertypetests-write-summary", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lowertypetests_write_summary = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lsr-complexity-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lsr_complexity_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lsr-drop-solution", arg)) {
                cmd.lsr_drop_solution = true;
            } else if (mem.testEqualString("--lsr-exp-narrow", arg)) {
                cmd.lsr_exp_narrow = true;
            } else if (mem.testEqualString("--lsr-filter-same-scaled-reg", arg)) {
                cmd.lsr_filter_same_scaled_reg = true;
            } else if (mem.testEqualString("--lsr-insns-cost", arg)) {
                cmd.lsr_insns_cost = true;
            } else if (mem.testEqualString("--lsr-setupcost-depth-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lsr_setupcost_depth_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lsr-term-fold", arg)) {
                cmd.lsr_term_fold = true;
            } else if (mem.testEqualString("--lto-aix-system-assembler", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lto_aix_system_assembler = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lto-discard-value-names", arg)) {
                cmd.lto_discard_value_names = true;
            } else if (mem.testEqualString("--lto-pass-remarks-filter", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lto_pass_remarks_filter = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lto-pass-remarks-format", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lto_pass_remarks_format = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lto-pass-remarks-hotness-threshold", arg)) {
                cmd.lto_pass_remarks_hotness_threshold = true;
            } else if (mem.testEqualString("--lto-pass-remarks-output", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lto_pass_remarks_output = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--lto-pass-remarks-with-hotness", arg)) {
                cmd.lto_pass_remarks_with_hotness = true;
            } else if (mem.testEqualString("--lto-stats-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.lto_stats_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-combiner-dump-subst-intrs", arg)) {
                cmd.machine_combiner_dump_subst_intrs = true;
            } else if (mem.testEqualString("--machine-combiner-inc-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_combiner_inc_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-combiner-verify-pattern-order", arg)) {
                cmd.machine_combiner_verify_pattern_order = true;
            } else if (mem.testEqualString("--machine-outliner-reruns", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_outliner_reruns = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-sink-bfi", arg)) {
                cmd.machine_sink_bfi = true;
            } else if (mem.testEqualString("--machine-sink-cycle-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_sink_cycle_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-sink-load-blocks-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_sink_load_blocks_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-sink-load-instrs-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_sink_load_instrs_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--machine-sink-split", arg)) {
                cmd.machine_sink_split = true;
            } else if (mem.testEqualString("--machine-sink-split-probability-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.machine_sink_split_probability_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mandatory-inlining-first", arg)) {
                cmd.mandatory_inlining_first = true;
            } else if (mem.testEqualString("--march", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.march = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mark-data-regions", arg)) {
                cmd.mark_data_regions = true;
            } else if (mem.testEqualString("--matrix-allow-contract", arg)) {
                cmd.matrix_allow_contract = true;
            } else if (mem.testEqualString("--matrix-print-after-transpose-opt", arg)) {
                cmd.matrix_print_after_transpose_opt = true;
            } else if (mem.testEqualString("--max-booleans-in-control-flow-hub", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_booleans_in_control_flow_hub = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-bytes-for-alignment", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_bytes_for_alignment = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-counter-promotions", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_counter_promotions = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-counter-promotions-per-loop", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_counter_promotions_per_loop = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-deopt-or-unreachable-succ-check-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_deopt_or_unreachable_succ_check_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-dependences", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_dependences = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-forked-scev-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_forked_scev_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-heap-to-stack-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_heap_to_stack_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-hsdr", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_hsdr = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-inst-checked-for-throw-during-inlining", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_inst_checked_for_throw_during_inlining = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-interleave-group-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_interleave_group_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-jump-table-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_jump_table_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-loads-per-memcmp", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_loads_per_memcmp = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-loads-per-memcmp-opt-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_loads_per_memcmp_opt_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-nested-scalar-reduction-interleave", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_nested_scalar_reduction_interleave = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-num-inline-blocks", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_num_inline_blocks = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-num-inst-between-tfr-and-nv-store", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_num_inst_between_tfr_and_nv_store = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-partial-inlining", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_partial_inlining = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-prefetch-iters-ahead", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_prefetch_iters_ahead = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-registers-for-gc-values", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_registers_for_gc_values = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-sched-reorder", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_sched_reorder = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-speculation-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_speculation_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memcpy", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memcpy = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memcpy-Os", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memcpy_Os = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memmove", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memmove = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memmove-Os", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memmove_Os = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memset", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memset = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-store-memset-Os", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_store_memset_Os = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-switch-cases-per-result", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_switch_cases_per_result = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--max-uses-for-sinking", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.max_uses_for_sinking = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mc-relax-all", arg)) {
                cmd.mc_relax_all = true;
            } else if (mem.testEqualString("--mcabac", arg)) {
                cmd.mcabac = true;
            } else if (mem.testEqualString("--mcfg-dot-filename-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mcfg_dot_filename_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mcfg-func-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mcfg_func_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mcp-use-is-copy-instr", arg)) {
                cmd.mcp_use_is_copy_instr = true;
            } else if (mem.testEqualString("--mcpu", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mcpu = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mem-loc-frag-fill", arg)) {
                cmd.mem_loc_frag_fill = true;
            } else if (mem.testEqualString("--membedded-data", arg)) {
                cmd.membedded_data = true;
            } else if (mem.testEqualString("--memcmp-num-loads-per-block", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memcmp_num_loads_per_block = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memdep-block-number-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memdep_block_number_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memdep-block-scan-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memdep_block_scan_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memop-max-annotations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memop_max_annotations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memop-value-prof-max-opt-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memop_value_prof_max_opt_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memory-check-merge-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memory_check_merge_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-accesses-per-byte-cold-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_accesses_per_byte_cold_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-debug", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_debug = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-debug-func", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_debug_func = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-debug-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_debug_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-debug-min", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_debug_min = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-guard-against-version-mismatch", arg)) {
                cmd.memprof_guard_against_version_mismatch = true;
            } else if (mem.testEqualString("--memprof-instrument-atomics", arg)) {
                cmd.memprof_instrument_atomics = true;
            } else if (mem.testEqualString("--memprof-instrument-reads", arg)) {
                cmd.memprof_instrument_reads = true;
            } else if (mem.testEqualString("--memprof-instrument-stack", arg)) {
                cmd.memprof_instrument_stack = true;
            } else if (mem.testEqualString("--memprof-instrument-writes", arg)) {
                cmd.memprof_instrument_writes = true;
            } else if (mem.testEqualString("--memprof-mapping-granularity", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_mapping_granularity = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-mapping-scale", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_mapping_scale = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-memory-access-callback-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_memory_access_callback_prefix = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-min-lifetime-cold-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memprof_min_lifetime_cold_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--memprof-use-callbacks", arg)) {
                cmd.memprof_use_callbacks = true;
            } else if (mem.testEqualString("--memssa-check-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.memssa_check_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mergefunc-preserve-debug-info", arg)) {
                cmd.mergefunc_preserve_debug_info = true;
            } else if (mem.testEqualString("--mergefunc-use-aliases", arg)) {
                cmd.mergefunc_use_aliases = true;
            } else if (mem.testEqualString("--mergefunc-verify", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mergefunc_verify = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--merror-missing-parenthesis", arg)) {
                cmd.merror_missing_parenthesis = true;
            } else if (mem.testEqualString("--merror-noncontigious-register", arg)) {
                cmd.merror_noncontigious_register = true;
            } else if (mem.testEqualString("--mextern-sdata", arg)) {
                cmd.mextern_sdata = true;
            } else if (mem.testEqualString("--mfix4300", arg)) {
                cmd.mfix4300 = true;
            } else if (mem.testEqualString("--mfs-count-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mfs_count_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mfs-psi-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mfs_psi_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mfs-split-ehcode", arg)) {
                cmd.mfs_split_ehcode = true;
            } else if (mem.testEqualString("--mgpopt", arg)) {
                cmd.mgpopt = true;
            } else if (mem.testEqualString("--mhvx-ieee-fp", arg)) {
                cmd.mhvx_ieee_fp = true;
            } else if (mem.testEqualString("--min-block-execution", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.min_block_execution = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--min-ctr-loop-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.min_ctr_loop_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--min-jump-table-entries", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.min_jump_table_entries = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--min-prefetch-stride", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.min_prefetch_stride = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--min-region-size-ratio", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.min_region_size_ratio = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--minimum-jump-tables", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.minimum_jump_tables = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mips-align-constant-islands", arg)) {
                cmd.mips_align_constant_islands = true;
            } else if (mem.testEqualString("--mips-constant-islands-no-load-relaxation", arg)) {
                cmd.mips_constant_islands_no_load_relaxation = true;
            } else if (mem.testEqualString("--mips-constant-islands-small-offset", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mips_constant_islands_small_offset = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mips-erase-gp-opnd", arg)) {
                cmd.mips_erase_gp_opnd = true;
            } else if (mem.testEqualString("--mips-fix-global-base-reg", arg)) {
                cmd.mips_fix_global_base_reg = true;
            } else if (mem.testEqualString("--mips-jalr-reloc", arg)) {
                cmd.mips_jalr_reloc = true;
            } else if (mem.testEqualString("--mips-load-target-from-got", arg)) {
                cmd.mips_load_target_from_got = true;
            } else if (mem.testEqualString("--mips-mixed-16-32", arg)) {
                cmd.mips_mixed_16_32 = true;
            } else if (mem.testEqualString("--mips-os16", arg)) {
                cmd.mips_os16 = true;
            } else if (mem.testEqualString("--mips-round-section-sizes", arg)) {
                cmd.mips_round_section_sizes = true;
            } else if (mem.testEqualString("--mips-ssection-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mips_ssection_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mips-tail-calls", arg)) {
                cmd.mips_tail_calls = true;
            } else if (mem.testEqualString("--mips16-constant-islands", arg)) {
                cmd.mips16_constant_islands = true;
            } else if (mem.testEqualString("--mips16-dont-expand-cond-pseudo", arg)) {
                cmd.mips16_dont_expand_cond_pseudo = true;
            } else if (mem.testEqualString("--mips16-hard-float", arg)) {
                cmd.mips16_hard_float = true;
            } else if (mem.testEqualString("--mips32-function-mask", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mips32_function_mask = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mipspostlegalizercombinerhelper-disable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mipspostlegalizercombinerhelper_disable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mipspostlegalizercombinerhelper-only-enable-rule", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mipspostlegalizercombinerhelper_only_enable_rule = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mir-debug-loc", arg)) {
                cmd.mir_debug_loc = true;
            } else if (mem.testEqualString("--mir-strip-debugify-only", arg)) {
                cmd.mir_strip_debugify_only = true;
            } else if (mem.testEqualString("--mir-vreg-namer-use-stable-hash", arg)) {
                cmd.mir_vreg_namer_use_stable_hash = true;
            } else if (mem.testEqualString("--misched-bottomup", arg)) {
                cmd.misched_bottomup = true;
            } else if (mem.testEqualString("--misched-cluster", arg)) {
                cmd.misched_cluster = true;
            } else if (mem.testEqualString("--misched-cyclicpath", arg)) {
                cmd.misched_cyclicpath = true;
            } else if (mem.testEqualString("--misched-dcpl", arg)) {
                cmd.misched_dcpl = true;
            } else if (mem.testEqualString("--misched-fusion", arg)) {
                cmd.misched_fusion = true;
            } else if (mem.testEqualString("--misched-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.misched_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--misched-postra", arg)) {
                cmd.misched_postra = true;
            } else if (mem.testEqualString("--misched-regpressure", arg)) {
                cmd.misched_regpressure = true;
            } else if (mem.testEqualString("--misched-topdown", arg)) {
                cmd.misched_topdown = true;
            } else if (mem.testEqualString("--misched-verbose-level", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.misched_verbose_level = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--misexpect-tolerance", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.misexpect_tolerance = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--misfetch-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.misfetch_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mispredict-default-rate", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mispredict_default_rate = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ml-advisor-keep-fpi-cache", arg)) {
                cmd.ml_advisor_keep_fpi_cache = true;
            } else if (mem.testEqualString("--ml-advisor-size-increase-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ml_advisor_size_increase_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mlocal-sdata", arg)) {
                cmd.mlocal_sdata = true;
            } else if (mem.testEqualString("--mno-check-zero-division", arg)) {
                cmd.mno_check_zero_division = true;
            } else if (mem.testEqualString("--mno-compound", arg)) {
                cmd.mno_compound = true;
            } else if (mem.testEqualString("--mno-fixup", arg)) {
                cmd.mno_fixup = true;
            } else if (mem.testEqualString("--mno-hvx", arg)) {
                cmd.mno_hvx = true;
            } else if (mem.testEqualString("--mno-ldc1-sdc1", arg)) {
                cmd.mno_ldc1_sdc1 = true;
            } else if (mem.testEqualString("--mno-pairing", arg)) {
                cmd.mno_pairing = true;
            } else if (mem.testEqualString("--mno-sort-sda", arg)) {
                cmd.mno_sort_sda = true;
            } else if (mem.testEqualString("--module-summary-dot-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.module_summary_dot_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--moudle-inliner-top-priority-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.moudle_inliner_top_priority_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-and-mask", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_and_mask = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-check-access-address", arg)) {
                cmd.msan_check_access_address = true;
            } else if (mem.testEqualString("--msan-check-constant-shadow", arg)) {
                cmd.msan_check_constant_shadow = true;
            } else if (mem.testEqualString("--msan-disable-checks", arg)) {
                cmd.msan_disable_checks = true;
            } else if (mem.testEqualString("--msan-disambiguate-warning-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_disambiguate_warning_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-dump-strict-instructions", arg)) {
                cmd.msan_dump_strict_instructions = true;
            } else if (mem.testEqualString("--msan-eager-checks", arg)) {
                cmd.msan_eager_checks = true;
            } else if (mem.testEqualString("--msan-handle-asm-conservative", arg)) {
                cmd.msan_handle_asm_conservative = true;
            } else if (mem.testEqualString("--msan-handle-icmp", arg)) {
                cmd.msan_handle_icmp = true;
            } else if (mem.testEqualString("--msan-handle-icmp-exact", arg)) {
                cmd.msan_handle_icmp_exact = true;
            } else if (mem.testEqualString("--msan-handle-lifetime-intrinsics", arg)) {
                cmd.msan_handle_lifetime_intrinsics = true;
            } else if (mem.testEqualString("--msan-instrumentation-with-call-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_instrumentation_with_call_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-keep-going", arg)) {
                cmd.msan_keep_going = true;
            } else if (mem.testEqualString("--msan-kernel", arg)) {
                cmd.msan_kernel = true;
            } else if (mem.testEqualString("--msan-origin-base", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_origin_base = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-poison-stack", arg)) {
                cmd.msan_poison_stack = true;
            } else if (mem.testEqualString("--msan-poison-stack-pattern", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_poison_stack_pattern = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-poison-stack-with-call", arg)) {
                cmd.msan_poison_stack_with_call = true;
            } else if (mem.testEqualString("--msan-poison-undef", arg)) {
                cmd.msan_poison_undef = true;
            } else if (mem.testEqualString("--msan-print-stack-names", arg)) {
                cmd.msan_print_stack_names = true;
            } else if (mem.testEqualString("--msan-shadow-base", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_shadow_base = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-track-origins", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_track_origins = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msan-with-comdat", arg)) {
                cmd.msan_with_comdat = true;
            } else if (mem.testEqualString("--msan-xor-mask", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.msan_xor_mask = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--msp430-branch-select", arg)) {
                cmd.msp430_branch_select = true;
            } else if (mem.testEqualString("--msp430-no-legal-immediate", arg)) {
                cmd.msp430_no_legal_immediate = true;
            } else if (mem.testEqualString("--mtriple", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mtriple = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mul-constant-optimization", arg)) {
                cmd.mul_constant_optimization = true;
            } else if (mem.testEqualString("--mv5", arg)) {
                cmd.mv5 = true;
            } else if (mem.testEqualString("--mv55", arg)) {
                cmd.mv55 = true;
            } else if (mem.testEqualString("--mv60", arg)) {
                cmd.mv60 = true;
            } else if (mem.testEqualString("--mv62", arg)) {
                cmd.mv62 = true;
            } else if (mem.testEqualString("--mv65", arg)) {
                cmd.mv65 = true;
            } else if (mem.testEqualString("--mv66", arg)) {
                cmd.mv66 = true;
            } else if (mem.testEqualString("--mv67", arg)) {
                cmd.mv67 = true;
            } else if (mem.testEqualString("--mv67t", arg)) {
                cmd.mv67t = true;
            } else if (mem.testEqualString("--mv68", arg)) {
                cmd.mv68 = true;
            } else if (mem.testEqualString("--mv69", arg)) {
                cmd.mv69 = true;
            } else if (mem.testEqualString("--mv71", arg)) {
                cmd.mv71 = true;
            } else if (mem.testEqualString("--mv71t", arg)) {
                cmd.mv71t = true;
            } else if (mem.testEqualString("--mv73", arg)) {
                cmd.mv73 = true;
            } else if (mem.testEqualString("--mve-max-interleave-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.mve_max_interleave_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--mwarn-missing-parenthesis", arg)) {
                cmd.mwarn_missing_parenthesis = true;
            } else if (mem.testEqualString("--mwarn-noncontigious-register", arg)) {
                cmd.mwarn_noncontigious_register = true;
            } else if (mem.testEqualString("--mwarn-sign-mismatch", arg)) {
                cmd.mwarn_sign_mismatch = true;
            } else if (mem.testEqualString("--no-deprecated-warn", arg)) {
                cmd.no_deprecated_warn = true;
            } else if (mem.testEqualString("--no-discriminators", arg)) {
                cmd.no_discriminators = true;
            } else if (mem.testEqualString("--no-dwarf-ranges-section", arg)) {
                cmd.no_dwarf_ranges_section = true;
            } else if (mem.testEqualString("--no-integrated-as", arg)) {
                cmd.no_integrated_as = true;
            } else if (mem.testEqualString("--no-pgo-warn-mismatch", arg)) {
                cmd.no_pgo_warn_mismatch = true;
            } else if (mem.testEqualString("--no-pgo-warn-mismatch-comdat-weak", arg)) {
                cmd.no_pgo_warn_mismatch_comdat_weak = true;
            } else if (mem.testEqualString("--no-phi-elim-live-out-early-exit", arg)) {
                cmd.no_phi_elim_live_out_early_exit = true;
            } else if (mem.testEqualString("--no-stack-coloring", arg)) {
                cmd.no_stack_coloring = true;
            } else if (mem.testEqualString("--no-stack-slot-sharing", arg)) {
                cmd.no_stack_slot_sharing = true;
            } else if (mem.testEqualString("--no-type-check", arg)) {
                cmd.no_type_check = true;
            } else if (mem.testEqualString("--no-warn", arg)) {
                cmd.no_warn = true;
            } else if (mem.testEqualString("--no-warn-sample-unused", arg)) {
                cmd.no_warn_sample_unused = true;
            } else if (mem.testEqualString("--no-x86-call-frame-opt", arg)) {
                cmd.no_x86_call_frame_opt = true;
            } else if (mem.testEqualString("--no-xray-index", arg)) {
                cmd.no_xray_index = true;
            } else if (mem.testEqualString("--non-global-value-max-name-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.non_global_value_max_name_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nozero-initialized-in-bss", arg)) {
                cmd.nozero_initialized_in_bss = true;
            } else if (mem.testEqualString("--number-scavenger-slots", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.number_scavenger_slots = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nvj-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.nvj_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nvptx-fma-level", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.nvptx_fma_level = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nvptx-no-f16-math", arg)) {
                cmd.nvptx_no_f16_math = true;
            } else if (mem.testEqualString("--nvptx-prec-divf32", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.nvptx_prec_divf32 = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nvptx-prec-sqrtf32", arg)) {
                cmd.nvptx_prec_sqrtf32 = true;
            } else if (mem.testEqualString("--nvptx-sched4reg", arg)) {
                cmd.nvptx_sched4reg = true;
            } else if (mem.testEqualString("--nvptx-short-ptr", arg)) {
                cmd.nvptx_short_ptr = true;
            } else if (mem.testEqualString("--nvvm-intr-range-sm", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.nvvm_intr_range_sm = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--nvvm-reflect-enable", arg)) {
                cmd.nvvm_reflect_enable = true;
            } else if (mem.testEqualString("--old-thumb2-ifcvt", arg)) {
                cmd.old_thumb2_ifcvt = true;
            } else if (mem.testEqualString("--only-nonnested-memmove-idiom", arg)) {
                cmd.only_nonnested_memmove_idiom = true;
            } else if (mem.testEqualString("--only-simple-regions", arg)) {
                cmd.only_simple_regions = true;
            } else if (mem.testEqualString("--opaque-pointers", arg)) {
                cmd.opaque_pointers = true;
            } else if (mem.testEqualString("--openmp-deduce-icv-values", arg)) {
                cmd.openmp_deduce_icv_values = true;
            } else if (mem.testEqualString("--openmp-hide-memory-transfer-latency", arg)) {
                cmd.openmp_hide_memory_transfer_latency = true;
            } else if (mem.testEqualString("--openmp-ir-builder-optimistic-attributes", arg)) {
                cmd.openmp_ir_builder_optimistic_attributes = true;
            } else if (mem.testEqualString("--openmp-ir-builder-unroll-threshold-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.openmp_ir_builder_unroll_threshold_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--openmp-opt-disable", arg)) {
                cmd.openmp_opt_disable = true;
            } else if (mem.testEqualString("--openmp-opt-disable-barrier-elimination", arg)) {
                cmd.openmp_opt_disable_barrier_elimination = true;
            } else if (mem.testEqualString("--openmp-opt-disable-deglobalization", arg)) {
                cmd.openmp_opt_disable_deglobalization = true;
            } else if (mem.testEqualString("--openmp-opt-disable-folding", arg)) {
                cmd.openmp_opt_disable_folding = true;
            } else if (mem.testEqualString("--openmp-opt-disable-internalization", arg)) {
                cmd.openmp_opt_disable_internalization = true;
            } else if (mem.testEqualString("--openmp-opt-disable-spmdization", arg)) {
                cmd.openmp_opt_disable_spmdization = true;
            } else if (mem.testEqualString("--openmp-opt-disable-state-machine-rewrite", arg)) {
                cmd.openmp_opt_disable_state_machine_rewrite = true;
            } else if (mem.testEqualString("--openmp-opt-enable-merging", arg)) {
                cmd.openmp_opt_enable_merging = true;
            } else if (mem.testEqualString("--openmp-opt-inline-device", arg)) {
                cmd.openmp_opt_inline_device = true;
            } else if (mem.testEqualString("--openmp-opt-max-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.openmp_opt_max_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--openmp-opt-print-module-after", arg)) {
                cmd.openmp_opt_print_module_after = true;
            } else if (mem.testEqualString("--openmp-opt-print-module-before", arg)) {
                cmd.openmp_opt_print_module_before = true;
            } else if (mem.testEqualString("--openmp-opt-shared-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.openmp_opt_shared_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--openmp-opt-verbose-remarks", arg)) {
                cmd.openmp_opt_verbose_remarks = true;
            } else if (mem.testEqualString("--openmp-print-gpu-kernels", arg)) {
                cmd.openmp_print_gpu_kernels = true;
            } else if (mem.testEqualString("--openmp-print-icv-values", arg)) {
                cmd.openmp_print_icv_values = true;
            } else if (mem.testEqualString("--opt-bisect-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.opt_bisect_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--opt-bisect-print-ir-path", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.opt_bisect_print_ir_path = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--optimize-regalloc", arg)) {
                cmd.optimize_regalloc = true;
            } else if (mem.testEqualString("--optsize-jump-table-density", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.optsize_jump_table_density = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--orderfile-write-mapping", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.orderfile_write_mapping = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--outline-region-freq-percent", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.outline_region_freq_percent = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--overwrite-existing-weights", arg)) {
                cmd.overwrite_existing_weights = true;
            } else if (mem.testEqualString("--partial-inlining-extra-penalty", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.partial_inlining_extra_penalty = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--partial-profile", arg)) {
                cmd.partial_profile = true;
            } else if (mem.testEqualString("--partial-reg-update-clearance", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.partial_reg_update_clearance = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--partial-sample-profile-working-set-size-scale-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.partial_sample_profile_working_set_size_scale_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--partial-unrolling-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.partial_unrolling_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-analysis", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks_analysis = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-filter", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks_filter = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-format", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks_format = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-hotness-threshold", arg)) {
                cmd.pass_remarks_hotness_threshold = true;
            } else if (mem.testEqualString("--pass-remarks-missed", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks_missed = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-output", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pass_remarks_output = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pass-remarks-with-hotness", arg)) {
                cmd.pass_remarks_with_hotness = true;
            } else if (mem.testEqualString("--pbqp-coalescing", arg)) {
                cmd.pbqp_coalescing = true;
            } else if (mem.testEqualString("--persist-profile-staleness", arg)) {
                cmd.persist_profile_staleness = true;
            } else if (mem.testEqualString("--pgo-critical-edge-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_critical_edge_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-emit-branch-prob", arg)) {
                cmd.pgo_emit_branch_prob = true;
            } else if (mem.testEqualString("--pgo-fix-entry-count", arg)) {
                cmd.pgo_fix_entry_count = true;
            } else if (mem.testEqualString("--pgo-function-entry-coverage", arg)) {
                cmd.pgo_function_entry_coverage = true;
            } else if (mem.testEqualString("--pgo-function-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_function_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-instr-memop", arg)) {
                cmd.pgo_instr_memop = true;
            } else if (mem.testEqualString("--pgo-instr-old-cfg-hashing", arg)) {
                cmd.pgo_instr_old_cfg_hashing = true;
            } else if (mem.testEqualString("--pgo-instr-select", arg)) {
                cmd.pgo_instr_select = true;
            } else if (mem.testEqualString("--pgo-instrument-entry", arg)) {
                cmd.pgo_instrument_entry = true;
            } else if (mem.testEqualString("--pgo-match-memprof", arg)) {
                cmd.pgo_match_memprof = true;
            } else if (mem.testEqualString("--pgo-memop-count-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_memop_count_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-memop-max-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_memop_max_version = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-memop-optimize-memcmp-bcmp", arg)) {
                cmd.pgo_memop_optimize_memcmp_bcmp = true;
            } else if (mem.testEqualString("--pgo-memop-percent-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_memop_percent_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-memop-scale-count", arg)) {
                cmd.pgo_memop_scale_count = true;
            } else if (mem.testEqualString("--pgo-test-profile-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_test_profile_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-test-profile-remapping-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_test_profile_remapping_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-verify-bfi", arg)) {
                cmd.pgo_verify_bfi = true;
            } else if (mem.testEqualString("--pgo-verify-bfi-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_verify_bfi_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-verify-bfi-ratio", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgo_verify_bfi_ratio = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgo-verify-hot-bfi", arg)) {
                cmd.pgo_verify_hot_bfi = true;
            } else if (mem.testEqualString("--pgo-warn-misexpect", arg)) {
                cmd.pgo_warn_misexpect = true;
            } else if (mem.testEqualString("--pgo-warn-missing-function", arg)) {
                cmd.pgo_warn_missing_function = true;
            } else if (mem.testEqualString("--pgso", arg)) {
                cmd.pgso = true;
            } else if (mem.testEqualString("--pgso-cold-code-only", arg)) {
                cmd.pgso_cold_code_only = true;
            } else if (mem.testEqualString("--pgso-cold-code-only-for-instr-pgo", arg)) {
                cmd.pgso_cold_code_only_for_instr_pgo = true;
            } else if (mem.testEqualString("--pgso-cold-code-only-for-partial-sample-pgo", arg)) {
                cmd.pgso_cold_code_only_for_partial_sample_pgo = true;
            } else if (mem.testEqualString("--pgso-cold-code-only-for-sample-pgo", arg)) {
                cmd.pgso_cold_code_only_for_sample_pgo = true;
            } else if (mem.testEqualString("--pgso-cutoff-instr-prof", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgso_cutoff_instr_prof = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgso-cutoff-sample-prof", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pgso_cutoff_sample_prof = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pgso-lwss-only", arg)) {
                cmd.pgso_lwss_only = true;
            } else if (mem.testEqualString("--phi-elim-split-all-critical-edges", arg)) {
                cmd.phi_elim_split_all_critical_edges = true;
            } else if (mem.testEqualString("--phi-node-folding-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.phi_node_folding_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--phicse-debug-hash", arg)) {
                cmd.phicse_debug_hash = true;
            } else if (mem.testEqualString("--phicse-num-phi-smallsize", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.phicse_num_phi_smallsize = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pi-force-live-exit-outline", arg)) {
                cmd.pi_force_live_exit_outline = true;
            } else if (mem.testEqualString("--pi-mark-coldcc", arg)) {
                cmd.pi_mark_coldcc = true;
            } else if (mem.testEqualString("--pipeliner-annotate-for-testing", arg)) {
                cmd.pipeliner_annotate_for_testing = true;
            } else if (mem.testEqualString("--pipeliner-dbg-res", arg)) {
                cmd.pipeliner_dbg_res = true;
            } else if (mem.testEqualString("--pipeliner-experimental-cg", arg)) {
                cmd.pipeliner_experimental_cg = true;
            } else if (mem.testEqualString("--pipeliner-force-ii", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pipeliner_force_ii = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pipeliner-force-issue-width", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pipeliner_force_issue_width = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pipeliner-max-mii", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pipeliner_max_mii = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pipeliner-max-stages", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pipeliner_max_stages = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pipeliner-prune-deps", arg)) {
                cmd.pipeliner_prune_deps = true;
            } else if (mem.testEqualString("--pipeliner-prune-loop-carried", arg)) {
                cmd.pipeliner_prune_loop_carried = true;
            } else if (mem.testEqualString("--pipeliner-show-mask", arg)) {
                cmd.pipeliner_show_mask = true;
            } else if (mem.testEqualString("--poison-checking-function-local", arg)) {
                cmd.poison_checking_function_local = true;
            } else if (mem.testEqualString("--post-RA-scheduler", arg)) {
                cmd.post_RA_scheduler = true;
            } else if (mem.testEqualString("--postra-sched-debugdiv", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.postra_sched_debugdiv = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--postra-sched-debugmod", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.postra_sched_debugmod = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-always-use-base-pointer", arg)) {
                cmd.ppc_always_use_base_pointer = true;
            } else if (mem.testEqualString("--ppc-asm-full-reg-names", arg)) {
                cmd.ppc_asm_full_reg_names = true;
            } else if (mem.testEqualString("--ppc-bit-perm-rewriter-stress-rotates", arg)) {
                cmd.ppc_bit_perm_rewriter_stress_rotates = true;
            } else if (mem.testEqualString("--ppc-chaincommon-max-vars", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_chaincommon_max_vars = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-chaincommon-min-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_chaincommon_min_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-convert-rr-to-ri", arg)) {
                cmd.ppc_convert_rr_to_ri = true;
            } else if (mem.testEqualString("--ppc-disable-non-volatile-cr", arg)) {
                cmd.ppc_disable_non_volatile_cr = true;
            } else if (mem.testEqualString("--ppc-disable-perfect-shuffle", arg)) {
                cmd.ppc_disable_perfect_shuffle = true;
            } else if (mem.testEqualString("--ppc-dispprep-min-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_dispprep_min_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-dqprep-max-vars", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_dqprep_max_vars = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-dsprep-max-vars", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_dsprep_max_vars = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-eliminate-signext", arg)) {
                cmd.ppc_eliminate_signext = true;
            } else if (mem.testEqualString("--ppc-eliminate-zeroext", arg)) {
                cmd.ppc_eliminate_zeroext = true;
            } else if (mem.testEqualString("--ppc-enable-coldcc", arg)) {
                cmd.ppc_enable_coldcc = true;
            } else if (mem.testEqualString("--ppc-enable-gpr-to-vsr-spills", arg)) {
                cmd.ppc_enable_gpr_to_vsr_spills = true;
            } else if (mem.testEqualString("--ppc-enable-pe-vector-spills", arg)) {
                cmd.ppc_enable_pe_vector_spills = true;
            } else if (mem.testEqualString("--ppc-enable-pipeliner", arg)) {
                cmd.ppc_enable_pipeliner = true;
            } else if (mem.testEqualString("--ppc-fma-rp-factor", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_fma_rp_factor = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-fma-rp-reduction", arg)) {
                cmd.ppc_fma_rp_reduction = true;
            } else if (mem.testEqualString("--ppc-formprep-chain-commoning", arg)) {
                cmd.ppc_formprep_chain_commoning = true;
            } else if (mem.testEqualString("--ppc-formprep-max-vars", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_formprep_max_vars = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-formprep-prefer-update", arg)) {
                cmd.ppc_formprep_prefer_update = true;
            } else if (mem.testEqualString("--ppc-formprep-update-nonconst-inc", arg)) {
                cmd.ppc_formprep_update_nonconst_inc = true;
            } else if (mem.testEqualString("--ppc-gen-isel", arg)) {
                cmd.ppc_gen_isel = true;
            } else if (mem.testEqualString("--ppc-gep-opt", arg)) {
                cmd.ppc_gep_opt = true;
            } else if (mem.testEqualString("--ppc-late-peephole", arg)) {
                cmd.ppc_late_peephole = true;
            } else if (mem.testEqualString("--ppc-lsr-no-insns-cost", arg)) {
                cmd.ppc_lsr_no_insns_cost = true;
            } else if (mem.testEqualString("--ppc-machine-combiner", arg)) {
                cmd.ppc_machine_combiner = true;
            } else if (mem.testEqualString("--ppc-max-crbit-spill-dist", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_max_crbit_spill_dist = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-old-latency-calc", arg)) {
                cmd.ppc_old_latency_calc = true;
            } else if (mem.testEqualString("--ppc-opt-conditional-trap", arg)) {
                cmd.ppc_opt_conditional_trap = true;
            } else if (mem.testEqualString("--ppc-pcrel-linker-opt", arg)) {
                cmd.ppc_pcrel_linker_opt = true;
            } else if (mem.testEqualString("--ppc-postra-bias-addi", arg)) {
                cmd.ppc_postra_bias_addi = true;
            } else if (mem.testEqualString("--ppc-preinc-prep-max-vars", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_preinc_prep_max_vars = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-quadword-atomics", arg)) {
                cmd.ppc_quadword_atomics = true;
            } else if (mem.testEqualString("--ppc-reduce-cr-logicals", arg)) {
                cmd.ppc_reduce_cr_logicals = true;
            } else if (mem.testEqualString("--ppc-reg-to-imm-fixed-point", arg)) {
                cmd.ppc_reg_to_imm_fixed_point = true;
            } else if (mem.testEqualString("--ppc-reg-with-percent-prefix", arg)) {
                cmd.ppc_reg_with_percent_prefix = true;
            } else if (mem.testEqualString("--ppc-set-dscr", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ppc_set_dscr = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--ppc-stack-ptr-caller-preserved", arg)) {
                cmd.ppc_stack_ptr_caller_preserved = true;
            } else if (mem.testEqualString("--ppc-tls-opt", arg)) {
                cmd.ppc_tls_opt = true;
            } else if (mem.testEqualString("--ppc-track-subreg-liveness", arg)) {
                cmd.ppc_track_subreg_liveness = true;
            } else if (mem.testEqualString("--ppc-use-absolute-jumptables", arg)) {
                cmd.ppc_use_absolute_jumptables = true;
            } else if (mem.testEqualString("--ppc-use-base-pointer", arg)) {
                cmd.ppc_use_base_pointer = true;
            } else if (mem.testEqualString("--ppc-use-bit-perm-rewriter", arg)) {
                cmd.ppc_use_bit_perm_rewriter = true;
            } else if (mem.testEqualString("--ppc-use-branch-hint", arg)) {
                cmd.ppc_use_branch_hint = true;
            } else if (mem.testEqualString("--ppc-vsr-nums-as-vr", arg)) {
                cmd.ppc_vsr_nums_as_vr = true;
            } else if (mem.testEqualString("--pragma-unroll-and-jam-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pragma_unroll_and_jam_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pragma-unroll-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pragma_unroll_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--pragma-vectorize-scev-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.pragma_vectorize_scev_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--precise-rotation-cost", arg)) {
                cmd.precise_rotation_cost = true;
            } else if (mem.testEqualString("--prefer-inloop-reductions", arg)) {
                cmd.prefer_inloop_reductions = true;
            } else if (mem.testEqualString("--prefer-no-csel", arg)) {
                cmd.prefer_no_csel = true;
            } else if (mem.testEqualString("--prefer-predicated-reduction-select", arg)) {
                cmd.prefer_predicated_reduction_select = true;
            } else if (mem.testEqualString("--prefetch-distance", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.prefetch_distance = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--prefetch-hints-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.prefetch_hints_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--preinline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.preinline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--preserve-alignment-assumptions-during-inlining", arg)) {
                cmd.preserve_alignment_assumptions_during_inlining = true;
            } else if (mem.testEqualString("--preserve-as-comments", arg)) {
                cmd.preserve_as_comments = true;
            } else if (mem.testEqualString("--print-after", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_after = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-after-all", arg)) {
                cmd.print_after_all = true;
            } else if (mem.testEqualString("--print-after-isel", arg)) {
                cmd.print_after_isel = true;
            } else if (mem.testEqualString("--print-all-options", arg)) {
                cmd.print_all_options = true;
            } else if (mem.testEqualString("--print-before", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_before = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-before-all", arg)) {
                cmd.print_before_all = true;
            } else if (mem.testEqualString("--print-before-changed", arg)) {
                cmd.print_before_changed = true;
            } else if (mem.testEqualString("--print-bfi", arg)) {
                cmd.print_bfi = true;
            } else if (mem.testEqualString("--print-bfi-func-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_bfi_func_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-bpi", arg)) {
                cmd.print_bpi = true;
            } else if (mem.testEqualString("--print-bpi-func-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_bpi_func_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-changed-dot-path", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_changed_dot_path = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-debug-ata", arg)) {
                cmd.print_debug_ata = true;
            } else if (mem.testEqualString("--print-debug-counter", arg)) {
                cmd.print_debug_counter = true;
            } else if (mem.testEqualString("--print-failed-fuse-candidates", arg)) {
                cmd.print_failed_fuse_candidates = true;
            } else if (mem.testEqualString("--print-gc", arg)) {
                cmd.print_gc = true;
            } else if (mem.testEqualString("--print-import-failures", arg)) {
                cmd.print_import_failures = true;
            } else if (mem.testEqualString("--print-imports", arg)) {
                cmd.print_imports = true;
            } else if (mem.testEqualString("--print-instruction-comments", arg)) {
                cmd.print_instruction_comments = true;
            } else if (mem.testEqualString("--print-isel-input", arg)) {
                cmd.print_isel_input = true;
            } else if (mem.testEqualString("--print-lsr-output", arg)) {
                cmd.print_lsr_output = true;
            } else if (mem.testEqualString("--print-lvi-after-jump-threading", arg)) {
                cmd.print_lvi_after_jump_threading = true;
            } else if (mem.testEqualString("--print-machine-bfi", arg)) {
                cmd.print_machine_bfi = true;
            } else if (mem.testEqualString("--print-module-scope", arg)) {
                cmd.print_module_scope = true;
            } else if (mem.testEqualString("--print-on-crash", arg)) {
                cmd.print_on_crash = true;
            } else if (mem.testEqualString("--print-options", arg)) {
                cmd.print_options = true;
            } else if (mem.testEqualString("--print-pipeline-passes", arg)) {
                cmd.print_pipeline_passes = true;
            } else if (mem.testEqualString("--print-regmask-num-regs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.print_regmask_num_regs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--print-regusage", arg)) {
                cmd.print_regusage = true;
            } else if (mem.testEqualString("--print-slotindexes", arg)) {
                cmd.print_slotindexes = true;
            } else if (mem.testEqualString("--print-summary-global-ids", arg)) {
                cmd.print_summary_global_ids = true;
            } else if (mem.testEqualString("--procres-cost-lim", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.procres_cost_lim = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-accurate-for-symsinlist", arg)) {
                cmd.profile_accurate_for_symsinlist = true;
            } else if (mem.testEqualString("--profile-guided-section-prefix", arg)) {
                cmd.profile_guided_section_prefix = true;
            } else if (mem.testEqualString("--profile-isfs", arg)) {
                cmd.profile_isfs = true;
            } else if (mem.testEqualString("--profile-likely-prob", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_likely_prob = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-sample-accurate", arg)) {
                cmd.profile_sample_accurate = true;
            } else if (mem.testEqualString("--profile-sample-block-accurate", arg)) {
                cmd.profile_sample_block_accurate = true;
            } else if (mem.testEqualString("--profile-summary-contextless", arg)) {
                cmd.profile_summary_contextless = true;
            } else if (mem.testEqualString("--profile-summary-cutoff-cold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_summary_cutoff_cold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-summary-cutoff-hot", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_summary_cutoff_hot = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-summary-huge-working-set-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_summary_huge_working_set_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-summary-large-working-set-size-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_summary_large_working_set_size_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-symbol-list-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.profile_symbol_list_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--profile-unknown-in-special-section", arg)) {
                cmd.profile_unknown_in_special_section = true;
            } else if (mem.testEqualString("--propagate-attrs", arg)) {
                cmd.propagate_attrs = true;
            } else if (mem.testEqualString("--protect-from-escaped-allocas", arg)) {
                cmd.protect_from_escaped_allocas = true;
            } else if (mem.testEqualString("--r600-ir-structurize", arg)) {
                cmd.r600_ir_structurize = true;
            } else if (mem.testEqualString("--rafast-ignore-missing-defs", arg)) {
                cmd.rafast_ignore_missing_defs = true;
            } else if (mem.testEqualString("--rdf-dump", arg)) {
                cmd.rdf_dump = true;
            } else if (mem.testEqualString("--rdf-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rdf_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rdf-liveness-max-rec", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rdf_liveness_max_rec = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rdf-opt", arg)) {
                cmd.rdf_opt = true;
            } else if (mem.testEqualString("--reassociate-geps-verify-no-dead-code", arg)) {
                cmd.reassociate_geps_verify_no_dead_code = true;
            } else if (mem.testEqualString("--rebalance-only-imbal", arg)) {
                cmd.rebalance_only_imbal = true;
            } else if (mem.testEqualString("--rebalance-only-opt", arg)) {
                cmd.rebalance_only_opt = true;
            } else if (mem.testEqualString("--recurrence-chain-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.recurrence_chain_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--recursive-inline-max-stacksize", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.recursive_inline_max_stacksize = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-cheap-remat-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_cheap_remat_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-copy-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_copy_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-csr-first-time-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_csr_first_time_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-eviction-max-interference-cutoff", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_eviction_max_interference_cutoff = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-expensive-remat-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_expensive_remat_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-load-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_load_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regalloc-store-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.regalloc_store_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--regbankselect-fast", arg)) {
                cmd.regbankselect_fast = true;
            } else if (mem.testEqualString("--regbankselect-greedy", arg)) {
                cmd.regbankselect_greedy = true;
            } else if (mem.testEqualString("--relax-elf-relocations", arg)) {
                cmd.relax_elf_relocations = true;
            } else if (mem.testEqualString("--relax-nv-checks", arg)) {
                cmd.relax_nv_checks = true;
            } else if (mem.testEqualString("--remarks-section", arg)) {
                cmd.remarks_section = true;
            } else if (mem.testEqualString("--remat-pic-stub-load", arg)) {
                cmd.remat_pic_stub_load = true;
            } else if (mem.testEqualString("--rename-exclude-alias-prefixes", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rename_exclude_alias_prefixes = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rename-exclude-function-prefixes", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rename_exclude_function_prefixes = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rename-exclude-global-prefixes", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rename_exclude_global_prefixes = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rename-exclude-struct-prefixes", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rename_exclude_struct_prefixes = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--renumber-blocks-before-view", arg)) {
                cmd.renumber_blocks_before_view = true;
            } else if (mem.testEqualString("--report-profile-staleness", arg)) {
                cmd.report_profile_staleness = true;
            } else if (mem.testEqualString("--reroll-num-tolerated-failed-matches", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.reroll_num_tolerated_failed_matches = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--reserve-regs-for-regalloc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.reserve_regs_for_regalloc = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--restrict-statepoint-remat", arg)) {
                cmd.restrict_statepoint_remat = true;
            } else if (mem.testEqualString("--reverse-csr-restore-seq", arg)) {
                cmd.reverse_csr_restore_seq = true;
            } else if (mem.testEqualString("--rewrite-map-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rewrite_map_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rewrite-phi-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rewrite_phi_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-disable-insert-vsetvl-phi-opt", arg)) {
                cmd.riscv_disable_insert_vsetvl_phi_opt = true;
            } else if (mem.testEqualString("--riscv-disable-regalloc-hints", arg)) {
                cmd.riscv_disable_regalloc_hints = true;
            } else if (mem.testEqualString("--riscv-disable-sextw-removal", arg)) {
                cmd.riscv_disable_sextw_removal = true;
            } else if (mem.testEqualString("--riscv-disable-strip-w-suffix", arg)) {
                cmd.riscv_disable_strip_w_suffix = true;
            } else if (mem.testEqualString("--riscv-disable-using-constant-pool-for-large-ints", arg)) {
                cmd.riscv_disable_using_constant_pool_for_large_ints = true;
            } else if (mem.testEqualString("--riscv-enable-copyelim", arg)) {
                cmd.riscv_enable_copyelim = true;
            } else if (mem.testEqualString("--riscv-enable-global-merge", arg)) {
                cmd.riscv_enable_global_merge = true;
            } else if (mem.testEqualString("--riscv-enable-machine-combiner", arg)) {
                cmd.riscv_enable_machine_combiner = true;
            } else if (mem.testEqualString("--riscv-enable-subreg-liveness", arg)) {
                cmd.riscv_enable_subreg_liveness = true;
            } else if (mem.testEqualString("--riscv-insert-vsetvl-strict-asserts", arg)) {
                cmd.riscv_insert_vsetvl_strict_asserts = true;
            } else if (mem.testEqualString("--riscv-lower-ext-max-web-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_lower_ext_max_web_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-lower-form-vw-w-with-splat", arg)) {
                cmd.riscv_lower_form_vw_w_with_splat = true;
            } else if (mem.testEqualString("--riscv-lower-fp-repeated-divisors", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_lower_fp_repeated_divisors = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-max-build-ints-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_max_build_ints_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-no-aliases", arg)) {
                cmd.riscv_no_aliases = true;
            } else if (mem.testEqualString("--riscv-prefer-whole-register-move", arg)) {
                cmd.riscv_prefer_whole_register_move = true;
            } else if (mem.testEqualString("--riscv-v-fixed-length-vector-lmul-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_v_fixed_length_vector_lmul_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-v-register-bit-width-lmul", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_v_register_bit_width_lmul = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-v-slp-max-vf", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_v_slp_max_vf = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-v-vector-bits-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_v_vector_bits_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--riscv-v-vector-bits-min", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.riscv_v_vector_bits_min = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rotation-max-header-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.rotation_max_header_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--rotation-prepare-for-lto", arg)) {
                cmd.rotation_prepare_for_lto = true;
            } else if (mem.testEqualString("--rs4gc-allow-statepoint-with-no-deopt-info", arg)) {
                cmd.rs4gc_allow_statepoint_with_no_deopt_info = true;
            } else if (mem.testEqualString("--rs4gc-clobber-non-live", arg)) {
                cmd.rs4gc_clobber_non_live = true;
            } else if (mem.testEqualString("--rs4gc-remat-derived-at-uses", arg)) {
                cmd.rs4gc_remat_derived_at_uses = true;
            } else if (mem.testEqualString("--run-pass", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.run_pass = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--runtime-check-per-loop-load-elim", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.runtime_check_per_loop_load_elim = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--runtime-counter-relocation", arg)) {
                cmd.runtime_counter_relocation = true;
            } else if (mem.testEqualString("--runtime-mem-idiom-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.runtime_mem_idiom_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--runtime-memory-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.runtime_memory_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--safe-stack-coloring", arg)) {
                cmd.safe_stack_coloring = true;
            } else if (mem.testEqualString("--safe-stack-layout", arg)) {
                cmd.safe_stack_layout = true;
            } else if (mem.testEqualString("--safepoint-ir-verifier-print-only", arg)) {
                cmd.safepoint_ir_verifier_print_only = true;
            } else if (mem.testEqualString("--safestack-use-pointer-address", arg)) {
                cmd.safestack_use_pointer_address = true;
            } else if (mem.testEqualString("--sample-profile-check-record-coverage", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_check_record_coverage = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-check-sample-coverage", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_check_sample_coverage = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-cold-inline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_cold_inline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-even-flow-distribution", arg)) {
                cmd.sample_profile_even_flow_distribution = true;
            } else if (mem.testEqualString("--sample-profile-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-hot-inline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_hot_inline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-icp-max-prom", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_icp_max_prom = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-icp-relative-hotness", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_icp_relative_hotness = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-icp-relative-hotness-skip", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_icp_relative_hotness_skip = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-inline-growth-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_inline_growth_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-inline-limit-max", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_inline_limit_max = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-inline-limit-min", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_inline_limit_min = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-inline-replay", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_inline_replay = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-inline-size", arg)) {
                cmd.sample_profile_inline_size = true;
            } else if (mem.testEqualString("--sample-profile-join-islands", arg)) {
                cmd.sample_profile_join_islands = true;
            } else if (mem.testEqualString("--sample-profile-max-propagate-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_max_propagate_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-merge-inlinee", arg)) {
                cmd.sample_profile_merge_inlinee = true;
            } else if (mem.testEqualString("--sample-profile-prioritized-inline", arg)) {
                cmd.sample_profile_prioritized_inline = true;
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-dec", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_dec = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-entry-dec", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_entry_dec = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-entry-inc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_entry_inc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-inc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_inc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-unknown-inc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_unknown_inc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-profi-cost-block-zero-inc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_profi_cost_block_zero_inc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-rebalance-unknown", arg)) {
                cmd.sample_profile_rebalance_unknown = true;
            } else if (mem.testEqualString("--sample-profile-recursive-inline", arg)) {
                cmd.sample_profile_recursive_inline = true;
            } else if (mem.testEqualString("--sample-profile-remapping-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sample_profile_remapping_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sample-profile-top-down-load", arg)) {
                cmd.sample_profile_top_down_load = true;
            } else if (mem.testEqualString("--sample-profile-use-preinliner", arg)) {
                cmd.sample_profile_use_preinliner = true;
            } else if (mem.testEqualString("--sample-profile-use-profi", arg)) {
                cmd.sample_profile_use_profi = true;
            } else if (mem.testEqualString("--sanitizer-coverage-control-flow", arg)) {
                cmd.sanitizer_coverage_control_flow = true;
            } else if (mem.testEqualString("--sanitizer-coverage-inline-8bit-counters", arg)) {
                cmd.sanitizer_coverage_inline_8bit_counters = true;
            } else if (mem.testEqualString("--sanitizer-coverage-inline-bool-flag", arg)) {
                cmd.sanitizer_coverage_inline_bool_flag = true;
            } else if (mem.testEqualString("--sanitizer-coverage-level", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sanitizer_coverage_level = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sanitizer-coverage-pc-table", arg)) {
                cmd.sanitizer_coverage_pc_table = true;
            } else if (mem.testEqualString("--sanitizer-coverage-prune-blocks", arg)) {
                cmd.sanitizer_coverage_prune_blocks = true;
            } else if (mem.testEqualString("--sanitizer-coverage-stack-depth", arg)) {
                cmd.sanitizer_coverage_stack_depth = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-compares", arg)) {
                cmd.sanitizer_coverage_trace_compares = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-divs", arg)) {
                cmd.sanitizer_coverage_trace_divs = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-geps", arg)) {
                cmd.sanitizer_coverage_trace_geps = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-loads", arg)) {
                cmd.sanitizer_coverage_trace_loads = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-pc", arg)) {
                cmd.sanitizer_coverage_trace_pc = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-pc-guard", arg)) {
                cmd.sanitizer_coverage_trace_pc_guard = true;
            } else if (mem.testEqualString("--sanitizer-coverage-trace-stores", arg)) {
                cmd.sanitizer_coverage_trace_stores = true;
            } else if (mem.testEqualString("--sanitizer-metadata-atomics", arg)) {
                cmd.sanitizer_metadata_atomics = true;
            } else if (mem.testEqualString("--sanitizer-metadata-covered", arg)) {
                cmd.sanitizer_metadata_covered = true;
            } else if (mem.testEqualString("--sanitizer-metadata-uar", arg)) {
                cmd.sanitizer_metadata_uar = true;
            } else if (mem.testEqualString("--sanitizer-metadata-weak-callbacks", arg)) {
                cmd.sanitizer_metadata_weak_callbacks = true;
            } else if (mem.testEqualString("--scalar-evolution-classify-expressions", arg)) {
                cmd.scalar_evolution_classify_expressions = true;
            } else if (mem.testEqualString("--scalar-evolution-finite-loop", arg)) {
                cmd.scalar_evolution_finite_loop = true;
            } else if (mem.testEqualString("--scalar-evolution-huge-expr-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_huge_expr_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-add-rec-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_add_rec_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-arith-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_arith_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-cast-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_cast_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-constant-evolving-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_constant_evolving_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-scc-analysis-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_scc_analysis_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-scev-compare-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_scev_compare_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-scev-operations-implication-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_scev_operations_implication_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-max-value-compare-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scalar_evolution_max_value_compare_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scalar-evolution-use-context-for-no-wrap-flag-strenghening", arg)) {
                cmd.scalar_evolution_use_context_for_no_wrap_flag_strenghening = true;
            } else if (mem.testEqualString("--scalar-evolution-use-expensive-range-sharpening", arg)) {
                cmd.scalar_evolution_use_expensive_range_sharpening = true;
            } else if (mem.testEqualString("--scalarize-load-store", arg)) {
                cmd.scalarize_load_store = true;
            } else if (mem.testEqualString("--scalarize-variable-insert-extract", arg)) {
                cmd.scalarize_variable_insert_extract = true;
            } else if (mem.testEqualString("--scale-partial-sample-profile-working-set-size", arg)) {
                cmd.scale_partial_sample_profile_working_set_size = true;
            } else if (mem.testEqualString("--scev-addops-inline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scev_addops_inline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scev-cheap-expansion-budget", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scev_cheap_expansion_budget = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scev-mulops-inline-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scev_mulops_inline_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scev-range-iter-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.scev_range_iter_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--scev-verify-ir", arg)) {
                cmd.scev_verify_ir = true;
            } else if (mem.testEqualString("--sched-avg-ipc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sched_avg_ipc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sched-high-latency-cycles", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sched_high_latency_cycles = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sched-preds-closer", arg)) {
                cmd.sched_preds_closer = true;
            } else if (mem.testEqualString("--sched-retval-optimization", arg)) {
                cmd.sched_retval_optimization = true;
            } else if (mem.testEqualString("--scheditins", arg)) {
                cmd.scheditins = true;
            } else if (mem.testEqualString("--schedmodel", arg)) {
                cmd.schedmodel = true;
            } else if (mem.testEqualString("--schedule-ppc-vsx-fma-mutation-early", arg)) {
                cmd.schedule_ppc_vsx_fma_mutation_early = true;
            } else if (mem.testEqualString("--select-opti-loop-cycle-gain-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.select_opti_loop_cycle_gain_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--select-opti-loop-gradient-gain-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.select_opti_loop_gradient_gain_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--select-opti-loop-relative-gain-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.select_opti_loop_relative_gain_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--show-fs-branchprob", arg)) {
                cmd.show_fs_branchprob = true;
            } else if (mem.testEqualString("--show-mc-encoding", arg)) {
                cmd.show_mc_encoding = true;
            } else if (mem.testEqualString("--shrink-frame-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.shrink_frame_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simple-loop-unswitch-drop-non-trivial-implicit-null-checks", arg)) {
                cmd.simple_loop_unswitch_drop_non_trivial_implicit_null_checks = true;
            } else if (mem.testEqualString("--simple-loop-unswitch-guards", arg)) {
                cmd.simple_loop_unswitch_guards = true;
            } else if (mem.testEqualString("--simple-loop-unswitch-memoryssa-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.simple_loop_unswitch_memoryssa_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simplify-mir", arg)) {
                cmd.simplify_mir = true;
            } else if (mem.testEqualString("--simplifycfg-branch-fold-common-dest-vector-multiplier", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.simplifycfg_branch_fold_common_dest_vector_multiplier = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simplifycfg-branch-fold-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.simplifycfg_branch_fold_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simplifycfg-hoist-common", arg)) {
                cmd.simplifycfg_hoist_common = true;
            } else if (mem.testEqualString("--simplifycfg-hoist-common-skip-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.simplifycfg_hoist_common_skip_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simplifycfg-hoist-cond-stores", arg)) {
                cmd.simplifycfg_hoist_cond_stores = true;
            } else if (mem.testEqualString("--simplifycfg-max-small-block-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.simplifycfg_max_small_block_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--simplifycfg-merge-compatible-invokes", arg)) {
                cmd.simplifycfg_merge_compatible_invokes = true;
            } else if (mem.testEqualString("--simplifycfg-merge-cond-stores", arg)) {
                cmd.simplifycfg_merge_cond_stores = true;
            } else if (mem.testEqualString("--simplifycfg-merge-cond-stores-aggressively", arg)) {
                cmd.simplifycfg_merge_cond_stores_aggressively = true;
            } else if (mem.testEqualString("--simplifycfg-require-and-preserve-domtree", arg)) {
                cmd.simplifycfg_require_and_preserve_domtree = true;
            } else if (mem.testEqualString("--simplifycfg-sink-common", arg)) {
                cmd.simplifycfg_sink_common = true;
            } else if (mem.testEqualString("--sink-common-insts", arg)) {
                cmd.sink_common_insts = true;
            } else if (mem.testEqualString("--sink-freq-percent-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sink_freq_percent_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sink-insts-to-avoid-spills", arg)) {
                cmd.sink_insts_to_avoid_spills = true;
            } else if (mem.testEqualString("--skip-mips-long-branch", arg)) {
                cmd.skip_mips_long_branch = true;
            } else if (mem.testEqualString("--skip-ret-exit-block", arg)) {
                cmd.skip_ret_exit_block = true;
            } else if (mem.testEqualString("--slot1-store-slot0-load", arg)) {
                cmd.slot1_store_slot0_load = true;
            } else if (mem.testEqualString("--slp-max-look-ahead-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_max_look_ahead_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-max-reg-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_max_reg_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-max-root-look-ahead-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_max_root_look_ahead_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-max-store-lookup", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_max_store_lookup = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-max-vf", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_max_vf = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-min-reg-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_min_reg_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-min-tree-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_min_tree_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-recursion-max-depth", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_recursion_max_depth = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-schedule-budget", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_schedule_budget = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.slp_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--slp-vectorize-hor", arg)) {
                cmd.slp_vectorize_hor = true;
            } else if (mem.testEqualString("--slp-vectorize-hor-store", arg)) {
                cmd.slp_vectorize_hor_store = true;
            } else if (mem.testEqualString("--small-loop-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.small_loop_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sort-profiled-scc-member", arg)) {
                cmd.sort_profiled_scc_member = true;
            } else if (mem.testEqualString("--sort-timers", arg)) {
                cmd.sort_timers = true;
            } else if (mem.testEqualString("--sparc-bpcc-offset-bits", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sparc_bpcc_offset_bits = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sparc-enable-branch-relax", arg)) {
                cmd.sparc_enable_branch_relax = true;
            } else if (mem.testEqualString("--sparc-reserve-app-registers", arg)) {
                cmd.sparc_reserve_app_registers = true;
            } else if (mem.testEqualString("--spec-exec-max-not-hoisted", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spec_exec_max_not_hoisted = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--spec-exec-max-speculation-cost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spec_exec_max_speculation_cost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--spec-exec-only-if-divergent-target", arg)) {
                cmd.spec_exec_only_if_divergent_target = true;
            } else if (mem.testEqualString("--speculate-one-expensive-inst", arg)) {
                cmd.speculate_one_expensive_inst = true;
            } else if (mem.testEqualString("--speculative-counter-promotion-max-exiting", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.speculative_counter_promotion_max_exiting = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--speculative-counter-promotion-to-loop", arg)) {
                cmd.speculative_counter_promotion_to_loop = true;
            } else if (mem.testEqualString("--spill-func-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spill_func_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--spill-func-threshold-Os", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spill_func_threshold_Os = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--split-dwarf-cross-cu-references", arg)) {
                cmd.split_dwarf_cross_cu_references = true;
            } else if (mem.testEqualString("--split-dwarf-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.split_dwarf_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--split-dwarf-output", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.split_dwarf_output = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--split-machine-functions", arg)) {
                cmd.split_machine_functions = true;
            } else if (mem.testEqualString("--spp-all-backedges", arg)) {
                cmd.spp_all_backedges = true;
            } else if (mem.testEqualString("--spp-counted-loop-trip-width", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spp_counted_loop_trip_width = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--spp-no-backedge", arg)) {
                cmd.spp_no_backedge = true;
            } else if (mem.testEqualString("--spp-no-call", arg)) {
                cmd.spp_no_call = true;
            } else if (mem.testEqualString("--spp-no-entry", arg)) {
                cmd.spp_no_entry = true;
            } else if (mem.testEqualString("--spp-print-base-pointers", arg)) {
                cmd.spp_print_base_pointers = true;
            } else if (mem.testEqualString("--spp-print-liveset", arg)) {
                cmd.spp_print_liveset = true;
            } else if (mem.testEqualString("--spp-print-liveset-size", arg)) {
                cmd.spp_print_liveset_size = true;
            } else if (mem.testEqualString("--spp-rematerialization-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.spp_rematerialization_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--spp-split-backedge", arg)) {
                cmd.spp_split_backedge = true;
            } else if (mem.testEqualString("--sroa-strict-inbounds", arg)) {
                cmd.sroa_strict_inbounds = true;
            } else if (mem.testEqualString("--ssc-dce-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.ssc_dce_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stack-safety-max-iterations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stack_safety_max_iterations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stack-safety-print", arg)) {
                cmd.stack_safety_print = true;
            } else if (mem.testEqualString("--stack-safety-run", arg)) {
                cmd.stack_safety_run = true;
            } else if (mem.testEqualString("--stack-size-section", arg)) {
                cmd.stack_size_section = true;
            } else if (mem.testEqualString("--stack-symbol-ordering", arg)) {
                cmd.stack_symbol_ordering = true;
            } else if (mem.testEqualString("--stack-tagging-first-slot-opt", arg)) {
                cmd.stack_tagging_first_slot_opt = true;
            } else if (mem.testEqualString("--stack-tagging-merge-init", arg)) {
                cmd.stack_tagging_merge_init = true;
            } else if (mem.testEqualString("--stack-tagging-merge-init-scan-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stack_tagging_merge_init_scan_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stack-tagging-merge-init-size-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stack_tagging_merge_init_size_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stack-tagging-merge-settag", arg)) {
                cmd.stack_tagging_merge_settag = true;
            } else if (mem.testEqualString("--stack-tagging-use-stack-safety", arg)) {
                cmd.stack_tagging_use_stack_safety = true;
            } else if (mem.testEqualString("--stackcoloring-lifetime-start-on-first-use", arg)) {
                cmd.stackcoloring_lifetime_start_on_first_use = true;
            } else if (mem.testEqualString("--stackmap-version", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stackmap_version = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stackrealign", arg)) {
                cmd.stackrealign = true;
            } else if (mem.testEqualString("--start-after", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.start_after = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--start-before", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.start_before = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--static-func-full-module-prefix", arg)) {
                cmd.static_func_full_module_prefix = true;
            } else if (mem.testEqualString("--static-func-strip-dirname-prefix", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.static_func_strip_dirname_prefix = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--static-likely-prob", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.static_likely_prob = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stats", arg)) {
                cmd.stats = true;
            } else if (mem.testEqualString("--stats-json", arg)) {
                cmd.stats_json = true;
            } else if (mem.testEqualString("--stop-after", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stop_after = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--stop-before", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stop_before = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--store-to-load-forwarding-conflict-detection", arg)) {
                cmd.store_to_load_forwarding_conflict_detection = true;
            } else if (mem.testEqualString("--stress-cgp-ext-ld-promotion", arg)) {
                cmd.stress_cgp_ext_ld_promotion = true;
            } else if (mem.testEqualString("--stress-cgp-store-extract", arg)) {
                cmd.stress_cgp_store_extract = true;
            } else if (mem.testEqualString("--stress-early-ifcvt", arg)) {
                cmd.stress_early_ifcvt = true;
            } else if (mem.testEqualString("--stress-regalloc", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.stress_regalloc = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--strict-dwarf", arg)) {
                cmd.strict_dwarf = true;
            } else if (mem.testEqualString("--structurizecfg-relaxed-uniform-regions", arg)) {
                cmd.structurizecfg_relaxed_uniform_regions = true;
            } else if (mem.testEqualString("--structurizecfg-skip-uniform-regions", arg)) {
                cmd.structurizecfg_skip_uniform_regions = true;
            } else if (mem.testEqualString("--summary-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.summary_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sve-gather-overhead", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sve_gather_overhead = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sve-scatter-overhead", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sve_scatter_overhead = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--sve-tail-folding", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.sve_tail_folding = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--switch-peel-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.switch_peel_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--switch-range-to-icmp", arg)) {
                cmd.switch_range_to_icmp = true;
            } else if (mem.testEqualString("--switch-to-lookup", arg)) {
                cmd.switch_to_lookup = true;
            } else if (mem.testEqualString("--systemz-subreg-liveness", arg)) {
                cmd.systemz_subreg_liveness = true;
            } else if (mem.testEqualString("--t2-reduce-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.t2_reduce_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--t2-reduce-limit2", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.t2_reduce_limit2 = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--t2-reduce-limit3", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.t2_reduce_limit3 = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-indirect-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_indirect_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-placement", arg)) {
                cmd.tail_dup_placement = true;
            } else if (mem.testEqualString("--tail-dup-placement-aggressive-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_placement_aggressive_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-placement-penalty", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_placement_penalty = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-placement-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_placement_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-profile-percent-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_profile_percent_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_dup_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-dup-verify", arg)) {
                cmd.tail_dup_verify = true;
            } else if (mem.testEqualString("--tail-merge-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_merge_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tail-merge-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tail_merge_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tailcallopt", arg)) {
                cmd.tailcallopt = true;
            } else if (mem.testEqualString("--target-abi", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.target_abi = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--temporal-reuse-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.temporal_reuse_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--terminal-rule", arg)) {
                cmd.terminal_rule = true;
            } else if (mem.testEqualString("--tfutils-use-simplelogger", arg)) {
                cmd.tfutils_use_simplelogger = true;
            } else if (mem.testEqualString("--thinlto-assume-merged", arg)) {
                cmd.thinlto_assume_merged = true;
            } else if (mem.testEqualString("--thinlto-synthesize-entry-counts", arg)) {
                cmd.thinlto_synthesize_entry_counts = true;
            } else if (mem.testEqualString("--threads", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.threads = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--time-compilations", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.time_compilations = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--time-passes", arg)) {
                cmd.time_passes = true;
            } else if (mem.testEqualString("--time-passes-per-run", arg)) {
                cmd.time_passes_per_run = true;
            } else if (mem.testEqualString("--time-trace", arg)) {
                cmd.time_trace = true;
            } else if (mem.testEqualString("--time-trace-file", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.time_trace_file = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--time-trace-granularity", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.time_trace_granularity = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tiny-trip-count-interleave-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tiny_trip_count_interleave_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--tls-load-hoist", arg)) {
                cmd.tls_load_hoist = true;
            } else if (mem.testEqualString("--tls-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.tls_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--trace-gv-placement", arg)) {
                cmd.trace_gv_placement = true;
            } else if (mem.testEqualString("--trace-hex-vector-stores-only", arg)) {
                cmd.trace_hex_vector_stores_only = true;
            } else if (mem.testEqualString("--track-memory", arg)) {
                cmd.track_memory = true;
            } else if (mem.testEqualString("--trap-func", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.trap_func = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--trap-unreachable", arg)) {
                cmd.trap_unreachable = true;
            } else if (mem.testEqualString("--treat-scalable-fixed-error-as-warning", arg)) {
                cmd.treat_scalable_fixed_error_as_warning = true;
            } else if (mem.testEqualString("--triangle-chain-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.triangle_chain_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--trim-var-locs", arg)) {
                cmd.trim_var_locs = true;
            } else if (mem.testEqualString("--tsan-compound-read-before-write", arg)) {
                cmd.tsan_compound_read_before_write = true;
            } else if (mem.testEqualString("--tsan-distinguish-volatile", arg)) {
                cmd.tsan_distinguish_volatile = true;
            } else if (mem.testEqualString("--tsan-handle-cxx-exceptions", arg)) {
                cmd.tsan_handle_cxx_exceptions = true;
            } else if (mem.testEqualString("--tsan-instrument-atomics", arg)) {
                cmd.tsan_instrument_atomics = true;
            } else if (mem.testEqualString("--tsan-instrument-func-entry-exit", arg)) {
                cmd.tsan_instrument_func_entry_exit = true;
            } else if (mem.testEqualString("--tsan-instrument-memintrinsics", arg)) {
                cmd.tsan_instrument_memintrinsics = true;
            } else if (mem.testEqualString("--tsan-instrument-memory-accesses", arg)) {
                cmd.tsan_instrument_memory_accesses = true;
            } else if (mem.testEqualString("--tsan-instrument-read-before-write", arg)) {
                cmd.tsan_instrument_read_before_write = true;
            } else if (mem.testEqualString("--two-entry-phi-node-folding-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.two_entry_phi_node_folding_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--twoaddr-reschedule", arg)) {
                cmd.twoaddr_reschedule = true;
            } else if (mem.testEqualString("--type-based-intrinsic-cost", arg)) {
                cmd.type_based_intrinsic_cost = true;
            } else if (mem.testEqualString("--undef-reg-clearance", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.undef_reg_clearance = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unique-basic-block-section-names", arg)) {
                cmd.unique_basic_block_section_names = true;
            } else if (mem.testEqualString("--unique-section-names", arg)) {
                cmd.unique_section_names = true;
            } else if (mem.testEqualString("--unlikely-branch-weight", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unlikely_branch_weight = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-allow-loop-nests-peeling", arg)) {
                cmd.unroll_allow_loop_nests_peeling = true;
            } else if (mem.testEqualString("--unroll-allow-partial", arg)) {
                cmd.unroll_allow_partial = true;
            } else if (mem.testEqualString("--unroll-allow-peeling", arg)) {
                cmd.unroll_allow_peeling = true;
            } else if (mem.testEqualString("--unroll-allow-remainder", arg)) {
                cmd.unroll_allow_remainder = true;
            } else if (mem.testEqualString("--unroll-and-jam-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_and_jam_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-and-jam-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_and_jam_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-force-peel-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_force_peel_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-full-max-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_full_max_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-max-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_max_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-max-iteration-count-to-analyze", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_max_iteration_count_to_analyze = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-max-percent-threshold-boost", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_max_percent_threshold_boost = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-max-upperbound", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_max_upperbound = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-optsize-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_optsize_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-partial-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_partial_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-peel-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_peel_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-peel-max-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_peel_max_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-remainder", arg)) {
                cmd.unroll_remainder = true;
            } else if (mem.testEqualString("--unroll-revisit-child-loops", arg)) {
                cmd.unroll_revisit_child_loops = true;
            } else if (mem.testEqualString("--unroll-runtime", arg)) {
                cmd.unroll_runtime = true;
            } else if (mem.testEqualString("--unroll-runtime-epilog", arg)) {
                cmd.unroll_runtime_epilog = true;
            } else if (mem.testEqualString("--unroll-runtime-multi-exit", arg)) {
                cmd.unroll_runtime_multi_exit = true;
            } else if (mem.testEqualString("--unroll-runtime-other-exit-predictable", arg)) {
                cmd.unroll_runtime_other_exit_predictable = true;
            } else if (mem.testEqualString("--unroll-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-threshold-aggressive", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_threshold_aggressive = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-threshold-default", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unroll_threshold_default = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unroll-verify-domtree", arg)) {
                cmd.unroll_verify_domtree = true;
            } else if (mem.testEqualString("--unroll-verify-loopinfo", arg)) {
                cmd.unroll_verify_loopinfo = true;
            } else if (mem.testEqualString("--unswitch-num-initial-unscaled-candidates", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unswitch_num_initial_unscaled_candidates = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unswitch-siblings-toplevel-div", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unswitch_siblings_toplevel_div = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--unswitch-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.unswitch_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--update-pseudo-probe", arg)) {
                cmd.update_pseudo_probe = true;
            } else if (mem.testEqualString("--update-return-attrs", arg)) {
                cmd.update_return_attrs = true;
            } else if (mem.testEqualString("--use-ctors", arg)) {
                cmd.use_ctors = true;
            } else if (mem.testEqualString("--use-dbg-addr", arg)) {
                cmd.use_dbg_addr = true;
            } else if (mem.testEqualString("--use-dereferenceable-at-point-semantics", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.use_dereferenceable_at_point_semantics = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--use-dwarf-ranges-base-address-specifier", arg)) {
                cmd.use_dwarf_ranges_base_address_specifier = true;
            } else if (mem.testEqualString("--use-gnu-debug-macro", arg)) {
                cmd.use_gnu_debug_macro = true;
            } else if (mem.testEqualString("--use-gpu-divergence-analysis", arg)) {
                cmd.use_gpu_divergence_analysis = true;
            } else if (mem.testEqualString("--use-iterative-bfi-inference", arg)) {
                cmd.use_iterative_bfi_inference = true;
            } else if (mem.testEqualString("--use-leb128-directives", arg)) {
                cmd.use_leb128_directives = true;
            } else if (mem.testEqualString("--use-lir-code-size-heurs", arg)) {
                cmd.use_lir_code_size_heurs = true;
            } else if (mem.testEqualString("--use-mbpi", arg)) {
                cmd.use_mbpi = true;
            } else if (mem.testEqualString("--use-newer-candidate", arg)) {
                cmd.use_newer_candidate = true;
            } else if (mem.testEqualString("--use-noalias-intrinsic-during-inlining", arg)) {
                cmd.use_noalias_intrinsic_during_inlining = true;
            } else if (mem.testEqualString("--use-profiled-call-graph", arg)) {
                cmd.use_profiled_call_graph = true;
            } else if (mem.testEqualString("--use-registers-for-deopt-values", arg)) {
                cmd.use_registers_for_deopt_values = true;
            } else if (mem.testEqualString("--use-registers-for-gc-values-in-landing-pad", arg)) {
                cmd.use_registers_for_gc_values_in_landing_pad = true;
            } else if (mem.testEqualString("--use-segment-set-for-physregs", arg)) {
                cmd.use_segment_set_for_physregs = true;
            } else if (mem.testEqualString("--use-source-filename-for-promoted-locals", arg)) {
                cmd.use_source_filename_for_promoted_locals = true;
            } else if (mem.testEqualString("--use-tbaa-in-sched-mi", arg)) {
                cmd.use_tbaa_in_sched_mi = true;
            } else if (mem.testEqualString("--vec-extabi", arg)) {
                cmd.vec_extabi = true;
            } else if (mem.testEqualString("--vector-combine-max-scan-instrs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vector_combine_max_scan_instrs = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vectorize-loops", arg)) {
                cmd.vectorize_loops = true;
            } else if (mem.testEqualString("--vectorize-memory-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vectorize_memory_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vectorize-num-stores-pred", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vectorize_num_stores_pred = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vectorize-scev-check-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vectorize_scev_check_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vectorize-slp", arg)) {
                cmd.vectorize_slp = true;
            } else if (mem.testEqualString("--vectorizer-maximize-bandwidth", arg)) {
                cmd.vectorizer_maximize_bandwidth = true;
            } else if (mem.testEqualString("--vectorizer-min-trip-count", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vectorizer_min_trip_count = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--verify-arm-pseudo-expand", arg)) {
                cmd.verify_arm_pseudo_expand = true;
            } else if (mem.testEqualString("--verify-assumption-cache", arg)) {
                cmd.verify_assumption_cache = true;
            } else if (mem.testEqualString("--verify-cfg-preserved", arg)) {
                cmd.verify_cfg_preserved = true;
            } else if (mem.testEqualString("--verify-cfiinstrs", arg)) {
                cmd.verify_cfiinstrs = true;
            } else if (mem.testEqualString("--verify-coalescing", arg)) {
                cmd.verify_coalescing = true;
            } else if (mem.testEqualString("--verify-dom-info", arg)) {
                cmd.verify_dom_info = true;
            } else if (mem.testEqualString("--verify-indvars", arg)) {
                cmd.verify_indvars = true;
            } else if (mem.testEqualString("--verify-loop-info", arg)) {
                cmd.verify_loop_info = true;
            } else if (mem.testEqualString("--verify-loop-lcssa", arg)) {
                cmd.verify_loop_lcssa = true;
            } else if (mem.testEqualString("--verify-machine-dom-info", arg)) {
                cmd.verify_machine_dom_info = true;
            } else if (mem.testEqualString("--verify-machineinstrs", arg)) {
                cmd.verify_machineinstrs = true;
            } else if (mem.testEqualString("--verify-memoryssa", arg)) {
                cmd.verify_memoryssa = true;
            } else if (mem.testEqualString("--verify-misched", arg)) {
                cmd.verify_misched = true;
            } else if (mem.testEqualString("--verify-noalias-scope-decl-dom", arg)) {
                cmd.verify_noalias_scope_decl_dom = true;
            } else if (mem.testEqualString("--verify-predicateinfo", arg)) {
                cmd.verify_predicateinfo = true;
            } else if (mem.testEqualString("--verify-pseudo-probe", arg)) {
                cmd.verify_pseudo_probe = true;
            } else if (mem.testEqualString("--verify-pseudo-probe-funcs", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.verify_pseudo_probe_funcs = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--verify-regalloc", arg)) {
                cmd.verify_regalloc = true;
            } else if (mem.testEqualString("--verify-region-info", arg)) {
                cmd.verify_region_info = true;
            } else if (mem.testEqualString("--verify-scev", arg)) {
                cmd.verify_scev = true;
            } else if (mem.testEqualString("--verify-scev-maps", arg)) {
                cmd.verify_scev_maps = true;
            } else if (mem.testEqualString("--verify-scev-strict", arg)) {
                cmd.verify_scev_strict = true;
            } else if (mem.testEqualString("--version", arg)) {
                cmd.version = true;
            } else if (mem.testEqualString("--view-bfi-func-name", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.view_bfi_func_name = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--view-edge-bundles", arg)) {
                cmd.view_edge_bundles = true;
            } else if (mem.testEqualString("--view-hot-freq-percent", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.view_hot_freq_percent = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--view-slp-tree", arg)) {
                cmd.view_slp_tree = true;
            } else if (mem.testEqualString("--vliw-misched-reg-pressure", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vliw_misched_reg_pressure = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vp-counters-per-site", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.vp_counters_per_site = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--vp-static-alloc", arg)) {
                cmd.vp_static_alloc = true;
            } else if (mem.testEqualString("--vplan-build-stress-test", arg)) {
                cmd.vplan_build_stress_test = true;
            } else if (mem.testEqualString("--vplan-print-in-dot-format", arg)) {
                cmd.vplan_print_in_dot_format = true;
            } else if (mem.testEqualString("--vplan-verify-hcfg", arg)) {
                cmd.vplan_verify_hcfg = true;
            } else if (mem.testEqualString("--wasm-disable-explicit-locals", arg)) {
                cmd.wasm_disable_explicit_locals = true;
            } else if (mem.testEqualString("--wasm-enable-eh", arg)) {
                cmd.wasm_enable_eh = true;
            } else if (mem.testEqualString("--wasm-enable-sjlj", arg)) {
                cmd.wasm_enable_sjlj = true;
            } else if (mem.testEqualString("--wasm-keep-registers", arg)) {
                cmd.wasm_keep_registers = true;
            } else if (mem.testEqualString("--whole-program-visibility", arg)) {
                cmd.whole_program_visibility = true;
            } else if (mem.testEqualString("--wholeprogramdevirt-branch-funnel-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.wholeprogramdevirt_branch_funnel_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--wholeprogramdevirt-print-index-based", arg)) {
                cmd.wholeprogramdevirt_print_index_based = true;
            } else if (mem.testEqualString("--wholeprogramdevirt-read-summary", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.wholeprogramdevirt_read_summary = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--wholeprogramdevirt-skip", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.wholeprogramdevirt_skip = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--wholeprogramdevirt-write-summary", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.wholeprogramdevirt_write_summary = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--write-relbf-to-summary", arg)) {
                cmd.write_relbf_to_summary = true;
            } else if (mem.testEqualString("--x86-align-branch", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_align_branch = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-align-branch-boundary", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_align_branch_boundary = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-and-imm-shrink", arg)) {
                cmd.x86_and_imm_shrink = true;
            } else if (mem.testEqualString("--x86-branches-within-32B-boundaries", arg)) {
                cmd.x86_branches_within_32B_boundaries = true;
            } else if (mem.testEqualString("--x86-bypass-prefetch-instructions", arg)) {
                cmd.x86_bypass_prefetch_instructions = true;
            } else if (mem.testEqualString("--x86-cmov-converter", arg)) {
                cmd.x86_cmov_converter = true;
            } else if (mem.testEqualString("--x86-cmov-converter-force-all", arg)) {
                cmd.x86_cmov_converter_force_all = true;
            } else if (mem.testEqualString("--x86-cmov-converter-force-mem-operand", arg)) {
                cmd.x86_cmov_converter_force_mem_operand = true;
            } else if (mem.testEqualString("--x86-cmov-converter-threshold", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_cmov_converter_threshold = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-disable-avoid-SFB", arg)) {
                cmd.x86_disable_avoid_SFB = true;
            } else if (mem.testEqualString("--x86-discriminate-memops", arg)) {
                cmd.x86_discriminate_memops = true;
            } else if (mem.testEqualString("--x86-early-ifcvt", arg)) {
                cmd.x86_early_ifcvt = true;
            } else if (mem.testEqualString("--x86-experimental-lvi-inline-asm-hardening", arg)) {
                cmd.x86_experimental_lvi_inline_asm_hardening = true;
            } else if (mem.testEqualString("--x86-experimental-pref-innermost-loop-alignment", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_experimental_pref_innermost_loop_alignment = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-experimental-unordered-atomic-isel", arg)) {
                cmd.x86_experimental_unordered_atomic_isel = true;
            } else if (mem.testEqualString("--x86-indirect-branch-tracking", arg)) {
                cmd.x86_indirect_branch_tracking = true;
            } else if (mem.testEqualString("--x86-lvi-load-dot", arg)) {
                cmd.x86_lvi_load_dot = true;
            } else if (mem.testEqualString("--x86-lvi-load-dot-only", arg)) {
                cmd.x86_lvi_load_dot_only = true;
            } else if (mem.testEqualString("--x86-lvi-load-dot-verify", arg)) {
                cmd.x86_lvi_load_dot_verify = true;
            } else if (mem.testEqualString("--x86-lvi-load-no-cbranch", arg)) {
                cmd.x86_lvi_load_no_cbranch = true;
            } else if (mem.testEqualString("--x86-lvi-load-opt-plugin", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_lvi_load_opt_plugin = mem.terminate(args[args_idx], 0);
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-machine-combiner", arg)) {
                cmd.x86_machine_combiner = true;
            } else if (mem.testEqualString("--x86-pad-for-align", arg)) {
                cmd.x86_pad_for_align = true;
            } else if (mem.testEqualString("--x86-pad-for-branch-align", arg)) {
                cmd.x86_pad_for_branch_align = true;
            } else if (mem.testEqualString("--x86-pad-max-prefix-size", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_pad_max_prefix_size = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-promote-anyext-load", arg)) {
                cmd.x86_promote_anyext_load = true;
            } else if (mem.testEqualString("--x86-seses-enable-without-lvi-cfi", arg)) {
                cmd.x86_seses_enable_without_lvi_cfi = true;
            } else if (mem.testEqualString("--x86-seses-omit-branch-lfences", arg)) {
                cmd.x86_seses_omit_branch_lfences = true;
            } else if (mem.testEqualString("--x86-seses-one-lfence-per-bb", arg)) {
                cmd.x86_seses_one_lfence_per_bb = true;
            } else if (mem.testEqualString("--x86-seses-only-lfence-non-const", arg)) {
                cmd.x86_seses_only_lfence_non_const = true;
            } else if (mem.testEqualString("--x86-sfb-inspection-limit", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.x86_sfb_inspection_limit = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else if (mem.testEqualString("--x86-slh-fence-call-and-ret", arg)) {
                cmd.x86_slh_fence_call_and_ret = true;
            } else if (mem.testEqualString("--x86-slh-indirect", arg)) {
                cmd.x86_slh_indirect = true;
            } else if (mem.testEqualString("--x86-slh-ip", arg)) {
                cmd.x86_slh_ip = true;
            } else if (mem.testEqualString("--x86-slh-lfence", arg)) {
                cmd.x86_slh_lfence = true;
            } else if (mem.testEqualString("--x86-slh-loads", arg)) {
                cmd.x86_slh_loads = true;
            } else if (mem.testEqualString("--x86-slh-post-load", arg)) {
                cmd.x86_slh_post_load = true;
            } else if (mem.testEqualString("--x86-speculative-load-hardening", arg)) {
                cmd.x86_speculative_load_hardening = true;
            } else if (mem.testEqualString("--x86-tile-ra", arg)) {
                cmd.x86_tile_ra = true;
            } else if (mem.testEqualString("--x86-use-base-pointer", arg)) {
                cmd.x86_use_base_pointer = true;
            } else if (mem.testEqualString("--x86-use-fsrm-for-memcpy", arg)) {
                cmd.x86_use_fsrm_for_memcpy = true;
            } else if (mem.testEqualString("--x86-use-vzeroupper", arg)) {
                cmd.x86_use_vzeroupper = true;
            } else if (mem.testEqualString("--xcoff-traceback-table", arg)) {
                cmd.xcoff_traceback_table = true;
            } else if (mem.testEqualString("--xcore-max-threads", arg)) {
                args_idx +%= 1;
                if (args_idx != args.len) {
                    cmd.xcore_max_threads = parse.noexcept.unsigned(mem.terminate(args[args_idx], 0));
                } else {
                    return;
                }
            } else {
                debug.write(llc_help);
            }
        }
    }
};
const llc_help: [:0]const u8 = 
    \\    --aarch64-a57-fp-load-balancing-force-all                               Always modify dest registers regardless of color
    \\    --aarch64-a57-fp-load-balancing-override=<integer>                      Ignore balance information, always return (1: Even, 2: Odd).
    \\    --aarch64-bcc-offset-bits=<integer>                                     Restrict range of Bcc instructions (DEBUG)
    \\    --aarch64-cbz-offset-bits=<integer>                                     Restrict range of CB[N]Z instructions (DEBUG)
    \\    --aarch64-ccmp-limit=<integer>                                          Maximum number of instructions per speculated block.
    \\    --aarch64-early-ifcvt                                                   Enable the early if converter pass
    \\    --aarch64-elf-ldtls-generation                                          Allow AArch64 Local Dynamic TLS code generation
    \\    --aarch64-enable-atomic-cfg-tidy                                        Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information
    \\    --aarch64-enable-branch-relax                                           Relax out of range conditional branches
    \\    --aarch64-enable-branch-targets                                         Enable the AArch64 branch target pass
    \\    --aarch64-enable-ccmp                                                   Enable the CCMP formation pass
    \\    --aarch64-enable-collect-loh                                            Enable the pass that emits the linker optimization hints (LOH)
    \\    --aarch64-enable-compress-jump-tables                                   Use smallest entry possible for jump tables
    \\    --aarch64-enable-cond-br-tune                                           Enable the conditional branch tuning pass
    \\    --aarch64-enable-condopt                                                Enable the condition optimizer pass
    \\    --aarch64-enable-copy-propagation                                       Enable the copy propagation with AArch64 copy instr
    \\    --aarch64-enable-copyelim                                               Enable the redundant copy elimination pass
    \\    --aarch64-enable-dead-defs                                              Enable the pass that removes dead definitons and replaces stores to them with stores to the zero register
    \\    --aarch64-enable-early-ifcvt                                            Run early if-conversion
    \\    --aarch64-enable-falkor-hwpf-fix                                        
    \\    --aarch64-enable-gep-opt                                                Enable optimizations on complex GEPs
    \\    --aarch64-enable-gisel-ldst-postlegal                                   Enable GlobalISel's post-legalizer load/store optimization pass
    \\    --aarch64-enable-gisel-ldst-prelegal                                    Enable GlobalISel's pre-legalizer load/store optimization pass
    \\    --aarch64-enable-global-isel-at-O=<integer>                             Enable GlobalISel at or below an opt level (-1 to disable)
    \\    --aarch64-enable-global-merge                                           Enable the global merge pass
    \\    --aarch64-enable-ldst-opt                                               Enable the load/store pair optimization pass
    \\    --aarch64-enable-logical-imm                                            Enable AArch64 logical imm instruction optimization
    \\    --aarch64-enable-loop-data-prefetch                                     Enable the loop data prefetch pass
    \\    --aarch64-enable-mcr                                                    Enable the machine combiner pass
    \\    --aarch64-enable-mgather-combine                                        Combine extends of AArch64 masked gather intrinsics
    \\    --aarch64-enable-nonlazybind                                            Call nonlazybind functions via direct GOT load
    \\    --aarch64-enable-promote-const                                          Enable the promote constant pass
    \\    --aarch64-enable-simd-scalar                                            Enable use of AdvSIMD scalar integer instructions
    \\    --aarch64-enable-stp-suppress                                           Suppress STP for AArch64
    \\    --aarch64-enable-sve-intrinsic-opts                                     Enable SVE intrinsic opts
    \\    --aarch64-insert-extract-base-cost=<integer>                            Base cost of vector insert/extract element
    \\    --aarch64-load-store-renaming                                           
    \\    --aarch64-load-store-scan-limit=<integer>                               
    \\    --aarch64-mark-bti-property                                             Add .note.gnu.property with BTI to assembly files
    \\    --aarch64-max-xors=<integer>                                            Maximum of xors
    \\    --aarch64-neon-syntax=<tag>                                             Choose style of NEON code to emit from AArch64 backend:
    \\    --aarch64-order-frame-objects                                           sort stack allocations
    \\    --aarch64-redzone                                                       enable use of redzone on AArch64
    \\    --aarch64-select-opt                                                    Enable select to branch optimizations
    \\    --aarch64-simd-scalar-force-all                                         Force use of AdvSIMD scalar instructions everywhere
    \\    --aarch64-slh-loads                                                     Sanitize loads from memory.
    \\    --aarch64-stress-ccmp                                                   Turn all knobs to 11
    \\    --aarch64-stress-promote-const                                          Promote all vector constants
    \\    --aarch64-sve-vector-bits-max=<integer>                                 Assume SVE vector registers are at most this big, with zero meaning no maximum size is assumed.
    \\    --aarch64-sve-vector-bits-min=<integer>                                 Assume SVE vector registers are at least this big, with zero meaning no minimum size is assumed.
    \\    --aarch64-tbz-offset-bits=<integer>                                     Restrict range of TB[N]Z instructions (DEBUG)
    \\    --aarch64-update-scan-limit=<integer>                                   
    \\    --aarch64-use-aa                                                        Enable the use of AA during codegen.
    \\    --aarch64-use-tbi                                                       Assume that top byte of an address is ignored
    \\    --aarch64o0prelegalizercombinerhelper-disable-rule=<string>             Disable one or more combiner rules temporarily in the AArch64O0PreLegalizerCombinerHelper pass
    \\    --aarch64o0prelegalizercombinerhelper-only-enable-rule=<string>         Disable all rules in the AArch64O0PreLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --aarch64postlegalizercombinerhelper-disable-rule=<string>              Disable one or more combiner rules temporarily in the AArch64PostLegalizerCombinerHelper pass
    \\    --aarch64postlegalizercombinerhelper-only-enable-rule=<string>          Disable all rules in the AArch64PostLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --aarch64postlegalizerloweringhelper-disable-rule=<string>              Disable one or more combiner rules temporarily in the AArch64PostLegalizerLoweringHelper pass
    \\    --aarch64postlegalizerloweringhelper-only-enable-rule=<string>          Disable all rules in the AArch64PostLegalizerLoweringHelper pass then re-enable the specified ones
    \\    --aarch64prelegalizercombinerhelper-disable-rule=<string>               Disable one or more combiner rules temporarily in the AArch64PreLegalizerCombinerHelper pass
    \\    --aarch64prelegalizercombinerhelper-only-enable-rule=<string>           Disable all rules in the AArch64PreLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --abort-on-max-devirt-iterations-reached                                Abort when the max iterations for devirtualization CGSCC repeat pass is reached
    \\    --accel-tables=<tag>                                                    Output dwarf accelerator tables.
    \\    --adce-remove-control-flow                                              
    \\    --adce-remove-loops                                                     
    \\    --addr-sink-combine-base-gv                                             Allow combining of BaseGV field in Address sinking.
    \\    --addr-sink-combine-base-offs                                           Allow combining of BaseOffs field in Address sinking.
    \\    --addr-sink-combine-base-reg                                            Allow combining of BaseReg field in Address sinking.
    \\    --addr-sink-combine-scaled-reg                                          Allow combining of ScaledReg field in Address sinking.
    \\    --addr-sink-new-phis                                                    Allow creation of Phis in Address sinking.
    \\    --addr-sink-new-select                                                  Allow creation of selects in Address sinking.
    \\    --addr-sink-using-gep                                                   Address sinking in CGP using GEPs.
    \\    --addrsig                                                               Emit an address-significance table
    \\    --agg-antidep-debugdiv=<integer>                                        Debug control for aggressive anti-dep breaker
    \\    --agg-antidep-debugmod=<integer>                                        Debug control for aggressive anti-dep breaker
    \\    --aggregate-extracted-args                                              Aggregate arguments to code-extracted functions
    \\    --aggressive-ext-opt                                                    Aggressive extension optimization
    \\    --aggressive-instcombine-max-scan-instrs=<integer>                      Max number of instructions to scan for aggressive instcombine.
    \\    --aix-ssp-tb-bit                                                        Enable Passing SSP Canary info in Trackback on AIX
    \\    --alias-set-saturation-threshold=<integer>                              The maximum number of pointers may-alias sets may contain before degradation
    \\    --align-all-blocks=<integer>                                            Force the alignment of all blocks in the function in log2 format (e.g 4 means align on 16B boundaries).
    \\    --align-all-functions=<integer>                                         Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).
    \\    --align-all-nofallthru-blocks=<integer>                                 Force the alignment of all blocks that have no fall-through predecessors (i.e. don't add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries).
    \\    --align-loops=<integer>                                                 Default alignment for loops
    \\    --align-neon-spills                                                     Align ARM NEON spills in prolog and epilog
    \\    --allow-arm-wlsloops                                                    Enable the generation of WLS loops
    \\    --allow-ginsert-as-artifact                                             Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.
    \\    --allow-unroll-and-jam                                                  Allows loops to be unroll-and-jammed.
    \\    --amdgcn-skip-cache-invalidations                                       Use this to skip inserting cache invalidating instructions.
    \\    --amdgpu-any-address-space-out-arguments                                Replace pointer out arguments with struct returns for non-private address space
    \\    --amdgpu-assume-dynamic-stack-object-size=<integer>                     Assumed extra stack use if there are any variable sized objects (in bytes)
    \\    --amdgpu-assume-external-call-stack-size=<integer>                      Assumed stack use of any external call (in bytes)
    \\    --amdgpu-atomic-optimizations                                           Enable atomic optimizations
    \\    --amdgpu-bypass-slow-div                                                Skip 64-bit divide for dynamic 32-bit values
    \\    --amdgpu-dce-in-ra                                                      Enable machine DCE inside regalloc
    \\    --amdgpu-disable-loop-alignment                                         Do not align and prefetch loops
    \\    --amdgpu-disable-unclustred-high-rp-reschedule                          Disable unclustred high register pressure reduction scheduling stage.
    \\    --amdgpu-dpp-combine                                                    Enable DPP combiner
    \\    --amdgpu-dump-hsa-metadata                                              Dump AMDGPU HSA Metadata
    \\    --amdgpu-early-ifcvt                                                    Run early if-conversion
    \\    --amdgpu-early-inline-all                                               Inline all functions early
    \\    --amdgpu-enable-delay-alu                                               Enable s_delay_alu insertion
    \\    --amdgpu-enable-lds-replace-with-pointer                                Enable LDS replace with pointer pass
    \\    --amdgpu-enable-lower-module-lds                                        Enable lower module lds pass
    \\    --amdgpu-enable-max-ilp-scheduling-strategy                             Enable scheduling strategy to maximize ILP for a single wave.
    \\    --amdgpu-enable-merge-m0                                                Merge and hoist M0 initializations
    \\    --amdgpu-enable-power-sched                                             Enable scheduling to minimize mAI power bursts
    \\    --amdgpu-enable-pre-ra-optimizations                                    Enable Pre-RA optimizations pass
    \\    --amdgpu-enable-promote-kernel-arguments                                Enable promotion of flat kernel pointer arguments to global
    \\    --amdgpu-enable-structurizer-workarounds                                Enable workarounds for the StructurizeCFG pass
    \\    --amdgpu-enable-vopd                                                    Enable VOPD, dual issue of VALU in wave32
    \\    --amdgpu-function-calls                                                 Enable AMDGPU function call support
    \\    --amdgpu-igrouplp-exact-solver                                          Whether to use the exponential time solver to fit the instructions to the pipeline as closely as possible.
    \\    --amdgpu-igrouplp-exact-solver-cost-heur                                Whether to use the cost heuristic to make choices as we traverse the search space using the exact solver. Defaulted to on, and if turned off, we will use the node order. Attempting to put the later nodes in the later sched groups. Experimentally, results are mixed, so this should be set on a case-by-case basis.
    \\    --amdgpu-igrouplp-exact-solver-cutoff=<integer>                         The maximum number of scheduling group conflicts which we attempt to solve with the exponential time exact solver. Problem sizes greater than this willbe solved by the less accurate greedy algorithm. Selecting solver by size is superseded by manually selecting the solver (e.g. by amdgpu-igrouplp-exact-solver)
    \\    --amdgpu-igrouplp-exact-solver-max-branches=<integer>                   The amount of branches that we are willing to explore with the exact algorithm before giving up.
    \\    --amdgpu-indirect-access-weight=<integer>                               Indirect access memory instruction weight
    \\    --amdgpu-inline-arg-alloca-cost=<integer>                               Cost of alloca argument
    \\    --amdgpu-inline-arg-alloca-cutoff=<integer>                             Maximum alloca size to use for inline cost
    \\    --amdgpu-inline-max-bb=<integer>                                        Maximum number of BBs allowed in a function after inlining (compile time constraint)
    \\    --amdgpu-internalize-symbols                                            Enable elimination of non-kernel functions and unused globals
    \\    --amdgpu-ir-lower-kernel-arguments                                      Lower kernel argument loads in IR pass
    \\    --amdgpu-large-stride-threshold=<integer>                               Large stride memory access threshold
    \\    --amdgpu-large-stride-weight=<integer>                                  Large stride memory access weight
    \\    --amdgpu-late-structurize                                               Enable late CFG structurization
    \\    --amdgpu-limit-wave-threshold=<integer>                                 Kernel limit wave threshold in %
    \\    --amdgpu-load-store-vectorizer                                          Enable load store vectorizer
    \\    --amdgpu-lower-module-lds-strategy=<tag>                                Specify lowering strategy for function LDS access:
    \\    --amdgpu-max-memory-clause=<integer>                                    Maximum length of a memory clause, instructions
    \\    --amdgpu-max-return-arg-num-regs=<integer>                              Approximately limit number of return registers for replacing out arguments
    \\    --amdgpu-mem-intrinsic-expand-size=<integer>                            Set minimum mem intrinsic size to expand in IR
    \\    --amdgpu-membound-threshold=<integer>                                   Function mem bound threshold in %
    \\    --amdgpu-mfma-padding-ratio=<integer>                                   Fill a percentage of the latency between neighboring MFMA with s_nops.
    \\    --amdgpu-mode-register                                                  Enable mode register pass
    \\    --amdgpu-nsa-threshold=<integer>                                        Number of addresses from which to enable MIMG NSA.
    \\    --amdgpu-opt-exec-mask-pre-ra                                           Run pre-RA exec mask optimizations
    \\    --amdgpu-opt-vgpr-liverange                                             Enable VGPR liverange optimizations for if-else structure
    \\    --amdgpu-prelink                                                        Enable pre-link mode optimizations
    \\    --amdgpu-promote-alloca-to-vector-limit=<integer>                       Maximum byte size to consider promote alloca to vector
    \\    --amdgpu-reassign-regs                                                  Enable register reassign optimizations on gfx10+
    \\    --amdgpu-scalar-ir-passes                                               Enable scalar IR passes
    \\    --amdgpu-scalarize-global-loads                                         Enable global load scalarization
    \\    --amdgpu-schedule-metric-bias=<integer>                                 Sets the bias which adds weight to occupancy vs latency. Set it to 100 to chase the occupancy only.
    \\    --amdgpu-sdwa-peephole                                                  Enable SDWA peepholer
    \\    --amdgpu-set-wave-priority                                              Adjust wave priority
    \\    --amdgpu-set-wave-priority-valu-insts-threshold=<integer>               VALU instruction count threshold for adjusting wave priority
    \\    --amdgpu-simplify-libcall                                               Enable amdgpu library simplifications
    \\    --amdgpu-skip-threshold=<integer>                                       Number of instructions before jumping over divergent control flow
    \\    --amdgpu-stress-function-calls                                          Force all functions to be noinline
    \\    --amdgpu-super-align-lds-globals                                        Increase alignment of LDS if it is not on align boundary
    \\    --amdgpu-unroll-max-block-to-analyze=<integer>                          Inner loop block size threshold to analyze in unroll for AMDGPU
    \\    --amdgpu-unroll-runtime-local                                           Allow runtime unroll for AMDGPU if local memory used in a loop
    \\    --amdgpu-unroll-threshold-if=<integer>                                  Unroll threshold increment for AMDGPU for each if statement inside loop
    \\    --amdgpu-unroll-threshold-local=<integer>                               Unroll threshold for AMDGPU if local memory used in a loop
    \\    --amdgpu-unroll-threshold-private=<integer>                             Unroll threshold for AMDGPU if private memory used in a loop
    \\    --amdgpu-use-aa-in-codegen                                              Enable the use of AA during codegen.
    \\    --amdgpu-use-divergent-register-indexing                                Use indirect register addressing for divergent indexes
    \\    --amdgpu-use-legacy-divergence-analysis                                 Enable legacy divergence analysis for AMDGPU
    \\    --amdgpu-use-native=<string>                                            Comma separated list of functions to replace with native, or all
    \\    --amdgpu-verify-hsa-metadata                                            Verify AMDGPU HSA Metadata
    \\    --amdgpu-vgpr-index-mode                                                Use GPR indexing mode instead of movrel for vector indexing
    \\    --amdgpu-waitcnt-forcezero                                              Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
    \\    --amdgpupostlegalizercombinerhelper-disable-rule=<string>               Disable one or more combiner rules temporarily in the AMDGPUPostLegalizerCombinerHelper pass
    \\    --amdgpupostlegalizercombinerhelper-only-enable-rule=<string>           Disable all rules in the AMDGPUPostLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --amdgpuprelegalizercombinerhelper-disable-rule=<string>                Disable one or more combiner rules temporarily in the AMDGPUPreLegalizerCombinerHelper pass
    \\    --amdgpuprelegalizercombinerhelper-only-enable-rule=<string>            Disable all rules in the AMDGPUPreLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --amdgpuregbankcombinerhelper-disable-rule=<string>                     Disable one or more combiner rules temporarily in the AMDGPURegBankCombinerHelper pass
    \\    --amdgpuregbankcombinerhelper-only-enable-rule=<string>                 Disable all rules in the AMDGPURegBankCombinerHelper pass then re-enable the specified ones
    \\    --amdhsa-code-object-version=<integer>                                  AMDHSA Code Object Version
    \\    --annotate-inline-phase                                                 If true, annotate inline advisor remarks with LTO and pass information.
    \\    --annotate-sample-profile-inline-phase                                  Annotate LTO phase (prelink / postlink), or main (no LTO) for sample-profile inline pass name.
    \\    --arc-opt-max-ptr-states=<integer>                                      Maximum number of ptr states the optimizer keeps track of
    \\    --arm-add-build-attributes                                              
    \\    --arm-adjust-jump-tables                                                Adjust basic block layout to better use TB[BH]
    \\    --arm-assume-itcm-bankconflict                                          
    \\    --arm-assume-misaligned-load-store                                      Be more conservative in ARM load/store opt
    \\    --arm-atomic-cfg-tidy                                                   Run SimplifyCFG after expanding atomic operations to make use of cmpxchg flow-based information
    \\    --arm-constant-island-max-iteration=<integer>                           The max number of iteration for converge
    \\    --arm-data-bank-mask=<integer>                                          
    \\    --arm-disable-omit-dls                                                  Disable omitting 'dls lr, lr' instructions
    \\    --arm-enable-merge-loopenddec                                           Enable merging Loop End and Dec instructions.
    \\    --arm-enable-subreg-liveness                                            
    \\    --arm-force-fast-isel                                                   
    \\    --arm-global-merge                                                      Enable the global merge pass
    \\    --arm-implicit-it=<tag>                                                 Allow conditional instructions outdside of an IT block
    \\    --arm-interworking                                                      Enable / disable ARM interworking (for debugging only)
    \\    --arm-load-store-opt                                                    Enable ARM load/store optimization pass
    \\    --arm-loloops-disable-tailpred                                          Disable tail-predication in the ARM LowOverheadLoop pass
    \\    --arm-memtransfer-tploop=<tag>                                          Control conversion of memcpy to Tail predicated loops (WLSTP)
    \\    --arm-parallel-dsp-load-limit=<integer>                                 Limit the number of loads analysed
    \\    --arm-prera-ldst-opt-reorder-limit=<integer>                            
    \\    --arm-promote-constant                                                  Enable / disable promotion of unnamed_addr constants into constant pools
    \\    --arm-promote-constant-max-size=<integer>                               Maximum size of constant to promote into a constant pool
    \\    --arm-promote-constant-max-total=<integer>                              Maximum size of ALL constants to promote into a constant pool
    \\    --arm-default-it                                                        Generate any type of IT block
    \\    --arm-restrict-it                                                       Disallow complex IT blocks
    \\    --arm-set-lr-predicate                                                  Enable setting lr as a predicate in tail predication regions.
    \\    --arm-synthesize-thumb-1-tbb                                            Use compressed jump tables in Thumb-1 by synthesizing an equivalent to the TBB/TBH instructions
    \\    --arm-use-mulops                                                        
    \\    --as-secure-log-file=<string>                                           As secure log file name
    \\    --asan-always-slow-path                                                 use instrumentation with slow path for all accesses
    \\    --asan-constructor-kind=<tag>                                           Sets the ASan constructor kind
    \\    --asan-debug=<integer>                                                  debug
    \\    --asan-debug-func=<string>                                              Debug func
    \\    --asan-debug-max=<integer>                                              Debug max inst
    \\    --asan-debug-min=<integer>                                              Debug min inst
    \\    --asan-debug-stack=<integer>                                            debug stack
    \\    --asan-destructor-kind=<tag>                                            Sets the ASan destructor kind. The default is to use the value provided to the pass constructor
    \\    --asan-detect-invalid-pointer-cmp                                       Instrument <, <=, >, >= with pointer operands
    \\    --asan-detect-invalid-pointer-pair                                      Instrument <, <=, >, >=, - with pointer operands
    \\    --asan-detect-invalid-pointer-sub                                       Instrument - operations with pointer operands
    \\    --asan-force-dynamic-shadow                                             Load shadow address into a local variable for each function
    \\    --asan-force-experiment=<integer>                                       Force optimization experiment (for testing)
    \\    --asan-globals                                                          Handle global objects
    \\    --asan-globals-live-support                                             Use linker features to support dead code stripping of globals
    \\    --asan-guard-against-version-mismatch                                   Guard against compiler/runtime version mismatch.
    \\    --asan-initialization-order                                             Handle C++ initializer order
    \\    --asan-instrument-atomics                                               instrument atomic instructions (rmw, cmpxchg)
    \\    --asan-instrument-byval                                                 instrument byval call arguments
    \\    --asan-instrument-dynamic-allocas                                       instrument dynamic allocas
    \\    --asan-instrument-reads                                                 instrument read instructions
    \\    --asan-instrument-writes                                                instrument write instructions
    \\    --asan-instrumentation-with-call-threshold=<integer>                    If the function being instrumented contains more than this number of memory accesses, use callbacks instead of inline checks (-1 means never use callbacks).
    \\    --asan-kernel                                                           Enable KernelAddressSanitizer instrumentation
    \\    --asan-kernel-mem-intrinsic-prefix                                      Use prefix for memory intrinsics in KASAN mode
    \\    --asan-mapping-offset=<integer>                                         offset of asan shadow mapping [EXPERIMENTAL]
    \\    --asan-mapping-scale=<integer>                                          scale of asan shadow mapping
    \\    --asan-max-inline-poisoning-size=<integer>                              Inline shadow poisoning for blocks up to the given size in bytes.
    \\    --asan-max-ins-per-bb=<integer>                                         maximal number of instructions to instrument in any given BB
    \\    --asan-memory-access-callback-prefix=<string>                           Prefix for memory access callbacks
    \\    --asan-opt                                                              Optimize instrumentation
    \\    --asan-opt-globals                                                      Don't instrument scalar globals
    \\    --asan-opt-same-temp                                                    Instrument the same temp just once
    \\    --asan-opt-stack                                                        Don't instrument scalar stack variables
    \\    --asan-optimize-callbacks                                               Optimize callbacks
    \\    --asan-realign-stack=<integer>                                          Realign stack to the value of this flag (power of two)
    \\    --asan-recover                                                          Enable recovery mode (continue-after-error).
    \\    --asan-redzone-byval-args                                               Create redzones for byval arguments (extra copy required)
    \\    --asan-skip-promotable-allocas                                          Do not instrument promotable allocas
    \\    --asan-stack                                                            Handle stack memory
    \\    --asan-stack-dynamic-alloca                                             Use dynamic alloca to represent stack variables
    \\    --asan-use-after-return=<tag>                                           Sets the mode of detection for stack-use-after-return.
    \\    --asan-use-after-scope                                                  Check stack-use-after-scope
    \\    --asan-use-odr-indicator                                                Use odr indicators to improve ODR reporting
    \\    --asan-use-private-alias                                                Use private aliases for global variables
    \\    --asan-use-stack-safety                                                 Use Stack Safety analysis results
    \\    --asan-with-comdat                                                      Place ASan constructors in comdat sections
    \\    --asan-with-ifunc                                                       Access dynamic shadow through an ifunc global on platforms that support this
    \\    --asan-with-ifunc-suppress-remat                                        Suppress rematerialization of dynamic shadow address by passing it through inline asm in prologue.
    \\    --asm-macro-max-nesting-depth=<integer>                                 The maximum nesting depth allowed for assembly macros.
    \\    --asm-show-inst                                                         Emit internal instruction representation to assembly file
    \\    --asm-verbose                                                           Add comments to directives.
    \\    --assume-preserve-all                                                   enable preservation of all attrbitues. even those that are unlikely to be usefull
    \\    --atomic-counter-update-promoted                                        Do counter update using atomic fetch add  for promoted counters only
    \\    --atomic-first-counter                                                  Use atomic fetch add for first counter in a function (usually the entry counter)
    \\    --attributor-allow-deep-wrappers                                        Allow the Attributor to use IP information derived from non-exact functions via cloning
    \\    --attributor-allow-shallow-wrappers                                     Allow the Attributor to create shallow wrappers for non-exact definitions.
    \\    --attributor-annotate-decl-cs                                           Annotate call sites of function declarations.
    \\    --attributor-depgraph-dot-filename-prefix=<string>                      The prefix used for the CallGraph dot file names.
    \\    --attributor-dump-dep-graph                                             Dump the dependency graph to dot files.
    \\    --attributor-enable=<tag>                                               Enable the attributor inter-procedural deduction pass
    \\    --attributor-enable-call-site-specific-deduction                        Allow the Attributor to do call site specific analysis
    \\    --attributor-manifest-internal                                          Manifest Attributor internal string attributes.
    \\    --attributor-max-initialization-chain-length=<integer>                  Maximal number of chained initializations (to avoid stack overflows)
    \\    --attributor-max-iterations=<integer>                                   Maximal number of fixpoint iterations.
    \\    --attributor-max-iterations-verify                                      Verify that max-iterations is a tight bound for a fixpoint
    \\    --attributor-max-potential-values=<integer>                             Maximum number of potential values to be tracked for each position.
    \\    --attributor-max-potential-values-iterations=<integer>                  Maximum number of iterations we keep dismantling potential values.
    \\    --attributor-print-call-graph                                           Print Attributor's internal call graph
    \\    --attributor-print-dep                                                  Print attribute dependencies
    \\    --attributor-simplify-all-loads                                         Try to simplify all loads.
    \\    --attributor-view-dep-graph                                             View the dependency graph.
    \\    --available-load-scan-limit=<integer>                                   Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
    \\    --avoid-speculation                                                     MachineLICM should avoid speculation
    \\    --basic-aa-recphi                                                       
    \\    --basic-aa-separate-storage                                             
    \\    --bbsections-cold-text-prefix=<string>                                  The text prefix to use for cold basic block clusters
    \\    --bbsections-detect-source-drift                                        This checks if there is a fdo instr. profile hash mismatch for this function
    \\    --bbsections-guided-section-prefix                                      Use the basic-block-sections profile to determine the text section prefix for hot functions. Functions with basic-block-sections profile will be placed in `.text.hot` regardless of their FDO profile info. Other functions won't be impacted, i.e., their prefixes will be decided by FDO/sampleFDO profiles.
    \\    --binutils-version=<string>                                             Produced object files can use all ELF features supported by this binutils version and newer.If -no-integrated-as is specified, the generated assembly will consider GNU as support.'none' means that all ELF features can be used, regardless of binutils support
    \\    --bitcode-flush-threshold=<integer>                                     The threshold (unit M) for flushing LLVM bitcode.
    \\    --bitcode-mdindex-threshold=<integer>                                   Number of metadatas above which we emit an index to enable lazy-loading
    \\    --block-freq-ratio-threshold=<integer>                                  Do not hoist instructions if targetblock is N times hotter than the source.
    \\    --block-placement-exit-block-bias=<integer>                             Block frequency percentage a loop exit block needs over the original exit to be considered the new exit.
    \\    --bonus-inst-threshold=<integer>                                        Control the number of bonus instructions (default = 1)
    \\    --bounds-checking-single-trap                                           Use one trap block per function
    \\    --bpf-disable-avoid-speculation                                         BPF: Disable Avoiding Speculative Code Motion.
    \\    --bpf-disable-serialize-icmp                                            BPF: Disable Serializing ICMP insns.
    \\    --bpf-expand-memcpy-in-order                                            Expand memcpy into load/store pairs in order
    \\    --branch-fold-placement                                                 Perform branch folding during placement. Reduces code size.
    \\    --branch-relax-asm-large                                                branch relax asm
    \\    --branch-relax-safety-buffer=<integer>                                  safety buffer size
    \\    --break-anti-dependencies=<string>                                      Break post-RA scheduling anti-dependencies: "critical", "all", or "none"
    \\    --cache-line-size=<integer>                                             Use this to override the target cache line size when specified by the user.
    \\    --callgraph-dot-filename-prefix=<string>                                The prefix used for the CallGraph dot file names.
    \\    --callgraph-heat-colors                                                 Show heat colors in call-graph
    \\    --callgraph-multigraph                                                  Show call-multigraph (do not remove parallel edges)
    \\    --callgraph-show-weights                                                Show edges labeled with weights
    \\    --callsite-splitting-duplication-threshold=<integer>                    Only allow instructions before a call, if their cost is below DuplicationThreshold
    \\    --canon-nth-function=<integer>                                          Function number to canonicalize.
    \\    --canonicalize-icmp-predicates-to-unsigned                              Enables canonicalization of signed relational predicates to unsigned (e.g. sgt => ugt)
    \\    --capture-tracking-max-uses-to-explore=<integer>                        Maximal number of uses to explore.
    \\    --cfg-dot-filename-prefix=<string>                                      The prefix used for the CFG dot file names.
    \\    --cfg-func-name=<string>                                                The name of a function (or its substring) whose CFG is viewed/printed.
    \\    --cfg-heat-colors                                                       Show heat colors in CFG
    \\    --cfg-hide-cold-paths=<integer>                                         Hide blocks with relative frequency below the given value
    \\    --cfg-hide-deoptimize-paths                                             
    \\    --cfg-hide-unreachable-paths                                            
    \\    --cfg-raw-weights                                                       Use raw weights for labels. Use percentages as default.
    \\    --cfg-weights                                                           Show edges labeled with weights
    \\    --cgp-freq-ratio-to-skip-merge=<integer>                                Skip merging empty blocks if (frequency of empty block) / (frequency of destination block) is greater than this ratio
    \\    --cgp-icmp-eq2icmp-st                                                   Enable ICMP_EQ to ICMP_S(L|G)T conversion.
    \\    --cgp-optimize-phi-types                                                Enable converting phi types in CodeGenPrepare
    \\    --cgp-split-large-offset-gep                                            Enable splitting large offset of GEP.
    \\    --cgp-type-promotion-merge                                              Enable merging of redundant sexts when one is dominating the other.
    \\    --cgp-verify-bfi-updates                                                Enable BFI update verification for CodeGenPrepare.
    \\    --cgpp-huge-func=<integer>                                              Least BB number of huge function.
    \\    --cgscc-inline-replay                                                   Optimization remarks file containing inline remarks to be replayed by cgscc inlining.
    \\    --cgscc-inline-replay-fallback=<tag>                                    How cgscc inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay
    \\    --cgscc-inline-replay-format=<tag>                                      How cgscc inline replay file is formatted
    \\    --cgscc-inline-replay-scope=<tag>                                       Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during cgscc inlining.
    \\    --check-bfi-unknown-block-queries                                       Check if block frequency is queried for an unknown block for debugging missed BFI updates
    \\    --check-early-avail                                                     
    \\    --chr-bias-threshold=<integer>                                          CHR considers a branch bias greater than this ratio as biased
    \\    --chr-dup-threshold=<integer>                                           Max number of duplications by CHR for a region
    \\    --chr-function-list=<string>                                            Specify file to retrieve the list of functions to apply CHR to
    \\    --chr-merge-threshold=<integer>                                         CHR merges a group of N branches/selects where N >= this value
    \\    --chr-module-list=<string>                                              Specify file to retrieve the list of modules to apply CHR to
    \\    --code-model=<tag>                                                      Choose code model
    \\    --cold-branch-ratio=<integer>                                           Minimum BranchProbability to consider a region cold.
    \\    --cold-callsite-rel-freq=<integer>                                      Maximum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
    \\    --cold-operand-max-cost-multiplier=<integer>                            Maximum cost multiplier of TCC_expensive for the dependence slice of a cold operand to be considered inexpensive.
    \\    --cold-operand-threshold=<integer>                                      Maximum frequency of path for an operand to be considered cold.
    \\    --cold-synthetic-count=<integer>                                        Initial synthetic entry count for cold functions.
    \\    --coldcc-rel-freq=<integer>                                             Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
    \\    --color                                                                 Use colors in output (default=autodetect)
    \\    --combiner-global-alias-analysis                                        Enable DAG combiner's use of IR alias analysis
    \\    --combiner-reduce-load-op-store-width                                   DAG combiner enable reducing the width of load/op/store sequence
    \\    --combiner-shrink-load-replace-store-with-store                         DAG combiner enable load/<replace bytes>/store with a narrower store
    \\    --combiner-split-load-index                                             DAG combiner may split indexing from loads
    \\    --combiner-store-merge-dependence-limit=<integer>                       Limit the number of times for the same StoreNode and RootNode to bail out in store merging dependence check
    \\    --combiner-store-merging                                                DAG combiner enable merging multiple stores into a wider store
    \\    --combiner-stress-load-slicing                                          Bypass the profitability model of load slicing
    \\    --combiner-tokenfactor-inline-limit=<integer>                           Limit the number of operands to inline for Token Factors
    \\    --combiner-use-tbaa                                                     Enable DAG combiner's use of TBAA
    \\    --combiner-vector-fcopysign-extend-round                                Enable merging extends and rounds into FCOPYSIGN on vector types
    \\    --commgep-const                                                         
    \\    --commgep-inv                                                           
    \\    --commgep-speculate                                                     
    \\    --compile-time-mem-idiom-threshold=<integer>                            Threshold (in bytes) to perform the transformation, if the runtime loop count (mem transfer size) is known at compile-time.
    \\    --compile-twice                                                         Run everything twice, re-using the same pass manager and verify the result is the same.
    \\    --compute-dead                                                          Compute dead symbols
    \\    --consthoist-gep                                                        Try hoisting constant gep expressions
    \\    --consthoist-min-num-to-rebase=<integer>                                Do not rebase if number of dependent constants of a Base is less than this number.
    \\    --consthoist-with-block-frequency                                       Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
    \\    --constraint-elimination-max-rows=<integer>                             Maximum number of rows to keep in constraint system
    \\    --cost-kind=<tag>                                                       Target cost kind
    \\    --costmodel-reduxcost                                                   Recognize reduction patterns.
    \\    --crash-diagnostics-dir=<string>                                        Directory for crash diagnostic files.
    \\    --crash-on-ppc-vsx-self-copy                                            Causes the backend to crash instead of generating a nop VSX copy
    \\    --cs-profile-generate                                                   Perform context sensitive PGO instrumentation
    \\    --cs-profile-path=<string>                                              Context sensitive profile file path
    \\    --csuses-threshold=<integer>                                            Threshold for the size of CSUses
    \\    --cvp-max-functions-per-value=<integer>                                 The maximum number of functions to track per lattice value
    \\    --da-delinearize                                                        Try to delinearize array references.
    \\    --da-disable-delinearization-checks                                     Disable checks that try to statically verify validity of delinearized subscripts. Enabling this option may result in incorrect dependence vectors for languages that allow the subscript of one dimension to underflow or overflow into another dimension.
    \\    --da-miv-max-level-threshold=<integer>                                  Maximum depth allowed for the recursive algorithm used to explore MIV direction vectors.
    \\    --dag-dump-verbose                                                      Display more information when dumping selection DAG nodes.
    \\    --dag-maps-huge-region=<integer>                                        The limit to use while constructing the DAG prior to scheduling, at which point a trade-off is made to avoid excessive compile time.
    \\    --dag-maps-reduction-size=<integer>                                     A huge scheduling region will have maps reduced by this many nodes at a time. Defaults to HugeRegion / 2.
    \\    --data-sections                                                         Emit data into separate sections
    \\    --dataflow-edge-limit=<integer>                                         Maximum number of dataflow edges to traverse when evaluating the benefit of commuting operands
    \\    --ddg-pi-blocks                                                         Create pi-block nodes.
    \\    --ddg-simplify                                                          Simplify DDG by merging nodes that have less interesting edges.
    \\    --debug-ata-max-blocks=<integer>                                        Maximum num basic blocks before debug info dropped
    \\    -debug-counter                                                          Comma separated list of debug counter skip and count
    \\    --debug-entry-values                                                    Enable debug info for the debug entry values.
    \\    --debug-info-correlate                                                  Use debug info to correlate profiles.
    \\    --debug-pass=<tag>                                                      Print legacy PassManager debugging information
    \\    --debugger-tune=<tag>                                                   Tune debug info for a particular debugger
    \\    --debugify-and-strip-all-safe                                           Debugify MIR before and Strip debug after each pass except those known to be unsafe when debug info is present
    \\    --debugify-check-and-strip-all-safe                                     Debugify MIR before, by checking and stripping the debug info after, each pass except those known to be unsafe when debug info is present
    \\    --debugify-func-limit=<integer>                                         Set max number of processed functions per pass.
    \\    --debugify-level=<tag>                                                  Kind of debug info to add
    \\    --debugify-quiet                                                        Suppress verbose debugify output
    \\    --default-gcov-version=<string>                                         
    \\    --default-trip-count=<integer>                                          Use this to specify the default trip count of a loop
    \\    --demote-catchswitch-only                                               Demote catchswitch BBs only (for wasm EH)
    \\    --denormal-fp-math=<tag>                                                Select which denormal numbers the code is permitted to require
    \\    --denormal-fp-math-f32=<tag>                                            Select which denormal numbers the code is permitted to require for float
    \\    --dfa-cost-threshold=<integer>                                          Maximum cost accepted for the transformation
    \\    --dfa-hazard-rec                                                        Use the DFA based hazard recognizer.
    \\    --dfa-instr-limit=<integer>                                             If present, stops packetizing after N instructions
    \\    --dfa-jump-view-cfg-before                                              View the CFG before DFA Jump Threading
    \\    --dfa-max-num-paths=<integer>                                           Max number of paths enumerated around a switch
    \\    --dfa-max-path-length=<integer>                                         Max number of blocks searched to find a threading path
    \\    --dfa-sched-reg-pressure-threshold=<integer>                            Track reg pressure and switch priority to in-depth
    \\    --dfsan-abilist=<string>                                                File listing native ABI functions and how the pass treats them
    \\    --dfsan-combine-offset-labels-on-gep                                    Combine the label of the offset with the label of the pointer when doing pointer arithmetic.
    \\    --dfsan-combine-pointer-labels-on-load                                  Combine the label of the pointer with the label of the data when loading from memory.
    \\    --dfsan-combine-pointer-labels-on-store                                 Combine the label of the pointer with the label of the data when storing in memory.
    \\    --dfsan-combine-taint-lookup-table=<string>                             When dfsan-combine-offset-labels-on-gep and/or dfsan-combine-pointer-labels-on-load are false, this flag can be used to re-enable combining offset and/or pointer taint when loading specific constant global variables (i.e. lookup tables).
    \\    --dfsan-conditional-callbacks                                           Insert calls to callback functions on conditionals.
    \\    --dfsan-debug-nonzero-labels                                            Insert calls to __dfsan_nonzero_label on observing a parameter, load or return with a nonzero label
    \\    --dfsan-event-callbacks                                                 Insert calls to __dfsan_*_callback functions on data events.
    \\    --dfsan-ignore-personality-routine                                      If a personality routine is marked uninstrumented from the ABI list, do not create a wrapper for it.
    \\    --dfsan-instrument-with-call-threshold=<integer>                        If the function being instrumented requires more than this number of origin stores, use callbacks instead of inline checks (-1 means never use callbacks).
    \\    --dfsan-preserve-alignment                                              respect alignment requirements provided by input IR
    \\    --dfsan-reaches-function-callbacks                                      Insert calls to callback functions on data reaching a function.
    \\    --dfsan-track-origins=<integer>                                         Track origins of labels
    \\    --dfsan-track-select-control-flow                                       Propagate labels from condition values of select instructions to results.
    \\    --disable-2addr-hack                                                    Disable scheduler's two-address hack
    \\    --disable-a15-sd-optimization                                           Inhibit optimization of S->D register accesses on A15
    \\    --disable-adv-copy-opt                                                  Disable advanced copy optimization
    \\    --disable-advanced-peeling                                              Disable advance peeling. Issues for convergent targets (D134803).
    \\    --disable-arm-loloops                                                   Disable the generation of low-overhead loops
    \\    --disable-arm-parallel-dsp                                              Disable the ARM Parallel DSP pass
    \\    --disable-auto-paired-vec-st                                            disable automatically generated 32byte paired vector stores
    \\    --disable-basic-aa                                                      
    \\    --disable-binop-extract-shuffle                                         Disable binop extract to shuffle transforms
    \\    --disable-bitcode-version-upgrade                                       Disable automatic bitcode upgrade for version mismatch
    \\    --disable-block-placement                                               Disable probability-driven block placement
    \\    --disable-bpf-peephole                                                  Disable machine peepholes for BPF
    \\    --disable-branch-fold                                                   Disable branch folding
    \\    --disable-cfi-fixup                                                     Disable the CFI fixup pass
    \\    --disable-cgp                                                           Disable Codegen Prepare
    \\    --disable-cgp-branch-opts                                               Disable branch optimizations in CodeGenPrepare
    \\    --disable-cgp-ext-ld-promotion                                          Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare
    \\    --disable-cgp-gc-opts                                                   Disable GC optimizations in CodeGenPrepare
    \\    --disable-cgp-select2branch                                             Disable select to branch conversion.
    \\    --disable-cgp-store-extract                                             Disable store(extract) optimizations in CodeGenPrepare
    \\    --disable-check-noreturn-call                                           
    \\    --disable-chr                                                           Disable CHR for all functions
    \\    --disable-cleanups                                                      Do not remove implausible terminators or other similar cleanups
    \\    --disable-complex-addr-modes                                            Disables combining addressing modes with different parts in optimizeMemoryInst.
    \\    --disable-const64                                                       Disable generation of const64
    \\    --disable-constant-hoisting                                             Disable ConstantHoisting
    \\    --disable-copyprop                                                      Disable Copy Propagation pass
    \\    --disable-debug-info-print                                              Disable debug info printing
    \\    --disable-demotion                                                      Clone multicolor basic blocks but do not demote cross scopes
    \\    --disable-dfa-sched                                                     Disable use of DFA during scheduling
    \\    --disable-early-ifcvt                                                   Disable Early If-conversion
    \\    --disable-early-taildup                                                 Disable pre-register allocation tail duplication
    \\    --disable-expand-reductions                                             Disable the expand reduction intrinsics pass from running
    \\    --disable-gep-const-evaluation                                          Disables evaluation of GetElementPtr with constant operands
    \\    --disable-gisel-legality-check                                          Don't verify that MIR is fully legal between GlobalISel passes
    \\    --disable-hcp                                                           Disable Hexagon constant propagation
    \\    --disable-hexagon-amodeopt                                              Disable Hexagon Addressing Mode Optimization
    \\    --disable-hexagon-cfgopt                                                Disable Hexagon CFG Optimization
    \\    --disable-hexagon-dealloc-ret                                           Disable Dealloc Return for Hexagon target
    \\    --disable-hexagon-hwloops                                               Disable Hardware Loops for Hexagon target
    \\    --disable-hexagon-misched                                               Disable Hexagon MI Scheduling
    \\    --disable-hexagon-nv-schedule                                           Disable schedule adjustment for new value stores.
    \\    --disable-hexagon-opt-ext-to-64                                         Disable Optimization of extensions to i64.
    \\    --disable-hexagon-optszext                                              Disable Optimization of Sign/Zero Extends
    \\    --disable-hexagon-peephole                                              Disable Peephole Optimization
    \\    --disable-hexagon-pnotp                                                 Disable Optimization of PNotP
    \\    --disable-hexagon-shuffle                                               Disable Hexagon instruction shuffling
    \\    --disable-hexagon-volatile-memcpy                                       Enable Hexagon-specific memcpy for volatile destination.
    \\    --disable-hoisting-to-hotter-blocks=<tag>                               Disable hoisting instructions to hotter blocks
    \\    --disable-hsdr                                                          Disable splitting double registers
    \\    --disable-i2p-p2i-opt                                                   Disables inttoptr/ptrtoint roundtrip optimization
    \\    --disable-icp                                                           Disable indirect call promotion
    \\    --disable-ifcvt-diamond                                                 
    \\    --disable-ifcvt-forked-diamond                                          
    \\    --disable-ifcvt-simple                                                  
    \\    --disable-ifcvt-simple-false                                            
    \\    --disable-ifcvt-triangle                                                
    \\    --disable-ifcvt-triangle-false                                          
    \\    --disable-ifcvt-triangle-false-rev                                      
    \\    --disable-ifcvt-triangle-rev                                            
    \\    --disable-inlined-alloca-merging                                        
    \\    --disable-interleaved-load-combine                                      Disable combining of interleaved loads
    \\    --disable-lanai-mem-alu-combiner                                        Do not combine ALU and memory operators
    \\    --disable-layout-fsprofile-loader                                       Disable MIRProfileLoader before BlockPlacement
    \\    --disable-lftr                                                          Disable Linear Function Test Replace optimization
    \\    --disable-licm-promotion                                                Disable memory promotion in LICM pass
    \\    --disable-loop-level-heuristics                                         Disable loop-level heuristics.
    \\    --disable-lsr                                                           Disable Loop Strength Reduction Pass
    \\    --disable-machine-cse                                                   Disable Machine Common Subexpression Elimination
    \\    --disable-machine-dce                                                   Disable Machine Dead Code Elimination
    \\    --disable-machine-licm                                                  Disable Machine LICM
    \\    --disable-machine-sink                                                  Disable Machine Sinking
    \\    --disable-memcpy-idiom                                                  Disable generation of memcpy in loop idiom recognition
    \\    --disable-memmove-idiom                                                 Disable generation of memmove in loop idiom recognition
    \\    --disable-memop-opt                                                     Disable optimize
    \\    --disable-merge-into-combines                                           Disable merging into combines
    \\    --disable-mergeicmps                                                    Disable MergeICmps Pass
    \\    --disable-mips-delay-filler                                             Fill all delay slots with NOPs.
    \\    --disable-mips-df-backward-search                                       Disallow MIPS delay filler to search backward.
    \\    --disable-mips-df-forward-search                                        Disallow MIPS delay filler to search forward.
    \\    --disable-mips-df-succbb-search                                         Disallow MIPS delay filler to search successor basic blocks.
    \\    --disable-mr-partial-inlining                                           Disable multi-region partial inlining
    \\    --disable-nofree-inference                                              Stop inferring nofree attribute during function-attrs pass
    \\    --disable-non-allocatable-phys-copy-opt                                 Disable non-allocatable physical register copy optimization
    \\    --disable-nounwind-inference                                            Stop inferring nounwind attribute during function-attrs pass
    \\    --disable-nvjump                                                        Disable New Value Jumps
    \\    --disable-nvptx-load-store-vectorizer                                   Disable load/store vectorizer
    \\    --disable-nvptx-require-structured-cfg                                  Transitional flag to turn off NVPTX's requirement on preserving structured CFG. The requirement should be disabled only when unexpected regressions happen.
    \\    --disable-ondemand-mds-loading                                          Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
    \\    --disable-packetizer                                                    Disable Hexagon packetizer pass
    \\    --disable-partial-inlining                                              Disable partial inlining
    \\    --disable-partial-libcall-inlining                                      Disable Partial Libcall Inlining
    \\    --disable-peephole                                                      Disable the peephole optimizer
    \\    --disable-phi-elim-edge-splitting                                       Disable critical edge splitting during PHI elimination
    \\    --disable-post-ra                                                       Disable Post Regalloc Scheduler
    \\    --disable-postra-machine-licm                                           Disable Machine LICM
    \\    --disable-postra-machine-sink                                           Disable PostRA Machine Sinking
    \\    --disable-ppc-cmp-opt                                                   Disable compare instruction optimization
    \\    --disable-ppc-constant-hoisting                                         disable constant hoisting on PPC
    \\    --disable-ppc-ctrloop-analysis                                          Disable analysis for CTR loops
    \\    --disable-ppc-ctrloops                                                  Disable CTR loops for PPC
    \\    --disable-ppc-ilp-pref                                                  disable setting the node scheduling preference to ILP on PPC
    \\    --disable-ppc-innermost-loop-align32                                    don't always align innermost loop to 32 bytes on ppc
    \\    --disable-ppc-instr-form-prep                                           Disable PPC loop instr form prep
    \\    --disable-ppc-peephole                                                  Disable machine peepholes for PPC
    \\    --disable-ppc-preinc                                                    disable preincrement load/store generation on PPC
    \\    --disable-ppc-sched-addi-load                                           Disable scheduling addi instruction beforeload for ppc
    \\    --disable-ppc-sco                                                       disable sibling call optimization on ppc
    \\    --disable-ppc-unaligned                                                 disable unaligned load/store generation on PPC
    \\    --disable-ppc-vsx-fma-mutation                                          Disable VSX FMA instruction mutation
    \\    --disable-ppc-vsx-swap-removal                                          Disable VSX Swap Removal for PPC
    \\    --disable-preheader-prot                                                Disable protection against removing loop preheaders
    \\    --disable-preinline                                                     Disable pre-instrumentation inliner
    \\    --disable-promote-alloca-to-lds                                         Disable promote alloca to LDS
    \\    --disable-promote-alloca-to-vector                                      Disable promote alloca to vector
    \\    --disable-ra-fsprofile-loader                                           Disable MIRProfileLoader before RegAlloc
    \\    --disable-sample-loader-inlining                                        If true, artifically skip inline transformation in sample-loader pass, and merge (or scale) profiles (as configured by --sample-profile-merge-inlinee).
    \\    --disable-sched-critical-path                                           Disable critical path priority in sched=list-ilp
    \\    --disable-sched-cycles                                                  Disable cycle-level precision during preRA scheduling
    \\    --disable-sched-hazard                                                  Disable hazard detection during preRA scheduling
    \\    --disable-sched-height                                                  Disable scheduled-height priority in sched=list-ilp
    \\    --disable-sched-live-uses                                               Disable live use priority in sched=list-ilp
    \\    --disable-sched-physreg-join                                            Disable physreg def-use affinity
    \\    --disable-sched-reg-pressure                                            Disable regpressure priority in sched=list-ilp
    \\    --disable-sched-stalls                                                  Disable no-stall priority in sched=list-ilp
    \\    --disable-sched-vrcycle                                                 Disable virtual register cycle interference checks
    \\    --disable-select-optimize                                               Disable the select-optimization pass from running
    \\    --disable-separate-const-offset-from-gep                                Do not separate the constant offset from a GEP instruction
    \\    --disable-shifter-op                                                    Disable isel of shifter-op
    \\    --disable-simplify-libcalls                                             Disable simplify-libcalls
    \\    --disable-sparc-delay-filler                                            Disable the Sparc delay slot filler.
    \\    --disable-sparc-leaf-proc                                               Disable Sparc leaf procedure optimization.
    \\    --disable-spill-fusing                                                  Disable fusing of spill code into instructions
    \\    --disable-spill-hoist                                                   Disable inline spill hoisting
    \\    --disable-ssc                                                           Disable Stack Slot Coloring
    \\    --disable-store-widen                                                   Disable store widening
    \\    --disable-strictnode-mutation                                           Don't mutate strict-float node to a legalize node
    \\    --disable-symbolication                                                 Disable symbolizing crash backtraces.
    \\    --disable-tail-calls                                                    Never emit tail calls
    \\    --disable-tail-duplicate                                                Disable tail duplication
    \\    --disable-thinlto-funcattrs                                             Don't propagate function-attrs in thinLTO
    \\    --disable-type-promotion                                                Disable type promotion pass
    \\    --disable-vecdbl-nv-stores                                              Disable vector double new-value-stores
    \\    --disable-vector-combine                                                Disable all vector combine transforms
    \\    --disable-verify                                                        Do not verify input module
    \\    --disable-vp                                                            Disable Value Profiling
    \\    --disable-wasm-fallthrough-return-opt                                   WebAssembly: Disable fallthrough-return optimizations.
    \\    --disable-whole-program-visibility                                      Disable whole program visibility (overrides enabling options)
    \\    --disable-x86-domain-reassignment                                       X86: Disable Virtual Register Reassignment.
    \\    --disable-x86-lea-opt                                                   X86: Disable LEA optimizations.
    \\    --discard-value-names                                                   Discard names from Value (other than GlobalValue).
    \\    --do-comdat-renaming                                                    Append function hash to the name of COMDAT function to avoid function hash mismatch due to the preinliner
    \\    --do-counter-promotion                                                  Do counter register promotion
    \\    --dom-conditions-max-uses=<integer>                                     
    \\    --dom-tree-reachability-max-bbs-to-explore=<integer>                    Max number of BBs to explore for reachability analysis
    \\    --dot-cfg-after-color=<string>                                          Color for dot-cfg after elements
    \\    --dot-cfg-before-color=<string>                                         Color for dot-cfg before elements
    \\    --dot-cfg-common-color=<string>                                         Color for dot-cfg common elements
    \\    --dot-cfg-dir=<string>                                                  Generate dot files into specified directory for changed IRs
    \\    --dot-ddg-filename-prefix=<string>                                      The prefix used for the DDG dot file names.
    \\    --dot-ddg-only                                                          simple ddg dot graph
    \\    --dot-mcfg-only                                                         Print only the CFG without blocks body
    \\    --dse-memoryssa-defs-per-block-limit=<integer>                          The number of MemoryDefs we consider as candidates to eliminated other stores per basic block (default = 5000)
    \\    --dse-memoryssa-otherbb-cost=<integer>                                  The cost of a step in a different basic block than the killing MemoryDef(default = 5)
    \\    --dse-memoryssa-partial-store-limit=<integer>                           The maximum number candidates that only partially overwrite the killing MemoryDef to consider (default = 5)
    \\    --dse-memoryssa-path-check-limit=<integer>                              The maximum number of blocks to check when trying to prove that all paths to an exit go through a killing block (default = 50)
    \\    --dse-memoryssa-samebb-cost=<integer>                                   The cost of a step in the same basic block as the killing MemoryDef(default = 1)
    \\    --dse-memoryssa-scanlimit=<integer>                                     The number of memory instructions to scan for dead store elimination (default = 150)
    \\    --dse-memoryssa-walklimit=<integer>                                     The maximum number of steps while walking upwards to find MemoryDefs that may be killed (default = 90)
    \\    --dse-optimize-memoryssa                                                Allow DSE to optimize memory accesses.
    \\    --dump-thin-cg-sccs                                                     Dump the SCCs in the ThinLTO index's callgraph
    \\    --dwarf-directory                                                       Use .file directives with an explicit directory
    \\    --dwarf-extended-loc=<tag>                                              Disable emission of the extended flags in .loc directives.
    \\    --dwarf-inlined-strings=<tag>                                           Use inlined strings rather than string section.
    \\    --dwarf-linkage-names=<tag>                                             Which DWARF linkage-name attributes to emit.
    \\    --dwarf-op-convert=<tag>                                                Enable use of the DWARFv5 DW_OP_convert operator
    \\    --dwarf-sections-as-references=<tag>                                    Use sections+offset as references rather than labels.
    \\    --dwarf-version=<integer>                                               Dwarf version
    \\    --dwarf64                                                               Generate debugging info in the 64-bit DWARF format
    \\    --eagerly-invalidate-analyses                                           Eagerly invalidate more analyses in default pipelines
    \\    --early-ifcvt-limit=<integer>                                           Maximum number of instructions per speculated block.
    \\    --early-live-intervals                                                  Run live interval analysis earlier in the pipeline
    \\    --earlycse-debug-hash                                                   Perform extra assertion checking to verify that SimpleValue's hash function is well-behaved w.r.t. its isEqual predicate
    \\    --earlycse-mssa-optimization-cap=<integer>                              Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.
    \\    --eif-limit=<integer>                                                   Size limit in Hexagon early if-conversion
    \\    --eif-no-loop-exit                                                      Do not convert branches that may exit the loop
    \\    --emit-call-site-info                                                   Emit call site debug information, if debug information is enabled.
    \\    --emit-dwarf-unwind=<tag>                                               Whether to emit DWARF EH frame entries.
    \\    --emscripten-cxx-exceptions-allowed=<string>                            The list of function names in which Emscripten-style exception handling is enabled (see emscripten EMSCRIPTEN_CATCHING_ALLOWED options)
    \\    --emulate-old-livedebugvalues                                           Act like old LiveDebugValues did
    \\    --emulated-tls                                                          Use emulated TLS model
    \\    --enable-aa-sched-mi                                                    Enable use of AA during MI DAG construction
    \\    --enable-acc-forwarding                                                 Enable vec acc forwarding
    \\    --enable-alu-forwarding                                                 Enable vec alu forwarding
    \\    --enable-amdgpu-aa                                                      Enable AMDGPU Alias Analysis
    \\    --enable-andcmp-sinking                                                 Enable sinkinig and/cmp into branches.
    \\    --enable-approx-func-fp-math                                            Enable FP math optimizations that assume approx func
    \\    --enable-arm-3-addr-conv                                                Enable ARM 2-addr to 3-addr conv
    \\    --enable-arm-maskedgatscat                                              Enable the generation of masked gathers and scatters
    \\    --enable-arm-maskedldst                                                 Enable the generation of masked loads and stores
    \\    --enable-block-placement-stats                                          Collect probability-driven block placement stats
    \\    --enable-bsb-sched                                                      
    \\    --enable-chr                                                            Enable control height reduction optimization (CHR)
    \\    --enable-cold-section                                                   Enable placement of extracted cold functions into a separate section after hot-cold splitting.
    \\    --enable-coldcc-stress-test                                             Enable stress test of coldcc by adding calling conv to all internal functions.
    \\    --enable-complex-deinterleaving                                         Enable generation of complex instructions
    \\    --enable-cond-stores-vec                                                Enable if predication of stores during vectorization.
    \\    --enable-constraint-elimination                                         Enable pass to eliminate conditions based on linear constraints
    \\    --enable-cse-in-irtranslator                                            Should enable CSE in irtranslator
    \\    --enable-cse-in-legalizer                                               Should enable CSE in Legalizer
    \\    --enable-cur-sched                                                      Enable the scheduler to generate .cur
    \\    --enable-deferred-spilling                                              Instead of spilling a variable right away, defer the actual code insertion to the end of the allocation. That way the allocator might still find a suitable coloring for this variable because of other evicted variables.
    \\    --enable-dfa-jump-thread                                                Enable DFA jump threading
    \\    --enable-double-float-shrink                                            Enable unsafe double to float shrinking for math lib calls
    \\    --enable-dse-partial-overwrite-tracking                                 Enable partial-overwrite tracking in DSE
    \\    --enable-dse-partial-store-merging                                      Enable partial store merging in DSE
    \\    --enable-emscripten-cxx-exceptions                                      WebAssembly Emscripten-style exception handling
    \\    --enable-emscripten-sjlj                                                WebAssembly Emscripten-style setjmp/longjmp handling
    \\    --enable-epilogue-vectorization                                         Enable vectorization of epilogue loops.
    \\    --enable-ext-tsp-block-placement                                        Enable machine block placement based on the ext-tsp model, optimizing I-cache utilization.
    \\    --enable-falkor-hwpf-unroll-fix                                         
    \\    --enable-fixedwidth-autovec-in-streaming-mode                           
    \\    --enable-fs-discriminator                                               Enable adding flow sensitive discriminators
    \\    --enable-gen-insn                                                       Generate all instruction with TC
    \\    --enable-global-analyses                                                Enable inter-procedural analyses
    \\    --enable-global-merge                                                   Enable the global merge pass
    \\    --enable-gvn-hoist                                                      Enable the GVN hoisting pass (default = off)
    \\    --enable-gvn-memdep                                                     
    \\    --enable-gvn-sink                                                       Enable the GVN sinking pass (default = off)
    \\    --enable-heap-to-stack-conversion                                       
    \\    --enable-hexagon-br-prob                                                Enable branch probability info
    \\    --enable-hexagon-sdnode-sched                                           Enable Hexagon SDNode scheduling
    \\    --enable-hexagon-vector-print                                           Enable Hexagon Vector print instr pass
    \\    --enable-if-conversion                                                  Enable if-conversion during vectorization.
    \\    --enable-implicit-null-checks                                           Fold null checks into faulting memory operations
    \\    --enable-import-metadata                                                Enable import metadata like 'thinlto_src_module'
    \\    --enable-ind-var-reg-heur                                               Count the induction variable only once when interleaving
    \\    --enable-interleaved-mem-accesses                                       Enable vectorization on interleaved memory accesses in a loop
    \\    --enable-ipra                                                           Enable interprocedural register allocation to reduce load/store at procedure calls.
    \\    --enable-jmc-instrument                                                 Instrument functions with a call to __CheckForDebuggerJustMyCode
    \\    --enable-knowledge-retention                                            enable preservation of attributes throughout code transformation
    \\    --enable-legalize-types-checking                                        
    \\    --enable-linkonceodr-ir-outlining                                       Enable the IR outliner on linkonceodr functions
    \\    --enable-linkonceodr-outlining                                          Enable the machine outliner on linkonceodr functions
    \\    --enable-load-in-loop-pre                                               
    \\    --enable-load-pre                                                       
    \\    --enable-loadstore-runtime-interleave                                   Enable runtime interleaving until load/store ports are saturated
    \\    --enable-local-reassign                                                 Local reassignment can yield better allocation decisions, but may be compile time intensive
    \\    --enable-loop-distribute                                                Enable the new, experimental LoopDistribution Pass
    \\    --enable-loop-flatten                                                   Enable the LoopFlatten Pass
    \\    --enable-loop-simplifycfg-term-folding                                  
    \\    --enable-loopinterchange                                                Enable the experimental LoopInterchange Pass
    \\    --enable-lsr-phielim                                                    Enable LSR phi elimination
    \\    --enable-lto-internalization                                            Enable global value internalization in LTO
    \\    --enable-machine-outliner=<tag>                                         Enable the machine outliner
    \\    --enable-masked-interleaved-mem-accesses                                Enable vectorization on masked interleaved memory accesses in a loop
    \\    --enable-matrix                                                         Enable lowering of the matrix intrinsics
    \\    --enable-mem-access-versioning                                          Enable symbolic stride memory access versioning
    \\    --enable-mem-prof                                                       Enable memory profiler
    \\    --enable-memcpy-dag-opt                                                 Gang up loads and stores generated by inlining of memcpy
    \\    --enable-memcpyopt-without-libcalls                                     Enable memcpyopt even when libcalls are disabled
    \\    --enable-merge-functions                                                Enable function merging as part of the optimization pipeline
    \\    --enable-misched                                                        Enable the machine instruction scheduling pass.
    \\    --enable-ml-inliner=<tag>                                               Enable ML policy for inliner. Currently trained for -Oz only
    \\    --enable-module-inliner                                                 Enable module inliner
    \\    --enable-mve-interleave                                                 Enable interleave MVE vector operation lowering
    \\    --enable-name-compression                                               Enable name/filename string compression
    \\    --enable-newgvn                                                         Run the NewGVN pass
    \\    --enable-no-infs-fp-math                                                Enable FP math optimizations that assume no +-Infs
    \\    --enable-no-nans-fp-math                                                Enable FP math optimizations that assume no NaNs
    \\    --enable-no-rerun-simplification-pipeline                               Prevent running the simplification pipeline on a function more than once in the case that SCC mutations cause a function to be visited multiple times as long as the function has not been changed
    \\    --enable-no-signed-zeros-fp-math                                        Enable FP math optimizations that assume the sign of 0 is insignificant
    \\    --enable-no-trapping-fp-math                                            Enable setting the FP exceptions build attribute not to use exceptions
    \\    --enable-noalias-to-md-conversion                                       Convert noalias attributes to metadata during inlining.
    \\    --enable-nonnull-arg-prop                                               Try to propagate nonnull argument attributes from callsites to caller functions.
    \\    --enable-nontrivial-unswitch                                            Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
    \\    --enable-npm-O3-nontrivial-unswitch                                     Enable non-trivial loop unswitching for -O3
    \\    --enable-npm-pgo-inline-deferral                                        Enable inline deferral during PGO
    \\    --enable-npm-synthetic-counts                                           Run synthetic function entry count generation pass
    \\    --enable-objc-arc-opts                                                  enable/disable all ARC Optimizations
    \\    --enable-order-file-instrumentation                                     Enable order file instrumentation (default = off)
    \\    --enable-partial-inlining                                               Run Partial inlinining pass
    \\    --enable-patchpoint-liveness                                            Enable PatchPoint Liveness Analysis Pass
    \\    --enable-phi-of-ops                                                     
    \\    --enable-pipeliner                                                      Enable Software Pipelining
    \\    --enable-pipeliner-opt-size                                             Enable SWP at Os.
    \\    --enable-post-misched                                                   Enable the post-ra machine instruction scheduling pass.
    \\    --enable-post-pgo-loop-rotation                                         Run the loop rotation transformation after PGO instrumentation
    \\    --enable-ppc-branch-coalesce                                            enable coalescing of duplicate branches for PPC
    \\    --enable-ppc-extra-toc-reg-deps                                         Add extra TOC register dependencies
    \\    --enable-ppc-gen-scalar-mass                                            Enable lowering math functions to their corresponding MASS (scalar) entries
    \\    --enable-ppc-prefetching                                                enable software prefetching on PPC
    \\    --enable-pre                                                            
    \\    --enable-save-restore-long                                              Enable long calls for save-restore stubs.
    \\    --enable-scalable-autovec-in-streaming-mode                             
    \\    --enable-scc-inline-advisor-printing                                    
    \\    --enable-scoped-noalias                                                 
    \\    --enable-selectiondag-sp                                                
    \\    --enable-shrink-wrap                                                    enable the shrink-wrapping pass
    \\    --enable-sign-dependent-rounding-fp-math                                Force codegen to assume rounding mode can change dynamically
    \\    --enable-split-backedge-in-load-pre                                     
    \\    --enable-split-machine-functions                                        Split out cold blocks from machine functions based on profile information.
    \\    --enable-stackovf-sanitizer                                             Enable runtime checks for stack overflow.
    \\    --enable-store-refinement                                               
    \\    --enable-subreg-liveness                                                Enable subregister liveness tracking.
    \\    --enable-tail-merge                                                     
    \\    --enable-tbaa                                                           
    \\    --enable-tc-latency-sched                                               
    \\    --enable-timing-class-latency                                           Enable timing class latency
    \\    --enable-unroll-and-jam                                                 Enable Unroll And Jam Pass
    \\    --enable-unsafe-fp-math                                                 Enable optimizations that may decrease FP precision
    \\    --enable-unsafe-globalsmodref-alias-results                             
    \\    --enable-unswitch-cost-multiplier                                       Enable unswitch cost multiplier that prohibits exponential explosion in nontrivial unswitch.
    \\    --enable-vfe                                                            Enable virtual function elimination
    \\    --enable-vplan-native-path                                              Enable VPlan-native vectorization path with support for outer loop vectorization.
    \\    --enable-x86-scalar-amx                                                 X86: enable AMX scalarizition.
    \\    --epilogue-vectorization-force-VF=<integer>                             When epilogue vectorization is enabled, and a value greater than 1 is specified, forces the given VF for all applicable epilogue loops.
    \\    --epilogue-vectorization-minimum-VF=<integer>                           Only loops with vectorization factor equal to or larger than the specified value are considered for epilogue vectorization.
    \\    --exception-model=<tag>                                                 exception model
    \\    --exec-on-ir-change=<string>                                            exe called with module IR after each pass that changes it
    \\    --exhaustive-register-search                                            Exhaustive Search for registers bypassing the depth and interference cutoffs of last chance recoloring
    \\    --expand-all-fp-mlx                                                     
    \\    --expand-condsets-coa-limit=<integer>                                   Max number of segment coalescings
    \\    --expand-condsets-tfr-limit=<integer>                                   Max number of mux expansions
    \\    --expand-constant-exprs                                                 Expand constant expressions to instructions for testing purposes
    \\    --expand-div-rem-bits=<integer>                                         div and rem instructions on integers with more than <N> bits are expanded.
    \\    --expand-fp-convert-bits=<integer>                                      fp convert instructions on integers with more than <N> bits are expanded.
    \\    --expand-limit=<integer>                                                
    \\    --expandvp-override-evl-transform=<string>                              Options: <empty>|Legal|Discard|Convert. If non-empty, ignore TargetTransformInfo and always use this transformation for the %evl parameter (Used in testing).
    \\    --expandvp-override-mask-transform=<string>                             Options: <empty>|Legal|Discard|Convert. If non-empty, Ignore TargetTransformInfo and always use this transformation for the %mask parameter (Used in testing).
    \\    --experimental-debug-variable-locations                                 Use experimental new value-tracking variable locations
    \\    --expose-ppc-andi-glue-bug                                              expose the ANDI glue bug on PPC
    \\    --ext-tsp-apply-without-profile                                         Whether to apply ext-tsp placement for instances w/o profile
    \\    --extra-vectorizer-passes                                               Run cleanup optimization passes after vectorization
    \\    --extract-blocks-erase-funcs                                            Erase the existing functions
    \\    --extract-blocks-file=<string>                                          A file containing list of basic blocks to extract
    \\    --extract-cutoff=<integer>                                              Cutoff for generating "extract" instructions
    \\    --extract-needand                                                       Require & in extract patterns
    \\    --extract-nosr0                                                         No extract instruction with offset 0
    \\    --fast-cluster-threshold=<integer>                                      The threshold for fast cluster
    \\    --fast-isel                                                             Enable the "fast" instruction selector
    \\    --fast-isel-abort=<integer>                                             Enable abort calls when "fast" instruction selection fails to lower an instruction: 0 disable the abort, 1 will abort but for args, calls and terminators, 2 will also abort for argument lowering, and 3 will never fallback to SelectionDAG.
    \\    --fast-isel-report-on-fallback                                          Emit a diagnostic when "fast" instruction selection falls back to SelectionDAG.
    \\    --fatal-warnings                                                        Treat warnings as errors
    \\    --ffast-math                                                            Enable Fast Math processing
    \\    --filetype=<tag>                                                        Choose a file type (not all types are supported by all targets):
    \\    --filter-passes=<string>                                                Only consider IR changes for passes whose names match the specified value. No-op without -print-changed
    \\    --filter-print-funcs=<string>                                           Only print IR for functions whose name match this for all print-[before|after][-all] options
    \\    --fixup-allow-gcptr-in-csr                                              Allow passing GC Pointer arguments in callee saved registers
    \\    --fixup-byte-word-insts                                                 Change byte and word instructions to larger sizes
    \\    --fixup-max-csr-statepoints=<integer>                                   Max number of statepoints allowed to pass GC Ptrs in registers
    \\    --fixup-scs-enable-copy-propagation                                     Enable simple copy propagation during register reloading
    \\    --fixup-scs-extend-slot-size                                            Allow spill in spill slot of greater size than register size
    \\    --flat-loop-tripcount-threshold=<integer>                               If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
    \\    --flattened-profile-used                                                Indicate the sample profile being used is flattened, i.e., no inline hierachy exists in the profile
    \\    --float-abi=<tag>                                                       Choose float ABI type
    \\    --float2int-max-integer-bw=<integer>                                    Max integer bitwidth to consider in float2int(default=64)
    \\    --force-attribute=<string>                                              Add an attribute to a function. This should be a pair of 'function-name:attribute-name', for example -force-attribute=foo:noinline. This option can be specified multiple times.
    \\    --force-chr                                                             Apply CHR for all functions
    \\    --force-dwarf-frame-section                                             Always emit a debug frame section.
    \\    --force-fast-cluster                                                    Switch to fast cluster algorithm with the lost of some fusion opportunities
    \\    --force-function-specialization                                         Force function specialization for every call site with a constant argument
    \\    --force-fuse-matrix                                                     Force matrix instruction fusion even if not profitable.
    \\    --force-hardware-loop-guard                                             Force generation of loop guard intrinsic
    \\    --force-hardware-loop-phi                                               Force hardware loop counter to be updated through a phi
    \\    --force-hardware-loops                                                  Force hardware loops intrinsics to be inserted
    \\    --force-hvx-float                                                       Enable auto-vectorization of floatint point types on v68.
    \\    --force-import-all                                                      Import functions with noinline attribute
    \\    --force-instr-ref-livedebugvalues                                       Use instruction-ref based LiveDebugValues with normal DBG_VALUE inputs
    \\    --force-legal-indexing                                                  Force all indexed operations to be legal for the GlobalISel combiner
    \\    --force-loop-cold-block                                                 Force outlining cold blocks from loops.
    \\    --force-mips-long-branch                                                MIPS: Expand all branches to long format.
    \\    --force-nested-hardware-loop                                            Force allowance of nested hardware loops
    \\    --force-ordered-reductions                                              Enable the vectorisation of loops with in-order (strict) FP reductions
    \\    --force-pgso                                                            Force the (profiled-guided) size optimizations. 
    \\    --force-precise-rotation-cost                                           Force the use of precise cost loop rotation strategy.
    \\    --force-remove-attribute=<string>                                       Remove an attribute from a function. This should be a pair of 'function-name:attribute-name', for example -force-remove-attribute=foo:noinline. This option can be specified multiple times.
    \\    --force-split-store                                                     Force store splitting no matter what the target query says.
    \\    --force-streaming-compatible-sve                                        
    \\    --force-summary-edges-cold=<tag>                                        Force all edges in the function summary to cold
    \\    --force-target-instruction-cost=<integer>                               A flag that overrides the target's expected cost for an instruction to a single constant value. Mostly useful for getting consistent testing.
    \\    --force-target-max-scalar-interleave=<integer>                          A flag that overrides the target's max interleave factor for scalar loops.
    \\    --force-target-max-vector-interleave=<integer>                          A flag that overrides the target's max interleave factor for vectorized loops.
    \\    --force-target-num-scalar-regs=<integer>                                A flag that overrides the target's number of scalar registers.
    \\    --force-target-num-vector-regs=<integer>                                A flag that overrides the target's number of vector registers.
    \\    --force-target-supports-scalable-vectors                                Pretend that scalable vectors are supported, even if the target does not support them. This flag should only be used for testing.
    \\    --force-vector-interleave=<integer>                                     Sets the vectorization interleave count. Zero is autoselect.
    \\    --force-vector-width=<integer>                                          Sets the SIMD width. Zero is autoselect.
    \\    --force-widen-divrem-via-safe-divisor                                   Override cost based safe divisor widening for div/rem instructions
    \\    --forget-scev-loop-unroll                                               Forget everything in SCEV when doing LoopUnroll, instead of just the current top-most loop. This is sometimes preferred to reduce compile time.
    \\    --forward-switch-cond                                                   Forward switch condition to phi ops (default = false)
    \\    --fp-contract=<tag>                                                     Enable aggressive formation of fused FP ops
    \\    --frame-helper-size-threshold=<integer>                                 The minimum number of instructions that are outlined in a frame helper (default = 2)
    \\    --frame-pointer=<tag>                                                   Specify frame pointer elimination optimization
    \\    --freeze-loop-unswitch-cond                                             If enabled, the freeze instruction will be added to condition of loop unswitch to prevent miscompilation.
    \\    --fs-no-final-discrim                                                   Do not insert FS-AFDO discriminators before emit.
    \\    --fs-profile-debug-bw-threshold=<integer>                               Only show debug message if the source branch weight is greater  than this value.
    \\    --fs-profile-debug-prob-diff-threshold=<integer>                        Only show debug message if the branch probility is greater than this value (in percentage).
    \\    --fs-profile-file=<string>                                              Flow Sensitive profile file name.
    \\    --fs-remapping-file=<string>                                            Flow Sensitive profile remapping file name.
    \\    --fs-viewbfi-after                                                      View BFI after MIR loader
    \\    --fs-viewbfi-before                                                     View BFI before MIR loader
    \\    --func-specialization-avg-iters-cost=<integer>                          Average loop iteration count cost
    \\    --func-specialization-max-clones=<integer>                              The maximum number of clones allowed for a single function specialization
    \\    --func-specialization-max-iters=<integer>                               The maximum number of iterations function specialization is run
    \\    --func-specialization-on-address                                        Enable function specialization on the address of global values
    \\    --func-specialization-size-threshold=<integer>                          Don't specialize functions that have less than this theshold number of instructions
    \\    --function-sections                                                     Emit functions into separate sections
    \\    --function-specialization-for-literal-constant                          Enable specialization of functions that take a literal constant as an argument.
    \\    --fuse-matrix                                                           Enable/disable fusing matrix instructions.
    \\    --fuse-matrix-tile-size=<integer>                                       Tile size for matrix instruction fusion using square-shaped tiles.
    \\    --fuse-matrix-use-loops                                                 Generate loop nest for tiling.
    \\    --gcov-atomic-counter                                                   Make counter updates atomic
    \\    --generate-arange-section                                               Generate dwarf aranges
    \\    --generate-merged-base-profiles                                         When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.
    \\    --generate-type-units                                                   Generate DWARF4 type units.
    \\    --global-isel                                                           Enable the "global" instruction selector
    \\    --global-isel-abort=<tag>                                               Enable abort calls when "global" instruction selection fails to lower/select an instruction
    \\    --global-merge-group-by-use                                             Improve global merge pass to look at uses
    \\    --global-merge-ignore-single-use                                        Improve global merge pass to ignore globals only used alone
    \\    --global-merge-max-offset=<integer>                                     Set maximum offset for global merge pass
    \\    --global-merge-on-const                                                 Enable global merge pass on constants
    \\    --global-merge-on-external                                              Enable global merge pass on external linkage
    \\    --gpsize=<integer>                                                      Global Pointer Addressing Size.  The default size is 8.
    \\    --greedy-regclass-priority-trumps-globalness                            Change the greedy register allocator's live range priority calculation to make the AllocationPriority of the register class more important then whether the range is global
    \\    --greedy-reverse-local-assignment                                       Reverse allocation order of local live ranges, such that shorter local live ranges will tend to be allocated first
    \\    --grow-region-complexity-budget=<integer>                               growRegion() does not scale with the number of BB edges, so limit its budget and bail out once we reach the limit.
    \\    --guard-widening-widen-branch-guards                                    Whether or not we should widen guards  expressed as branches by widenable conditions
    \\    --guards-predicate-pass-branch-weight=<integer>                         The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
    \\    --gvn-add-phi-translation                                               Enable phi-translation of add instructions
    \\    --gvn-hoist-max-bbs=<integer>                                           Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
    \\    --gvn-hoist-max-chain-length=<integer>                                  Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
    \\    --gvn-hoist-max-depth=<integer>                                         Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
    \\    --gvn-max-block-speculations=<integer>                                  Max number of blocks we're willing to speculate on (and recurse into) when deducing if a value is fully available or not in GVN (default = 600)
    \\    --gvn-max-hoisted=<integer>                                             Max number of instructions to hoist (default unlimited = -1)
    \\    --gvn-max-num-deps=<integer>                                            Max number of dependences to attempt Load PRE (default = 100)
    \\    --gvn-max-num-visited-insts=<integer>                                   Max number of visited instructions when trying to find dominating value of select dependency (default = 100)
    \\    --hardware-loop-counter-bitwidth=<integer>                              Set the loop counter bitwidth
    \\    --hardware-loop-decrement=<integer>                                     Set the loop decrement value
    \\    --hash-based-counter-split                                              Rename counter variable of a comdat function based on cfg hash
    \\    --help                                                                  Display available options (--help-hidden for more)
    \\    --help-hidden                                                           Display all available options
    \\    --help-list                                                             Display list of available options (--help-list-hidden for more)
    \\    --help-list-hidden                                                      Display list of all available options
    \\    --hexagon-align-loads                                                   Rewrite unaligned loads as a pair of aligned loads
    \\    --hexagon-amode-growth-limit=<integer>                                  Code growth limit for address mode optimization
    \\    --hexagon-autohvx                                                       Enable loop vectorizer for HVX
    \\    --hexagon-bit                                                           Bit simplification
    \\    --hexagon-cext                                                          Enable Hexagon constant-extender optimization
    \\    --hexagon-cext-limit=<integer>                                          Maximum number of replacements
    \\    --hexagon-cext-threshold=<integer>                                      Minimum number of extenders to trigger replacement
    \\    --hexagon-check-bank-conflict                                           Enable checking for cache bank conflicts
    \\    --hexagon-commgep                                                       Enable commoning of GEP instructions
    \\    --hexagon-disable-args-min-alignment                                    Disable minimum alignment of 1 for arguments passed by value on stack
    \\    --hexagon-eif                                                           Enable early if-conversion
    \\    --hexagon-emit-jt-text                                                  Emit hexagon jump tables in function section
    \\    --hexagon-emit-jump-tables                                              Control jump table emission on Hexagon target
    \\    --hexagon-emit-lookup-tables                                            Control lookup table emission on Hexagon target
    \\    --hexagon-emit-lut-text                                                 Emit hexagon lookup tables in function section
    \\    --hexagon-enable-branch-prediction                                      Enable branch prediction
    \\    --hexagon-expand-condsets                                               Early expansion of MUX
    \\    --hexagon-extract                                                       Generate "extract" instructions
    \\    --hexagon-fp-elim                                                       Refrain from using FP whenever possible
    \\    --hexagon-frame-index-reuse-limit=<integer>                             Limit on the number of reused registers in frame index elimination
    \\    --hexagon-frame-index-search-range=<integer>                            Limit on instruction search range in frame index elimination
    \\    --hexagon-gen-mux-threshold=<integer>                                   Minimum distance between predicate definition and farther of the two predicated uses
    \\    --hexagon-gen-pred                                                      Enable conversion of arithmetic operations to predicate instructions
    \\    --hexagon-hvx-widen=<integer>                                           Lower threshold (in bytes) for widening to HVX vectors
    \\    --hexagon-hwloop-preheader                                              Add a preheader to a hardware loop if one doesn't exist
    \\    --hexagon-initial-cfg-cleanup                                           Simplify the CFG after atomic expansion pass
    \\    --hexagon-insert                                                        Generate "insert" instructions
    \\    --hexagon-instsimplify                                                  Enable instsimplify
    \\    --hexagon-isel-su                                                       Enable checking of SDNode's single-use status
    \\    --hexagon-long-calls                                                    If present, forces/disables the use of long calls
    \\    --hexagon-loop-prefetch                                                 Enable loop data prefetch on Hexagon
    \\    --hexagon-loop-range=<integer>                                          Restrict range of loopN instructions (testing only)
    \\    --hexagon-loop-resched                                                  Loop rescheduling
    \\    --hexagon-masked-vmem                                                   Enable masked loads/stores for HVX
    \\    --hexagon-mux                                                           Enable converting conditional transfers into MUX instructions
    \\    --hexagon-noopt                                                         Disable backend optimizations
    \\    --hexagon-opt-spill                                                     Optimize spill slots
    \\    --hexagon-opt-vextract                                                  Enable vextract optimization
    \\    --hexagon-packetize-volatiles                                           Allow non-solo packetization of volatile memory references
    \\    --hexagon-pred-calls                                                    Consider calls to be predicable
    \\    --hexagon-sched-inline-asm                                              Do not consider inline-asm a scheduling/packetization boundary.
    \\    --hexagon-shrink-frame                                                  Enable stack frame shrink wrapping
    \\    --hexagon-small-data-threshold=<integer>                                The maximum size of an object in the sdata section
    \\    --hexagon-statics-in-small-data                                         Allow static variables in .sdata
    \\    --hexagon-subreg-liveness                                               Enable subregister liveness tracking for Hexagon
    \\    --hexagon-vector-combine                                                Enable HVX vector combining
    \\    --hexagon-vextract-threshold=<integer>                                  Threshold for triggering vextract replacement
    \\    --hexagon-vlcr-iteration-lim=<integer>                                  Maximum distance of loop carried dependences that are handled
    \\    --hexbit-bitsplit                                                       Generate bitsplit instructions
    \\    --hexbit-extract                                                        Generate extract instructions
    \\    --hexbit-keep-tied                                                      Preserve subregisters in tied operands
    \\    --hexbit-max-bitsplit=<integer>                                         
    \\    --hexbit-max-extract=<integer>                                          
    \\    --hexbit-registerset-limit=<integer>                                    
    \\    --hints-allow-reordering                                                Allow enabling loop hints to reorder FP operations during vectorization.
    \\    --hlir-simplify-limit=<integer>                                         Maximum number of simplification steps in HLIR
    \\    --hoist-cheap-insts                                                     MachineLICM should hoist even cheap instructions
    \\    --hoist-common-insts                                                    hoist common instructions (default = false)
    \\    --hoist-const-stores                                                    Hoist invariant stores
    \\    --homogeneous-prolog-epilog                                             Emit homogeneous prologue and epilogue for the size optimization (default = off)
    \\    --hot-callsite-rel-freq=<integer>                                       Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
    \\    --hot-callsite-threshold=<integer>                                      Threshold for hot callsites 
    \\    --hot-cold-split                                                        Enable hot-cold splitting pass
    \\    --hot-cold-static-analysis                                              
    \\    --hotcoldsplit-cold-section-name=<string>                               Name for the section containing cold functions extracted by hot-cold splitting.
    \\    --hotcoldsplit-max-params=<integer>                                     Maximum number of parameters for a split function
    \\    --hotcoldsplit-threshold=<integer>                                      Base penalty for splitting cold code (as a multiple of TCC_Basic)
    \\    --hsdr-no-mem                                                           Do not split loads or stores
    \\    --hsdr-split-all                                                        Split all partitions
    \\    --huge-size-for-split=<integer>                                         A threshold of live range size which may cause high compile time cost in global splitting.
    \\    --hwasan-experimental-use-page-aliases                                  Use page aliasing in HWASan
    \\    --hwasan-generate-tags-with-calls                                       generate new tags with runtime library calls
    \\    --hwasan-globals                                                        Instrument globals
    \\    --hwasan-inline-all-checks                                              inline all checks
    \\    --hwasan-instrument-atomics                                             instrument atomic instructions (rmw, cmpxchg)
    \\    --hwasan-instrument-byval                                               instrument byval arguments
    \\    --hwasan-instrument-landing-pads                                        instrument landing pads
    \\    --hwasan-instrument-mem-intrinsics                                      instrument memory intrinsics
    \\    --hwasan-instrument-personality-functions                               instrument personality functions
    \\    --hwasan-instrument-reads                                               instrument read instructions
    \\    --hwasan-instrument-stack                                               instrument stack (allocas)
    \\    --hwasan-instrument-with-calls                                          instrument reads and writes with callbacks
    \\    --hwasan-instrument-writes                                              instrument write instructions
    \\    --hwasan-kernel                                                         Enable KernelHWAddressSanitizer instrumentation
    \\    --hwasan-kernel-mem-intrinsic-prefix                                    Use prefix for memory intrinsics in KASAN mode
    \\    --hwasan-mapping-offset=<integer>                                       HWASan shadow mapping offset [EXPERIMENTAL]
    \\    --hwasan-match-all-tag=<integer>                                        don't report bad accesses via pointers with this tag
    \\    --hwasan-memory-access-callback-prefix=<string>                         Prefix for memory access callbacks
    \\    --hwasan-record-stack-history=<tag>                                     Record stack frames with tagged allocations in a thread-local ring buffer
    \\    --hwasan-recover                                                        Enable recovery mode (continue-after-error).
    \\    --hwasan-uar-retag-to-zero                                              Clear alloca tags before returning from the function to allow non-instrumented and instrumented function calls mix. When set to false, allocas are retagged before returning from the function to detect use after return.
    \\    --hwasan-use-after-scope                                                detect use after scope within function
    \\    --hwasan-use-short-granules                                             use short granules in allocas and outlined checks
    \\    --hwasan-use-stack-safety                                               Use Stack Safety analysis results
    \\    --hwasan-with-ifunc                                                     Access dynamic shadow through an ifunc global on platforms that support this
    \\    --hwasan-with-tls                                                       Access dynamic shadow through an thread-local pointer on platforms that support this
    \\    --hwloop-spec-preheader                                                 Allow speculation of preheader instructions
    \\    --icp-call-only                                                         Run indirect-call promotion for call instructions only
    \\    --icp-csskip=<integer>                                                  Skip Callsite up to this number for this compilation
    \\    --icp-cutoff=<integer>                                                  Max number of promotions for this compilation
    \\    --icp-dumpafter                                                         Dump IR after transformation happens
    \\    --icp-invoke-only                                                       Run indirect-call promotion for invoke instruction only
    \\    --icp-lto                                                               Run indirect-call promotion in LTO mode
    \\    --icp-max-annotations=<integer>                                         Max number of annotations for a single indirect call callsite
    \\    --icp-max-prom=<integer>                                                Max number of promotions for a single indirect call callsite
    \\    --icp-remaining-percent-threshold=<integer>                             The percentage threshold against remaining unpromoted indirect call count for the promotion
    \\    --icp-samplepgo                                                         Run indirect-call promotion in SamplePGO mode
    \\    --icp-total-percent-threshold=<integer>                                 The percentage threshold against total count for the promotion
    \\    --ifcvt-branch-fold                                                     
    \\    --ifcvt-fn-start=<integer>                                              
    \\    --ifcvt-fn-stop=<integer>                                               
    \\    --ifcvt-limit=<integer>                                                 
    \\    --ignore-bb-reg-pressure                                                
    \\    --ignore-tti-inline-compatible                                          Ignore TTI attributes compatibility check between callee/caller during inline cost calculation
    \\    --ignore-xcoff-visibility                                               Not emit the visibility attribute for asm in AIX OS or give all symbols 'unspecified' visibility in XCOFF object file
    \\    --imp-null-check-page-size=<integer>                                    The page size of the target in bytes
    \\    --imp-null-max-insts-to-consider=<integer>                              The max number of instructions to consider hoisting loads over (the algorithm is quadratic over this number)
    \\    --import-all-index                                                      Import all external functions in index.
    \\    --import-cold-multiplier=<integer>                                      Multiply the `import-instr-limit` threshold for cold callsites
    \\    --import-constants-with-refs                                            Import constant global variables with references
    \\    --import-critical-multiplier=<integer>                                  Multiply the `import-instr-limit` threshold for critical callsites
    \\    --import-cutoff=<integer>                                               Only import first N functions if N>=0 (default -1)
    \\    --import-full-type-definitions                                          Import full type definitions for ThinLTO.
    \\    --import-hot-evolution-factor=<integer>                                 As we import functions called from hot callsite, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions
    \\    --import-hot-multiplier=<integer>                                       Multiply the `import-instr-limit` threshold for hot callsites
    \\    --import-instr-evolution-factor=<integer>                               As we import functions, multiply the `import-instr-limit` threshold by this factor before processing newly imported functions
    \\    --import-instr-limit=<integer>                                          Only import functions with less than N instructions
    \\    --incremental-linker-compatible                                         When used with filetype=obj, emit an object file which can be used with an incremental linker
    \\    --indvars-post-increment-ranges                                         Use post increment control-dependent ranges in IndVarSimplify
    \\    --indvars-predicate-loops                                               Predicate conditions in read only loops
    \\    --indvars-widen-indvars                                                 Allow widening of indvars to eliminate s/zext
    \\    --info-output-file=<string>                                             File to append -stats and -timer output to
    \\    --initial-synthetic-count=<integer>                                     Initial value of synthetic entry count
    \\    --inline-call-penalty=<integer>                                         Call penalty that is applied per callsite when inlining
    \\    --inline-caller-superset-nobuiltin                                      Allow inlining when caller has a superset of callee's nobuiltin attributes.
    \\    --inline-cold-callsite-threshold=<integer>                              Threshold for inlining cold callsites
    \\    --inline-cost-full                                                      Compute the full inline cost of a call site even when the cost exceeds the threshold.
    \\    --inline-deferral                                                       Enable deferred inlining
    \\    --inline-deferral-scale=<integer>                                       Scale to limit the cost of inline deferral
    \\    --inline-enable-cost-benefit-analysis                                   Enable the cost-benefit analysis for the inliner
    \\    --inline-instr-cost=<integer>                                           Cost of a single instruction when inlining
    \\    --inline-max-stacksize=<integer>                                        Do not inline functions with a stack size that exceeds the specified limit
    \\    --inline-memaccess-cost=<integer>                                       Cost of load/store instruction when inlining
    \\    --inline-priority-mode=<tag>                                            Choose the priority mode to use in module inline
    \\    --inline-remark-attribute                                               Enable adding inline-remark attribute to callsites processed by inliner but decided to be not inlined
    \\    --inline-savings-multiplier=<integer>                                   Multiplier to multiply cycle savings by during inlining
    \\    --inline-size-allowance=<integer>                                       The maximum size of a callee that get's inlined without sufficient cycle savings
    \\    --inline-synthetic-count=<integer>                                      Initial synthetic entry count for inline functions.
    \\    --inline-threshold=<integer>                                            Control the amount of inlining to perform (default = 225)
    \\    --inlinecold-threshold=<integer>                                        Threshold for inlining functions with cold attribute
    \\    --inlinedefault-threshold=<integer>                                     Default amount of inlining to perform
    \\    --inlinehint-threshold=<integer>                                        Threshold for inlining functions with inline hint
    \\    --inliner-function-import-stats=<tag>                                   Enable inliner stats for imported functions
    \\    --insert-all0                                                           
    \\    --insert-const                                                          
    \\    --insert-dist-cutoff=<integer>                                          Vreg distance cutoff for insert generation.
    \\    --insert-has0                                                           
    \\    --insert-max-ifmap=<integer>                                            Maximum size of IFMap
    \\    --insert-max-orl=<integer>                                              Maximum size of OrderedRegisterList
    \\    --insert-timing                                                         Enable timing of insert generation
    \\    --insert-timing-detail                                                  Enable detailed timing of insert generation
    \\    --insert-vreg-cutoff=<integer>                                          Vreg# cutoff for insert generation.
    \\    --instcombine-code-sinking                                              Enable code sinking
    \\    --instcombine-guard-widening-window=<integer>                           How wide an instruction window to bypass looking for another guard
    \\    --instcombine-infinite-loop-threshold=<integer>                         Number of instruction combining iterations considered an infinite loop
    \\    --instcombine-lower-dbg-declare=<integer>                               
    \\    --instcombine-max-copied-from-constant-users=<integer>                  Maximum users to visit in copy from constant transform
    \\    --instcombine-max-iterations=<integer>                                  Limit the maximum number of instruction combining iterations
    \\    --instcombine-max-num-phis=<integer>                                    Maximum number phis to handle in intptr/ptrint folding
    \\    --instcombine-max-sink-users=<integer>                                  Maximum number of undroppable users for instruction sinking
    \\    --instcombine-maxarray-size=<integer>                                   Maximum array size considered when doing a combine
    \\    --instcombine-negator-enabled                                           Should we attempt to sink negations?
    \\    --instcombine-negator-max-depth=<integer>                               What is the maximal lookup depth when trying to check for viability of negation sinking.
    \\    --instrprof-atomic-counter-update-all                                   Make all profile counter updates atomic (for testing only)
    \\    --interleave-loops                                                      Enable loop interleaving in Loop vectorization passes
    \\    --interleave-small-loop-scalar-reduction                                Enable interleaving for loops with small iteration counts that contain scalar reductions to expose ILP.
    \\    --internalize-public-api-file=<string>                                  A file containing list of symbol names to preserve
    \\    --internalize-public-api-list                                           A list of symbol names to preserve
    \\    --interpreter-print-volatile                                            make the interpreter print every volatile load and store
    \\    --intra-scc-cost-multiplier=<integer>                                   Cost multiplier to multiply onto inlined call sites where the new call was previously an intra-SCC call (not relevant when the original call was already intra-SCC). This can accumulate over multiple inlinings (e.g. if a call site already had a cost multiplier and one of its inlined calls was also subject to this, the inlined call would have the original multiplier multiplied by intra-scc-cost-multiplier). This is to prevent tons of inlining through a child SCC which can cause terrible compile times
    \\    --ir-outliner                                                           Enable ir outliner pass
    \\    --irce-allow-narrow-latch                                               If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.
    \\    --irce-allow-unsigned-latch                                             
    \\    --irce-loop-size-cutoff=<integer>                                       
    \\    --irce-min-runtime-iterations=<integer>                                 
    \\    --irce-print-changed-loops                                              
    \\    --irce-print-range-checks                                               
    \\    --irce-skip-profitability-checks                                        
    \\    --isel-rebalance-addr                                                   Rebalance address calculation trees to improve instruction selection
    \\    --iterative-bfi-max-iterations-per-block=<integer>                      Iterative inference: maximum number of update iterations per block
    \\    --iterative-bfi-precision=<integer>                                     Iterative inference: delta convergence precision; smaller values typically lead to better results at the cost of worsen runtime
    \\    --iterative-counter-promotion                                           Allow counter promotion across the whole loop nest.
    \\    --join-globalcopies                                                     Coalesce copies that span blocks (default=subtarget)
    \\    --join-liveintervals                                                    Coalesce copies (default=true)
    \\    --join-splitedges                                                       Coalesce copies on split edges (default=subtarget)
    \\    --jump-inst-cost=<integer>                                              Cost of jump instructions.
    \\    --jump-is-expensive                                                     Do not create extra branches to split comparison logic.
    \\    --jump-table-density=<integer>                                          Minimum density for building a jump table in a normal function
    \\    --jump-threading-across-loop-headers                                    Allow JumpThreading to thread across loop headers, for testing
    \\    --jump-threading-implication-search-threshold=<integer>                 The number of predecessors to search for a stronger condition to use to thread over a weaker condition
    \\    --jump-threading-phi-threshold=<integer>                                Max PHIs in BB to duplicate for jump threading
    \\    --jump-threading-threshold=<integer>                                    Max block size to duplicate for jump threading
    \\    --keep-inline-advisor-for-printing                                      
    \\    --keep-loops                                                            Preserve canonical loop structure (default = true)
    \\    --lanai-constant-mul-threshold=<integer>                                Maximum number of instruction to generate when lowering constant multiplication instead of calling library function [default=14]
    \\    --lanai-nop-delay-filler                                                Fill Lanai delay slots with NOPs.
    \\    --lanai-ssection-threshold=<integer>                                    Small data and bss section threshold size (default=0)
    \\    --large-interval-freq-threshold=<integer>                               For a large interval, if it is coalesed with other live intervals many times more than the threshold, stop its coalescing to control the compile time. 
    \\    --large-interval-size-threshold=<integer>                               If the valnos size of an interval is larger than the threshold, it is regarded as a large interval. 
    \\    --late-remat-update-threshold=<integer>                                 During rematerialization for a copy, if the def instruction has many other copy uses to be rematerialized, delay the multiple separate live interval update work and do them all at once after all those rematerialization are done. It will save a lot of repeated work. 
    \\    --lcr-max-depth=<integer>                                               Last chance recoloring max depth
    \\    --lcr-max-interf=<integer>                                              Last chance recoloring maximum number of considered interference at a time
    \\    --ldstmemcpy-glue-max=<integer>                                         Number limit for gluing ld/st of memcpy.
    \\    --licm-control-flow-hoisting                                            Enable control flow (and PHI) hoisting in LICM
    \\    --licm-force-thread-model-single                                        Force thread model single in LICM pass
    \\    --licm-max-num-uses-traversed=<integer>                                 Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
    \\    --licm-mssa-max-acc-promotion=<integer>                                 [LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in LICM is enabled, then this is the maximum number of accesses allowed to be present in a loop in order to enable memory promotion.
    \\    --licm-mssa-optimization-cap=<integer>                                  Enable imprecision in LICM in pathological cases, in exchange for faster compile. Caps the MemorySSA clobbering calls.
    \\    --licm-versioning-invariant-threshold=<integer>                         LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
    \\    --licm-versioning-max-depth-threshold=<integer>                         LoopVersioningLICM's threshold for maximum allowed loop nest/depth
    \\    --likely-branch-weight=<integer>                                        Weight of the branch likely to be taken (default = 2000)
    \\    --limit-float-precision=<integer>                                       Generate low-precision inline sequences for some float libcalls
    \\    --live-debug-variables                                                  Enable the live debug variables pass
    \\    --livedebugvalues-input-bb-limit=<integer>                              Maximum input basic blocks before DBG_VALUE limit applies
    \\    --livedebugvalues-input-dbg-value-limit=<integer>                       Maximum input DBG_VALUE insts supported by debug range extension
    \\    --livedebugvalues-max-stack-slots=<integer>                             livedebugvalues-stack-ws-limit
    \\    --load=<string>                                                         Load the specified plugin
    \\    --locally-hot-callsite-threshold=<integer>                              Threshold for locally hot callsites 
    \\    --loongarch-check-zero-division                                         Trap on integer division by zero.
    \\    --loongarch-numeric-reg                                                 Print numeric register names rather than the ABI names (such as $r0 instead of $zero)
    \\    --loop-deletion-enable-symbolic-execution                               Break backedge through symbolic execution of 1st iteration attempting to prove that the backedge is never taken
    \\    --loop-distribute-non-if-convertible                                    Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
    \\    --loop-distribute-scev-check-threshold=<integer>                        The maximum number of SCEV checks allowed for Loop Distribution
    \\    --loop-distribute-scev-check-threshold-with-pragma=<integer>            The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
    \\    --loop-distribute-verify                                                Turn on DominatorTree and LoopInfo verification after Loop Distribution
    \\    --loop-flatten-assume-no-overflow                                       Assume that the product of the two iteration trip counts will never overflow
    \\    --loop-flatten-cost-threshold=<integer>                                 Limit on the cost of instructions that can be repeated due to loop flattening
    \\    --loop-flatten-widen-iv                                                 Widen the loop induction variables, if possible, so overflow checks won't reject flattening
    \\    --loop-fusion-dependence-analysis=<tag>                                 Which dependence analysis should loop fusion use?
    \\    --loop-fusion-peel-max-count=<integer>                                  Max number of iterations to be peeled from a loop, such that fusion can take place
    \\    --loop-interchange-threshold=<integer>                                  Interchange if you gain more than this number
    \\    --loop-load-elimination-scev-check-threshold=<integer>                  The maximum number of SCEV checks allowed for Loop Load Elimination
    \\    --loop-predication-enable-count-down-loop                               
    \\    --loop-predication-enable-iv-truncation                                 
    \\    --loop-predication-insert-assumes-of-predicated-guards-conditions       Whether or not we should insert assumes of conditions of predicated guards
    \\    --loop-predication-latch-probability-scale=<integer>                    scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
    \\    --loop-predication-predicate-widenable-branches-to-deopt                Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks
    \\    --loop-predication-skip-profitability-checks                            
    \\    --loop-prefetch-writes                                                  Prefetch write addresses
    \\    --loop-rotate-multi                                                     Allow loop rotation multiple times in order to reach a better latch exit
    \\    --loop-to-cold-block-ratio=<integer>                                    Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) is greater than this ratio
    \\    --loop-vectorize-with-block-frequency                                   Enable the use of the block frequency analysis to access PGO heuristics minimizing code growth in cold regions and being more aggressive in hot regions.
    \\    --loop-version-annotate-no-alias                                        Add no-alias annotation for instructions that are disambiguated by memchecks
    \\    --lower-global-dtors-via-cxa-atexit                                     Lower llvm.global_dtors (global destructors) via __cxa_atexit
    \\    --lower-interleaved-accesses                                            Enable lowering interleaved accesses to intrinsics
    \\    --lowertypetests-avoid-reuse                                            Try to avoid reuse of byte array addresses using aliases
    \\    --lowertypetests-drop-type-tests                                        Simply drop type test assume sequences
    \\    --lowertypetests-read-summary=<string>                                  Read summary from given YAML file before running pass
    \\    --lowertypetests-summary-action=<tag>                                   What to do with the summary when running this pass
    \\    --lowertypetests-write-summary=<string>                                 Write summary to given YAML file after running pass
    \\    --lsr-complexity-limit=<integer>                                        LSR search space complexity limit
    \\    --lsr-drop-solution                                                     Attempt to drop solution if it is less profitable
    \\    --lsr-exp-narrow                                                        Narrow LSR complex solution using expectation of registers number
    \\    --lsr-filter-same-scaled-reg                                            Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
    \\    --lsr-insns-cost                                                        Add instruction count to a LSR cost model
    \\    --lsr-preferred-addressing-mode=<tag>                                   A flag that overrides the target's preferred addressing mode.
    \\    --lsr-setupcost-depth-limit=<integer>                                   The limit on recursion depth for LSRs setup cost
    \\    --lsr-term-fold                                                         Attempt to replace primary IV with other IV.
    \\    --lto-aix-system-assembler=<string>                                     Path to a system assembler, picked up on AIX only
    \\    --lto-discard-value-names                                               Strip names from Value during LTO (other than GlobalValue).
    \\    --lto-embed-bitcode=<tag>                                               Embed LLVM bitcode in object files produced by LTO
    \\    --lto-pass-remarks-filter=<string>                                      Only record optimization remarks from passes whose names match the given regular expression
    \\    --lto-pass-remarks-format=<string>                                      The format used for serializing remarks (default: YAML)
    \\    --lto-pass-remarks-hotness-threshold                                    Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary.
    \\    --lto-pass-remarks-output=<string>                                      Output filename for pass remarks
    \\    --lto-pass-remarks-with-hotness                                         With PGO, include profile count in optimization remarks
    \\    --lto-stats-file=<string>                                               Save statistics to the specified file
    \\    --machine-combiner-dump-subst-intrs                                     Dump all substituted intrs
    \\    --machine-combiner-inc-threshold=<integer>                              Incremental depth computation will be used for basic blocks with more instructions.
    \\    --machine-combiner-verify-pattern-order                                 Verify that the generated patterns are ordered by increasing latency
    \\    --machine-outliner-reruns=<integer>                                     Number of times to rerun the outliner after the initial outline
    \\    --machine-sink-bfi                                                      Use block frequency info to find successors to sink
    \\    --machine-sink-cycle-limit=<integer>                                    The maximum number of instructions considered for cycle sinking.
    \\    --machine-sink-load-blocks-threshold=<integer>                          Do not try to find alias store for a load if the block number in the straight line is higher than this threshold.
    \\    --machine-sink-load-instrs-threshold=<integer>                          Do not try to find alias store for a load if there is a in-path block whose instruction number is higher than this threshold.
    \\    --machine-sink-split                                                    Split critical edges during machine sinking
    \\    --machine-sink-split-probability-threshold=<integer>                    Percentage threshold for splitting single-instruction critical edge. If the branch threshold is higher than this threshold, we allow speculative execution of up to 1 instruction to avoid branching to splitted critical edge
    \\    --mandatory-inlining-first                                              Perform mandatory inlinings module-wide, before performing inlining
    \\    --march=<string>                                                        Architecture to generate code for (see --version)
    \\    --mark-data-regions                                                     Mark code section jump table data regions.
    \\    --matrix-allow-contract                                                 Allow the use of FMAs if available and profitable. This may result in different results, due to less rounding error.
    \\    --matrix-default-layout=<tag>                                           Sets the default matrix layout
    \\    --matrix-print-after-transpose-opt                                      
    \\    --max-booleans-in-control-flow-hub=<integer>                            Set the maximum number of outgoing blocks for using a boolean value to record the exiting block in CreateControlFlowHub.
    \\    --max-bytes-for-alignment=<integer>                                     Forces the maximum bytes allowed to be emitted when padding for alignment
    \\    --max-counter-promotions=<integer>                                      Max number of allowed counter promotions
    \\    --max-counter-promotions-per-loop=<integer>                             Max number counter promotions per loop to avoid increasing register pressure too much
    \\    --max-deopt-or-unreachable-succ-check-depth=<integer>                   Set the maximum path length when checking whether a basic block is followed by a block that either has a terminating deoptimizing call or is terminated with an unreachable
    \\    --max-dependences=<integer>                                             Maximum number of dependences collected by loop-access analysis (default = 100)
    \\    --max-forked-scev-depth=<integer>                                       Maximum recursion depth when finding forked SCEVs (default = 5)
    \\    --max-heap-to-stack-size=<integer>                                      
    \\    --max-hsdr=<integer>                                                    Maximum number of split partitions
    \\    --max-inst-checked-for-throw-during-inlining=<integer>                  the maximum number of instructions analyzed for may throw during attribute inference in inlined body
    \\    --max-interleave-group-factor=<integer>                                 Maximum factor for an interleaved access group (default = 8)
    \\    --max-jump-table-size=<integer>                                         Set maximum size of jump tables.
    \\    --max-loads-per-memcmp=<integer>                                        Set maximum number of loads used in expanded memcmp
    \\    --max-loads-per-memcmp-opt-size=<integer>                               Set maximum number of loads used in expanded memcmp for -Os/Oz
    \\    --max-nested-scalar-reduction-interleave=<integer>                      The maximum interleave count to use when interleaving a scalar reduction in a nested loop.
    \\    --max-num-inline-blocks=<integer>                                       Max number of blocks to be partially inlined
    \\    --max-num-inst-between-tfr-and-nv-store=<integer>                       Maximum distance between a tfr feeding a store we consider the store still to be newifiable
    \\    --max-partial-inlining=<integer>                                        Max number of partial inlining. The default is unlimited
    \\    --max-prefetch-iters-ahead=<integer>                                    Max number of iterations to prefetch ahead
    \\    --max-registers-for-gc-values=<integer>                                 Max number of VRegs allowed to pass GC pointer meta args in
    \\    --max-sched-reorder=<integer>                                           Number of instructions to allow ahead of the critical path in sched=list-ilp
    \\    --max-speculation-depth=<integer>                                       Limit maximum recursion depth when calculating costs of speculatively executed instructions
    \\    --max-store-memcpy=<integer>                                            Max #stores to inline memcpy
    \\    --max-store-memcpy-Os=<integer>                                         Max #stores to inline memcpy
    \\    --max-store-memmove=<integer>                                           Max #stores to inline memmove
    \\    --max-store-memmove-Os=<integer>                                        Max #stores to inline memmove
    \\    --max-store-memset=<integer>                                            Max #stores to inline memset
    \\    --max-store-memset-Os=<integer>                                         Max #stores to inline memset
    \\    --max-switch-cases-per-result=<integer>                                 Limit cases to analyze when converting a switch to select
    \\    --max-uses-for-sinking=<integer>                                        Do not sink instructions that have too many uses.
    \\    --mc-relax-all                                                          When used with filetype=obj, relax all fixups in the emitted object file
    \\    --mcabac                                                                tbd
    \\    --mcfg-dot-filename-prefix=<string>                                     The prefix used for the Machine CFG dot file names.
    \\    --mcfg-func-name=<string>                                               The name of a function (or its substring) whose CFG is viewed/printed.
    \\    --mcp-use-is-copy-instr                                                 
    \\    --mcpu=<string>                                                         Target a specific cpu type (-mcpu=help for details)
    \\    --meabi=<tag>                                                           Set EABI type (default depends on triple):
    \\    --mem-loc-frag-fill                                                     
    \\    --membedded-data                                                        MIPS: Try to allocate variables in the following sections if possible: .rodata, .sdata, .data .
    \\    --memcmp-num-loads-per-block=<integer>                                  The number of loads per basic block for inline expansion of memcmp that is only being compared against zero.
    \\    --memdep-block-number-limit=<integer>                                   The number of blocks to scan during memory dependency analysis (default = 200)
    \\    --memdep-block-scan-limit=<integer>                                     The number of instructions to scan in a block in memory dependency analysis (default = 100)
    \\    --memop-max-annotations=<integer>                                       Max number of preicise value annotations for a single memopintrinsic
    \\    --memop-value-prof-max-opt-size=<integer>                               Optimize the memop size <= this value
    \\    --memory-check-merge-threshold=<integer>                                Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
    \\    --memprof-accesses-per-byte-cold-threshold=<integer>                    The threshold the accesses per byte must be under to consider an allocation cold
    \\    --memprof-debug=<integer>                                               debug
    \\    --memprof-debug-func=<string>                                           Debug func
    \\    --memprof-debug-max=<integer>                                           Debug max inst
    \\    --memprof-debug-min=<integer>                                           Debug min inst
    \\    --memprof-guard-against-version-mismatch                                Guard against compiler/runtime version mismatch.
    \\    --memprof-instrument-atomics                                            instrument atomic instructions (rmw, cmpxchg)
    \\    --memprof-instrument-reads                                              instrument read instructions
    \\    --memprof-instrument-stack                                              Instrument scalar stack variables
    \\    --memprof-instrument-writes                                             instrument write instructions
    \\    --memprof-mapping-granularity=<integer>                                 granularity of memprof shadow mapping
    \\    --memprof-mapping-scale=<integer>                                       scale of memprof shadow mapping
    \\    --memprof-memory-access-callback-prefix=<string>                        Prefix for memory access callbacks
    \\    --memprof-min-lifetime-cold-threshold=<integer>                         The minimum lifetime (s) for an allocation to be considered cold
    \\    --memprof-use-callbacks                                                 Use callbacks instead of inline instrumentation sequences.
    \\    --memssa-check-limit=<integer>                                          The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
    \\    --mergefunc-preserve-debug-info                                         Preserve debug info in thunk when mergefunc transformations are made.
    \\    --mergefunc-use-aliases                                                 Allow mergefunc to create aliases
    \\    --mergefunc-verify=<integer>                                            How many functions in a module could be used for MergeFunctions to pass a basic correctness check. '0' disables this check. Works only with '-debug' key.
    \\    --merror-missing-parenthesis                                            Error for missing parenthesis around predicate registers
    \\    --merror-noncontigious-register                                         Error for register names that aren't contigious
    \\    --mextern-sdata                                                         MIPS: Use gp_rel for data that is not defined by the current object.
    \\    --mfix4300                                                              Enable the VR4300 mulmul bug fix.
    \\    --mfs-count-threshold=<integer>                                         Minimum number of times a block must be executed to be retained.
    \\    --mfs-psi-cutoff=<integer>                                              Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.
    \\    --mfs-split-ehcode                                                      Splits all EH code and it's descendants by default.
    \\    --mgpopt                                                                Enable gp-relative addressing of mips small data items
    \\    --mhvx=<tag>                                                            Enable Hexagon Vector eXtensions
    \\    --mhvx-ieee-fp                                                          Enable HVX IEEE floating point extensions
    \\    --mhwmult=<tag>                                                         Hardware multiplier use mode for MSP430
    \\    --min-block-execution=<integer>                                         Minimum block executions to consider its BranchProbabilityInfo valid
    \\    --min-ctr-loop-threshold=<integer>                                      Loops with a constant trip count smaller than this value will not use the count register.
    \\    --min-jump-table-entries=<integer>                                      Set minimum number of entries to use a jump table.
    \\    --min-prefetch-stride=<integer>                                         Min stride to add prefetches
    \\    --min-region-size-ratio=<integer>                                       Minimum ratio comparing relative sizes of each outline candidate and original function
    \\    --minimize-addr-in-v5=<tag>                                             Always use DW_AT_ranges in DWARFv5 whenever it could allow more address pool entry sharing to reduce relocations/object size
    \\    --minimum-jump-tables=<integer>                                         Set minimum jump tables
    \\    --mips-align-constant-islands                                           Align constant islands in code
    \\    --mips-compact-branches=<tag>                                           MIPS Specific: Compact branch policy.
    \\    --mips-constant-islands-no-load-relaxation                              Don't relax loads to long loads - for testing purposes
    \\    --mips-constant-islands-small-offset=<integer>                          Make small offsets be this amount for testing purposes
    \\    --mips-erase-gp-opnd                                                    Erase GP Operand
    \\    --mips-fix-global-base-reg                                              Always use $gp as the global base register.
    \\    --mips-jalr-reloc                                                       MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr
    \\    --mips-load-target-from-got                                             Load target address from GOT
    \\    --mips-mixed-16-32                                                      Allow for a mixture of Mips16 and Mips32 code in a single output file
    \\    --mips-os16                                                             Compile all functions that don't use floating point as Mips 16
    \\    --mips-round-section-sizes                                              Round section sizes up to the section alignment
    \\    --mips-ssection-threshold=<integer>                                     Small data and bss section threshold size (default=8)
    \\    --mips-tail-calls                                                       MIPS: permit tail calls.
    \\    --mips16-constant-islands                                               Enable mips16 constant islands.
    \\    --mips16-dont-expand-cond-pseudo                                        Don't expand conditional move related pseudos for Mips 16
    \\    --mips16-hard-float                                                     Enable mips16 hard float.
    \\    --mips32-function-mask=<string>                                         Force function to be mips32
    \\    --mipspostlegalizercombinerhelper-disable-rule=<string>                 Disable one or more combiner rules temporarily in the MipsPostLegalizerCombinerHelper pass
    \\    --mipspostlegalizercombinerhelper-only-enable-rule=<string>             Disable all rules in the MipsPostLegalizerCombinerHelper pass then re-enable the specified ones
    \\    --mir-debug-loc                                                         Print MIR debug-locations
    \\    --mir-strip-debugify-only                                               Should mir-strip-debug only strip debug info from debugified modules by default
    \\    --mir-vreg-namer-use-stable-hash                                        Use Stable Hashing for MIR VReg Renaming
    \\    --misched=<tag>                                                         Machine instruction scheduler to use
    \\    --misched-bottomup                                                      Force bottom-up list scheduling
    \\    --misched-cluster                                                       Enable memop clustering.
    \\    --misched-cyclicpath                                                    Enable cyclic critical path analysis.
    \\    --misched-dcpl                                                          Print critical path length to stdout
    \\    --misched-fusion                                                        Enable scheduling for macro fusion.
    \\    --misched-limit=<integer>                                               Limit ready list to N instructions
    \\    --misched-postra                                                        Run MachineScheduler post regalloc (independent of preRA sched)
    \\    --misched-regpressure                                                   Enable register pressure scheduling.
    \\    --misched-topdown                                                       Force top-down list scheduling
    \\    --misched-verbose-level=<integer>                                       
    \\    --misexpect-tolerance=<integer>                                         Prevents emiting diagnostics when profile counts are within N% of the threshold..
    \\    --misfetch-cost=<integer>                                               Cost that models the probabilistic risk of an instruction misfetch due to a jump comparing to falling through, whose cost is zero.
    \\    --mispredict-default-rate=<integer>                                     Default mispredict rate (initialized to 25%).
    \\    --ml-advisor-keep-fpi-cache                                             For test - keep the ML Inline advisor's FunctionPropertiesInfo cache
    \\    --ml-advisor-size-increase-threshold=<integer>                          Maximum factor by which expected native size may increase before blocking any further inlining.
    \\    --mlocal-sdata                                                          MIPS: Use gp_rel for object-local data.
    \\    --mno-check-zero-division                                               MIPS: Don't trap on integer division by zero.
    \\    --mno-compound                                                          Disable looking for compound instructions for Hexagon
    \\    --mno-fixup                                                             Disable fixing up resolved relocations for Hexagon
    \\    --mno-hvx                                                               Disable Hexagon Vector eXtensions
    \\    --mno-ldc1-sdc1                                                         Expand double precision loads and stores to their single precision counterparts
    \\    --mno-pairing                                                           Disable looking for duplex instructions for Hexagon
    \\    --mno-sort-sda                                                          Disable small data sections sorting
    \\    --module-summary-dot-file=<string>                                      File to emit dot graph of new summary into
    \\    --moudle-inliner-top-priority-threshold=<integer>                       The cost threshold for call sites that get inlined without the cost-benefit analysis
    \\    --msan-and-mask=<integer>                                               Define custom MSan AndMask
    \\    --msan-check-access-address                                             report accesses through a pointer which has poisoned shadow
    \\    --msan-check-constant-shadow                                            Insert checks for constant shadow values
    \\    --msan-disable-checks                                                   Apply no_sanitize to the whole file
    \\    --msan-disambiguate-warning-threshold=<integer>                         Define threshold for number of checks per debug location to force origin update.
    \\    --msan-dump-strict-instructions                                         print out instructions with default strict semantics
    \\    --msan-eager-checks                                                     check arguments and return values at function call boundaries
    \\    --msan-handle-asm-conservative                                          conservative handling of inline assembly
    \\    --msan-handle-icmp                                                      propagate shadow through ICmpEQ and ICmpNE
    \\    --msan-handle-icmp-exact                                                exact handling of relational integer ICmp
    \\    --msan-handle-lifetime-intrinsics                                       when possible, poison scoped variables at the beginning of the scope (slower, but more precise)
    \\    --msan-instrumentation-with-call-threshold=<integer>                    If the function being instrumented requires more than this number of checks and origin stores, use callbacks instead of inline checks (-1 means never use callbacks).
    \\    --msan-keep-going                                                       keep going after reporting a UMR
    \\    --msan-kernel                                                           Enable KernelMemorySanitizer instrumentation
    \\    --msan-origin-base=<integer>                                            Define custom MSan OriginBase
    \\    --msan-poison-stack                                                     poison uninitialized stack variables
    \\    --msan-poison-stack-pattern=<integer>                                   poison uninitialized stack variables with the given pattern
    \\    --msan-poison-stack-with-call                                           poison uninitialized stack variables with a call
    \\    --msan-poison-undef                                                     poison undef temps
    \\    --msan-print-stack-names                                                Print name of local stack variable
    \\    --msan-shadow-base=<integer>                                            Define custom MSan ShadowBase
    \\    --msan-track-origins=<integer>                                          Track origins (allocation sites) of poisoned memory
    \\    --msan-with-comdat                                                      Place MSan constructors in comdat sections
    \\    --msan-xor-mask=<integer>                                               Define custom MSan XorMask
    \\    --msp430-branch-select                                                  Expand out of range branches
    \\    --msp430-no-legal-immediate                                             Enable non legal immediates (for testing purposes only)
    \\    --mtriple=<string>                                                      Override target triple for module
    \\    --mul-constant-optimization                                             Replace 'mul x, Const' with more effective instructions like SHIFT, LEA, etc.
    \\    --mv5                                                                   Build for Hexagon V5
    \\    --mv55                                                                  Build for Hexagon V55
    \\    --mv60                                                                  Build for Hexagon V60
    \\    --mv62                                                                  Build for Hexagon V62
    \\    --mv65                                                                  Build for Hexagon V65
    \\    --mv66                                                                  Build for Hexagon V66
    \\    --mv67                                                                  Build for Hexagon V67
    \\    --mv67t                                                                 Build for Hexagon V67T
    \\    --mv68                                                                  Build for Hexagon V68
    \\    --mv69                                                                  Build for Hexagon V69
    \\    --mv71                                                                  Build for Hexagon V71
    \\    --mv71t                                                                 Build for Hexagon V71T
    \\    --mv73                                                                  Build for Hexagon V73
    \\    --mve-max-interleave-factor=<integer>                                   Maximum interleave factor for MVE VLDn to generate.
    \\    --mwarn-missing-parenthesis                                             Warn for missing parenthesis around predicate registers
    \\    --mwarn-noncontigious-register                                          Warn for register names that arent contigious
    \\    --mwarn-sign-mismatch                                                   Warn for mismatching a signed and unsigned value
    \\    --no-deprecated-warn                                                    Suppress all deprecated warnings
    \\    --no-discriminators                                                     Disable generation of discriminator information.
    \\    --no-dwarf-ranges-section                                               Disable emission .debug_ranges section.
    \\    --no-integrated-as                                                      Disable integrated assembler
    \\    --no-pgo-warn-mismatch                                                  Use this option to turn off/on warnings about profile cfg mismatch.
    \\    --no-pgo-warn-mismatch-comdat-weak                                      The option is used to turn on/off warnings about hash mismatch for comdat or weak functions.
    \\    --no-phi-elim-live-out-early-exit                                       Do not use an early exit if isLiveOutPastPHIs returns true.
    \\    --no-stack-coloring                                                     Disable stack coloring
    \\    --no-stack-slot-sharing                                                 Suppress slot sharing during stack coloring
    \\    --no-type-check                                                         Suppress type errors (Wasm)
    \\    --no-warn                                                               Suppress all warnings
    \\    --no-warn-sample-unused                                                 Use this option to turn off/on warnings about function with samples but without debug information to use those samples. 
    \\    --no-x86-call-frame-opt                                                 Avoid optimizing x86 call frames for size
    \\    --no-xray-index                                                         Don't emit xray_fn_idx section
    \\    --non-global-value-max-name-size=<integer>                              Maximum size for the name of non-global values.
    \\    --nozero-initialized-in-bss                                             Don't place zero-initialized symbols into bss section
    \\    --number-scavenger-slots=<integer>                                      Set the number of scavenger slots
    \\    --nvj-count=<integer>                                                   Maximum number of predicated jumps to be converted to New Value Jump
    \\    --nvptx-fma-level=<integer>                                             NVPTX Specific: FMA contraction (0: don't do it 1: do it  2: do it aggressively
    \\    --nvptx-no-f16-math                                                     NVPTX Specific: Disable generation of f16 math ops.
    \\    --nvptx-prec-divf32=<integer>                                           NVPTX Specifies: 0 use div.approx, 1 use div.full, 2 use IEEE Compliant F32 div.rnd if available.
    \\    --nvptx-prec-sqrtf32                                                    NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn.
    \\    --nvptx-sched4reg                                                       NVPTX Specific: schedule for register pressue
    \\    --nvptx-short-ptr                                                       Use 32-bit pointers for accessing const/local/shared address spaces.
    \\    --nvvm-intr-range-sm=<integer>                                          SM variant
    \\    --nvvm-reflect-enable                                                   NVVM reflection, enabled by default
    \\    --old-thumb2-ifcvt                                                      Use old-style Thumb2 if-conversion heuristics
    \\    --only-nonnested-memmove-idiom                                          Only enable generating memmove in non-nested loops
    \\    --only-simple-regions                                                   Show only simple regions in the graphviz viewer
    \\    --opaque-pointers                                                       Use opaque pointers
    \\    --openmp-deduce-icv-values                                              
    \\    --openmp-hide-memory-transfer-latency                                   [WIP] Tries to hide the latency of host to device memory transfers
    \\    --openmp-ir-builder-optimistic-attributes                               Use optimistic attributes describing 'as-if' properties of runtime calls.
    \\    --openmp-ir-builder-unroll-threshold-factor=<integer>                   Factor for the unroll threshold to account for code simplifications still taking place
    \\    --openmp-opt-disable                                                    Disable OpenMP specific optimizations.
    \\    --openmp-opt-disable-barrier-elimination                                Disable OpenMP optimizations that eliminate barriers.
    \\    --openmp-opt-disable-deglobalization                                    Disable OpenMP optimizations involving deglobalization.
    \\    --openmp-opt-disable-folding                                            Disable OpenMP optimizations involving folding.
    \\    --openmp-opt-disable-internalization                                    Disable function internalization.
    \\    --openmp-opt-disable-spmdization                                        Disable OpenMP optimizations involving SPMD-ization.
    \\    --openmp-opt-disable-state-machine-rewrite                              Disable OpenMP optimizations that replace the state machine.
    \\    --openmp-opt-enable-merging                                             Enable the OpenMP region merging optimization.
    \\    --openmp-opt-inline-device                                              Inline all applicible functions on the device.
    \\    --openmp-opt-max-iterations=<integer>                                   Maximal number of attributor iterations.
    \\    --openmp-opt-print-module-after                                         Print the current module after OpenMP optimizations.
    \\    --openmp-opt-print-module-before                                        Print the current module before OpenMP optimizations.
    \\    --openmp-opt-shared-limit=<integer>                                     Maximum amount of shared memory to use.
    \\    --openmp-opt-verbose-remarks                                            Enables more verbose remarks.
    \\    --openmp-print-gpu-kernels                                              
    \\    --openmp-print-icv-values                                               
    \\    --opt-bisect-limit=<integer>                                            Maximum optimization to perform
    \\    --opt-bisect-print-ir-path=<string>                                     Print IR to path when opt-bisect-limit is reached
    \\    --optimize-regalloc                                                     Enable optimized register allocation compilation path.
    \\    --optsize-jump-table-density=<integer>                                  Minimum density for building a jump table in an optsize function
    \\    --orderfile-write-mapping=<string>                                      Dump functions and their MD5 hash to deobfuscate profile data
    \\    --outline-region-freq-percent=<integer>                                 Relative frequency of outline region to the entry block
    \\    --overwrite-existing-weights                                            Ignore existing branch weights on IR and always overwrite.
    \\    --partial-inlining-extra-penalty=<integer>                              A debug option to add additional penalty to the computed one.
    \\    --partial-profile                                                       Specify the current profile is used as a partial profile.
    \\    --partial-reg-update-clearance=<integer>                                Clearance between two register writes for inserting XOR to avoid partial register update
    \\    --partial-sample-profile-working-set-size-scale-factor=<integer>        The scale factor used to scale the working set size of the partial sample profile along with the partial profile ratio. This includes the factor of the profile counter per block and the factor to scale the working set size to use the same shared thresholds as PGO.
    \\    --partial-unrolling-threshold=<integer>                                 Threshold for partial unrolling
    \\    --pass-remarks=<string>                                                 Enable optimization remarks from passes whose name match the given regular expression
    \\    --pass-remarks-analysis=<string>                                        Enable optimization analysis remarks from passes whose name match the given regular expression
    \\    --pass-remarks-filter=<string>                                          Only record optimization remarks from passes whose names match the given regular expression
    \\    --pass-remarks-format=<string>                                          The format used for serializing remarks (default: YAML)
    \\    --pass-remarks-hotness-threshold                                        Minimum profile count required for an optimization remark to be output. Use 'auto' to apply the threshold from profile summary.
    \\    --pass-remarks-missed=<string>                                          Enable missed optimization remarks from passes whose name match the given regular expression
    \\    --pass-remarks-output=<string>                                          Output filename for pass remarks
    \\    --pass-remarks-with-hotness                                             With PGO, include profile count in optimization remarks
    \\    --pbqp-coalescing                                                       Attempt coalescing during PBQP register allocation.
    \\    --persist-profile-staleness                                             Compute stale profile statistical metrics and write it into the native object file(.llvm_stats section).
    \\    --pgo-critical-edge-threshold=<integer>                                 Do not instrument functions with the number of critical edges  greater than this threshold.
    \\    --pgo-emit-branch-prob                                                  When this option is on, the annotated branch probability will be emitted as optimization remarks: -{Rpass|pass-remarks}=pgo-instrumentation
    \\    --pgo-fix-entry-count                                                   Fix function entry count in profile use.
    \\    --pgo-function-entry-coverage                                           Use this option to enable function entry coverage instrumentation.
    \\    --pgo-function-size-threshold=<integer>                                 Do not instrument functions smaller than this threshold.
    \\    --pgo-instr-memop                                                       Use this option to turn on/off memory intrinsic size profiling.
    \\    --pgo-instr-old-cfg-hashing                                             Use the old CFG function hashing
    \\    --pgo-instr-select                                                      Use this option to turn on/off SELECT instruction instrumentation. 
    \\    --pgo-instrument-entry                                                  Force to instrument function entry basicblock.
    \\    --pgo-match-memprof                                                     Perform matching and annotation of memprof profiles.
    \\    --pgo-memop-count-threshold=<integer>                                   The minimum count to optimize memory intrinsic calls
    \\    --pgo-memop-max-version=<integer>                                       The max version for the optimized memory  intrinsic calls
    \\    --pgo-memop-optimize-memcmp-bcmp                                        Size-specialize memcmp and bcmp calls
    \\    --pgo-memop-percent-threshold=<integer>                                 The percentage threshold for the memory intrinsic calls optimization
    \\    --pgo-memop-scale-count                                                 Scale the memop size counts using the basic  block count value
    \\    --pgo-test-profile-file=<string>                                        Specify the path of profile data file. This ismainly for test purpose.
    \\    --pgo-test-profile-remapping-file=<string>                              Specify the path of profile remapping file. This is mainly for test purpose.
    \\    --pgo-verify-bfi                                                        Print out mismatched BFI counts after setting profile metadata The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remakrs-analysis=pgo.
    \\    --pgo-verify-bfi-cutoff=<integer>                                       Set the threshold for pgo-verify-bfi: skip the counts whose profile count value is below.
    \\    --pgo-verify-bfi-ratio=<integer>                                        Set the threshold for pgo-verify-bfi:  only print out mismatched BFI if the difference percentage is greater than this value (in percentage).
    \\    --pgo-verify-hot-bfi                                                    Print out the non-match BFI count if a hot raw profile count becomes non-hot, or a cold raw profile count becomes hot. The print is enabled under -Rpass-analysis=pgo, or internal option -pass-remakrs-analysis=pgo.
    \\    --pgo-view-counts=<tag>                                                 A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
    \\    --pgo-view-raw-counts=<tag>                                             A boolean option to show CFG dag or text with raw profile counts from profile data. See also option -pgo-view-counts. To limit graph display to only one function, use filtering option -view-bfi-func-name.
    \\    --pgo-warn-misexpect                                                    Use this option to turn on/off warnings about incorrect usage of llvm.expect intrinsics.
    \\    --pgo-warn-missing-function                                             Use this option to turn on/off warnings about missing profile data for functions.
    \\    --pgso                                                                  Enable the profile guided size optimizations. 
    \\    --pgso-cold-code-only                                                   Apply the profile guided size optimizations only to cold code.
    \\    --pgso-cold-code-only-for-instr-pgo                                     Apply the profile guided size optimizations only to cold code under instrumentation PGO.
    \\    --pgso-cold-code-only-for-partial-sample-pgo                            Apply the profile guided size optimizations only to cold code under partial-profile sample PGO.
    \\    --pgso-cold-code-only-for-sample-pgo                                    Apply the profile guided size optimizations only to cold code under sample PGO.
    \\    --pgso-cutoff-instr-prof=<integer>                                      The profile guided size optimization profile summary cutoff for instrumentation profile.
    \\    --pgso-cutoff-sample-prof=<integer>                                     The profile guided size optimization profile summary cutoff for sample profile.
    \\    --pgso-lwss-only                                                        Apply the profile guided size optimizations only if the working set size is large (except for cold code.)
    \\    --phi-elim-split-all-critical-edges                                     Split all critical edges during PHI elimination
    \\    --phi-node-folding-threshold=<integer>                                  Control the amount of phi node folding to perform (default = 2)
    \\    --phicse-debug-hash                                                     Perform extra assertion checking to verify that PHINodes's hash function is well-behaved w.r.t. its isEqual predicate
    \\    --phicse-num-phi-smallsize=<integer>                                    When the basic block contains not more than this number of PHI nodes, perform a (faster!) exhaustive search instead of set-driven one.
    \\    --pi-force-live-exit-outline                                            Force outline regions with live exits
    \\    --pi-mark-coldcc                                                        Mark outline function calls with ColdCC
    \\    --pipeliner-annotate-for-testing                                        Instead of emitting the pipelined code, annotate instructions with the generated schedule for feeding into the -modulo-schedule-test pass
    \\    --pipeliner-dbg-res                                                     
    \\    --pipeliner-experimental-cg                                             Use the experimental peeling code generator for software pipelining
    \\    --pipeliner-force-ii=<integer>                                          Force pipeliner to use specified II.
    \\    --pipeliner-force-issue-width=<integer>                                 Force pipeliner to use specified issue width.
    \\    --pipeliner-max-mii=<integer>                                           Size limit for the MII.
    \\    --pipeliner-max-stages=<integer>                                        Maximum stages allowed in the generated scheduled.
    \\    --pipeliner-prune-deps                                                  Prune dependences between unrelated Phi nodes.
    \\    --pipeliner-prune-loop-carried                                          Prune loop carried order dependences.
    \\    --pipeliner-show-mask                                                   
    \\    --poison-checking-function-local                                        Check that returns are non-poison (for testing)
    \\    --post-RA-scheduler                                                     Enable scheduling after register allocation
    \\    --postra-sched-debugdiv=<integer>                                       Debug control MBBs that are scheduled
    \\    --postra-sched-debugmod=<integer>                                       Debug control MBBs that are scheduled
    \\    --ppc-always-use-base-pointer                                           Force the use of a base pointer in every function
    \\    --ppc-asm-full-reg-names                                                Use full register names when printing assembly
    \\    --ppc-bit-perm-rewriter-stress-rotates                                  stress rotate selection in aggressive ppc isel for bit permutations
    \\    --ppc-chaincommon-max-vars=<integer>                                    Bucket number per loop for PPC loop chain common
    \\    --ppc-chaincommon-min-threshold=<integer>                               Minimal common base load/store instructions triggering chain commoning preparation. Must be not smaller than 4
    \\    --ppc-convert-rr-to-ri                                                  Convert eligible reg+reg instructions to reg+imm
    \\    --ppc-disable-non-volatile-cr                                           Disable the use of non-volatile CR register fields
    \\    --ppc-disable-perfect-shuffle                                           disable vector permute decomposition
    \\    --ppc-dispprep-min-threshold=<integer>                                  Minimal common base load/store instructions triggering DS/DQ form preparation
    \\    --ppc-dqprep-max-vars=<integer>                                         Potential PHI threshold per loop for PPC loop prep of DQ form
    \\    --ppc-dsprep-max-vars=<integer>                                         Potential PHI threshold per loop for PPC loop prep of DS form
    \\    --ppc-eliminate-signext                                                 enable elimination of sign-extensions
    \\    --ppc-eliminate-zeroext                                                 enable elimination of zero-extensions
    \\    --ppc-enable-coldcc                                                     Enable using coldcc calling conv for cold internal functions
    \\    --ppc-enable-gpr-to-vsr-spills                                          Enable spills from gpr to vsr rather than stack
    \\    --ppc-enable-pe-vector-spills                                           Enable spills in prologue to vector registers.
    \\    --ppc-enable-pipeliner                                                  Enable Machine Pipeliner for PPC
    \\    --ppc-fma-rp-factor=<integer>                                           register pressure factor for the transformations.
    \\    --ppc-fma-rp-reduction                                                  enable register pressure reduce in machine combiner pass.
    \\    --ppc-formprep-chain-commoning                                          Enable chain commoning in PPC loop prepare pass.
    \\    --ppc-formprep-max-vars=<integer>                                       Potential common base number threshold per function for PPC loop prep
    \\    --ppc-formprep-prefer-update                                            prefer update form when ds form is also a update form
    \\    --ppc-formprep-update-nonconst-inc                                      prepare update form when the load/store increment is a loop invariant non-const value.
    \\    --ppc-gen-isel                                                          Enable generating the ISEL instruction.
    \\    --ppc-gep-opt                                                           Enable optimizations on complex GEPs
    \\    --ppc-gpr-icmps=<tag>                                                   Specify the types of comparisons to emit GPR-only code for.
    \\    --ppc-late-peephole                                                     Run pre-emit peephole optimizations.
    \\    --ppc-lsr-no-insns-cost                                                 Do not add instruction count to lsr cost model
    \\    --ppc-machine-combiner                                                  Enable the machine combiner pass
    \\    --ppc-max-crbit-spill-dist=<integer>                                    Maximum search distance for definition of CR bit spill on ppc
    \\    --ppc-old-latency-calc                                                  Use the old (incorrect) instruction latency calculation
    \\    --ppc-opt-conditional-trap                                              enable optimization of conditional traps
    \\    --ppc-pcrel-linker-opt                                                  enable PC Relative linker optimization
    \\    --ppc-postra-bias-addi                                                  Enable scheduling addi instruction as earlyas possible post ra
    \\    --ppc-preinc-prep-max-vars=<integer>                                    Potential PHI threshold per loop for PPC loop prep of update form
    \\    --ppc-quadword-atomics                                                  enable quadword lock-free atomic operations
    \\    --ppc-reduce-cr-logicals                                                Expand eligible cr-logical binary ops to branches
    \\    --ppc-reg-to-imm-fixed-point                                            Iterate to a fixed point when attempting to convert reg-reg instructions to reg-imm
    \\    --ppc-reg-with-percent-prefix                                           Prints full register names with percent
    \\    --ppc-set-dscr=<integer>                                                Set the Data Stream Control Register.
    \\    --ppc-stack-ptr-caller-preserved                                        Consider R1 caller preserved so stack saves of caller preserved registers can be LICM candidates
    \\    --ppc-tls-opt                                                           Enable tls optimization peephole
    \\    --ppc-track-subreg-liveness                                             Enable subregister liveness tracking for PPC
    \\    --ppc-use-absolute-jumptables                                           use absolute jump tables on ppc
    \\    --ppc-use-base-pointer                                                  Enable use of a base pointer for complex stack frames
    \\    --ppc-use-bit-perm-rewriter                                             use aggressive ppc isel for bit permutations
    \\    --ppc-use-branch-hint                                                   Enable static hinting of branches on ppc
    \\    --ppc-vsr-nums-as-vr                                                    Prints full register names with vs{31-63} as v{0-31}
    \\    --pragma-unroll-and-jam-threshold=<integer>                             Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
    \\    --pragma-unroll-threshold=<integer>                                     Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
    \\    --pragma-vectorize-scev-check-threshold=<integer>                       The maximum number of SCEV checks allowed with a vectorize(enable) pragma
    \\    --pre-RA-sched=<tag>                                                    Instruction schedulers available (before register allocation):
    \\    --precise-rotation-cost                                                 Model the cost of loop rotation more precisely by using profile data.
    \\    --prefer-inloop-reductions                                              Prefer in-loop vector reductions, overriding the targets preference.
    \\    --prefer-no-csel                                                        Prefer predicated Move to CSEL
    \\    --prefer-predicate-over-epilogue=<tag>                                  Tail-folding and predication preferences over creating a scalar epilogue loop.
    \\    --prefer-predicated-reduction-select                                    Prefer predicating a reduction operation over an after loop select.
    \\    --prefetch-distance=<integer>                                           Number of instructions to prefetch ahead
    \\    --prefetch-hints-file=<string>                                          Path to the prefetch hints profile. See also -x86-discriminate-memops
    \\    --preinline-threshold=<integer>                                         Control the amount of inlining in pre-instrumentation inliner (default = 75)
    \\    --preserve-alignment-assumptions-during-inlining                        Convert align attributes to assumptions during inlining.
    \\    --preserve-as-comments                                                  Preserve Comments in outputted assembly
    \\    --print-after=<string>                                                  Print IR after specified passes
    \\    --print-after-all                                                       Print IR after each pass
    \\    --print-after-isel                                                      Print machine instrs after ISel
    \\    --print-all-options                                                     Print all option values after command line parsing
    \\    --print-before=<string>                                                 Print IR before specified passes
    \\    --print-before-all                                                      Print IR before each pass
    \\    --print-before-changed                                                  Print before passes that change them
    \\    --print-bfi                                                             Print the block frequency info.
    \\    --print-bfi-func-name=<string>                                          The option to specify the name of the function whose block frequency info is printed.
    \\    --print-bpi                                                             Print the branch probability info.
    \\    --print-bpi-func-name=<string>                                          The option to specify the name of the function whose branch probability info is printed.
    \\    --print-changed=<tag>                                                   Print changed IRs
    \\    --print-changed-dot-path=<string>                                       system dot used by change reporters
    \\    --print-debug-ata                                                       
    \\    --print-debug-counter                                                   Print out debug counter info after all counters accumulated
    \\    --print-failed-fuse-candidates                                          Print instructions that the allocator wants to fuse, but the X86 backend currently can't
    \\    --print-gc                                                              Dump garbage collector data
    \\    --print-import-failures                                                 Print information for functions rejected for importing
    \\    --print-imports                                                         Print imported functions
    \\    --print-instruction-comments                                            Prints comments for instruction based on inline cost analysis
    \\    --print-isel-input                                                      Print LLVM IR input to isel pass
    \\    --print-lsr-output                                                      Print LLVM IR produced by the loop-reduce pass
    \\    --print-lvi-after-jump-threading                                        Print the LazyValueInfo cache after JumpThreading
    \\    --print-machine-bfi                                                     Print the machine block frequency info.
    \\    --print-module-scope                                                    When printing IR for print-[before|after]{-all} always print a module IR
    \\    --print-on-crash                                                        Print the last form of the IR before crash
    \\    --print-options                                                         Print non-default options after command line parsing
    \\    --print-pipeline-passes                                                 Print a '-passes' compatible string describing the pipeline (best-effort only).
    \\    --print-region-style=<tag>                                              style of printing regions
    \\    --print-regmask-num-regs=<integer>                                      Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
    \\    --print-regusage                                                        print register usage details collected for analysis.
    \\    --print-slotindexes                                                     When printing machine IR, annotate instructions and blocks with SlotIndexes when available
    \\    --print-summary-global-ids                                              Print the global id for each value when reading the module summary
    \\    --procres-cost-lim=<integer>                                            The OOO window for processor resources during scheduling.
    \\    --profile-accurate-for-symsinlist                                       For symbols in profile symbol list, regard their profiles to be accurate. It may be overriden by profile-sample-accurate. 
    \\    --profile-guided-section-prefix                                         Use profile info to add section prefix for hot/cold functions
    \\    --profile-isfs                                                          Profile uses flow sensitive discriminators
    \\    --profile-likely-prob=<integer>                                         branch probability threshold in percentage to be considered very likely when profile is available
    \\    --profile-sample-accurate                                               If the sample profile is accurate, we will mark all un-sampled callsite and function as having 0 samples. Otherwise, treat un-sampled callsites and functions conservatively as unknown.
    \\    --profile-sample-block-accurate                                         If the sample profile is accurate, we will mark all un-sampled branches and calls as having 0 samples. Otherwise, treat them conservatively as unknown.
    \\    --profile-summary-contextless                                           Merge context profiles before calculating thresholds.
    \\    --profile-summary-cutoff-cold=<integer>                                 A count is cold if it is below the minimum count to reach this percentile of total counts.
    \\    --profile-summary-cutoff-hot=<integer>                                  A count is hot if it exceeds the minimum count to reach this percentile of total counts.
    \\    --profile-summary-huge-working-set-size-threshold=<integer>             The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
    \\    --profile-summary-large-working-set-size-threshold=<integer>            The code working set size is considered large if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
    \\    --profile-symbol-list-cutoff=<integer>                                  Cutoff value about how many symbols in profile symbol list will be used. This is very useful for performance debugging
    \\    --profile-unknown-in-special-section                                    In profiling mode like sampleFDO, if a function doesn't have profile, we cannot tell the function is cold for sure because it may be a function newly added without ever being sampled. With the flag enabled, compiler can put such profile unknown functions into a special section, so runtime system can choose to handle it in a different way than .text section, to save RAM for example. 
    \\    --propagate-attrs                                                       Propagate attributes in index
    \\    --protect-from-escaped-allocas                                          Do not optimize lifetime zones that are broken
    \\    --r600-ir-structurize                                                   Use StructurizeCFG IR pass
    \\    --rafast-ignore-missing-defs                                            
    \\    --rdf-dump                                                              
    \\    --rdf-limit=<integer>                                                   
    \\    --rdf-liveness-max-rec=<integer>                                        Maximum recursion level
    \\    --rdf-opt                                                               Enable RDF-based optimizations
    \\    --reassociate-geps-verify-no-dead-code                                  Verify this pass produces no dead code
    \\    --rebalance-only-imbal                                                  Rebalance address tree only if it is imbalanced
    \\    --rebalance-only-opt                                                    Rebalance address tree only if this allows optimizations
    \\    --recurrence-chain-limit=<integer>                                      Maximum length of recurrence chain when evaluating the benefit of commuting operands
    \\    --recursive-inline-max-stacksize=<integer>                              Do not inline recursive functions with a stack size that exceeds the specified limit
    \\    --regalloc=<tag>                                                        Register allocator to use
    \\    --regalloc-cheap-remat-weight=<integer>                                 
    \\    --regalloc-copy-weight=<integer>                                        
    \\    --regalloc-csr-first-time-cost=<integer>                                Cost for first time use of callee-saved register.
    \\    --regalloc-enable-advisor=<tag>                                         Enable regalloc advisor mode
    \\    --regalloc-enable-priority-advisor=<tag>                                Enable regalloc advisor mode
    \\    --regalloc-eviction-max-interference-cutoff=<integer>                   Number of interferences after which we declare an interference unevictable and bail out. This is a compilation cost-saving consideration. To disable, pass a very large number.
    \\    --regalloc-expensive-remat-weight=<integer>                             
    \\    --regalloc-load-weight=<integer>                                        
    \\    --regalloc-store-weight=<integer>                                       
    \\    --regbankselect-fast                                                    Run the Fast mode (default mapping)
    \\    --regbankselect-greedy                                                  Use the Greedy mode (best local mapping)
    \\    --relax-elf-relocations                                                 Emit GOTPCRELX/REX_GOTPCRELX instead of GOTPCREL on x86-64 ELF
    \\    --relax-nv-checks                                                       Relax checks of new-value validity
    \\    --relocation-model=<tag>                                                Choose relocation model
    \\    --remarks-section                                                       Emit a section containing remark diagnostics metadata. By default, this is enabled for the following formats: yaml-strtab, bitstream.
    \\    --remat-pic-stub-load                                                   Re-materialize load from stub in PIC mode
    \\    --rename-exclude-alias-prefixes=<string>                                Prefixes for aliases that don't need to be renamed, separated by a comma
    \\    --rename-exclude-function-prefixes=<string>                             Prefixes for functions that don't need to be renamed, separated by a comma
    \\    --rename-exclude-global-prefixes=<string>                               Prefixes for global values that don't need to be renamed, separated by a comma
    \\    --rename-exclude-struct-prefixes=<string>                               Prefixes for structs that don't need to be renamed, separated by a comma
    \\    --renumber-blocks-before-view                                           If true, basic blocks are re-numbered before MBP layout is printed into a dot graph. Only used when a function is being printed.
    \\    --replexitval=<tag>                                                     Choose the strategy to replace exit value in IndVarSimplify
    \\    --report-profile-staleness                                              Compute and report stale profile statistical metrics.
    \\    --reroll-num-tolerated-failed-matches=<integer>                         The maximum number of failures to tolerate during fuzzy matching. (default: 400)
    \\    --reserve-regs-for-regalloc=<string>                                    Reserve physical registers, so they can't be used by register allocator. Should only be used for testing register allocator.
    \\    --restrict-statepoint-remat                                             Restrict remat for statepoint operands
    \\    --reverse-csr-restore-seq                                               reverse the CSR restore sequence
    \\    --rewrite-map-file=<string>                                             Symbol Rewrite Map
    \\    --rewrite-phi-limit=<integer>                                           Limit the length of PHI chains to lookup
    \\    --riscv-disable-insert-vsetvl-phi-opt                                   Disable looking through phis when inserting vsetvlis.
    \\    --riscv-disable-regalloc-hints                                          Disable two address hints for register allocation
    \\    --riscv-disable-sextw-removal                                           Disable removal of sext.w
    \\    --riscv-disable-strip-w-suffix                                          Disable strip W suffix
    \\    --riscv-disable-using-constant-pool-for-large-ints                      Disable using constant pool for large integers.
    \\    --riscv-enable-copyelim                                                 Enable the redundant copy elimination pass
    \\    --riscv-enable-global-merge                                             Enable the global merge pass
    \\    --riscv-enable-machine-combiner                                         Enable the machine combiner pass
    \\    --riscv-enable-subreg-liveness                                          
    \\    --riscv-insert-vsetvl-strict-asserts                                    Enable strict assertion checking for the dataflow algorithm
    \\    --riscv-lower-ext-max-web-size=<integer>                                Give the maximum size (in number of nodes) of the web of instructions that we will consider for VW expansion
    \\    --riscv-lower-form-vw-w-with-splat                                      Allow the formation of VW_W operations (e.g., VWADD_W) with splat constants
    \\    --riscv-lower-fp-repeated-divisors=<integer>                            Set the minimum number of repetitions of a divisor to allow transformation to multiplications by the reciprocal
    \\    --riscv-max-build-ints-cost=<integer>                                   The maximum cost used for building integers.
    \\    --riscv-no-aliases                                                      Disable the emission of assembler pseudo instructions
    \\    --riscv-prefer-whole-register-move                                      Prefer whole register move for vector registers.
    \\    --riscv-v-fixed-length-vector-lmul-max=<integer>                        The maximum LMUL value to use for fixed length vectors. Fractional LMUL values are not supported.
    \\    --riscv-v-register-bit-width-lmul=<integer>                             The LMUL to use for getRegisterBitWidth queries. Affects LMUL used by autovectorized code. Fractional LMULs are not supported.
    \\    --riscv-v-slp-max-vf=<integer>                                          Result used for getMaximumVF query which is used exclusively by SLP vectorizer.  Defaults to 1 which disables SLP.
    \\    --riscv-v-vector-bits-max=<integer>                                     Assume V extension vector registers are at most this big, with zero meaning no maximum size is assumed.
    \\    --riscv-v-vector-bits-min=<integer>                                     Assume V extension vector registers are at least this big, with zero meaning no minimum size is assumed. A value of -1 means use Zvl*b extension. This is primarily used to enable autovectorization with fixed width vectors.
    \\    --rotation-max-header-size=<integer>                                    The default maximum header size for automatic loop rotation
    \\    --rotation-prepare-for-lto                                              Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.
    \\    --rs4gc-allow-statepoint-with-no-deopt-info                             
    \\    --rs4gc-clobber-non-live                                                
    \\    --rs4gc-remat-derived-at-uses                                           
    \\    --run-pass=<string>                                                     Run compiler only for specified passes (comma separated list)
    \\    --runtime-check-per-loop-load-elim=<integer>                            Max number of memchecks allowed per eliminated load on average
    \\    --runtime-counter-relocation                                            Enable relocating counters at runtime.
    \\    --runtime-mem-idiom-threshold=<integer>                                 Threshold (in bytes) for the runtime check guarding the memmove.
    \\    --runtime-memory-check-threshold=<integer>                              When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
    \\    --safe-stack-coloring                                                   enable safe stack coloring
    \\    --safe-stack-layout                                                     enable safe stack layout
    \\    --safepoint-ir-verifier-print-only                                      
    \\    --safestack-use-pointer-address                                         
    \\    --sample-profile-check-record-coverage=<integer>                        Emit a warning if less than N% of records in the input profile are matched to the IR.
    \\    --sample-profile-check-sample-coverage=<integer>                        Emit a warning if less than N% of samples in the input profile are matched to the IR.
    \\    --sample-profile-cold-inline-threshold=<integer>                        Threshold for inlining cold callsites
    \\    --sample-profile-even-flow-distribution                                 Try to evenly distribute flow when there are multiple equally likely options.
    \\    --sample-profile-file=<string>                                          Profile file loaded by -sample-profile
    \\    --sample-profile-hot-inline-threshold=<integer>                         Hot callsite threshold for proirity-based sample profile loader inlining.
    \\    --sample-profile-icp-max-prom=<integer>                                 Max number of promotions for a single indirect call callsite in sample profile loader
    \\    --sample-profile-icp-relative-hotness=<integer>                         Relative hotness percentage threshold for indirect call promotion in proirity-based sample profile loader inlining.
    \\    --sample-profile-icp-relative-hotness-skip=<integer>                    Skip relative hotness check for ICP up to given number of targets.
    \\    --sample-profile-inline-growth-limit=<integer>                          The size growth ratio limit for proirity-based sample profile loader inlining.
    \\    --sample-profile-inline-limit-max=<integer>                             The upper bound of size growth limit for proirity-based sample profile loader inlining.
    \\    --sample-profile-inline-limit-min=<integer>                             The lower bound of size growth limit for proirity-based sample profile loader inlining.
    \\    --sample-profile-inline-replay=<string>                                 Optimization remarks file containing inline remarks to be replayed by inlining from sample profile loader.
    \\    --sample-profile-inline-replay-fallback=<tag>                           How sample profile inline replay treats sites that don't come from the replay. Original: defers to original advisor, AlwaysInline: inline all sites not in replay, NeverInline: inline no sites not in replay
    \\    --sample-profile-inline-replay-format=<tag>                             How sample profile inline replay file is formatted
    \\    --sample-profile-inline-replay-scope=<tag>                              Whether inline replay should be applied to the entire Module or just the Functions (default) that are present as callers in remarks during sample profile inlining.
    \\    --sample-profile-inline-size                                            Inline cold call sites in profile loader if it's beneficial for code size.
    \\    --sample-profile-join-islands                                           Join isolated components having positive flow.
    \\    --sample-profile-max-propagate-iterations=<integer>                     Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.
    \\    --sample-profile-merge-inlinee                                          Merge past inlinee's profile to outline version if sample profile loader decided not to inline a call site. It will only be enabled when top-down order of profile loading is enabled. 
    \\    --sample-profile-prioritized-inline                                     Use call site prioritized inlining for sample profile loader.Currently only CSSPGO is supported.
    \\    --sample-profile-profi-cost-block-dec=<integer>                         The cost of decreasing a block's count by one.
    \\    --sample-profile-profi-cost-block-entry-dec=<integer>                   The cost of decreasing the entry block's count by one.
    \\    --sample-profile-profi-cost-block-entry-inc=<integer>                   The cost of increasing the entry block's count by one.
    \\    --sample-profile-profi-cost-block-inc=<integer>                         The cost of increasing a block's count by one.
    \\    --sample-profile-profi-cost-block-unknown-inc=<integer>                 The cost of increasing an unknown block's count by one.
    \\    --sample-profile-profi-cost-block-zero-inc=<integer>                    The cost of increasing a count of zero-weight block by one.
    \\    --sample-profile-rebalance-unknown                                      Evenly re-distribute flow among unknown subgraphs.
    \\    --sample-profile-recursive-inline                                       Allow sample loader inliner to inline recursive calls.
    \\    --sample-profile-remapping-file=<string>                                Profile remapping file loaded by -sample-profile
    \\    --sample-profile-top-down-load                                          Do profile annotation and inlining for functions in top-down order of call graph during sample profile loading. It only works for new pass manager. 
    \\    --sample-profile-use-preinliner                                         Use the preinliner decisions stored in profile context.
    \\    --sample-profile-use-profi                                              Use profi to infer block and edge counts.
    \\    --sanitizer-coverage-control-flow                                       collect control flow for each function
    \\    --sanitizer-coverage-inline-8bit-counters                               increments 8-bit counter for every edge
    \\    --sanitizer-coverage-inline-bool-flag                                   sets a boolean flag for every edge
    \\    --sanitizer-coverage-level=<integer>                                    Sanitizer Coverage. 0: none, 1: entry block, 2: all blocks, 3: all blocks and critical edges
    \\    --sanitizer-coverage-pc-table                                           create a static PC table
    \\    --sanitizer-coverage-prune-blocks                                       Reduce the number of instrumented blocks
    \\    --sanitizer-coverage-stack-depth                                        max stack depth tracing
    \\    --sanitizer-coverage-trace-compares                                     Tracing of CMP and similar instructions
    \\    --sanitizer-coverage-trace-divs                                         Tracing of DIV instructions
    \\    --sanitizer-coverage-trace-geps                                         Tracing of GEP instructions
    \\    --sanitizer-coverage-trace-loads                                        Tracing of load instructions
    \\    --sanitizer-coverage-trace-pc                                           Experimental pc tracing
    \\    --sanitizer-coverage-trace-pc-guard                                     pc tracing with a guard
    \\    --sanitizer-coverage-trace-stores                                       Tracing of store instructions
    \\    --sanitizer-metadata-atomics                                            Emit PCs for atomic operations.
    \\    --sanitizer-metadata-covered                                            Emit PCs for covered functions.
    \\    --sanitizer-metadata-uar                                                Emit PCs for start of functions that are subject for use-after-return checking
    \\    --sanitizer-metadata-weak-callbacks                                     Declare callbacks extern weak, and only call if non-null.
    \\    --scalable-vectorization=<tag>                                          Control whether the compiler can use scalable vectors to vectorize a loop
    \\    --scalar-evolution-classify-expressions                                 When printing analysis, include information on every instruction
    \\    --scalar-evolution-finite-loop                                          Handle <= and >= in finite loops
    \\    --scalar-evolution-huge-expr-threshold=<integer>                        Size of the expression which is considered huge
    \\    --scalar-evolution-max-add-rec-size=<integer>                           Max coefficients in AddRec during evolving
    \\    --scalar-evolution-max-arith-depth=<integer>                            Maximum depth of recursive arithmetics
    \\    --scalar-evolution-max-cast-depth=<integer>                             Maximum depth of recursive SExt/ZExt/Trunc
    \\    --scalar-evolution-max-constant-evolving-depth=<integer>                Maximum depth of recursive constant evolving
    \\    --scalar-evolution-max-scc-analysis-depth=<integer>                     Maximum amount of nodes to process while searching SCEVUnknown Phi strongly connected components
    \\    --scalar-evolution-max-scev-compare-depth=<integer>                     Maximum depth of recursive SCEV complexity comparisons
    \\    --scalar-evolution-max-scev-operations-implication-depth=<integer>      Maximum depth of recursive SCEV operations implication analysis
    \\    --scalar-evolution-max-value-compare-depth=<integer>                    Maximum depth of recursive value complexity comparisons
    \\    --scalar-evolution-use-context-for-no-wrap-flag-strenghening            Infer nuw/nsw flags using context where suitable
    \\    --scalar-evolution-use-expensive-range-sharpening                       Use more powerful methods of sharpening expression ranges. May be costly in terms of compile time
    \\    --scalarize-load-store                                                  Allow the scalarizer pass to scalarize loads and store
    \\    --scalarize-variable-insert-extract                                     Allow the scalarizer pass to scalarize insertelement/extractelement with variable index
    \\    --scale-partial-sample-profile-working-set-size                         If true, scale the working set size of the partial sample profile by the partial profile ratio to reflect the size of the program being compiled.
    \\    --scev-addops-inline-threshold=<integer>                                Threshold for inlining addition operands into a SCEV
    \\    --scev-cheap-expansion-budget=<integer>                                 When performing SCEV expansion only if it is cheap to do, this controls the budget that is considered cheap (default = 4)
    \\    --scev-mulops-inline-threshold=<integer>                                Threshold for inlining multiplication operands into a SCEV
    \\    --scev-range-iter-threshold=<integer>                                   Threshold for switching to iteratively computing SCEV ranges
    \\    --scev-verify-ir                                                        Verify IR correctness when making sensitive SCEV queries (slow)
    \\    --sched-avg-ipc=<integer>                                               Average inst/cycle whan no target itinerary exists.
    \\    --sched-high-latency-cycles=<integer>                                   Roughly estimate the number of cycles that 'long latency'instructions take for targets with no itinerary
    \\    --sched-preds-closer                                                    
    \\    --sched-retval-optimization                                             
    \\    --scheditins                                                            Use InstrItineraryData for latency lookup
    \\    --schedmodel                                                            Use TargetSchedModel for latency lookup
    \\    --schedule-ppc-vsx-fma-mutation-early                                   Schedule VSX FMA instruction mutation early
    \\    --select-opti-loop-cycle-gain-threshold=<integer>                       Minimum gain per loop (in cycles) threshold.
    \\    --select-opti-loop-gradient-gain-threshold=<integer>                    Gradient gain threshold (%).
    \\    --select-opti-loop-relative-gain-threshold=<integer>                    Minimum relative gain per loop threshold (1/X). Defaults to 12.5%
    \\    --sgpr-regalloc=<tag>                                                   Register allocator to use for SGPRs
    \\    --show-fs-branchprob                                                    Print setting flow sensitive branch probabilities
    \\    --show-mc-encoding                                                      Show encoding in .s output
    \\    --shrink-frame-limit=<integer>                                          Max count of stack frame shrink-wraps
    \\    --simple-loop-unswitch-drop-non-trivial-implicit-null-checks            If enabled, drop make.implicit metadata in unswitched implicit null checks to save time analyzing if we can keep it.
    \\    --simple-loop-unswitch-guards                                           If enabled, simple loop unswitching will also consider llvm.experimental.guard intrinsics as unswitch candidates.
    \\    --simple-loop-unswitch-memoryssa-threshold=<integer>                    Max number of memory uses to explore during partial unswitching analysis
    \\    --simplify-mir                                                          Leave out unnecessary information when printing MIR
    \\    --simplifycfg-branch-fold-common-dest-vector-multiplier=<integer>       Multiplier to apply to threshold when determining whether or not to fold branch to common destination when vector operations are present
    \\    --simplifycfg-branch-fold-threshold=<integer>                           Maximum cost of combining conditions when folding branches
    \\    --simplifycfg-hoist-common                                              Hoist common instructions up to the parent block
    \\    --simplifycfg-hoist-common-skip-limit=<integer>                         Allow reordering across at most this many instructions when hoisting
    \\    --simplifycfg-hoist-cond-stores                                         Hoist conditional stores if an unconditional store precedes
    \\    --simplifycfg-max-small-block-size=<integer>                            Max size of a block which is still considered small enough to thread through
    \\    --simplifycfg-merge-compatible-invokes                                  Allow SimplifyCFG to merge invokes together when appropriate
    \\    --simplifycfg-merge-cond-stores                                         Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
    \\    --simplifycfg-merge-cond-stores-aggressively                            When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
    \\    --simplifycfg-require-and-preserve-domtree                              Temorary development switch used to gradually uplift SimplifyCFG into preserving DomTree,
    \\    --simplifycfg-sink-common                                               Sink common instructions down to the end block
    \\    --sink-common-insts                                                     Sink common instructions (default = false)
    \\    --sink-freq-percent-threshold=<integer>                                 Do not sink instructions that require cloning unless they execute less than this percent of the time.
    \\    --sink-insts-to-avoid-spills                                            Sink instructions into cycles to avoid register spills
    \\    --skip-mips-long-branch                                                 MIPS: Skip branch expansion pass.
    \\    --skip-ret-exit-block                                                   Suppress counter promotion if exit blocks contain ret.
    \\    --slot1-store-slot0-load                                                Allow slot1 store and slot0 load
    \\    --slp-max-look-ahead-depth=<integer>                                    The maximum look-ahead depth for operand reordering scores
    \\    --slp-max-reg-size=<integer>                                            Attempt to vectorize for this register size in bits
    \\    --slp-max-root-look-ahead-depth=<integer>                               The maximum look-ahead depth for searching best rooting option
    \\    --slp-max-store-lookup=<integer>                                        Maximum depth of the lookup for consecutive stores.
    \\    --slp-max-vf=<integer>                                                  Maximum SLP vectorization factor (0=unlimited)
    \\    --slp-min-reg-size=<integer>                                            Attempt to vectorize for this register size in bits
    \\    --slp-min-tree-size=<integer>                                           Only vectorize small trees if they are fully vectorizable
    \\    --slp-recursion-max-depth=<integer>                                     Limit the recursion depth when building a vectorizable tree
    \\    --slp-schedule-budget=<integer>                                         Limit the size of the SLP scheduling region per block
    \\    --slp-threshold=<integer>                                               Only vectorize if you gain more than this number 
    \\    --slp-vectorize-hor                                                     Attempt to vectorize horizontal reductions
    \\    --slp-vectorize-hor-store                                               Attempt to vectorize horizontal reductions feeding into a store
    \\    --small-loop-cost=<integer>                                             The cost of a loop that is considered 'small' by the interleaver.
    \\    --sort-profiled-scc-member                                              Sort profiled recursion by edge weights.
    \\    --sort-timers                                                           In the report, sort the timers in each group in wall clock time order
    \\    --sparc-bpcc-offset-bits=<integer>                                      Restrict range of BPcc/FBPfcc instructions (DEBUG)
    \\    --sparc-enable-branch-relax                                             Relax out of range conditional branches
    \\    --sparc-reserve-app-registers                                           Reserve application registers (%g2-%g4)
    \\    --spec-exec-max-not-hoisted=<integer>                                   Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
    \\    --spec-exec-max-speculation-cost=<integer>                              Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
    \\    --spec-exec-only-if-divergent-target                                    Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
    \\    --speculate-one-expensive-inst                                          Allow exactly one expensive instruction to be speculatively executed
    \\    --speculative-counter-promotion-max-exiting=<integer>                   The max number of exiting blocks of a loop to allow  speculative counter promotion
    \\    --speculative-counter-promotion-to-loop                                 When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.
    \\    --spill-func-threshold=<integer>                                        Specify O2(not Os) spill func threshold
    \\    --spill-func-threshold-Os=<integer>                                     Specify Os spill func threshold
    \\    --split-dwarf-cross-cu-references                                       Enable cross-cu references in DWO files
    \\    --split-dwarf-file=<string>                                             Specify the name of the .dwo file to encode in the DWARF output
    \\    --split-dwarf-output=<string>                                           .dwo output filename
    \\    --split-machine-functions                                               Split out cold basic blocks from machine functions based on profile information
    \\    --split-spill-mode=<tag>                                                Spill mode for splitting live ranges
    \\    --spp-all-backedges                                                     
    \\    --spp-counted-loop-trip-width=<integer>                                 
    \\    --spp-no-backedge                                                       
    \\    --spp-no-call                                                           
    \\    --spp-no-entry                                                          
    \\    --spp-print-base-pointers                                               
    \\    --spp-print-liveset                                                     
    \\    --spp-print-liveset-size                                                
    \\    --spp-rematerialization-threshold=<integer>                             
    \\    --spp-split-backedge                                                    
    \\    --sroa-strict-inbounds                                                  
    \\    --ssc-dce-limit=<integer>                                               
    \\    --stack-safety-max-iterations=<integer>                                 
    \\    --stack-safety-print                                                    
    \\    --stack-safety-run                                                      
    \\    --stack-size-section                                                    Emit a section containing stack size metadata
    \\    --stack-symbol-ordering                                                 Order local stack symbols.
    \\    --stack-tagging-first-slot-opt                                          Apply first slot optimization for stack tagging (eliminate ADDG Rt, Rn, 0, 0).
    \\    --stack-tagging-merge-init                                              merge stack variable initializers with tagging when possible
    \\    --stack-tagging-merge-init-scan-limit=<integer>                         
    \\    --stack-tagging-merge-init-size-limit=<integer>                         
    \\    --stack-tagging-merge-settag                                            merge settag instruction in function epilog
    \\    --stack-tagging-unchecked-ld-st=<tag>                                   Unconditionally apply unchecked-ld-st optimization (even for large stack frames, or in the presence of variable sized allocas).
    \\    --stack-tagging-use-stack-safety                                        Use Stack Safety analysis results
    \\    --stackcoloring-lifetime-start-on-first-use                             Treat stack lifetimes as starting on first use, not on START marker.
    \\    --stackmap-version=<integer>                                            Specify the stackmap encoding version (default = 3)
    \\    --stackrealign                                                          Force align the stack to the minimum alignment
    \\    --start-after=<string>                                                  Resume compilation after a specific pass
    \\    --start-before=<string>                                                 Resume compilation before a specific pass
    \\    --static-func-full-module-prefix                                        Use full module build paths in the profile counter names for static functions.
    \\    --static-func-strip-dirname-prefix=<integer>                            Strip specified level of directory name from source path in the profile counter name for static functions.
    \\    --static-likely-prob=<integer>                                          branch probability threshold in percentageto be considered very likely
    \\    --stats                                                                 Enable statistics output from program (available with Asserts)
    \\    --stats-json                                                            Display statistics as json data
    \\    --stop-after=<string>                                                   Stop compilation after a specific pass
    \\    --stop-before=<string>                                                  Stop compilation before a specific pass
    \\    --store-to-load-forwarding-conflict-detection                           Enable conflict detection in loop-access analysis
    \\    --stress-cgp-ext-ld-promotion                                           Stress test ext(promotable(ld)) -> promoted(ext(ld)) optimization in CodeGenPrepare
    \\    --stress-cgp-store-extract                                              Stress test store(extract) optimizations in CodeGenPrepare
    \\    --stress-early-ifcvt                                                    Turn all knobs to 11
    \\    --stress-regalloc=<integer>                                             Limit all regclasses to N registers
    \\    --strict-dwarf                                                          use strict dwarf
    \\    --structurizecfg-relaxed-uniform-regions                                Allow relaxed uniform region checks
    \\    --structurizecfg-skip-uniform-regions                                   Force whether the StructurizeCFG pass skips uniform regions
    \\    --summary-file=<string>                                                 The summary file to use for function importing.
    \\    --sve-gather-overhead=<integer>                                         
    \\    --sve-scatter-overhead=<integer>                                        
    \\    --sve-tail-folding=<string>                                             Control the use of vectorisation using tail-folding for SVE:
    \\    --swift-async-fp=<tag>                                                  Determine when the Swift async frame pointer should be set
    \\    --switch-peel-threshold=<integer>                                       Set the case probability threshold for peeling the case from a switch statement. A value greater than 100 will void this optimization
    \\    --switch-range-to-icmp                                                  Convert switches into an integer range comparison (default = false)
    \\    --switch-to-lookup                                                      Convert switches to lookup tables (default = false)
    \\    --systemz-subreg-liveness                                               Enable subregister liveness tracking for SystemZ (experimental)
    \\    --t2-reduce-limit=<integer>                                             
    \\    --t2-reduce-limit2=<integer>                                            
    \\    --t2-reduce-limit3=<integer>                                            
    \\    --tail-dup-indirect-size=<integer>                                      Maximum instructions to consider tail duplicating blocks that end with indirect branches.
    \\    --tail-dup-limit=<integer>                                              
    \\    --tail-dup-placement                                                    Perform tail duplication during placement. Creates more fallthrough opportunites in outline branches.
    \\    --tail-dup-placement-aggressive-threshold=<integer>                     Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail merging during layout is forced to have a threshold that won't conflict.
    \\    --tail-dup-placement-penalty=<integer>                                  Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increase fallthrough, but it also increases icache pressure. This parameter controls the penalty to account for that. Percent as integer.
    \\    --tail-dup-placement-threshold=<integer>                                Instruction cutoff for tail duplication during layout. Tail merging during layout is forced to have a threshold that won't conflict.
    \\    --tail-dup-profile-percent-threshold=<integer>                          If profile count information is used in tail duplication cost model, the gained fall through number from tail duplication should be at least this percent of hot count.
    \\    --tail-dup-size=<integer>                                               Maximum instructions to consider tail duplicating
    \\    --tail-dup-verify                                                       Verify sanity of PHI instructions during taildup
    \\    --tail-merge-size=<integer>                                             Min number of instructions to consider tail merging
    \\    --tail-merge-threshold=<integer>                                        Max number of predecessors to consider tail merging
    \\    --tail-predication=<tag>                                                MVE tail-predication pass options
    \\    --tailcallopt                                                           Turn fastcc calls into tail calls by (potentially) changing ABI.
    \\    --target-abi=<string>                                                   The name of the ABI to be targeted from the backend.
    \\    --temporal-reuse-threshold=<integer>                                    Use this to specify the max. distance between array elements accessed in a loop so that the elements are classified to have temporal reuse
    \\    --terminal-rule                                                         Apply the terminal rule
    \\    --tfutils-use-simplelogger                                              Output simple (non-protobuf) log.
    \\    --thinlto-assume-merged                                                 Assume the input has already undergone ThinLTO function importing and the other pre-optimization pipeline changes.
    \\    --thinlto-synthesize-entry-counts                                       Synthesize entry counts based on the summary
    \\    --thread-model=<tag>                                                    Choose threading model
    \\    --threads=<integer>                                                     
    \\    --time-compilations=<integer>                                           Repeat compilation N times for timing
    \\    --time-passes                                                           Time each pass, printing elapsed time for each on exit
    \\    --time-passes-per-run                                                   Time each pass run, printing elapsed time for each run on exit
    \\    --time-trace                                                            Record time trace
    \\    --time-trace-file=<string>                                              Specify time trace file destination
    \\    --time-trace-granularity=<integer>                                      Minimum time granularity (in microseconds) traced by time profiler
    \\    --tiny-trip-count-interleave-threshold=<integer>                        We don't interleave loops with a estimated constant trip count below this number
    \\    --tls-load-hoist                                                        hoist the TLS loads in PIC model to eliminate redundant TLS address calculation.
    \\    --tls-size=<integer>                                                    Bit size of immediate TLS offsets
    \\    --trace-gv-placement                                                    Trace global value placement
    \\    --trace-hex-vector-stores-only                                          Enables tracing of vector stores
    \\    --track-memory                                                          Enable -time-passes memory tracking (this may be slow)
    \\    --trap-func=<string>                                                    Emit a call to trap function rather than a trap instruction
    \\    --trap-unreachable                                                      Enable generating trap for unreachable
    \\    --treat-scalable-fixed-error-as-warning                                 Treat issues where a fixed-width property is requested from a scalable type as a warning, instead of an error
    \\    --triangle-chain-count=<integer>                                        Number of triangle-shaped-CFG's that need to be in a row for the triangle tail duplication heuristic to kick in. 0 to disable.
    \\    --trim-var-locs                                                         
    \\    --tsan-compound-read-before-write                                       Emit special compound instrumentation for reads-before-writes
    \\    --tsan-distinguish-volatile                                             Emit special instrumentation for accesses to volatiles
    \\    --tsan-handle-cxx-exceptions                                            Handle C++ exceptions (insert cleanup blocks for unwinding)
    \\    --tsan-instrument-atomics                                               Instrument atomics
    \\    --tsan-instrument-func-entry-exit                                       Instrument function entry and exit
    \\    --tsan-instrument-memintrinsics                                         Instrument memintrinsics (memset/memcpy/memmove)
    \\    --tsan-instrument-memory-accesses                                       Instrument memory accesses
    \\    --tsan-instrument-read-before-write                                     Do not eliminate read instrumentation for read-before-writes
    \\    --two-entry-phi-node-folding-threshold=<integer>                        Control the maximal total instruction cost that we are willing to speculatively execute to fold a 2-entry PHI node into a select (default = 4)
    \\    --twoaddr-reschedule                                                    Coalesce copies by rescheduling (default=true)
    \\    --type-based-intrinsic-cost                                             Calculate intrinsics cost based only on argument types
    \\    --undef-reg-clearance=<integer>                                         How many idle instructions we would like before certain undef register reads
    \\    --unique-basic-block-section-names                                      Give unique names to every basic block section
    \\    --unique-section-names                                                  Give unique names to every section
    \\    --unlikely-branch-weight=<integer>                                      Weight of the branch unlikely to be taken (default = 1)
    \\    --unroll-allow-loop-nests-peeling                                       Allows loop nests to be peeled.
    \\    --unroll-allow-partial                                                  Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
    \\    --unroll-allow-peeling                                                  Allows loops to be peeled when the dynamic trip count is known to be low.
    \\    --unroll-allow-remainder                                                Allow generation of a loop remainder (extra iterations) when unrolling a loop.
    \\    --unroll-and-jam-count=<integer>                                        Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
    \\    --unroll-and-jam-threshold=<integer>                                    Threshold to use for inner loop when doing unroll and jam.
    \\    --unroll-count=<integer>                                                Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
    \\    --unroll-force-peel-count=<integer>                                     Force a peel count regardless of profiling information.
    \\    --unroll-full-max-count=<integer>                                       Set the max unroll count for full unrolling, for testing purposes
    \\    --unroll-max-count=<integer>                                            Set the max unroll count for partial and runtime unrolling, fortesting purposes
    \\    --unroll-max-iteration-count-to-analyze=<integer>                       Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
    \\    --unroll-max-percent-threshold-boost=<integer>                          The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
    \\    --unroll-max-upperbound=<integer>                                       The max of trip count upper bound that is considered in unrolling
    \\    --unroll-optsize-threshold=<integer>                                    The cost threshold for loop unrolling when optimizing for size
    \\    --unroll-partial-threshold=<integer>                                    The cost threshold for partial loop unrolling
    \\    --unroll-peel-count=<integer>                                           Set the unroll peeling count, for testing purposes
    \\    --unroll-peel-max-count=<integer>                                       Max average trip count which will cause loop peeling.
    \\    --unroll-remainder                                                      Allow the loop remainder to be unrolled.
    \\    --unroll-revisit-child-loops                                            Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
    \\    --unroll-runtime                                                        Unroll loops with run-time trip counts
    \\    --unroll-runtime-epilog                                                 Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
    \\    --unroll-runtime-multi-exit                                             Allow runtime unrolling for loops with multiple exits, when epilog is generated
    \\    --unroll-runtime-other-exit-predictable                                 Assume the non latch exit block to be predictable
    \\    --unroll-threshold=<integer>                                            The cost threshold for loop unrolling
    \\    --unroll-threshold-aggressive=<integer>                                 Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations
    \\    --unroll-threshold-default=<integer>                                    Default threshold (max size of unrolled loop), used in all but O3 optimizations
    \\    --unroll-verify-domtree                                                 Verify domtree after unrolling
    \\    --unroll-verify-loopinfo                                                Verify loopinfo after unrolling
    \\    --unswitch-num-initial-unscaled-candidates=<integer>                    Number of unswitch candidates that are ignored when calculating cost multiplier.
    \\    --unswitch-siblings-toplevel-div=<integer>                              Toplevel siblings divisor for cost multiplier.
    \\    --unswitch-threshold=<integer>                                          The cost threshold for unswitching a loop.
    \\    --update-pseudo-probe                                                   Update pseudo probe distribution factor
    \\    --update-return-attrs                                                   Update return attributes on calls within inlined body
    \\    --use-ctors                                                             Use .ctors instead of .init_array.
    \\    --use-dbg-addr                                                          Use llvm.dbg.addr for all local variables
    \\    --use-dereferenceable-at-point-semantics=<integer>                      Deref attributes and metadata infer facts at definition only
    \\    --use-dwarf-ranges-base-address-specifier                               Use base address specifiers in debug_ranges
    \\    --use-gnu-debug-macro                                                   Emit the GNU .debug_macro format with DWARF <5
    \\    --use-gpu-divergence-analysis                                           turn the LegacyDivergenceAnalysis into a wrapper for GPUDivergenceAnalysis
    \\    --use-iterative-bfi-inference                                           Apply an iterative post-processing to infer correct BFI counts
    \\    --use-leb128-directives                                                 Disable the usage of LEB128 directives, and generate .byte instead.
    \\    --use-lir-code-size-heurs                                               Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
    \\    --use-mbpi                                                              use Machine Branch Probability Info
    \\    --use-newer-candidate                                                   
    \\    --use-noalias-intrinsic-during-inlining                                 Use the llvm.experimental.noalias.scope.decl intrinsic during inlining.
    \\    --use-profiled-call-graph                                               Process functions in a top-down order defined by the profiled call graph when -sample-profile-top-down-load is on.
    \\    --use-registers-for-deopt-values                                        Allow using registers for non pointer deopt args
    \\    --use-registers-for-gc-values-in-landing-pad                            Allow using registers for gc pointer in landing pad
    \\    --use-segment-set-for-physregs                                          Use segment set for the computation of the live ranges of physregs.
    \\    --use-source-filename-for-promoted-locals                               Uses the source file name instead of the Module hash. This requires that the source filename has a unique name / path to avoid name collisions.
    \\    --use-tbaa-in-sched-mi                                                  Enable use of TBAA during MI DAG construction
    \\    --use-unknown-locations=<tag>                                           Make an absence of debug location information explicit.
    \\    --vec-extabi                                                            Enable the AIX Extended Altivec ABI.
    \\    --vector-combine-max-scan-instrs=<integer>                              Max number of instructions to scan for vector combining.
    \\    --vector-library=<tag>                                                  Vector functions library
    \\    --vectorize-loops                                                       Run the Loop vectorization passes
    \\    --vectorize-memory-check-threshold=<integer>                            The maximum allowed number of runtime memory checks
    \\    --vectorize-num-stores-pred=<integer>                                   Max number of stores to be predicated behind an if.
    \\    --vectorize-scev-check-threshold=<integer>                              The maximum number of SCEV checks allowed.
    \\    --vectorize-slp                                                         Run the SLP vectorization passes
    \\    --vectorizer-maximize-bandwidth                                         Maximize bandwidth when selecting vectorization factor which will be determined by the smallest type in loop.
    \\    --vectorizer-min-trip-count=<integer>                                   Loops with a constant trip count that is smaller than this value are vectorized only if no scalar iteration overheads are incurred.
    \\    --verify-arm-pseudo-expand                                              Verify machine code after expanding ARM pseudos
    \\    --verify-assumption-cache                                               Enable verification of assumption cache
    \\    --verify-cfg-preserved                                                  
    \\    --verify-cfiinstrs                                                      Verify Call Frame Information instructions
    \\    --verify-coalescing                                                     Verify machine instrs before and after register coalescing
    \\    --verify-dom-info                                                       Verify dominator info (time consuming)
    \\    --verify-indvars                                                        Verify the ScalarEvolution result after running indvars. Has no effect in release builds. (Note: this adds additional SCEV queries potentially changing the analysis result)
    \\    --verify-loop-info                                                      Verify loop info (time consuming)
    \\    --verify-loop-lcssa                                                     Verify loop lcssa form (time consuming)
    \\    --verify-machine-dom-info                                               Verify machine dominator info (time consuming)
    \\    --verify-machineinstrs                                                  Verify generated machine code
    \\    --verify-memoryssa                                                      Enable verification of MemorySSA.
    \\    --verify-misched                                                        Verify machine instrs before and after machine scheduling
    \\    --verify-noalias-scope-decl-dom                                         Ensure that llvm.experimental.noalias.scope.decl for identical scopes are not dominating
    \\    --verify-predicateinfo                                                  Verify PredicateInfo in legacy printer pass.
    \\    --verify-pseudo-probe                                                   Do pseudo probe verification
    \\    --verify-pseudo-probe-funcs=<string>                                    The option to specify the name of the functions to verify.
    \\    --verify-regalloc                                                       Verify during register allocation
    \\    --verify-region-info                                                    Verify region info (time consuming)
    \\    --verify-scev                                                           Verify ScalarEvolution's backedge taken counts (slow)
    \\    --verify-scev-maps                                                      Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
    \\    --verify-scev-strict                                                    Enable stricter verification with -verify-scev is passed
    \\    --version                                                               Display the version of this program
    \\    --vgpr-regalloc=<tag>                                                   Register allocator to use for VGPRs
    \\    --view-bfi-func-name=<string>                                           The option to specify the name of the function whose CFG will be displayed.
    \\    --view-block-freq-propagation-dags=<tag>                                Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
    \\    --view-block-layout-with-bfi=<tag>                                      Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
    \\    --view-edge-bundles                                                     Pop up a window to show edge bundle graphs
    \\    --view-hot-freq-percent=<integer>                                       An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
    \\    --view-machine-block-freq-propagation-dags=<tag>                        Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
    \\    --view-slp-tree                                                         Display the SLP trees with Graphviz
    \\    --vliw-misched-reg-pressure=<integer>                                   High register pressure threhold.
    \\    --vp-counters-per-site=<integer>                                        The average number of profile counters allocated per value profiling site.
    \\    --vp-static-alloc                                                       Do static counter allocation for value profiler
    \\    --vplan-build-stress-test                                               Build VPlan for every supported loop nest in the function and bail out right after the build (stress test the VPlan H-CFG construction in the VPlan-native vectorization path).
    \\    --vplan-print-in-dot-format                                             Use dot format instead of plain text when dumping VPlans
    \\    --vplan-verify-hcfg                                                     Verify VPlan H-CFG.
    \\    --wasm-disable-explicit-locals                                          WebAssembly: output implicit locals in instruction output for test purposes only.
    \\    --wasm-enable-eh                                                        WebAssembly exception handling
    \\    --wasm-enable-sjlj                                                      WebAssembly setjmp/longjmp handling
    \\    --wasm-keep-registers                                                   WebAssembly: output stack registers in instruction output for test purposes only.
    \\    --whole-program-visibility                                              Enable whole program visibility
    \\    --wholeprogramdevirt-branch-funnel-threshold=<integer>                  Maximum number of call targets per call site to enable branch funnels
    \\    --wholeprogramdevirt-check=<tag>                                        Type of checking for incorrect devirtualizations
    \\    --wholeprogramdevirt-print-index-based                                  Print index-based devirtualization messages
    \\    --wholeprogramdevirt-read-summary=<string>                              Read summary from given bitcode or YAML file before running pass
    \\    --wholeprogramdevirt-skip=<string>                                      Prevent function(s) from being devirtualized
    \\    --wholeprogramdevirt-summary-action=<tag>                               What to do with the summary when running this pass
    \\    --wholeprogramdevirt-write-summary=<string>                             Write summary to given bitcode or YAML file after running pass. Output file format is deduced from extension: *.bc means writing bitcode, otherwise YAML
    \\    --write-relbf-to-summary                                                Write relative block frequency to function summary 
    \\    --x86-align-branch=<string>                                             Specify types of branches to align (plus separated list of types):
    \\    --x86-align-branch-boundary=<integer>                                   Control how the assembler should align branches with NOP. If the boundary's size is not 0, it should be a power of 2 and no less than 32. Branches will be aligned to prevent from being across or against the boundary of specified size. The default value 0 does not align branches.
    \\    --x86-and-imm-shrink                                                    Enable setting constant bits to reduce size of mask immediates
    \\    --x86-asm-syntax=<tag>                                                  Choose style of code to emit from X86 backend:
    \\    --x86-branches-within-32B-boundaries                                    Align selected instructions to mitigate negative performance impact of Intel's micro code update for errata skx102.  May break assumptions about labels corresponding to particular instructions, and should be used with caution.
    \\    --x86-bypass-prefetch-instructions                                      When discriminating instructions with memory operands, ignore prefetch instructions. This ensures the other memory operand instructions have the same identifiers after inserting prefetches, allowing for successive insertions.
    \\    --x86-cmov-converter                                                    Enable the X86 cmov-to-branch optimization.
    \\    --x86-cmov-converter-force-all                                          Convert all cmovs to branches.
    \\    --x86-cmov-converter-force-mem-operand                                  Convert cmovs to branches whenever they have memory operands.
    \\    --x86-cmov-converter-threshold=<integer>                                Minimum gain per loop (in cycles) threshold.
    \\    --x86-disable-avoid-SFB                                                 X86: Disable Store Forwarding Blocks fixup.
    \\    --x86-discriminate-memops                                               Generate unique debug info for each instruction with a memory operand. Should be enabled for profile-driven cache prefetching, both in the build of the binary being profiled, as well as in the build of the binary consuming the profile.
    \\    --x86-early-ifcvt                                                       Enable early if-conversion on X86
    \\    --x86-experimental-lvi-inline-asm-hardening                             Harden inline assembly code that may be vulnerable to Load Value Injection (LVI). This feature is experimental.
    \\    --x86-experimental-pref-innermost-loop-alignment=<integer>              Sets the preferable loop alignment for experiments (as log2 bytes) for innermost loops only. If specified, this option overrides alignment set by x86-experimental-pref-loop-alignment.
    \\    --x86-experimental-unordered-atomic-isel                                Use LoadSDNode and StoreSDNode instead of AtomicSDNode for unordered atomic loads and stores respectively.
    \\    --x86-indirect-branch-tracking                                          Enable X86 indirect branch tracking pass.
    \\    --x86-lvi-load-dot                                                      For each function, emit a dot graph depicting potential LVI gadgets
    \\    --x86-lvi-load-dot-only                                                 For each function, emit a dot graph depicting potential LVI gadgets, and do not insert any fences
    \\    --x86-lvi-load-dot-verify                                               For each function, emit a dot graph to stdout depicting potential LVI gadgets, used for testing purposes only
    \\    --x86-lvi-load-no-cbranch                                               Don't treat conditional branches as disclosure gadgets. This may improve performance, at the cost of security.
    \\    --x86-lvi-load-opt-plugin=<string>                                      Specify a plugin to optimize LFENCE insertion
    \\    --x86-machine-combiner                                                  Enable the machine combiner pass
    \\    --x86-pad-for-align                                                     Pad previous instructions to implement align directives
    \\    --x86-pad-for-branch-align                                              Pad previous instructions to implement branch alignment
    \\    --x86-pad-max-prefix-size=<integer>                                     Maximum number of prefixes to use for padding
    \\    --x86-promote-anyext-load                                               Enable promoting aligned anyext load to wider load
    \\    --x86-seses-enable-without-lvi-cfi                                      Force enable speculative execution side effect suppression. (Note: User must pass -mlvi-cfi in order to mitigate indirect branches and returns.)
    \\    --x86-seses-omit-branch-lfences                                         Omit all lfences before branch instructions.
    \\    --x86-seses-one-lfence-per-bb                                           Omit all lfences other than the first to be placed in a basic block.
    \\    --x86-seses-only-lfence-non-const                                       Only lfence before groups of terminators where at least one branch instruction has an input to the addressing mode that is a register other than %rip.
    \\    --x86-sfb-inspection-limit=<integer>                                    X86: Number of instructions backward to inspect for store forwarding blocks.
    \\    --x86-slh-fence-call-and-ret                                            Use a full speculation fence to harden both call and ret edges rather than a lighter weight mitigation.
    \\    --x86-slh-indirect                                                      Harden indirect calls and jumps against using speculatively stored attacker controlled addresses. This is designed to mitigate Spectre v1.2 style attacks.
    \\    --x86-slh-ip                                                            Harden interprocedurally by passing our state in and out of functions in the high bits of the stack pointer.
    \\    --x86-slh-lfence                                                        Use LFENCE along each conditional edge to harden against speculative loads rather than conditional movs and poisoned pointers.
    \\    --x86-slh-loads                                                         Sanitize loads from memory. When disable, no significant security is provided.
    \\    --x86-slh-post-load                                                     Harden the value loaded *after* it is loaded by flushing the loaded bits to 1. This is hard to do in general but can be done easily for GPRs.
    \\    --x86-speculative-load-hardening                                        Force enable speculative load hardening
    \\    --x86-tile-ra                                                           Enable the tile register allocation pass
    \\    --x86-use-base-pointer                                                  Enable use of a base pointer for complex stack frames
    \\    --x86-use-fsrm-for-memcpy                                               Use fast short rep mov in memcpy lowering
    \\    --x86-use-vzeroupper                                                    Minimize AVX to SSE transition penalty
    \\    --xcoff-traceback-table                                                 Emit the XCOFF traceback table
    \\    --xcore-max-threads=<integer>                                           Maximum number of threads (for emulation thread-local storage)
    \\
    \\
;
