const mem = @import("./mem.zig");
const file = @import("./file.zig");
const meta = @import("./meta.zig");
const testing = @import("./testing.zig");
const Allocator = mem.GenericArenaAllocator(.{ .arena_index = 0 });

fn testAutomaticAppend(comptime spec: mem.ReinterpretSpec, comptime dst_type: type, expected: []const dst_type, any: anytype) void {
    const Array = mem.StaticArray(dst_type, 4096);
    var array: Array = .{};
    array.writeAny(spec, any);
    try testing.expectEqualMany(dst_type, array.readAll(), expected);
}
fn testDynamicAppend(comptime spec: mem.ReinterpretSpec, allocator: *Allocator, comptime dst_type: type, expected: []const dst_type, any: anytype) !void {
    const Array = Allocator.StructuredVector(dst_type);
    var array: Array = try Array.init(allocator);
    defer array.deinit(allocator);
    try array.appendAny(spec, any);
    try testing.expectEqualMany(dst_type, array.readAll(), expected);
}
fn unfairAndUnreasonableTestCases() !void {
    var address_space: mem.AddressSpace = .{};
    var allocator: Allocator = try Allocator.init(&address_space);
    {
        const S = struct {
            a: u16 = 25,
            b: u32 = 44,
            const sentinel: @This() = .{ .a = 0, .b = 0 };
            fn get(n: u16) [5:sentinel]@This() {
                const x = n * 5;
                return .{
                    .{ .a = x + '0', .b = x + '1' }, .{ .a = x + '2', .b = x + '3' },
                    .{ .a = x + '4', .b = x + '5' }, .{ .a = x + '6', .b = x + '7' },
                    .{ .a = x + '8', .b = x + '9' },
                };
            }
        };
        const dst_type: type = []?[]S;
        var v_0 = S.get(0);
        var v_1 = S.get(1);
        var v_2 = S.get(2);
        var v_3 = S.get(3);
        var v_4 = S.get(4);
        var src_0: [5:null]?[:S.sentinel]S = .{ &v_0, &v_1, &v_2, &v_3, &v_4 };
        var src_1 = @ptrCast([*:null]?[:S.sentinel]S, &src_0);
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(spec, dst_type, src_1, .{ &v_0, &v_1, &v_2, &v_3, &v_4 });
        try testDynamicAppend(spec, allocator, dst_type, src_1);
    }
    {
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .dereference = &.{} } };
        const dst_type: type = u8;
        const src_0: [11:0]u8 = "hello_world".*;
        const src_1: *const [11:0]u8 = &src_0;
        const src_2: [:0]const u8 = &src_0;
        const src_3: [*:0]const u8 = src_2.ptr;
        const src = .{ src_0, src_1, src_2, src_3 };
        try testAutomaticAppend(spec, dst_type, 4, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        // The desired response to the following parameters is to iterate over
        // the tuple, identify that the tuple arguments are references to
        // aggregates of the element type, and to copy these in the most
        // efficient way. The array's compile-time-known length must be
        // utilised. So must the compile-time-known length of the pointer to
        // array.
        const dst_type: type = [:0]const u8;
        const src_0: [11:0]u8 = "hello_world".*;
        const src_1: *const [11:0]u8 = &src_0;
        const src_2: [:0]const u8 = &src_0;
        const src_3: [*:0]const u8 = src_2.ptr;
        const src = .{ src_1, src_2, src_3 };
        const spec = .{ .reference = .{ .dereference = &.{} } };
        try testAutomaticAppend(spec, dst_type, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = []const []align(8) const u8;
        const src_0: []align(8) const u8 = @alignCast(8, "hello_world");
        const src_2: []const []align(8) const u8 = &.{src_0};
        const src_4: []const []const []align(8) const u8 = &.{src_2};
        const src_6: []const []const []const []align(8) const u8 = &.{src_4};
        const src_8: []const []const []const []const []align(8) const u8 = &.{src_6};
        try testAutomaticAppend(mem.follow_wr_spec, dst_type, src_8);
        try testDynamicAppend(mem.follow_wr_spec, allocator, dst_type, src_8);
    }
    {
        var p0 = "hello_world".*;
        var p1 = "hello".*;
        var p2 = "world".*;
        const src_0 = &p0;
        const src_1 = .{ &p1, &p2 };
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(spec, u8, src_0);
        try testDynamicAppend(spec, allocator, u8, src_0);
        try testAutomaticAppend(spec, u8, src_1);
        try testDynamicAppend(spec, allocator, u8, src_1);
    }
    {
        const dst_type: type = []u8;
        const src_type: type = [*:0]u8;
        var p0 = "hello_world".*;
        var p1 = @ptrCast(src_type, &p0);
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(spec, dst_type, p1);
        try testDynamicAppend(spec, allocator, dst_type, p1);
    }
    {
        const dst_type: type = [:'k']u8;
        const src_type: type = [:'k']u8;
        var src_0: [32:'k']u8 = .{'a'} ** 32;
        var src: src_type = &src_0;
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(spec, dst_type, 1, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        const S = struct { c: u8 = 'k', d: u8 = 'l' };
        const dst_type: type = [:.{}]S;
        const src_type: type = [:.{}]S;
        var src_0: [32:.{}]S = .{.{}} ** 32;
        const src: src_type = &src_0;
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(spec, dst_type, 1, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        const c: u8 = 'k';
        const dst_type: type = []*const u8;
        const src_type: type = [:&c]*const u8;
        const v_0: u8 = 'a';
        const v_1: u8 = 'b';
        const v_2: u8 = 'c';
        const v_3: u8 = 'd';
        var src_0: [4]*const u8 = [_]*const u8{ &v_0, &v_1, &v_2, &v_3, &c };
        var src: src_type = src_0[0..4 :&c];
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(spec, dst_type, 1, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = [*:0]u8;
        var src_0: [4:0]u8 = "abcd".*;
        const src: [*:0]u8 = @as([:0]u8, &src_0).ptr;
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(spec, dst_type, 1, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = u8;
        const src = @embedFile("./container-test.zig");
        const spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(spec, dst_type, 1, src);
        try testDynamicAppend(spec, allocator, dst_type, src);
    }
}
pub fn main() !void {
    var b: bool = true;
    if (b) return;
    var address_space: mem.AddressSpace = .{};
    var random: file.DeviceRandomBytes(1024 * 1024) = .{};
    { // StructuredAutomaticView
        const child: type = u16;
        const value: child = 7060;
        const read_count: u64 = 9740;
        const write_count: u64 = 12869;
        const offset: u64 = 56097;
        const values: [write_count]child = random.readCount(child, write_count);
        const Array: type = mem.StructuredAutomaticView(child, null, write_count + read_count, @alignOf(child), .{});
        var array: Array = .{};
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredAutomaticView
    { // StructuredAutomaticStreamView
        const child: type = u16;
        const value: child = 54316;
        const read_count: u64 = 41616;
        const write_count: u64 = 48966;
        const offset: u64 = 13736;
        const values: [write_count]child = random.readCount(child, write_count);
        const Array: type = mem.StructuredAutomaticStreamView(child, null, write_count + read_count, @alignOf(child), .{});
        var array: Array = .{};
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredAutomaticStreamView
    { // StructuredAutomaticStreamVector
        const child: type = u16;
        const value: child = 16866;
        const read_count: u64 = 3975;
        const write_count: u64 = 35498;
        const offset: u64 = 20135;
        const values: [write_count]child = random.readCount(child, write_count);
        const Array: type = mem.StructuredAutomaticStreamVector(child, null, write_count + read_count, @alignOf(child), .{});
        var array: Array = .{};
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredAutomaticStreamVector
    { // StructuredAutomaticVector
        const child: type = u16;
        const value: child = 16293;
        const read_count: u64 = 6250;
        const write_count: u64 = 42024;
        const offset: u64 = 30989;
        const values: [write_count]child = random.readCount(child, write_count);
        const Array: type = mem.StructuredAutomaticVector(child, null, write_count + read_count, @alignOf(child), .{});
        var array: Array = .{};
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredAutomaticVector
    { // StructuredStaticView
        const child: type = u16;
        const value: child = 38100;
        const read_count: u64 = 7245;
        const write_count: u64 = 32190;
        const offset: u64 = 15448;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticView(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredStaticView
    { // StructuredStaticStreamVector
        const child: type = u16;
        const value: child = 49398;
        const read_count: u64 = 52386;
        const write_count: u64 = 63025;
        const offset: u64 = 43436;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticStreamVector(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredStaticStreamVector
    { // StructuredStaticVector
        const child: type = u16;
        const value: child = 35750;
        const read_count: u64 = 13256;
        const write_count: u64 = 35343;
        const offset: u64 = 33762;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticVector(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredStaticVector
    { // StructuredStaticView
        const child: type = u16;
        const value: child = 53272;
        const read_count: u64 = 11165;
        const write_count: u64 = 15275;
        const offset: u64 = 21403;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticView(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredStaticView
    { // StructuredStaticStreamVector
        const child: type = u16;
        const value: child = 34621;
        const read_count: u64 = 13028;
        const write_count: u64 = 64930;
        const offset: u64 = 33630;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticStreamVector(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredStaticStreamVector
    { // StructuredStaticVector
        const child: type = u16;
        const value: child = 42297;
        const read_count: u64 = 48541;
        const write_count: u64 = 48891;
        const offset: u64 = 34689;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStaticVector(child, read_count + write_count);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // StructuredStaticVector
    { // UnstructuredStaticView
        const child: type = u16;
        const value: child = 54162;
        const read_count: u64 = 41414;
        const write_count: u64 = 44867;
        const offset: mem.Amount = .{ .count = 10493 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStaticView(@sizeOf(child) * (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // UnstructuredStaticView
    { // UnstructuredStaticStreamVector
        const child: type = u16;
        const value: child = 46547;
        const read_count: u64 = 17242;
        const write_count: u64 = 28580;
        const offset: mem.Amount = .{ .count = 63140 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStaticStreamVector(@sizeOf(child) * (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_4: []child = array.referAllUndefined(child);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_12: child = array.readOneBehind(child);
        const ret_13: child = array.readOneAhead(child);
        const ret_14: [read_count]child = array.readCountBehind(child, read_count);
        const ret_15: []const child = array.readManyBehind(child, offset);
        const ret_16: [read_count]child = array.readCountAhead(child, read_count);
        const ret_17: []const child = array.readManyAhead(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(child, read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(child, offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(child, read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(child, read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // UnstructuredStaticStreamVector
    { // UnstructuredStaticVector
        const child: type = u16;
        const value: child = 51531;
        const read_count: u64 = 14470;
        const write_count: u64 = 18288;
        const offset: mem.Amount = .{ .count = 31120 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStaticVector(@sizeOf(child) * (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_4: []child = array.referAllUndefined(child);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
    } // UnstructuredStaticVector
    { // StructuredStreamVector
        const child: type = u16;
        const value: child = 51642;
        const read_count: u64 = 31125;
        const write_count: u64 = 53963;
        const offset: u64 = 919;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStreamVector(child);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // StructuredStreamVector
    { // StructuredStreamView
        const child: type = u16;
        const value: child = 9306;
        const read_count: u64 = 48782;
        const write_count: u64 = 56398;
        const offset: u64 = 52393;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStreamView(child);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredStreamView
    { // StructuredVector
        const child: type = u16;
        const value: child = 49263;
        const read_count: u64 = 51922;
        const write_count: u64 = 63069;
        const offset: u64 = 63717;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredVector(child);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_4: []child = array.referAllUndefined();
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // StructuredVector
    { // StructuredView
        const child: type = u16;
        const value: child = 55827;
        const read_count: u64 = 2112;
        const write_count: u64 = 43497;
        const offset: u64 = 18448;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredView(child);
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll();
        const ret_1: [:value]const child = array.readAllWithSentinel(value);
        const ret_2: []child = array.referAllDefined();
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(value);
        const ret_6: child = array.readOneAt(offset);
        const ret_7: [read_count]child = array.readCountAt(offset, read_count);
        const ret_8: []const child = array.readManyAt(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(offset, value);
        const ret_26: *child = array.referOneAt(offset);
        const ret_27: *[read_count]child = array.referCountAt(offset, read_count);
        const ret_28: []child = array.referManyAt(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(offset, value);
        const ret_38: void = array.overwriteOneAt(offset, value);
        const ret_39: void = array.overwriteCountAt(offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // StructuredView
    { // UnstructuredStreamVector
        const child: type = u16;
        const value: child = 3282;
        const read_count: u64 = 2693;
        const write_count: u64 = 55037;
        const offset: mem.Amount = .{ .count = 26327 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStreamVector(@sizeOf(child), (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_4: []child = array.referAllUndefined(child);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_12: child = array.readOneBehind(child);
        const ret_13: child = array.readOneAhead(child);
        const ret_14: [read_count]child = array.readCountBehind(child, read_count);
        const ret_15: []const child = array.readManyBehind(child, offset);
        const ret_16: [read_count]child = array.readCountAhead(child, read_count);
        const ret_17: []const child = array.readManyAhead(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(child, read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(child, offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(child, read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(child, read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // UnstructuredStreamVector
    { // UnstructuredStreamView
        const child: type = u16;
        const value: child = 36664;
        const read_count: u64 = 11045;
        const write_count: u64 = 14036;
        const offset: mem.Amount = .{ .count = 6657 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStreamView(@sizeOf(child), (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_12: child = array.readOneBehind(child);
        const ret_13: child = array.readOneAhead(child);
        const ret_14: [read_count]child = array.readCountBehind(child, read_count);
        const ret_15: []const child = array.readManyBehind(child, offset);
        const ret_16: [read_count]child = array.readCountAhead(child, read_count);
        const ret_17: []const child = array.readManyAhead(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(child, read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(child, offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(child, read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(child, read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // UnstructuredStreamView
    { // UnstructuredVector
        const child: type = u16;
        const value: child = 11812;
        const read_count: u64 = 7083;
        const write_count: u64 = 21690;
        const offset: mem.Amount = .{ .count = 33491 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredVector(@sizeOf(child), (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_4: []child = array.referAllUndefined(child);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // UnstructuredVector
    { // UnstructuredView
        const child: type = u16;
        const value: child = 8897;
        const read_count: u64 = 27647;
        const write_count: u64 = 63634;
        const offset: mem.Amount = .{ .count = 43237 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredView(@sizeOf(child), (read_count + write_count));
        var array: Array = try Array.init(&allocator, random.readOne(u16));
        const ret_0: []const child = array.readAll(child);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, value);
        const ret_2: []child = array.referAllDefined(child);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, value);
        const ret_6: child = array.readOneAt(child, offset);
        const ret_7: [read_count]child = array.readCountAt(child, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, offset, value);
        const ret_26: *child = array.referOneAt(child, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, offset, read_count);
        const ret_28: []child = array.referManyAt(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, offset, value);
        const ret_39: void = array.overwriteCountAt(child, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, offset, &values);
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_18;
        _ = ret_19;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_32;
        _ = ret_33;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
    } // UnstructuredView
    { // StructuredStreamHolder
        const child: type = u16;
        const value: child = 28064;
        const read_count: u64 = 13362;
        const write_count: u64 = 38903;
        const offset: u64 = 32045;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredStreamHolder(child);
        var array: Array = Array.init(&allocator);
        const ret_0: []const child = array.readAll(allocator);
        const ret_1: [:value]const child = array.readAllWithSentinel(allocator, value);
        const ret_2: []child = array.referAllDefined(allocator);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(allocator, value);
        const ret_4: []child = array.referAllUndefined(allocator);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(allocator, value);
        const ret_6: child = array.readOneAt(allocator, offset);
        const ret_7: [read_count]child = array.readCountAt(allocator, offset, read_count);
        const ret_8: []const child = array.readManyAt(allocator, offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_12: child = array.readOneBehind();
        const ret_13: child = array.readOneAhead();
        const ret_14: [read_count]child = array.readCountBehind(read_count);
        const ret_15: []const child = array.readManyBehind(offset);
        const ret_16: [read_count]child = array.readCountAhead(read_count);
        const ret_17: []const child = array.readManyAhead(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(allocator, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(allocator, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(offset, value);
        const ret_26: *child = array.referOneAt(allocator, offset);
        const ret_27: *[read_count]child = array.referCountAt(allocator, offset, read_count);
        const ret_28: []child = array.referManyAt(allocator, offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(allocator, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(allocator, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(offset, value);
        const ret_38: void = array.overwriteOneAt(allocator, offset, value);
        const ret_39: void = array.overwriteCountAt(allocator, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(allocator, offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // StructuredStreamHolder
    { // StructuredHolder
        const child: type = u16;
        const value: child = 7606;
        const read_count: u64 = 18853;
        const write_count: u64 = 26502;
        const offset: u64 = 33537;
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.StructuredHolder(child);
        var array: Array = Array.init(&allocator);
        const ret_0: []const child = array.readAll(allocator);
        const ret_1: [:value]const child = array.readAllWithSentinel(allocator, value);
        const ret_2: []child = array.referAllDefined(allocator);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(allocator, value);
        const ret_4: []child = array.referAllUndefined(allocator);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(allocator, value);
        const ret_6: child = array.readOneAt(allocator, offset);
        const ret_7: [read_count]child = array.readCountAt(allocator, offset, read_count);
        const ret_8: []const child = array.readManyAt(allocator, offset);
        const ret_9: child = array.readOneBack();
        const ret_10: [read_count]child = array.readCountBack(read_count);
        const ret_11: []const child = array.readManyBack(offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(allocator, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(allocator, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(offset, value);
        const ret_26: *child = array.referOneAt(allocator, offset);
        const ret_27: *[read_count]child = array.referCountAt(allocator, offset, read_count);
        const ret_28: []child = array.referManyAt(allocator, offset);
        const ret_29: *child = array.referOneBack();
        const ret_30: *[read_count]child = array.referCountBack(read_count);
        const ret_31: []child = array.referManyBack(offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(allocator, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(allocator, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(offset, value);
        const ret_38: void = array.overwriteOneAt(allocator, offset, value);
        const ret_39: void = array.overwriteCountAt(allocator, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(allocator, offset, &values);
        const ret_41: void = array.overwriteOneBack(value);
        const ret_42: void = array.overwriteManyBack(&values);
        const ret_43: void = array.overwriteCountBack(write_count, values);
        const ret_44: void = array.writeOne(value);
        const ret_45: void = array.writeCount(write_count, values);
        const ret_46: void = array.writeMany(&values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // StructuredHolder
    { // UnstructuredStreamHolder
        const child: type = u16;
        const value: child = 62809;
        const read_count: u64 = 41135;
        const write_count: u64 = 45409;
        const offset: mem.Amount = .{ .count = 27676 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredStreamHolder(@sizeOf(child), (read_count + write_count));
        var array: Array = Array.init(&allocator);
        const ret_0: []const child = array.readAll(child, allocator);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, allocator, value);
        const ret_2: []child = array.referAllDefined(child, allocator);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, allocator, value);
        const ret_4: []child = array.referAllUndefined(child, allocator);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, allocator, value);
        const ret_6: child = array.readOneAt(child, allocator, offset);
        const ret_7: [read_count]child = array.readCountAt(child, allocator, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, allocator, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_12: child = array.readOneBehind(child);
        const ret_13: child = array.readOneAhead(child);
        const ret_14: [read_count]child = array.readCountBehind(child, read_count);
        const ret_15: []const child = array.readManyBehind(child, offset);
        const ret_16: [read_count]child = array.readCountAhead(child, read_count);
        const ret_17: []const child = array.readManyAhead(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, allocator, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, allocator, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_22: [read_count:value]child = array.readCountWithSentinelBehind(child, read_count, value);
        const ret_23: [:value]const child = array.readManyWithSentinelBehind(child, offset, value);
        const ret_24: [read_count:value]child = array.readCountWithSentinelAhead(child, read_count, value);
        const ret_25: [:value]const child = array.readManyWithSentinelAhead(child, offset, value);
        const ret_26: *child = array.referOneAt(child, allocator, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, allocator, offset, read_count);
        const ret_28: []child = array.referManyAt(child, allocator, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, allocator, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, allocator, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_36: *[read_count:value]child = array.referCountWithSentinelBehind(child, read_count, value);
        const ret_37: [:value]child = array.referManyWithSentinelBehind(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, allocator, offset, value);
        const ret_39: void = array.overwriteCountAt(child, allocator, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, allocator, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_12;
        _ = ret_13;
        _ = ret_14;
        _ = ret_15;
        _ = ret_16;
        _ = ret_17;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_22;
        _ = ret_23;
        _ = ret_24;
        _ = ret_25;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_36;
        _ = ret_37;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // UnstructuredStreamHolder
    { // UnstructuredHolder
        const child: type = u16;
        const value: child = 49238;
        const read_count: u64 = 9686;
        const write_count: u64 = 16107;
        const offset: mem.Amount = .{ .count = 17374 };
        const values: [write_count]child = random.readCount(child, write_count);
        var allocator: Allocator = try Allocator.init(&address_space);
        defer allocator.deinit(&address_space);
        const Array: type = Allocator.UnstructuredHolder(@sizeOf(child), (read_count + write_count));
        var array: Array = Array.init(&allocator);
        const ret_0: []const child = array.readAll(child, allocator);
        const ret_1: [:value]const child = array.readAllWithSentinel(child, allocator, value);
        const ret_2: []child = array.referAllDefined(child, allocator);
        const ret_3: [:value]child = array.referAllDefinedWithSentinel(child, allocator, value);
        const ret_4: []child = array.referAllUndefined(child, allocator);
        const ret_5: [:value]child = array.referAllUndefinedWithSentinel(child, allocator, value);
        const ret_6: child = array.readOneAt(child, allocator, offset);
        const ret_7: [read_count]child = array.readCountAt(child, allocator, offset, read_count);
        const ret_8: []const child = array.readManyAt(child, allocator, offset);
        const ret_9: child = array.readOneBack(child);
        const ret_10: [read_count]child = array.readCountBack(child, read_count);
        const ret_11: []const child = array.readManyBack(child, offset);
        const ret_18: [read_count:value]child = array.readCountWithSentinelAt(child, allocator, offset, read_count, value);
        const ret_19: [:value]const child = array.readManyWithSentinelAt(child, allocator, offset, value);
        const ret_20: [read_count:value]child = array.readCountWithSentinelBack(child, read_count, value);
        const ret_21: [:value]const child = array.readManyWithSentinelBack(child, offset, value);
        const ret_26: *child = array.referOneAt(child, allocator, offset);
        const ret_27: *[read_count]child = array.referCountAt(child, allocator, offset, read_count);
        const ret_28: []child = array.referManyAt(child, allocator, offset);
        const ret_29: *child = array.referOneBack(child);
        const ret_30: *[read_count]child = array.referCountBack(child, read_count);
        const ret_31: []child = array.referManyBack(child, offset);
        const ret_32: *[read_count:value]child = array.referCountWithSentinelAt(child, allocator, offset, read_count, value);
        const ret_33: [:value]child = array.referManyWithSentinelAt(child, allocator, offset, value);
        const ret_34: *[read_count:value]child = array.referCountWithSentinelBack(child, read_count, value);
        const ret_35: [:value]child = array.referManyWithSentinelBack(child, offset, value);
        const ret_38: void = array.overwriteOneAt(child, allocator, offset, value);
        const ret_39: void = array.overwriteCountAt(child, allocator, offset, write_count, values);
        const ret_40: void = array.overwriteManyAt(child, allocator, offset, &values);
        const ret_41: void = array.overwriteOneBack(child, value);
        const ret_42: void = array.overwriteManyBack(child, &values);
        const ret_43: void = array.overwriteCountBack(child, write_count, values);
        const ret_44: void = array.writeOne(child, value);
        const ret_45: void = array.writeCount(child, write_count, values);
        const ret_46: void = array.writeMany(child, &values);
        const ret_51: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
        const ret_52: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
        const ret_53: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
        _ = ret_0;
        _ = ret_1;
        _ = ret_2;
        _ = ret_3;
        _ = ret_4;
        _ = ret_5;
        _ = ret_6;
        _ = ret_7;
        _ = ret_8;
        _ = ret_9;
        _ = ret_10;
        _ = ret_11;
        _ = ret_18;
        _ = ret_19;
        _ = ret_20;
        _ = ret_21;
        _ = ret_26;
        _ = ret_27;
        _ = ret_28;
        _ = ret_29;
        _ = ret_30;
        _ = ret_31;
        _ = ret_32;
        _ = ret_33;
        _ = ret_34;
        _ = ret_35;
        _ = ret_38;
        _ = ret_39;
        _ = ret_40;
        _ = ret_41;
        _ = ret_42;
        _ = ret_43;
        _ = ret_44;
        _ = ret_45;
        _ = ret_46;
        _ = try ret_51;
        _ = try ret_52;
        _ = try ret_53;
    } // UnstructuredHolder
}
