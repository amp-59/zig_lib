//! This stage generates reference implementations
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const meta = @import("./../meta.zig");
const mach = @import("./../mach.zig");
const proc = @import("./../proc.zig");
const preset = @import("./../preset.zig");
const testing = @import("./../testing.zig");
const builtin = @import("./../builtin.zig");

const config = @import("./config.zig");
const gen = struct {
    usingnamespace @import("./gen.zig");

    usingnamespace @import("./gen-0.zig");
    usingnamespace @import("./gen-1.zig");
    usingnamespace @import("./gen-2.zig");

    usingnamespace @import("./abstract_params.zig");
    usingnamespace @import("./type_specs.zig");
    usingnamespace @import("./impl_variants.zig");
};
const Array = mem.StaticString(1024 * 1024);
const fmt_spec = .{
    .omit_default_fields = true,
    .infer_type_names = true,
    .omit_trailing_comma = true,
};
const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 3
    \\const mach = @import("./../mach.zig");
    \\
;

// zig fmt: off
const key: [18]Fn = .{
    .{ .tag = .define,                      .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .seek,                        .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .undefine,                    .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .tell,                        .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .allocated_byte_address,      .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .aligned_byte_address,        .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .unstreamed_byte_address,     .val = .Address,    .loc = .Relative, .mut = .Immutable },
    .{ .tag = .undefined_byte_address,      .val = .Address,    .loc = .Relative, .mut = .Immutable },
    .{ .tag = .unwritable_byte_address,     .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .unallocated_byte_address,    .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .allocated_byte_count,        .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .aligned_byte_count,          .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .streamed_byte_count,         .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .unstreamed_byte_count,       .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .writable_byte_count,         .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .undefined_byte_count,        .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .defined_byte_count,          .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .alignment,                   .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
};
// zig fmt: on

const word_type_name: [:0]const u8 = "u64";
const impl_name: [:0]const u8 = "impl";
const impl_type_name: [:0]const u8 = "Implementation";
const impl_ptr_type_name: [:0]const u8 = "*" ++ impl_type_name;
const impl_const_ptr_type_name: [:0]const u8 = "*const " ++ impl_type_name;
const impl_param: [:0]const u8 = impl_name ++ ": " ++ impl_ptr_type_name;
const impl_const_param: [:0]const u8 = impl_name ++ ": " ++ impl_const_ptr_type_name;
const slave_name: [:0]const u8 = "allocator";
const slave_type_name: [:0]const u8 = "spec.Allocator";
const slave_param: [:0]const u8 = slave_name ++ ": " ++ slave_type_name;
const offset_bytes_name: [:0]const u8 = "x_bytes";
const offset_bytes_param: [:0]const u8 = offset_bytes_name ++ ": " ++ word_type_name;
const automatic_storage_field_name: [:0]const u8 = "auto";
const allocated_byte_address_word_field_name: [:0]const u8 = "lb_word";
const unstreamed_byte_address_word_field_name: [:0]const u8 = "ss_word";
const undefined_byte_address_word_field_name: [:0]const u8 = "ub_word";
const unallocated_byte_address_word_field_name: [:0]const u8 = "up_word";
const automatic_storage_access: [:0]const u8 = impl_name ++ "." ++ automatic_storage_field_name;
const allocated_byte_address_word_access: [:0]const u8 = impl_name ++ "." ++ allocated_byte_address_word_field_name;
const unstreamed_byte_address_word_access: [:0]const u8 = impl_name ++ "." ++ unstreamed_byte_address_word_field_name;
const undefined_byte_address_word_access: [:0]const u8 = impl_name ++ "." ++ undefined_byte_address_word_field_name;
const unallocated_byte_address_word_access: [:0]const u8 = impl_name ++ "." ++ unallocated_byte_address_word_field_name;
const automatic_storage_ptr: [:0]const u8 = impl_name ++ "&" ++ automatic_storage_access;
const allocated_byte_address_word_ptr: [:0]const u8 = "&" ++ allocated_byte_address_word_access;
const undefined_byte_address_word_ptr: [:0]const u8 = "&" ++ undefined_byte_address_word_access;
const unstreamed_byte_address_word_ptr: [:0]const u8 = "&" ++ unstreamed_byte_address_word_access;
const unallocated_byte_address_word_ptr: [:0]const u8 = "&" ++ unallocated_byte_address_word_access;
const allocated_byte_address_word_field: [:0]const u8 = allocated_byte_address_word_field_name ++ ": " ++ word_type_name;
const unstreamed_byte_address_word_field: [:0]const u8 = unstreamed_byte_address_word_field_name ++ ": " ++ word_type_name;
const undefined_byte_address_word_field: [:0]const u8 = undefined_byte_address_word_field_name ++ ": " ++ word_type_name;
const unallocated_byte_address_word_field: [:0]const u8 = unallocated_byte_address_word_field_name ++ ": " ++ word_type_name;

const return_keyword: [:0]const u8 = "return ";
const end_expression: [:0]const u8 = ";\n";

const allocated_byte_address_alignment_name: [:0]const u8 = "spec.low_alignment";
const unwritable_byte_address_alignment_name: [:0]const u8 = "spec.high_alignment";

const Fn = struct {
    tag: Tag,
    val: Value,
    loc: Location,
    mut: Mutability,
    const Tag = enum {
        define,
        seek,
        undefine,
        tell,
        allocated_byte_address,
        aligned_byte_address,
        unstreamed_byte_address,
        undefined_byte_address,
        unwritable_byte_address,
        unallocated_byte_address,
        allocated_byte_count,
        aligned_byte_count,
        streamed_byte_count,
        unstreamed_byte_count,
        writable_byte_count,
        undefined_byte_count,
        defined_byte_count,
        alignment,
    };
    const Value = enum {
        Address,
        Offset,
    };
    const Location = enum {
        Relative,
        Absolute,
    };
    const Mutability = enum {
        Mutable,
        Immutable,
    };
    fn fnName(impl_fn_info: *const Fn) []const u8 {
        return @tagName(impl_fn_info.tag);
    }
};
fn get(comptime tag: Fn.Tag) *const Fn {
    comptime {
        for (key) |val| {
            if (val.tag == tag) return &val;
        }
        unreachable;
    }
}
const Operand = union(enum) {
    constant: usize,
    symbol: [:0]const u8,
    add_op: *const AddOp,
    align_above_op: *const AlignAboveOp,
    align_below_op: *const AlignBelowOp,
    and_op: *const AndOp,
    and_not_op: *const AndNotOp,
    conditional_move_op: *const ConditionalMoveOp,
    multiply_op: *const MultiplyOp,
    or_op: *const OrOp,
    shift_left_op: *const ShiftLeftOp,
    shift_right_op: *const ShiftRightOp,
    subtract_op: *const SubtractOp,
    call: *const FnCall,
    const Format = @This();
    pub fn formatWrite(format: Format, array: anytype) void {
        switch (format) {
            .constant => |constant| array.writeFormat(fmt.ud(constant)),
            .symbol => |symbol| array.writeMany(symbol),
            .add_op => |add_op| add_op.formatWrite(array),
            .align_above_op => |align_above_op| align_above_op.formatWrite(array),
            .align_below_op => |align_below_op| align_below_op.formatWrite(array),
            .and_op => |and_op| and_op.formatWrite(array),
            .and_not_op => |and_not_op| and_not_op.formatWrite(array),
            .conditional_move_op => |conditional_move_op| conditional_move_op.formatWrite(array),
            .multiply_op => |multiply_op| multiply_op.formatWrite(array),
            .or_op => |or_op| or_op.formatWrite(array),
            .shift_left_op => |shift_left_op| shift_left_op.formatWrite(array),
            .shift_right_op => |shift_right_op| shift_right_op.formatWrite(array),
            .subtract_op => |subtract_op| subtract_op.formatWrite(array),
            .call => |call| call.formatWrite(array),
        }
    }
};
pub fn formatWriteToken(op1: Operand, op2: Operand, array: anytype, fn_token: [:0]const u8) void {
    array.writeMany(fn_token);
    array.writeMany("(");
    array.writeFormat(op1);
    array.writeMany(", ");
    array.writeFormat(op2);
    array.writeMany(")");
}
const AddEquOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token = "mach.addEqu64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const SubEquOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token = "mach.subEqu64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const AddOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token = "mach.add64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const AlignAboveOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.alignA64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const AlignBelowOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.alignB64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const AndOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.and64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const AndNotOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.andn64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const ConditionalMoveOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.cmov64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const MultiplyOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.mul64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const OrOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.or64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const ShiftLeftOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.shl64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const ShiftRightOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.shr64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const SubtractOp = struct {
    op1: Operand,
    op2: Operand,
    const Format = @This();
    const fn_token: [:0]const u8 = "mach.sub64";
    pub inline fn formatWrite(format: Format, array: anytype) void {
        return formatWriteToken(format.op1, format.op2, array, fn_token);
    }
};
const FnCall = struct {
    impl_variant: *const gen.DetailExtra,
    impl_fn_info: *const Fn,
    const Format = @This();
    pub fn formatWrite(format: Format, array: anytype) void {
        writeFnSignatureOrCall(array, format.impl_variant, format.impl_fn_info, false);
    }
};
fn writeComma(array: *Array) void {
    const j0: bool = mem.testEqualOneBack(u8, '(', array.readAll());
    const j1: bool = mem.testEqualManyBack(u8, ", ", array.readAll());
    if (builtin.int2a(bool, !j0, !j1)) {
        array.writeMany(", ");
    }
}
fn writeArgument(array: *Array, argument_name: [:0]const u8) void {
    writeComma(array);
    array.writeMany(argument_name);
}
fn writeCallOffsetOf(comptime type_name: [:0]const u8, comptime field_name: [:0]const u8) [:0]const u8 {
    return "@offsetOf(" ++ type_name ++ ", \"" ++ field_name ++ "\")";
}
fn writeCallPtrToInt(comptime symbol_ptr: [:0]const u8) [:0]const u8 {
    return "@ptrToInt(" ++ symbol_ptr ++ ")";
}
fn writeCallAutomaticStorageAddress(array: *Array) void {
    array.writeMany("automatic_storage_address(" ++ impl_name ++ ")" ++ end_expression);
}
fn writeCallAllocatorUnallocatedByteAddress(array: *Array) void {
    array.writeMany();
}

fn writeFnSignatureOrCall(array: *Array, impl_variant: *const gen.DetailExtra, impl_fn_info: *const Fn, sign: bool) void {
    if (sign) array.writeMany("pub inline fn ");
    array.writeMany(impl_fn_info.fnName());
    array.writeMany("(");
    if (impl_fn_info.mut == .Mutable) {
        writeArgument(array, if (sign) impl_param else impl_name);
    } else if (impl_variant.kind.parametric) {
        if (impl_fn_info.loc == .Absolute) {
            if (impl_fn_info.val == .Address) {
                writeArgument(array, if (sign) slave_param else slave_name);
            }
            if (impl_fn_info.val == .Offset) {
                writeArgument(array, mach.cmovx(sign, impl_const_param, impl_name));
                writeArgument(array, mach.cmovx(sign, slave_param, slave_name));
            }
        } else {
            writeArgument(array, mach.cmovx(sign, impl_const_param, impl_name));
        }
    } else {
        writeArgument(array, mach.cmovx(sign, impl_const_param, impl_name));
    }
    if (impl_fn_info.mut == .Mutable) {
        if (sign) writeArgument(array, offset_bytes_param);
    }
    if (impl_fn_info.mut == .Mutable) {
        array.writeMany(if (sign) ") void " else ")");
    } else {
        array.writeMany(if (sign) ") u64 " else ")");
    }
}
inline fn writeFnCallGeneric(array: *Array, impl_variant: *const gen.DetailExtra, impl_fn_info: *const Fn) void {
    writeFnSignatureOrCall(array, impl_variant, impl_fn_info, false);
}
inline fn writeFnSignatureGeneric(array: *Array, impl_variant: *const gen.DetailExtra, impl_fn_info: *const Fn) void {
    writeFnSignatureOrCall(array, impl_variant, impl_fn_info, true);
}
fn writeFnBodyGeneric(array: *Array, impl_variant: *const gen.DetailExtra, impl_fn_info: *const Fn) void {
    // Should the reader find inconsistencies in the following logical
    // structures (such as duplicating write operating in an inner scope, when
    // that write would have identical semantics and result in fewer lines of
    // code if moved to an outer scope), the reason is simple: at the time of
    // writing, the chosen method resulted in a smaller binary.
    const allocated_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.allocated_byte_address),
    };
    const aligned_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.aligned_byte_address),
    };
    const unstreamed_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unstreamed_byte_address),
    };
    const undefined_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.undefined_byte_address),
    };
    const unwritable_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unwritable_byte_address),
    };
    const unallocated_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unallocated_byte_address),
    };
    _ = unallocated_byte_address;
    const allocated_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.allocated_byte_count),
    };
    _ = allocated_byte_count;
    const aligned_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.aligned_byte_count),
    };
    _ = aligned_byte_count;
    const streamed_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.streamed_byte_count),
    };
    _ = streamed_byte_count;
    const unstreamed_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unstreamed_byte_count),
    };
    _ = unstreamed_byte_count;
    const writable_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.writable_byte_count),
    };
    _ = writable_byte_count;
    const undefined_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.undefined_byte_count),
    };
    _ = undefined_byte_count;
    const defined_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.defined_byte_count),
    };
    _ = defined_byte_count;
    const alignment: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.alignment),
    };
    const subtract_op_1: SubtractOp = .{
        .op1 = .{ .symbol = allocated_byte_address_alignment_name },
        .op2 = .{ .constant = 1 },
    };
    const shift_left_op_65535_48: ShiftLeftOp = .{
        .op1 = .{ .constant = 65535 },
        .op2 = .{ .constant = 48 },
    };
    const shift_right_op_lb_16: ShiftRightOp = .{
        .op1 = .{ .symbol = allocated_byte_address_word_access },
        .op2 = .{ .constant = 16 },
    };
    const shift_right_op_ub_16: ShiftRightOp = .{
        .op1 = .{ .symbol = undefined_byte_address_word_access },
        .op2 = .{ .constant = 16 },
    };
    switch (impl_fn_info.tag) {
        .define => {
            array.writeFormat(AddEquOp{
                .op1 = .{ .symbol = undefined_byte_address_word_ptr },
                .op2 = .{ .symbol = offset_bytes_name },
            });
            return array.writeMany(end_expression);
        },
        .undefine => {
            array.writeFormat(SubEquOp{
                .op1 = .{ .symbol = undefined_byte_address_word_ptr },
                .op2 = .{ .symbol = offset_bytes_name },
            });
            return array.writeMany(end_expression);
        },
        .seek => {
            array.writeFormat(AddEquOp{
                .op1 = .{ .symbol = unstreamed_byte_address_word_ptr },
                .op2 = .{ .symbol = offset_bytes_name },
            });
            return array.writeMany(end_expression);
        },
        .tell => {
            array.writeFormat(SubEquOp{
                .op1 = .{ .symbol = unstreamed_byte_address_word_ptr },
                .op2 = .{ .symbol = offset_bytes_name },
            });
            return array.writeMany(end_expression);
        },
        .allocated_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.isAutomatic()) {
                array.writeFormat(AddOp{
                    .op1 = .{ .symbol = writeCallPtrToInt(impl_name) },
                    .op2 = .{ .symbol = writeCallOffsetOf(impl_type_name, automatic_storage_field_name) },
                });
                return array.writeMany(end_expression);
            }
            if (impl_variant.isParametric()) {
                array.writeMany(slave_name ++ ".unallocated_byte_address()");
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasPackedApproximateCapacity()) {
                if (config.packed_capacity_low) {
                    array.writeFormat(shift_right_op_lb_16);
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(AndNotOp{
                        .op1 = .{ .symbol = allocated_byte_address_word_access },
                        .op2 = .{ .shift_left_op = &shift_left_op_65535_48 },
                    });
                    return array.writeMany(end_expression);
                }
            }
            if (impl_variant.hasDisjunctAlignment()) {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &aligned_byte_address },
                    .op2 = .{ .call = &alignment },
                });
                return array.writeMany(end_expression);
            }
            array.writeMany(allocated_byte_address_word_access);
            return array.writeMany(end_expression);
        },
        .aligned_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.hasUnitAlignment()) {
                array.writeFormat(allocated_byte_address);
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasLazyAlignment()) {
                array.writeFormat(AlignAboveOp{
                    .op1 = .{ .call = &allocated_byte_address },
                    .op2 = .{ .symbol = allocated_byte_address_alignment_name },
                });
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasDisjunctAlignment()) {
                if (impl_variant.hasPackedApproximateCapacity()) {
                    if (config.packed_capacity_low) {
                        array.writeFormat(AndNotOp{
                            .op1 = .{ .shift_right_op = &shift_right_op_lb_16 },
                            .op2 = .{ .subtract_op = &subtract_op_1 },
                        });
                        return array.writeMany(end_expression);
                    } else {
                        const or_op: OrOp = .{
                            .op1 = .{ .subtract_op = &subtract_op_1 },
                            .op2 = .{ .shift_left_op = &shift_left_op_65535_48 },
                        };
                        array.writeFormat(AndNotOp{
                            .op1 = .{ .symbol = allocated_byte_address_word_access },
                            .op2 = .{ .or_op = &or_op },
                        });
                        return array.writeMany(end_expression);
                    }
                } else {
                    array.writeFormat(AndNotOp{
                        .op1 = .{ .symbol = allocated_byte_address_word_access },
                        .op2 = .{ .subtract_op = &subtract_op_1 },
                    });
                    return array.writeMany(end_expression);
                }
            }
            if (impl_variant.isParametric()) {
                if (impl_variant.hasLazyAlignment()) {
                    array.writeFormat(AlignAboveOp{
                        .op1 = .{ .symbol = slave_name ++ ".unallocated_byte_address()" },
                        .op2 = .{ .symbol = allocated_byte_address_alignment_name },
                    });
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(allocated_byte_address);
                    return array.writeMany(end_expression);
                }
            }
        },
        .unstreamed_byte_address => {
            // ss_word
        },
        .undefined_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.techs.double_packed_approximate_capacity) {
                if (config.packed_capacity_low) {
                    array.writeFormat(shift_right_op_ub_16);
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(AndNotOp{
                        .op1 = .{ .symbol = undefined_byte_address_word_access },
                        .op2 = .{ .shift_left_op = &shift_left_op_65535_48 },
                    });
                    return array.writeMany(end_expression);
                }
            } else if (impl_variant.isAutomatic()) {
                array.writeFormat(AddOp{
                    .op1 = .{ .call = &allocated_byte_address },
                    .op2 = .{ .symbol = undefined_byte_address_word_access },
                });
                return array.writeMany(end_expression);
            } else {
                array.writeMany(undefined_byte_address_word_access);
                return array.writeMany(end_expression);
            }
        },
        .unallocated_byte_address => {
            // up_word
            const _unallocated_byte_address = .{
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .single_packed_approximate_capacity = .Ignore,
                        .double_packed_approximate_capacity = .Ignore,
                    },
                    .blk = 
                    \\        pub inline fn unallocated_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(allocated_byte_address(impl), allocated_byte_count(impl));
                    else
                        \\            return allocated_byte_address(impl) +% allocated_byte_count(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Forbid },
                },
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .techs = .{
                        .unit_alignment = "permit_alignment",
                        .auto_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn unallocated_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(allocated_byte_address(impl), allocated_byte_count());
                    else
                        \\            return allocated_byte_address(impl) +% allocated_byte_count();
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Require },
                },
                .{
                    .fields = .{ .auto = .Ignore, .lb_word = .Ignore, .ub_word = .Ignore },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn unallocated_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(allocated_byte_address(impl), allocated_byte_count(impl));
                    else
                        \\            return allocated_byte_address(impl) +% allocated_byte_count(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Ignore, .up_word = .Require },
                    .techs = "any_techs",
                    .blk =
                    \\        pub inline fn unallocated_byte_address(impl: *const Implementation) u64 {
                    \\            return impl.up_word;
                    \\        }
                    \\
                    ,
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Require },
                    .techs = .{
                        .parametric_read = "permit_parametric",
                        .parametric = "permit_parametric",
                    },
                    .blk = if (config.minimise_indirection and false)
                        \\        pub const unallocated_byte_address: Slave = Allocator.finish;
                        \\
                    else
                        \\        pub inline fn unallocated_byte_address(allocator: Allocator) u64 {
                        \\            return allocator.unmapped_byte_address();
                        \\        }
                        \\
                        ,
                },
            };
            _ = _unallocated_byte_address;
        },
        .unwritable_byte_address => {
            // unallocated_byte_address() - high_alignment
            const _unwritable_byte_address = .{
                .{
                    .fields = .{ .auto = .Ignore, .lb_word = .Ignore, .ub_word = .Ignore },
                    .techs = "any_techs",
                    .blk = 
                    \\        pub inline fn unwritable_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(aligned_byte_address(impl), writable_byte_count());
                    else
                        \\            return aligned_byte_address(impl) +% writable_byte_count();
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = "permit_factor", .bytes = "permit_factor" },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = "any_techs",
                    .blk = 
                    \\        pub inline fn unwritable_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(aligned_byte_address(impl), writable_byte_count(impl));
                    else
                        \\            return aligned_byte_address(impl) +% writable_byte_count(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Forbid, .bytes = .Forbid },
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Require },
                    .techs = .{
                        .parametric = "permit_parametric",
                        .parametric_read = "permit_parametric",
                    },
                    .blk = if (config.minimise_indirection)
                        \\        pub const unwritable_byte_address: Slave = unallocated_byte_address;
                        \\
                    else
                        \\        pub inline fn unwritable_byte_address(allocator: Allocator) u64 {
                        \\            return unallocated_byte_address(allocator);
                        \\        }
                        \\
                        ,
                    .specs = .{ .sentinel = .Forbid },
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Require },
                    .techs = .{
                        .parametric = "permit_parametric",
                        .parametric_read = "permit_parametric",
                    },
                    .blk = 
                    \\        pub inline fn unwritable_byte_address(allocator: Allocator) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(allocator.unmapped_byte_address(), high_alignment);
                    else
                        \\            return allocator.unmapped_byte_address() -% high_alignment;
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .sentinel = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Ignore, .up_word = .Require },
                    .techs = "any_techs",
                    .blk =
                    \\        pub inline fn unwritable_byte_address(impl: *const Implementation) u64 {
                    \\            return impl.up_word;
                    \\        }
                    \\
                    ,
                    .specs = .{ .sentinel = .Forbid },
                },
                .{
                    .fields = .{ .lb_word = .Ignore, .ub_word = .Ignore, .up_word = .Require },
                    .techs = "any_techs",
                    .blk = 
                    \\        pub inline fn unwritable_byte_address(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(impl.up_word, high_alignment);
                    else
                        \\            return impl.up_word -% high_alignment;
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .child = .Require, .sentinel = .Require },
                },
            };
            _ = _unwritable_byte_address;
        },
        .allocated_byte_count => {
            // unallocated_byte_address() - allocated_byte_address()
            if (impl_variant.isAutomatic()) {
                //
            } else if (impl_variant.isStatic()) {
                if (impl_variant.hasUnitAlignment()) {
                    //
                } else {
                    //
                }
            } else if (impl_variant.isParametric()) {
                //
            } else {
                //
            }
            const _allocated_byte_count = .{
                // aligned_byte_count()
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .techs = .{
                        .unit_alignment = "permit_alignment",
                        .auto_alignment = "permit_alignment",
                    },
                    .blk = if (config.minimise_indirection)
                        \\        pub const allocated_byte_count: Static = aligned_byte_count;
                        \\
                    else
                        \\        pub inline fn allocated_byte_count() u64 {
                        \\            return aligned_byte_count();
                        \\        }
                        \\
                        ,
                    .specs = .{ .count = "permit_factor", .bytes = "permit_factor" },
                },
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .techs = .{
                        .unit_alignment = "permit_alignment",
                        .auto_alignment = "permit_alignment",
                    },
                    .blk = if (config.minimise_indirection)
                        \\        pub const allocated_byte_count: Static = aligned_byte_count;
                        \\
                    else
                        \\        pub inline fn allocated_byte_count() u64 {
                        \\            return aligned_byte_count();
                        \\        }
                        \\
                        ,
                    .specs = .{ .count = .Require, .child = .Require, .sentinel = .Require },
                },

                // alignment(impl) + aligned_byte_count()
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(alignment(impl), aligned_byte_count());
                    else
                        \\            return alignment(impl) +% aligned_byte_count();
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = "permit_factor", .bytes = "permit_factor" },
                },
                .{
                    .fields = .{ .lb_word = .Require },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(alignment(impl), aligned_byte_count());
                    else
                        \\            return alignment(impl) +% aligned_byte_count();
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .high_alignment = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(alignment(impl), aligned_byte_count());
                    else
                        \\            return alignment(impl) +% aligned_byte_count();
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Require, .child = .Require, .sentinel = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{ .single_packed_approximate_capacity = .Require },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                        ++ (if (config.prefer_operator_wrapper)
                            \\            return mach.add64(alignment(impl), algo.unpackSingleApproxB(impl.lb_word));
                        else
                            \\            return alignment(impl) +% algo.unpackSingleApproxB(impl.lb_word);
                        ) ++
                            \\        }
                            \\
                    else
                        \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                        ++ (if (config.prefer_operator_wrapper)
                            \\            return mach.add64(alignment(impl), algo.unpackSingleApproxA(impl.lb_word));
                        else
                            \\            return alignment(impl) +% algo.unpackSingleApproxA(impl.lb_word);
                        ) ++
                            \\        }
                            \\
                        ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{ .unit_alignment = .Require, .single_packed_approximate_capacity = .Require },
                    .blk = if (config.minimise_indirection)
                        "        const allocated_byte_count: " ++ "value_type_name" ++ " = aligned_byte_count;\n"
                    else
                        \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                        \\            return aligned_byte_count(impl);
                        \\        }
                        \\
                        ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Require },
                    .techs = .{ .double_packed_approximate_capacity = .Require },
                    .blk = 
                    \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.add64(alignment(impl), aligned_byte_count(impl));
                    else
                        \\            return alignment(impl) +% aligned_byte_count(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Require },
                    .techs = .{ .unit_alignment = .Require, .double_packed_approximate_capacity = .Require },
                    .blk = if (config.minimise_indirection)
                        "        const allocated_byte_count: " ++ "value_type_name" ++ " = aligned_byte_count;\n"
                    else
                        \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                        \\            return aligned_byte_count(impl);
                        \\        }
                        \\
                        ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = "any_techs",
                    .blk = 
                    \\        pub inline fn allocated_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unallocated_byte_address(impl), allocated_byte_address(impl));
                    else
                        \\            return unallocated_byte_address(impl) -% allocated_byte_address(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .ub_word = .Require },
                    .techs = .{ .parametric = .Require },
                    .blk = 
                    \\        pub inline fn allocated_byte_count(allocator: Allocator) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unallocated_byte_address(allocator), allocated_byte_address(allocator));
                    else
                        \\            return unallocated_byte_address(allocator) -% allocated_byte_address(allocator);
                    ) ++
                        \\        }
                        \\
                    ,
                },
            };
            _ = _allocated_byte_count;
        },
        .aligned_byte_count => {
            // unallocated_byte_address() - aligned_byte_address()
            const _aligned_byte_count = .{
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .blk = if (config.minimise_indirection)
                        "        pub const aligned_byte_count: " ++ "static_type_name" ++ " = writable_byte_count;\n"
                    else
                        \\        pub inline fn aligned_byte_count() u64 {
                        \\            return writable_byte_count();
                        \\        }
                        \\
                        ,
                    .specs = .{ .count = "permit_factor", .bytes = "permit_factor" },
                },
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .blk = 
                    \\        pub inline fn aligned_byte_count() u64 {
                    ++ (if (config.packed_capacity_low)
                        \\            return mach.add64(writable_byte_count(), high_alignment);
                    else
                        \\            return writable_byte_count() +% high_alignment;
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .count = .Require, .child = .Require, .sentinel = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{ .single_packed_approximate_capacity = .Require },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn aligned_byte_count(impl: *const Implementation) u64 {
                        \\            return algo.unpackSingleApproxB(impl.lb_word);
                        \\        }
                        \\
                    else
                        \\        pub inline fn aligned_byte_count(impl: *const Implementation) u64 {
                        \\            return algo.unpackSingleApproxA(impl.lb_word);
                        \\        }
                        \\
                        ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Require },
                    .techs = .{ .double_packed_approximate_capacity = .Require },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn aligned_byte_count(impl: *const Implementation) u64 {
                        \\            return algo.unpackDoubleApproxS(impl.lb_word, impl.ub_word);
                        \\        }
                        \\
                    else
                        \\        pub inline fn aligned_byte_count(impl: *const Implementation) u64 {
                        \\            return algo.unpackDoubleApproxH(impl.lb_word, impl.ub_word);
                        \\        }
                        \\
                        ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = "any_techs",
                    .blk = 
                    \\        pub inline fn aligned_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unallocated_byte_address(impl), aligned_byte_address(impl));
                    else
                        \\            return unallocated_byte_address(impl) -% aligned_byte_address(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Require },
                    .techs = .{ .parametric_read = .Require },
                    .blk = 
                    \\        pub inline fn aligned_byte_count(impl: *const Implementation, allocator: Allocator) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unallocated_byte_address(allocator), aligned_byte_address(impl));
                    else
                        \\            return unallocated_byte_address(allocator) -% aligned_byte_address(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .ub_word = .Require },
                    .techs = .{ .parametric = .Require },
                    .blk = 
                    \\        pub inline fn aligned_byte_count(allocator: Allocator) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unallocated_byte_address(allocator), aligned_byte_address(allocator));
                    else
                        \\            return unallocated_byte_address(allocator) -% aligned_byte_address(allocator);
                    ) ++
                        \\        }
                        \\
                    ,
                },
            };
            _ = _aligned_byte_count;
        },
        .writable_byte_count => {
            // unwritable_byte_address() - aligned_byte_address()
            const _writable_byte_count = .{
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Require },
                    .techs = .{ .parametric_read = .Require },
                    .blk = 
                    \\        pub inline fn writable_byte_count(impl: *const Implementation, allocator: Allocator) u64 { // @b1
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unwritable_byte_address(allocator), aligned_byte_address(impl));
                    else
                        \\            return unwritable_byte_address(allocator) -% aligned_byte_address(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .ub_word = .Require, .up_word = .Require },
                    .techs = .{ .parametric_write = .Require },
                    .blk = 
                    \\        pub inline fn writable_byte_count(impl: *const Implementation, allocator: Allocator) u64 { // @b2
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unwritable_byte_address(impl), aligned_byte_address(allocator));
                    else
                        \\            return unwritable_byte_address(impl) -% aligned_byte_address(allocator);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .ub_word = .Require },
                    .techs = .{ .parametric = .Require },
                    .blk = 
                    \\        pub inline fn writable_byte_count(allocator: Allocator) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(unwritable_byte_address(allocator), aligned_byte_address(allocator));
                    else
                        \\            return unwritable_byte_address(allocator) -% aligned_byte_address(allocator);
                    ) ++
                        \\        }
                        \\
                    ,
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(allocated_byte_count(impl), alignment(impl));
                    else
                        \\            return allocated_byte_count(impl) -% alignment(impl);
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .child = "permit_factor", .high_alignment = "permit_factor", .sentinel = .Forbid },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = .{
                        .lazy_alignment = "permit_alignment",
                        .disjunct_alignment = "permit_alignment",
                    },
                    .blk = 
                    \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(allocated_byte_count(impl), alignment(impl) + high_alignment);
                    else
                        \\            return allocated_byte_count(impl) -% (alignment(impl) +% high_alignment);
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .child = "permit_factor", .high_alignment = "permit_factor", .sentinel = .Require },
                },

                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = .{ .unit_alignment = .Require },
                    .blk =
                    \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                    \\            return allocated_byte_count(impl);
                    \\        }
                    \\
                    ,
                    .specs = .{ .child = "permit_factor", .high_alignment = "permit_factor", .sentinel = .Forbid },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore, .up_word = .Require },
                    .techs = .{ .unit_alignment = .Require },
                    .blk = 
                    \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                    ++ (if (config.prefer_operator_wrapper)
                        \\            return mach.sub64(allocated_byte_count(impl), high_alignment);
                    else
                        \\            return allocated_byte_count(impl) -% high_alignment;
                    ) ++
                        \\        }
                        \\
                    ,
                    .specs = .{ .child = "permit_factor", .high_alignment = "permit_factor", .sentinel = .Require },
                },
                .{
                    .fields = .{ .auto = "permit_allocated", .lb_word = "permit_allocated", .ub_word = .Ignore },
                    .techs = "any_techs",
                    .blk = if (config.minimise_declaration)
                        \\        pub inline fn writable_byte_count() u64 {
                        ++ (if (config.prefer_operator_wrapper)
                            \\            return mach.mul64(spec.count, high_alignment);
                        else
                            \\            return spec.count *% high_alignment;
                        ) ++
                            \\        }
                            \\
                    else
                        \\        pub inline fn writable_byte_count() u64 {
                        ++ (if (config.prefer_operator_wrapper)
                            \\            return mach.mul64(count, high_alignment);
                        else
                            \\            return count *% high_alignment;
                        ) ++
                            \\        }
                            \\
                        ,
                    .specs = .{ .count = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = "any_techs",
                    .blk =
                    \\        pub inline fn writable_byte_count() u64 {
                    \\            return high_alignment;
                    \\        }
                    \\
                    ,
                    .specs = .{ .bytes = .Require },
                },

                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .single_packed_approximate_capacity = .Require,
                    },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackSingleApproxB(impl.lb_word), high_alignment);
                        \\        }
                        \\
                    else
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackSingleApproxA(impl.lb_word), high_alignment);
                        \\        }
                        \\
                        ,
                    .specs = .{ .sentinel = .Forbid, .child = "permit_factor", .high_alignment = "permit_factor" },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .single_packed_approximate_capacity = .Require,
                    },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackSingleApproxB(impl.lb_word), high_alignment) -% high_alignment;
                        \\        }
                        \\
                    else
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackSingleApproxA(impl.lb_word), high_alignment) -% high_alignment;
                        \\        }
                        \\
                        ,
                    .specs = .{ .sentinel = .Require },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .double_packed_approximate_capacity = .Require,
                    },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackDoubleApproxS(impl.lb_word, impl.ub_word), high_alignment);
                        \\        }
                        \\
                    else
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackDoubleApproxH(impl.lb_word, impl.ub_word), high_alignment);
                        \\        }
                        \\
                        ,
                    .specs = .{ .sentinel = .Forbid, .child = "permit_factor", .high_alignment = "permit_factor" },
                },
                .{
                    .fields = .{ .lb_word = .Require, .ub_word = .Ignore },
                    .techs = .{
                        .double_packed_approximate_capacity = .Require,
                    },
                    .blk = if (config.packed_capacity_low)
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackDoubleApproxS(impl.lb_word, impl.ub_word), high_alignment) - high_alignment;
                        \\        }
                        \\
                    else
                        \\        pub inline fn writable_byte_count(impl: *const Implementation) u64 {
                        \\            return mach.alignB64(algo.unpackDoubleApproxH(impl.lb_word, impl.ub_word), high_alignment) - high_alignment;
                        \\        }
                        \\
                        ,
                    .specs = .{ .sentinel = .Require },
                },
            };
            _ = _writable_byte_count;
        },
        .defined_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.hasUnitAlignment()) {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &undefined_byte_address },
                    .op2 = .{ .call = &allocated_byte_address },
                });
            } else {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &undefined_byte_address },
                    .op2 = .{ .call = &aligned_byte_address },
                });
            }
            return array.writeMany(end_expression);
        },
        .undefined_byte_count => {
            array.writeMany(return_keyword);
            array.writeFormat(SubtractOp{
                .op1 = .{ .call = &unwritable_byte_address },
                .op2 = .{ .call = &undefined_byte_address },
            });
            return array.writeMany(end_expression);
        },
        .streamed_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.isAutomatic()) {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &unstreamed_byte_address },
                    .op2 = .{ .call = &allocated_byte_address },
                });
            } else {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &unstreamed_byte_address },
                    .op2 = .{ .call = &aligned_byte_address },
                });
            }
            return array.writeMany(end_expression);
        },
        .unstreamed_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.modes.resize) {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &undefined_byte_address },
                    .op2 = .{ .call = &unstreamed_byte_address },
                });
                return array.writeMany(end_expression);
            } else {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &unwritable_byte_address },
                    .op2 = .{ .call = &unstreamed_byte_address },
                });
                return array.writeMany(end_expression);
            }
        },
        .alignment => {
            array.writeMany(return_keyword);
            if (impl_variant.hasDisjunctAlignment() and
                impl_variant.hasPackedApproximateCapacity())
            {
                if (config.packed_capacity_low) {
                    array.writeFormat(AndOp{
                        .op1 = .{ .shift_right_op = &shift_right_op_lb_16 },
                        .op2 = .{ .subtract_op = &subtract_op_1 },
                    });
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(AndOp{
                        .op1 = .{ .symbol = allocated_byte_address_word_access },
                        .op2 = .{ .subtract_op = &subtract_op_1 },
                    });
                    return array.writeMany(end_expression);
                }
            } else {
                array.writeFormat(SubtractOp{
                    .op1 = .{ .call = &aligned_byte_address },
                    .op2 = .{ .call = &allocated_byte_address },
                });
                return array.writeMany(end_expression);
            }
        },
    }
}
fn writeFn(array: *Array, impl_variant: *const gen.DetailExtra, impl_fn_info: *const Fn) void {
    if (!hasCapability(impl_variant, impl_fn_info)) {
        return;
    }
    writeFnSignatureGeneric(array, impl_variant, impl_fn_info);
    array.writeMany("{\n");
    writeFnBodyGeneric(array, impl_variant, impl_fn_info);
    array.writeMany("}\n");
}
fn writeDecls(array: *Array, impl_variant: *const gen.DetailExtra) void {
    if (impl_variant.isParametric() and !config.minimise_declaration) {
        array.writeMany("const " ++ slave_type_name ++ " = spec." ++ slave_type_name);
        array.writeMany(end_expression);
    }
    if (!impl_variant.hasUnitAlignment() and !config.minimise_declaration) {
        array.writeMany("const " ++ allocated_byte_address_alignment_name ++
            ": " ++ word_type_name ++ " = spec." ++ allocated_byte_address_alignment_name);
        array.writeMany(end_expression);
    }
}
fn writeFields(array: *Array, impl_variant: *const gen.DetailExtra) void {
    if (impl_variant.fields.allocated_byte_address) {
        array.writeMany(allocated_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.unstreamed_byte_address) {
        array.writeMany(unstreamed_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.undefined_byte_address) {
        array.writeMany(undefined_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.unallocated_byte_address) {
        array.writeMany(unallocated_byte_address_word_field);
        array.writeMany(", ");
    }
}
fn writeFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/reference.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
}
fn hasCapability(impl_variant: *const gen.DetailExtra, fn_info: *const Fn) bool {
    return switch (fn_info.tag) {
        .define,
        .undefine,
        .undefined_byte_address,
        .defined_byte_count,
        .undefined_byte_count,
        => impl_variant.modes.resize,
        .seek,
        .tell,
        .unstreamed_byte_address,
        .streamed_byte_count,
        .unstreamed_byte_count,
        => impl_variant.modes.stream,
        .alignment,
        .aligned_byte_address,
        => !impl_variant.kind.automatic and !impl_variant.techs.unit_alignment,
        else => true,
    };
}
pub fn generateFnDefinitions() void {
    var array: Array = .{};
    for (gen.abstract_params) |_, spec_index| {
        array.writeMany("pub const Specification");
        array.writeFormat(fmt.ud64(spec_index));
        array.writeMany(" = struct {};\n");
        const spec_index_fmt: fmt.Type.Ud64 = fmt.ud64(spec_index);
        for (gen.impl_variants) |impl_variant, impl_index| {
            const impl_index_fmt: fmt.Type.Ud64 = fmt.ud64(impl_index);
            if (impl_variant.index == spec_index) {
                array.writeMany("fn " ++ impl_type_name);
                array.writeFormat(impl_index_fmt);
                array.writeMany("(comptime spec: Specification");
                array.writeFormat(spec_index_fmt);
                array.writeMany(") type {\n");
                array.writeMany("return (struct {\n");
                writeFields(&array, &impl_variant);
                array.writeMany("const Implementation = @This();\n");
                writeDecls(&array, &impl_variant);
                for (key) |impl_fn_info| {
                    writeFn(&array, &impl_variant, &impl_fn_info);
                }
                array.writeMany("});\n}\n");
            }
        }
    }
    writeFile(&array);
}
