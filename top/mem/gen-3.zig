//! This stage generates reference implementations
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const meta = @import("./../meta.zig");
const mach = @import("./../mach.zig");
const proc = @import("./../proc.zig");
const preset = @import("./../preset.zig");
const testing = @import("./../testing.zig");
const builtin = @import("./../builtin.zig");

const config = @import("./config.zig");
const gen = struct {
    usingnamespace @import("./gen.zig");
    usingnamespace @import("./gen-0.zig");
    usingnamespace @import("./gen-1.zig");
    usingnamespace @import("./gen-2.zig");
};
const Array = mem.StaticString(1024 * 1024);
const fmt_spec = .{
    .omit_default_fields = true,
    .infer_type_names = true,
    .omit_trailing_comma = true,
};
const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 3
    \\const mach = @import("./../mach.zig");
    \\const algo = @import("./../algo.zig");
    \\
;

// zig fmt: off
const key: [18]Fn = .{
    .{ .tag = .allocated_byte_address,      .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .aligned_byte_address,        .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .unstreamed_byte_address,     .val = .Address,    .loc = .Relative, .mut = .Immutable },
    .{ .tag = .undefined_byte_address,      .val = .Address,    .loc = .Relative, .mut = .Immutable },
    .{ .tag = .unwritable_byte_address,     .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .unallocated_byte_address,    .val = .Address,    .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .allocated_byte_count,        .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .aligned_byte_count,          .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .streamed_byte_count,         .val = .Offset,     .loc = .Relative, .mut = .Immutable },
    .{ .tag = .unstreamed_byte_count,       .val = .Offset,     .loc = .Relative, .mut = .Immutable },
    .{ .tag = .writable_byte_count,         .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .undefined_byte_count,        .val = .Offset,     .loc = .Relative, .mut = .Immutable },
    .{ .tag = .defined_byte_count,          .val = .Offset,     .loc = .Relative, .mut = .Immutable },
    .{ .tag = .alignment,                   .val = .Offset,     .loc = .Absolute, .mut = .Immutable },
    .{ .tag = .define,                      .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .undefine,                    .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .seek,                        .val = .Offset,     .loc = .Relative, .mut = .Mutable },
    .{ .tag = .tell,                        .val = .Offset,     .loc = .Relative, .mut = .Mutable },
};
// zig fmt: on

const word_type_name: [:0]const u8 = "u64";
const impl_name: [:0]const u8 = "impl";
const impl_type_name: [:0]const u8 = "Implementation";
const impl_ptr_type_name: [:0]const u8 = pointerTo(impl_type_name);
const impl_const_ptr_type_name: [:0]const u8 = constPointerTo(impl_type_name);
const impl_param: [:0]const u8 = paramDecl(impl_name, impl_ptr_type_name);
const impl_const_param: [:0]const u8 = paramDecl(impl_name, impl_const_ptr_type_name);
const spec_name: [:0]const u8 = "spec";
const generic_spec_type_name: [:0]const u8 = "Specification";
const sentinel_specifier_name: [:0]const u8 = fieldAccess(spec_name, "sentinel");
const arena_specifier_name: [:0]const u8 = fieldAccess(spec_name, "arena");
const count_specifier_name: [:0]const u8 = fieldAccess(spec_name, "count");
const low_alignment_specifier_name: [:0]const u8 = fieldAccess(spec_name, "low_alignment");
const high_alignment_specifier_name: [:0]const u8 = fieldAccess(spec_name, "high_alignment");
const child_specifier_name: [:0]const u8 = fieldAccess(spec_name, "child");
const slave_specifier_name: [:0]const u8 = "allocator";
const slave_specifier_type_name: [:0]const u8 = fieldAccess(spec_name, "Allocator");
const slave_specifier_ptr_type_name: [:0]const u8 = pointerTo(slave_specifier_type_name);
const slave_specifier_const_ptr_type_name: [:0]const u8 = constPointerTo(slave_specifier_type_name);
const slave_specifier_param: [:0]const u8 = paramDecl(slave_specifier_name, slave_specifier_type_name);
const slave_specifier_ptr_param: [:0]const u8 = paramDecl(slave_specifier_name, slave_specifier_ptr_type_name);
const slave_specifier_const_ptr_param: [:0]const u8 = paramDecl(slave_specifier_name, slave_specifier_const_ptr_type_name);
const slave_specifier_call_unallocated_byte_address: [:0]const u8 = callSimple(fieldAccess(slave_specifier_name, "unallocated_byte_address"));
const slave_specifier_call_unmapped_byte_address: [:0]const u8 = callSimple(fieldAccess(slave_specifier_name, "unmapped_byte_address"));
const slave_specifier_call_unaddressable_byte_address: [:0]const u8 = callSimple(fieldAccess(slave_specifier_name, "unaddressable_byte_address"));
const offset_bytes_name: [:0]const u8 = "x_bytes";
const offset_bytes_param: [:0]const u8 = paramDecl(offset_bytes_name, word_type_name);
const automatic_storage_type_name: [:0]const u8 = arrayType(child_specifier_name, count_specifier_name, null);
const automatic_storage_with_sentinel_type_name: [:0]const u8 = arrayType(child_specifier_name, count_specifier_name, sentinel_specifier_name);
const automatic_storage_field_name: [:0]const u8 = "auto";
const automatic_storage_access: [:0]const u8 = fieldAccess(impl_name, automatic_storage_field_name);
const automatic_storage_ptr: [:0]const u8 = impl_name ++ addressOf(automatic_storage_access);
const automatic_storage_field: [:0]const u8 = paramDecl(automatic_storage_field_name, automatic_storage_type_name);
const automatic_storage_with_sentinel_field: [:0]const u8 = paramDecl(automatic_storage_field_name, automatic_storage_with_sentinel_type_name);
const allocated_byte_address_word_field_name: [:0]const u8 = "lb_word";
const allocated_byte_address_word_access: [:0]const u8 = fieldAccess(impl_name, allocated_byte_address_word_field_name);
const allocated_byte_address_word_ptr: [:0]const u8 = addressOf(allocated_byte_address_word_access);
const allocated_byte_address_word_field: [:0]const u8 = paramDecl(allocated_byte_address_word_field_name, word_type_name);
const unstreamed_byte_address_word_field_name: [:0]const u8 = "ss_word";
const unstreamed_byte_address_word_access: [:0]const u8 = fieldAccess(impl_name, unstreamed_byte_address_word_field_name);
const unstreamed_byte_address_word_ptr: [:0]const u8 = addressOf(unstreamed_byte_address_word_access);
const unstreamed_byte_address_word_field: [:0]const u8 = paramDecl(unstreamed_byte_address_word_field_name, word_type_name);
const undefined_byte_address_word_field_name: [:0]const u8 = "ub_word";
const undefined_byte_address_word_access: [:0]const u8 = fieldAccess(impl_name, undefined_byte_address_word_field_name);
const undefined_byte_address_word_ptr: [:0]const u8 = addressOf(undefined_byte_address_word_access);
const undefined_byte_address_word_field: [:0]const u8 = paramDecl(undefined_byte_address_word_field_name, word_type_name);
const unallocated_byte_address_word_field_name: [:0]const u8 = "up_word";
const unallocated_byte_address_word_access: [:0]const u8 = fieldAccess(impl_name, unallocated_byte_address_word_field_name);
const unallocated_byte_address_word_ptr: [:0]const u8 = addressOf(unallocated_byte_address_word_access);
const unallocated_byte_address_word_field: [:0]const u8 = paramDecl(unallocated_byte_address_word_field_name, word_type_name);

const return_keyword: [:0]const u8 = "return ";
const end_expression: [:0]const u8 = ";\n";

fn arrayType(
    comptime type_name: [:0]const u8,
    comptime count_symbol: [:0]const u8,
    comptime sentinel_symbol_opt: ?[:0]const u8,
) [:0]const u8 {
    if (sentinel_symbol_opt) |sentinel_symbol| {
        return "[" ++ count_symbol ++ ":" ++ sentinel_symbol ++ "]" ++ type_name;
    } else {
        return "[" ++ count_symbol ++ "]" ++ type_name;
    }
}
fn fieldAccess(comptime symbol: [:0]const u8, field_name: [:0]const u8) [:0]const u8 {
    return symbol ++ "." ++ field_name;
}
fn callSimple(comptime symbol: [:0]const u8) [:0]const u8 {
    return symbol ++ "()";
}
fn addressOf(comptime symbol: [:0]const u8) [:0]const u8 {
    return "&" ++ symbol;
}
fn pointerTo(comptime type_name: [:0]const u8) [:0]const u8 {
    return "*" ++ type_name;
}
fn constPointerTo(comptime type_name: [:0]const u8) [:0]const u8 {
    return "*const " ++ type_name;
}
fn paramDecl(comptime symbol: [:0]const u8, type_name: [:0]const u8) [:0]const u8 {
    return symbol ++ ": " ++ type_name;
}
fn callOffsetOf(comptime type_name: [:0]const u8, comptime field_name: [:0]const u8) [:0]const u8 {
    return "@offsetOf(" ++ type_name ++ ", \"" ++ field_name ++ "\")";
}
fn callPtrToInt(comptime symbol_ptr: [:0]const u8) [:0]const u8 {
    return "@ptrToInt(" ++ symbol_ptr ++ ")";
}
fn callSizeOf(comptime type_name: [:0]const u8) [:0]const u8 {
    return "@sizeOf(" ++ type_name ++ ")";
}

const Fn = packed struct {
    tag: Tag,
    val: Value,
    loc: Location,
    mut: Mutability,
    const Tag = enum(u5) {
        allocated_byte_address,
        aligned_byte_address,
        unstreamed_byte_address,
        undefined_byte_address,
        unwritable_byte_address,
        unallocated_byte_address,
        allocated_byte_count,
        aligned_byte_count,
        streamed_byte_count,
        unstreamed_byte_count,
        writable_byte_count,
        undefined_byte_count,
        defined_byte_count,
        alignment,
        define,
        undefine,
        seek,
        tell,
    };
    const Value = enum(u1) { Address, Offset };
    const Location = enum(u1) { Relative, Absolute };
    const Mutability = enum(u1) { Mutable, Immutable };

    inline fn fnName(impl_fn_info: *const Fn) []const u8 {
        return @tagName(impl_fn_info.tag);
    }
};
inline fn get(comptime tag: Fn.Tag) *const Fn {
    comptime {
        for (key) |val| {
            if (val.tag == tag) return &val;
        }
        unreachable;
    }
}
const Operand = union(enum) {
    uni_op: *const UnaryOp,
    bin_op: *const BinaryOp,
    call: *const FnCall,
    constant: usize,
    symbol: [:0]const u8,
    const Format = @This();

    pub fn formatWrite(format: Format, array: anytype) void {
        switch (format) {
            .symbol => |symbol| array.writeMany(symbol),
            .constant => |constant| array.writeFormat(fmt.ud64(constant)),
            inline else => |op| op.formatWrite(array),
        }
    }
    fn init(any: anytype) Operand {
        inline for (@typeInfo(Operand).Union.fields) |field| {
            if (field.type == @TypeOf(any)) {
                return @unionInit(Operand, field.name, any);
            }
        }
        @compileError(@typeName(@TypeOf(any)));
    }
};
pub fn formatWriteCall1(op1: Operand, array: anytype, fn_token: [:0]const u8) void {
    array.writeMany(fn_token);
    array.writeOne('(');
    array.writeFormat(op1);
    array.writeOne(')');
}
pub fn formatWriteCall2(op1: Operand, op2: Operand, array: anytype, fn_token: [:0]const u8) void {
    array.writeMany(fn_token);
    array.writeOne('(');
    array.writeFormat(op1);
    array.writeCount(2, ", ".*);
    array.writeFormat(op2);
    array.writeOne(')');
}
pub inline fn GenericUnaryOpFormat(comptime Format: type) type {
    return (struct {
        fn exec(array: anytype, op1: anytype) void {
            array.writeFormat(Format{ .op1 = Operand.init(op1) });
        }
        fn make(op1: anytype) Format {
            return .{ .op1 = Operand.init(op1) };
        }
        pub fn formatWrite(format: Format, array: anytype) void {
            return formatWriteCall1(format.op1, array, Format.fn_token);
        }
    });
}
pub inline fn GenericBinaryOpFormat(comptime Format: type) type {
    return (struct {
        fn exec(array: anytype, op1: anytype, op2: anytype) void {
            array.writeFormat(make(op1, op2));
        }
        fn make(op1: anytype, op2: anytype) Format {
            return .{ .op1 = Operand.init(op1), .op2 = Operand.init(op2) };
        }
        pub fn formatWrite(format: Format, array: anytype) void {
            return formatWriteCall2(format.op1, format.op2, array, Format.fn_token);
        }
    });
}
const BinaryOp = struct {
    symbol: [:0]const u8,
    op1: Operand,
    op2: Operand,

    const Format = @This();
    const add_equ_fn_name: [:0]const u8 = "mach.addEqu64";
    const subtract_equ_fn_name: [:0]const u8 = "mach.subEqu64";
    const add_fn_name: [:0]const u8 = "mach.add64";
    const subtract_fn_name: [:0]const u8 = "mach.sub64";
    const align_above_fn_name: [:0]const u8 = "mach.alignA64";
    const align_below_fn_name: [:0]const u8 = "mach.alignB64";
    const and_fn_name: [:0]const u8 = "mach.and64";
    const and_not_fn_name: [:0]const u8 = "mach.andn64";
    const conditional_move_fn_name: [:0]const u8 = "mach.cmov64";
    const multiply_fn_name: [:0]const u8 = "mach.mul64";
    const or_fn_name: [:0]const u8 = "mach.or64";
    const shift_left_fn_name: [:0]const u8 = "mach.shl64";
    const shift_right_fn_name: [:0]const u8 = "mach.shr64";
    const unpack_double_fn_name: [:0]const u8 = if (config.packed_capacity_low)
        "algo.unpackDoubleApproxS"
    else
        "algo.unpackDoubleApproxH";

    pub fn formatWrite(format: Format, array: anytype) void {
        formatWriteCall2(format.op1, format.op2, array, format.symbol);
    }
};
inline fn addEqualOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.add_equ_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn subtractEqualOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.subtract_equ_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn addOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.add_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn alignAboveOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.subtract_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn alignBelowOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.align_below_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn andOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.and_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn andNotOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.and_not_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn conditionalMoveOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.conditional_move_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn multiplyOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.multiply_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn orOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.or_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn shiftLeftOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.shift_left_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn shiftRightOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.shift_right_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn subtractOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.subtract_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
inline fn unpackDoubleApproxOp(op1: anytype, op2: anytype) BinaryOp {
    return .{
        .symbol = BinaryOp.unpack_double_fn_name,
        .op1 = Operand.init(op1),
        .op2 = Operand.init(op2),
    };
}
const UnaryOp = struct {
    symbol: [:0]const u8,
    op1: Operand,

    const Format = @This();
    const unpack_single_fn_name: [:0]const u8 = if (config.packed_capacity_low)
        "algo.unpackSingleApproxB"
    else
        "algo.unpackSingleApproxA";

    pub inline fn formatWrite(format: Format, array: anytype) void {
        formatWriteCall1(format.op1, array, format.symbol);
    }
    inline fn unpackSingleApproxOp(op1: anytype) BinaryOp {
        return .{
            .symbol = unpack_single_fn_name,
            .op1 = Operand.init(op1),
        };
    }
};
const FnCall = struct {
    impl_variant: *const gen.DetailMore,
    impl_fn_info: *const Fn,
    const Format = @This();
    pub inline fn formatWrite(format: Format, array: anytype) void {
        writeFnSignatureOrCall(array, format.impl_variant, format.impl_fn_info, false);
    }
};
fn writeComma(array: *Array) void {
    const j0: bool = mem.testEqualOneBack(u8, '(', array.readAll());
    const j1: bool = mem.testEqualManyBack(u8, ", ", array.readAll());
    if (builtin.int2a(bool, !j0, !j1)) {
        array.writeMany(", ");
    }
}
fn writeArgument(array: *Array, argument_name: [:0]const u8) void {
    writeComma(array);
    array.writeMany(argument_name);
}
fn writeFnCallGeneric(array: *Array, impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn) void {
    writeFnSignatureOrCall(array, impl_variant, impl_fn_info, false);
}
fn writeFnSignatureGeneric(array: *Array, impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn) void {
    writeFnSignatureOrCall(array, impl_variant, impl_fn_info, true);
}
const Info = struct {
    start: u64,
    alias: ?*const Fn = null,

    fn setAlias(info: *Info, impl_fn_info: *const Fn) void {
        info.alias = impl_fn_info;
    }
};
fn writeFnBodyGeneric(array: *Array, impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn, info: *Info) void {
    // Should the reader find inconsistencies in the following logical
    // structures (such as duplicating write operating in an inner scope, when
    // that write would have identical semantics and result in fewer lines of
    // code if moved to an outer scope), the reason is simple: at the time of
    // writing, the chosen method resulted in a smaller binary.
    const allocated_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.allocated_byte_address),
    };
    const aligned_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.aligned_byte_address),
    };
    const unstreamed_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unstreamed_byte_address),
    };
    const undefined_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.undefined_byte_address),
    };
    const unwritable_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unwritable_byte_address),
    };
    const unallocated_byte_address: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unallocated_byte_address),
    };
    const allocated_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.allocated_byte_count),
    };
    const aligned_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.aligned_byte_count),
    };
    const streamed_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.streamed_byte_count),
    };
    _ = streamed_byte_count;
    const unstreamed_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.unstreamed_byte_count),
    };
    _ = unstreamed_byte_count;
    const writable_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.writable_byte_count),
    };
    const undefined_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.undefined_byte_count),
    };
    _ = undefined_byte_count;
    const defined_byte_count: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.defined_byte_count),
    };
    _ = defined_byte_count;
    const alignment: FnCall = .{
        .impl_variant = impl_variant,
        .impl_fn_info = get(.alignment),
    };
    const subtract_op_1: BinaryOp = .{
        .symbol = BinaryOp.subtract_fn_name,
        .op1 = .{ .symbol = low_alignment_specifier_name },
        .op2 = .{ .constant = 1 },
    };
    const shift_left_op_65535_48: BinaryOp = .{
        .symbol = BinaryOp.shift_left_fn_name,
        .op1 = .{ .constant = 65535 },
        .op2 = .{ .constant = 48 },
    };
    const shift_right_op_lb_16: BinaryOp = .{
        .symbol = BinaryOp.shift_right_fn_name,
        .op1 = .{ .symbol = allocated_byte_address_word_access },
        .op2 = .{ .constant = 16 },
    };
    const shift_right_op_ub_16: BinaryOp = .{
        .symbol = BinaryOp.shift_right_fn_name,
        .op1 = .{ .symbol = undefined_byte_address_word_access },
        .op2 = .{ .constant = 16 },
    };
    const or_op_1_65535_48: BinaryOp = .{
        .symbol = BinaryOp.or_fn_name,
        .op1 = .{ .bin_op = &subtract_op_1 },
        .op2 = .{ .bin_op = &shift_left_op_65535_48 },
    };
    const unpck1x_op: UnaryOp = .{
        .symbol = UnaryOp.unpack_single_fn_name,
        .op1 = .{ .symbol = allocated_byte_address_word_access },
    };
    const unpck2x_op: BinaryOp = .{
        .symbol = BinaryOp.unpack_double_fn_name,
        .op1 = .{ .symbol = allocated_byte_address_word_access },
        .op2 = .{ .symbol = undefined_byte_address_word_access },
    };
    const address_of_impl: [:0]const u8 = callPtrToInt(impl_name);
    const offset_of_automatic_storage: [:0]const u8 =
        callOffsetOf(impl_type_name, automatic_storage_field_name);
    switch (impl_fn_info.tag) {
        .define => {
            array.writeFormat(addEqualOp(undefined_byte_address_word_ptr, offset_bytes_name));
            if (impl_variant.specs.sentinel) {}
            return array.writeMany(end_expression);
        },
        .undefine => {
            array.writeFormat(subtractEqualOp(undefined_byte_address_word_ptr, offset_bytes_name));
            if (impl_variant.specs.sentinel) {}
            return array.writeMany(end_expression);
        },
        .seek => {
            array.writeFormat(addEqualOp(unstreamed_byte_address_word_ptr, offset_bytes_name));
            if (impl_variant.specs.sentinel) {}
            return array.writeMany(end_expression);
        },
        .tell => {
            array.writeFormat(subtractEqualOp(unstreamed_byte_address_word_ptr, offset_bytes_name));
            if (impl_variant.specs.sentinel) {}
            return array.writeMany(end_expression);
        },
        .allocated_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.isAutomatic()) {
                array.writeFormat(addOp(address_of_impl, offset_of_automatic_storage));
                return array.writeMany(end_expression);
            }
            if (impl_variant.isParametric()) {
                array.writeMany(slave_specifier_call_unallocated_byte_address);
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasPackedApproximateCapacity()) {
                if (config.packed_capacity_low) {
                    array.writeFormat(shift_right_op_lb_16);
                    return array.writeMany(end_expression);
                }
                array.writeFormat(andNotOp(allocated_byte_address_word_access, &shift_left_op_65535_48));
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasDisjunctAlignment()) {
                array.writeFormat(subtractOp(&aligned_byte_address, &alignment));
                return array.writeMany(end_expression);
            }
            array.writeMany(allocated_byte_address_word_access);
            return array.writeMany(end_expression);
        },
        .aligned_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.hasUnitAlignment()) {
                return info.setAlias(allocated_byte_address.impl_fn_info);
            }
            if (impl_variant.hasDisjunctAlignment()) {
                if (impl_variant.hasPackedApproximateCapacity()) {
                    if (config.packed_capacity_low) {
                        array.writeFormat(andNotOp(&shift_right_op_lb_16, &subtract_op_1));
                        return array.writeMany(end_expression);
                    }
                    array.writeFormat(andNotOp(allocated_byte_address_word_access, &or_op_1_65535_48));
                    return array.writeMany(end_expression);
                }
                array.writeFormat(andNotOp(allocated_byte_address_word_access, &subtract_op_1));
                return array.writeMany(end_expression);
            }
            if (impl_variant.isParametric()) {
                if (impl_variant.hasLazyAlignment()) {
                    array.writeFormat(alignAboveOp(slave_specifier_call_unallocated_byte_address, low_alignment_specifier_name));
                    return array.writeMany(end_expression);
                }
                return info.setAlias(allocated_byte_address.impl_fn_info);
            }
            if (impl_variant.hasLazyAlignment()) {
                array.writeFormat(alignAboveOp(&allocated_byte_address, low_alignment_specifier_name));
                return array.writeMany(end_expression);
            }
        },
        .unstreamed_byte_address => {
            array.writeMany(return_keyword);
            array.writeMany(unstreamed_byte_address_word_access);
            return array.writeMany(end_expression);
        },
        .undefined_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.techs.double_packed_approximate_capacity) {
                if (config.packed_capacity_low) {
                    array.writeFormat(shift_right_op_ub_16);
                    return array.writeMany(end_expression);
                }
                array.writeFormat(andNotOp(undefined_byte_address_word_access, &shift_left_op_65535_48));
                return array.writeMany(end_expression);
            }
            if (impl_variant.isAutomatic()) {
                array.writeFormat(addOp(&allocated_byte_address, undefined_byte_address_word_access));
                return array.writeMany(end_expression);
            }
            array.writeMany(undefined_byte_address_word_access);
            return array.writeMany(end_expression);
        },
        .unallocated_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.fields.unallocated_byte_address) {
                array.writeMany(unallocated_byte_address_word_access);
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasPackedApproximateCapacity() or
                impl_variant.hasStaticMaximumLength())
            {
                array.writeFormat(addOp(&allocated_byte_address, &allocated_byte_count));
                return array.writeMany(end_expression);
            }
            array.writeMany(slave_specifier_call_unmapped_byte_address);
            return array.writeMany(end_expression);
        },
        .unwritable_byte_address => {
            array.writeMany(return_keyword);
            if (impl_variant.isParametric()) {
                if (impl_variant.specs.sentinel) {
                    array.writeFormat(subtractOp(&unallocated_byte_address, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                }
                return info.setAlias(unallocated_byte_address.impl_fn_info);
            }
            if (impl_variant.fields.unallocated_byte_address) {
                if (impl_variant.specs.sentinel) {
                    array.writeFormat(subtractOp(unallocated_byte_address_word_access, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                }
                array.writeMany(unallocated_byte_address_word_access);
                return array.writeMany(end_expression);
            }
            array.writeFormat(addOp(&aligned_byte_address, &writable_byte_count));
            return array.writeMany(end_expression);
        },
        .allocated_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.techs.single_packed_approximate_capacity) {
                if (impl_variant.hasUnitAlignment()) {
                    return info.setAlias(aligned_byte_count.impl_fn_info);
                } else {
                    array.writeFormat(addOp(&alignment, &aligned_byte_count));
                    return array.writeMany(end_expression);
                }
            }
            if (impl_variant.techs.double_packed_approximate_capacity) {
                if (impl_variant.hasUnitAlignment()) {
                    return info.setAlias(aligned_byte_count.impl_fn_info);
                } else {
                    array.writeFormat(addOp(&alignment, &aligned_byte_count));
                    return array.writeMany(end_expression);
                }
            }
            if (impl_variant.hasStaticMaximumLength()) {
                return info.setAlias(writable_byte_count.impl_fn_info);
            }
            array.writeFormat(subtractOp(&unallocated_byte_address, &allocated_byte_address));
            return array.writeMany(end_expression);
        },
        .aligned_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.techs.single_packed_approximate_capacity) {
                array.writeFormat(unpck1x_op);
                return array.writeMany(end_expression);
            }
            if (impl_variant.techs.double_packed_approximate_capacity) {
                array.writeFormat(unpck2x_op);
                return array.writeMany(end_expression);
            }
            if (impl_variant.specs.sentinel) {
                array.writeFormat(addOp(&writable_byte_count, high_alignment_specifier_name));
                return array.writeMany(end_expression);
            }
            return info.setAlias(writable_byte_count.impl_fn_info);
        },
        .writable_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.isParametric()) {
                array.writeFormat(subtractOp(&unwritable_byte_address, &aligned_byte_address));
                return array.writeMany(end_expression);
            }
            if (impl_variant.hasStaticMaximumLength()) {
                array.writeFormat(multiplyOp(count_specifier_name, callSizeOf(child_specifier_name)));
                return array.writeMany(end_expression);
            }
            if (impl_variant.techs.double_packed_approximate_capacity) {
                if (impl_variant.specs.sentinel) {
                    const align_below_op: BinaryOp = alignBelowOp(&unpck2x_op, high_alignment_specifier_name);
                    array.writeFormat(subtractOp(&align_below_op, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(alignBelowOp(&unpck2x_op, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                }
            } else if (impl_variant.techs.double_packed_approximate_capacity) {
                if (impl_variant.specs.sentinel) {
                    const align_below_op: BinaryOp = alignBelowOp(&unpck1x_op, high_alignment_specifier_name);
                    array.writeFormat(subtractOp(&align_below_op, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(alignBelowOp(&unpck1x_op, high_alignment_specifier_name));
                    return array.writeMany(end_expression);
                }
            } else if (impl_variant.specs.sentinel) {
                const subtract_op: BinaryOp = subtractOp(&allocated_byte_count, high_alignment_specifier_name);
                if (impl_variant.hasUnitAlignment()) {
                    array.writeFormat(subtract_op);
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(subtractOp(&subtract_op, &alignment));
                    return array.writeMany(end_expression);
                }
            }
            if (impl_variant.hasUnitAlignment()) {
                return info.setAlias(allocated_byte_count.impl_fn_info);
            } else {
                array.writeFormat(subtractOp(&allocated_byte_count, &alignment));
                return array.writeMany(end_expression);
            }
        },
        .defined_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.hasUnitAlignment()) {
                array.writeFormat(subtractOp(&undefined_byte_address, &allocated_byte_address));
                return array.writeMany(end_expression);
            } else {
                array.writeFormat(subtractOp(&undefined_byte_address, &aligned_byte_address));
                return array.writeMany(end_expression);
            }
        },
        .undefined_byte_count => {
            array.writeMany(return_keyword);
            array.writeFormat(subtractOp(&unwritable_byte_address, &undefined_byte_address));
            return array.writeMany(end_expression);
        },
        .streamed_byte_count => {
            array.writeMany(return_keyword);
            array.writeFormat(subtractOp(&unstreamed_byte_address, &aligned_byte_address));
            return array.writeMany(end_expression);
        },
        .unstreamed_byte_count => {
            array.writeMany(return_keyword);
            if (impl_variant.modes.resize) {
                array.writeFormat(subtractOp(&undefined_byte_address, &unstreamed_byte_address));
                return array.writeMany(end_expression);
            } else {
                array.writeFormat(subtractOp(&unwritable_byte_address, &unstreamed_byte_address));
                return array.writeMany(end_expression);
            }
        },
        .alignment => {
            array.writeMany(return_keyword);
            if (impl_variant.hasDisjunctAlignment() and
                impl_variant.hasPackedApproximateCapacity())
            {
                if (config.packed_capacity_low) {
                    array.writeFormat(andOp(&shift_right_op_lb_16, &subtract_op_1));
                    return array.writeMany(end_expression);
                } else {
                    array.writeFormat(andOp(allocated_byte_address_word_access, &subtract_op_1));
                    return array.writeMany(end_expression);
                }
            } else {
                array.writeFormat(subtractOp(&aligned_byte_address, &allocated_byte_address));
                return array.writeMany(end_expression);
            }
        },
    }
}
fn writeFn(array: *Array, impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn) void {
    if (hasCapability(impl_variant, impl_fn_info)) {
        var info: Info = .{ .start = array.len() };
        writeFnSignatureGeneric(array, impl_variant, impl_fn_info);
        array.writeMany("{\n");
        writeFnBodyGeneric(array, impl_variant, impl_fn_info, &info);
        array.writeMany("}\n");
        writeSimpleRedecl(array, impl_fn_info, &info);
    }
}
fn writeDecls(array: *Array, impl_variant: *const gen.DetailMore) void {
    if (impl_variant.hasStaticMaximumLength()) {
        array.writeMany("const Static = fn () callconv(.Inline) u64;\n");
    }
    if (impl_variant.isParametric()) {
        array.writeMany("const Slave = fn (" ++ slave_specifier_const_ptr_type_name ++ ") callconv(.Inline) u64;\n");
    }
}
fn writeSimpleRedecl(array: *Array, impl_fn_info: *const Fn, info: *Info) void {
    if (info.alias) |impl_fn_alias_info| {
        array.undefine(array.len() - info.start);
        array.writeMany("pub const ");
        array.writeMany(@tagName(impl_fn_info.tag));
        array.writeMany(" = ");
        array.writeMany(@tagName(impl_fn_alias_info.tag));
        array.writeMany(";\n");
        info.alias = null;
    }
}
fn writeComptimeFieldInternal(array: *Array, fn_tag: Fn.Tag, args: *const Args) void {
    if (args.len() == 0) {
        array.writeMany("comptime ");
        array.writeMany(@tagName(fn_tag));
        array.writeMany(": Static = ");
        array.writeMany(@tagName(fn_tag));
        return array.writeMany(",\n");
    }
    if (args.len() == 1 and
        args.readOneAt(0).ptr == slave_specifier_name.ptr)
    {
        array.writeMany("comptime ");
        array.writeMany(@tagName(fn_tag));
        array.writeMany(": Slave = ");
        array.writeMany(@tagName(fn_tag));
        return array.writeMany(",\n");
    }
}
inline fn writeComptimeField(array: *Array, impl_variant: *const gen.DetailMore, comptime fn_tag: Fn.Tag) void {
    const args: Args = getArgList(impl_variant, get(fn_tag), false);
    writeComptimeFieldInternal(array, fn_tag, &args);
}
inline fn writeFields(array: *Array, impl_variant: *const gen.DetailMore) void {
    writeComptimeField(array, impl_variant, .allocated_byte_address);
    writeComptimeField(array, impl_variant, .aligned_byte_address);
    writeComptimeField(array, impl_variant, .unallocated_byte_address);
    if (impl_variant.fields.automatic_storage) {
        if (impl_variant.specs.sentinel) {
            array.writeMany(automatic_storage_with_sentinel_field);
        } else {
            array.writeMany(automatic_storage_field);
        }
        array.writeMany(", ");
    }
    if (impl_variant.fields.allocated_byte_address) {
        array.writeMany(allocated_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.unstreamed_byte_address) {
        array.writeMany(unstreamed_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.undefined_byte_address) {
        array.writeMany(undefined_byte_address_word_field);
        array.writeMany(", ");
    }
    if (impl_variant.fields.unallocated_byte_address) {
        array.writeMany(unallocated_byte_address_word_field);
        array.writeMany(", ");
    }
    writeComptimeField(array, impl_variant, .unwritable_byte_address);
    writeComptimeField(array, impl_variant, .allocated_byte_count);
    writeComptimeField(array, impl_variant, .writable_byte_count);
    writeComptimeField(array, impl_variant, .aligned_byte_count);
}
const Args = mem.StaticArray([:0]const u8, 8);

fn getArgList(impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn, sign: bool) Args {
    var array: Args = undefined;
    array.undefineAll();
    if (impl_fn_info.mut == .Mutable) {
        array.writeOne(mach.cmovx(sign, impl_param, impl_name));
        array.writeOne(mach.cmovx(sign, offset_bytes_param, offset_bytes_name));
    } else if (impl_variant.isParametric()) {
        if (impl_fn_info.val == .Address) {
            if (impl_fn_info.loc == .Absolute) {
                array.writeOne(mach.cmovx(sign, slave_specifier_const_ptr_param, slave_specifier_name));
            } else {
                array.writeOne(mach.cmovx(sign, impl_const_param, impl_name));
            }
        } else if (impl_fn_info.val == .Offset) {
            if (impl_fn_info.tag == .unstreamed_byte_count and
                impl_variant.fields.undefined_byte_address)
            {
                array.writeOne(mach.cmovx(sign, impl_const_param, impl_name));
            } else if (impl_fn_info.loc == .Relative) {
                array.writeOne(mach.cmovx(sign, impl_const_param, impl_name));
                array.writeOne(mach.cmovx(sign, slave_specifier_const_ptr_param, slave_specifier_name));
            } else {
                array.writeOne(mach.cmovx(sign, slave_specifier_const_ptr_param, slave_specifier_name));
            }
        }
    } else if (impl_variant.hasStaticMaximumLength()) {
        if (!(impl_fn_info.tag == .writable_byte_count or
            impl_fn_info.tag == .aligned_byte_count or
            impl_fn_info.tag == .allocated_byte_count and impl_variant.hasUnitAlignment()))
        {
            array.writeOne(mach.cmovx(sign, impl_const_param, impl_name));
        }
    } else {
        array.writeOne(mach.cmovx(sign, impl_const_param, impl_name));
    }
    return array;
}
fn writeFnSignatureOrCall(array: *Array, impl_variant: *const gen.DetailMore, impl_fn_info: *const Fn, sign: bool) void {
    const list: Args = getArgList(impl_variant, impl_fn_info, sign);
    if (sign) array.writeMany("pub inline fn ");
    array.writeMany(impl_fn_info.fnName());
    array.writeMany("(");
    for (list.readAll()) |arg| {
        writeArgument(array, arg);
    }
    if (impl_fn_info.mut == .Mutable) {
        array.writeMany(if (sign) ") void " else ")");
    } else {
        array.writeMany(if (sign) ") u64 " else ")");
    }
}
fn writeHelpInformation(array: *Array, impl_variant: gen.DetailMore) void {
    array.writeMany("// ");
    inline for (@typeInfo(gen.DetailMore).Struct.fields[1..]) |field| {
        inline for (@typeInfo(meta.Field(gen.DetailMore, field.name)).Struct.fields) |field_field| {
            if (@field(@field(impl_variant, field.name), field_field.name)) {
                array.writeMany(field_field.name ++ ", ");
            }
        }
    }
    array.writeMany("\n");
}
fn printFunctionsInTagOrder() void {
    var fn_index: usize = 0;
    while (fn_index <= ~@as(meta.Child(Fn.Tag), 0)) : (fn_index +%= 1) {
        const tag: Fn.Tag = @intToEnum(Fn.Tag, fn_index);
        for (key) |fn_info| {
            if (fn_info.tag == tag) {
                testing.printN(4096, .{ fmt.any(fn_info), '\n' });
            }
        }
    }
}
fn writeFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/reference.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
}
fn hasCapability(impl_variant: *const gen.DetailMore, fn_info: *const Fn) bool {
    return switch (fn_info.tag) {
        .define,
        .undefine,
        .undefined_byte_address,
        .defined_byte_count,
        .undefined_byte_count,
        => impl_variant.modes.resize,
        .seek,
        .tell,
        .unstreamed_byte_address,
        .streamed_byte_count,
        .unstreamed_byte_count,
        => impl_variant.modes.stream,
        .alignment => !impl_variant.kind.automatic and
            !impl_variant.techs.unit_alignment,
        else => true,
    };
}
pub fn generateFnDefinitions() void {
    var array: Array = undefined;
    array.undefineAll();
    var impl_index: u64 = 0;
    for (gen.impl_variant_groups) |impl_group, spec_index| {
        for (impl_group) |impl_variant| {
            array.writeMany("inline fn " ++ impl_type_name);
            array.writeFormat(fmt.ud64(impl_index));
            array.writeMany("(comptime " ++ spec_name ++ ": " ++ generic_spec_type_name);
            array.writeFormat(fmt.ud64(spec_index));
            array.writeMany(") type {\nreturn (struct {\n");
            writeFields(&array, &impl_variant);
            array.writeMany("const " ++ impl_type_name ++ " = @This();\n");
            writeDecls(&array, &impl_variant);
            for (key) |impl_fn_info| writeFn(&array, &impl_variant, &impl_fn_info);
            array.writeMany("});\n}\n");
            impl_index +%= 1;
        }
    }
    writeFile(&array);
}
