//! This stage generates implementations variations
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const meta = @import("./../meta.zig");
const proc = @import("./../proc.zig");
const preset = @import("./../preset.zig");
const testing = @import("./../testing.zig");
const builtin = @import("./../builtin.zig");

const config = @import("./config.zig");
const gen = struct {
    usingnamespace @import("./gen.zig");
    usingnamespace @import("./gen-0.zig");
    usingnamespace @import("./gen-1.zig");
};

const Array = mem.StaticString(1024 * 1024);

const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 2
    \\const gen = @import("./gen.zig");
    \\
;
const fmt_spec = .{
    .omit_default_fields = true,
    .infer_type_names = true,
    .omit_trailing_comma = true,
};

fn writeContainerVariantStructs(array: *Array) void {
    array.writeMany("pub const ctn_variant_groups = [_][]const gen.DetailLess{\n");
    var uniques: mem.StaticArray(gen.DetailLess, gen.impl_details.len) = undefined;
    uniques.undefineAll();
    for (gen.impl_details) |impl_detail| {
        const less: gen.DetailLess = impl_detail.less();
        for (uniques.readAll()) |unique| {
            if (builtin.testEqual(gen.DetailLess, less, unique)) {
                break;
            }
        } else {
            uniques.writeOne(less);
            writeContainerVariantsStructsInternal(array, &less);
        }
    }
    array.writeMany("};\n");
}

fn writeContainerVariantsStructsInternal(array: *Array, ctn_detail: *const gen.DetailLess) void {
    array.writeMany("    ");
    array.writeFormat(ctn_detail.*);
    array.writeMany(",\n");
}
fn writeImplementationVariantStructsInternal(array: *Array, impl_detail: *const gen.Detail, specs: gen.Specifiers) void {
    array.writeMany("        ");
    array.writeFormat(impl_detail.more(specs));
    array.writeMany(",\n");
}

fn writeImplementationsVariantStructs(array: *Array) void {
    var accm_spec_index: u8 = 0;
    var matrix: [8][8]u8 = [1][8]u8{[1]u8{0} ** 8} ** 8;
    inline for (gen.type_specs) |type_spec, param_index| {
        inline for (type_spec.specs) |_, spec_index| {
            matrix[param_index][spec_index] = accm_spec_index;
            accm_spec_index +%= 1;
        }
    }
    const accm_spec_len: u8 = accm_spec_index + 1;
    accm_spec_index = 0;
    array.writeMany("pub const impl_variant_groups = [_][]const gen.DetailMore{\n");
    while (accm_spec_index != accm_spec_len) : (accm_spec_index +%= 1) {
        array.writeMany("    &.{\n");
        inline for (gen.type_specs) |type_spec, param_index| {
            const I = meta.Child(type_spec.vars);
            for (gen.impl_details) |impl_detail| {
                if (impl_detail.index != param_index) {
                    continue;
                }
                var spec_index: u8 = 0;
                while (spec_index <= ~@as(I, 0)) : (spec_index += 1) {
                    if (matrix[param_index][spec_index] == accm_spec_index) {
                        const vars: type_spec.vars = @bitCast(type_spec.vars, @intCast(I, spec_index));
                        var specs: gen.Specifiers = undefined;
                        inline for (@typeInfo(type_spec.vars).Struct.fields) |field| {
                            if (@hasField(gen.Specifiers, field.name)) {
                                @field(specs, field.name) = @field(vars, field.name);
                            }
                        }
                        writeImplementationVariantStructsInternal(array, &impl_detail, specs);
                    }
                }
            }
        }
        array.writeMany("    },\n");
    }
    array.writeMany("};\n");
}
fn writeImplementationVariantsFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/impl_variant_groups.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
    array.undefineAll();
}
pub fn generateVariantData() void {
    var array: Array = .{};
    writeContainerVariantStructs(&array);
    writeImplementationsVariantStructs(&array);
    writeImplementationVariantsFile(&array);
}
