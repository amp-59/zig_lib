//! This stage generates implementations variations
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const meta = @import("./../meta.zig");
const proc = @import("./../proc.zig");
const preset = @import("./../preset.zig");
const testing = @import("./../testing.zig");
const builtin = @import("./../builtin.zig");

const config = @import("./config.zig");
const gen = struct {
    usingnamespace @import("./gen.zig");

    usingnamespace @import("./gen-0.zig");
    usingnamespace @import("./gen-1.zig");

    usingnamespace @import("./type_specs.zig");
    usingnamespace @import("./impl_details.zig");
};

const Array = mem.StaticString(1024 * 1024);

pub const DetailExtra = packed struct {
    index: u8 = undefined,
    kind: gen.Kind = .{},
    layout: gen.Layout = .{},
    modes: gen.Modes = .{},
    fields: gen.Fields = .{},
    techs: gen.Techniques = .{},
    specs: gen.Specifiers = .{},

    pub fn isAutomatic(impl_variant: *const DetailExtra) bool {
        return impl_variant.kind.automatic;
    }
    pub fn isParametric(impl_variant: *const DetailExtra) bool {
        return impl_variant.kind.parametric;
    }
    pub fn isDynamic(impl_variant: *const DetailExtra) bool {
        return impl_variant.kind.dynamic;
    }
    pub fn isStatic(impl_variant: *const DetailExtra) bool {
        return impl_variant.kind.static;
    }
    pub fn hasUnitAlignment(impl_variant: *const DetailExtra) bool {
        return builtin.int2v(
            bool,
            impl_variant.techs.unit_alignment,
            impl_variant.kind.automatic,
        );
    }
    pub fn hasLazyAlignment(impl_variant: *const DetailExtra) bool {
        return impl_variant.techs.lazy_alignment;
    }
    pub fn hasDisjunctAlignment(impl_variant: *const DetailExtra) bool {
        return impl_variant.techs.disjunct_alignment;
    }
    pub fn hasStaticMaximumLength(impl_variant: *const DetailExtra) bool {
        return builtin.int2v(bool, impl_variant.kind.automatic, impl_variant.kind.static);
    }
    pub fn hasPackedApproximateCapacity(impl_variant: *const DetailExtra) bool {
        return builtin.int2v(
            bool,
            impl_variant.techs.single_packed_approximate_capacity,
            impl_variant.techs.double_packed_approximate_capacity,
        );
    }
};
const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 2
    \\const gen = @import("./gen-2.zig");
    \\
;
const fmt_spec = .{
    .omit_default_fields = true,
    .infer_type_names = true,
    .omit_trailing_comma = true,
};
fn writeVariantStructsInternal(array: *Array, impl_detail: *const gen.Detail, specs: gen.Specifiers) void {
    array.writeMany("        .{ .index = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.index));
    array.writeMany(", .kind = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.kind));
    array.writeMany(", .layout = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.layout));
    array.writeMany(", .modes = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.modes));
    array.writeMany(", .fields = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.fields));
    array.writeMany(", .techs = ");
    array.writeFormat(fmt.render(fmt_spec, impl_detail.techs));
    array.writeMany(", .specs = ");
    array.writeFormat(fmt.render(fmt_spec, specs));
    array.writeMany(" },\n");
}
fn writeMatrix(array: *Array, matrix: [8][8]u8) void {
    array.writeMany("pub const matrix = ");
    array.writeFormat(fmt.render(.{ .radix = 16 }, matrix));
    array.writeMany(";\n");
}

pub const param_impl_groups: [gen.type_specs.len][]const gen.Detail = blk: {
    var ret: [gen.type_specs.len][]const gen.Detail = [1][]const gen.Detail{&.{}} ** gen.type_specs.len;
    var param_index: u8 = 0;
    while (param_index != gen.type_specs.len) : (param_index +%= 1) {
        var impl_group: []const gen.Detail = &.{};
        var impl_index: u16 = 0;
        while (impl_index != gen.impl_details.len and
            gen.impl_details[impl_index].index <= param_index) : (impl_index +%= 1)
        {
            if (gen.impl_details[impl_index].index == param_index) {
                impl_group = impl_group ++ [1]gen.Detail{gen.impl_details[impl_index]};
            }
        }
        ret[param_index] = impl_group;
    }
    break :blk ret;
};

fn writeVariantStructs(array: *Array) void {
    var accm_spec_index: u8 = 0;
    var matrix: [8][8]u8 = [1][8]u8{[1]u8{0} ** 8} ** 8;
    inline for (gen.type_specs) |type_spec, param_index| {
        inline for (type_spec.specs) |_, spec_index| {
            matrix[param_index][spec_index] = accm_spec_index;
            accm_spec_index +%= 1;
        }
    }
    const accm_spec_len: u8 = accm_spec_index + 1;
    accm_spec_index = 0;
    array.writeMany("pub const impl_variant_groups = [_][]const gen.DetailExtra{\n");
    while (accm_spec_index != accm_spec_len) : (accm_spec_index +%= 1) {
        array.writeMany("    &.{\n");
        inline for (gen.type_specs) |type_spec, param_index| {
            const I = meta.Child(type_spec.vars);
            for (gen.impl_details) |impl_detail| {
                if (impl_detail.index != param_index) {
                    continue;
                }
                var spec_index: u8 = 0;
                while (spec_index <= ~@as(I, 0)) : (spec_index += 1) {
                    if (matrix[param_index][spec_index] == accm_spec_index) {
                        const vars: type_spec.vars = @bitCast(type_spec.vars, @intCast(I, spec_index));
                        var specs: gen.Specifiers = undefined;
                        inline for (@typeInfo(type_spec.vars).Struct.fields) |field| {
                            if (@hasField(gen.Specifiers, field.name)) {
                                @field(specs, field.name) = @field(vars, field.name);
                            }
                        }
                        writeVariantStructsInternal(array, &impl_detail, specs);
                    }
                }
            }
        }
        array.writeMany("    },\n");
    }
    array.writeMany("};\n");
}
fn writeImplementationVariantsFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/impl_variant_groups.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
    array.undefineAll();
}
pub fn generateVariantData() void {
    var array: Array = .{};
    writeVariantStructs(&array);
    writeImplementationVariantsFile(&array);
}
