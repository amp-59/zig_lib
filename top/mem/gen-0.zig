//! This stage summarises the abstract specification.
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const preset = @import("./../preset.zig");
const builtin = @import("./../builtin.zig");

const gen = @import("./gen.zig");

pub const Array = mem.StaticString(65536);

fn slices(comptime T: type) *[]const T {
    var ptrs: []const T = &.{};
    return &ptrs;
}
const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 0
    \\const gen = @import("./gen.zig");
    \\
;
const fmt_spec = .{
    .omit_default_fields = true,
    .infer_type_names = true,
    .omit_trailing_comma = true,
};
pub fn BinaryFilter(comptime T: type) type {
    return (struct { []const T, []const T });
}
pub fn typeIndex(comptime types: []const type, comptime T: type) ?comptime_int {
    for (types) |U, index| {
        if (U == T) return index;
    }
    return null;
}
fn fieldOption(comptime field: builtin.Type.StructField) gen.Option {
    comptime var field_names: []const []const u8 = &.{};
    const field_type_info: builtin.Type = @typeInfo(field.type);
    if (field_type_info == .Optional) {
        const field_type_child_info: builtin.Type = @typeInfo(field_type_info.Optional.child);
        if (field_type_child_info == .Enum) {
            inline for (field_type_child_info.Enum.fields) |field_field| {
                const field_name: []const u8 = field_field.name ++ "_" ++ field.name;
                builtin.static.assert(@hasField(gen.Techniques, field_name));
                field_names = field_names ++ [1][]const u8{field_name};
            }
            return .{
                .kind = .mutually_exclusive_optional,
                .info = .{ .field_name = field.name, .field_field_names = field_names },
            };
        }
    } else if (field_type_info == .Enum) {
        inline for (field_type_info.Enum.fields) |field_field| {
            const field_name: []const u8 = field_field.name ++ "_" ++ field.name;
            builtin.static.assert(@hasField(gen.Techniques, field_name));
            field_names = field_names ++ [1][]const u8{field_name};
        }
        return .{
            .kind = .mutually_exclusive_mandatory,
            .info = .{ .field_name = field.name, .field_field_names = field_names },
        };
    }
}

inline fn writeDetailStructsInternal(array: *Array, comptime types: *[]const type, comptime T: type, detail: *gen.Detail) void {
    const type_info: builtin.Type = @typeInfo(T);
    if (type_info == .Union) {
        inline for (type_info.Union.fields) |field| {
            const tmp = detail.*;
            defer detail.* = tmp;
            if (@hasField(gen.Kind, field.name)) {
                @field(detail.kind, field.name) = true;
            } else if (@hasField(gen.Layout, field.name)) {
                @field(detail.layout, field.name) = true;
            } else if (@hasField(gen.Modes, field.name)) {
                @field(detail.modes, field.name) = true;
            } else if (@hasField(gen.Fields, field.name)) {
                @field(detail.fields, field.name) = true;
            } else if (@hasField(gen.Techniques, field.name)) {
                @field(detail.techs, field.name) = true;
            } else if (field.name.len != 1 or field.name[0] != '_') {
                @compileError(field.name);
            }
            writeDetailStructsInternal(array, types, field.type, detail);
        }
    } else if (type_info == .Struct) {
        detail.index = comptime blk: {
            if (typeIndex(types.*, T)) |index| {
                break :blk index;
            } else {
                types.* = types.* ++ [1]type{T};
                break :blk types.len - 1;
            }
        };
        writeDetailStruct(array, detail.*);
    }
}
fn writeDetailStruct(array: *Array, detail: gen.Detail) void {
    array.writeMany("    .{ .index = ");
    array.writeFormat(fmt.ud64(detail.index));
    array.writeMany(", .kind = ");
    array.writeFormat(fmt.render(fmt_spec, detail.kind));
    array.writeMany(", .layout = ");
    array.writeFormat(fmt.render(fmt_spec, detail.layout));
    array.writeMany(", .modes = ");
    array.writeFormat(fmt.render(fmt_spec, detail.modes));
    array.writeMany(", .fields = ");
    array.writeFormat(fmt.render(fmt_spec, detail.fields));
    array.writeMany(", .techs = ");
    array.writeFormat(fmt.render(fmt_spec, detail.techs));
    array.writeMany(" },\n");
}
fn writeDetailStructs(array: *Array, comptime types: *[]const type) void {
    var detail: gen.Detail = .{};
    array.writeMany("pub const impl_details = [_]gen.Detail{\n");
    writeDetailStructsInternal(array, types, gen.AbstractSpec, &detail);
    array.writeMany("};\n");
}
fn writeAbstractParams(array: *Array, comptime types: *[]const type) void {
    array.writeMany("pub const abstract_params = [_]type{\n");
    inline for (types.*) |U| {
        array.writeMany("    ");
        array.writeFormat(comptime fmt.render(.{ .omit_trailing_comma = true }, U));
        array.writeMany(",\n");
    }
    array.writeMany("};\n");
}
fn writeOptions(array: *Array) void {
    array.writeMany("pub const options = [_]gen.Option{\n");
    inline for (@typeInfo(gen.Techniques.Options).Struct.fields) |field| {
        const option: gen.Option = comptime fieldOption(field);
        array.writeMany("    .{ .kind = .");
        array.writeMany(@tagName(option.kind));
        array.writeMany(", .info = .{ .field_name = \"");
        array.writeMany(option.info.field_name);
        array.writeMany("\", .field_field_names = &[_][]const u8{");
        for (option.info.field_field_names) |field_field_name| {
            array.writeMany("\"");
            array.writeMany(field_field_name);
            array.writeMany("\", ");
        }
        array.overwriteManyBack(" }");
        array.writeMany(" } },\n");
    }
    array.writeMany("};\n");
}
fn writeAbstractParametersFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/abstract_params.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
    array.undefineAll();
}
fn writeImplementationDetailsFile(array: *Array) void {
    const fd: u64 = gen.create(builtin.build_root.? ++ "/top/mem/impl_details.zig");
    defer gen.close(fd);
    gen.write(fd, boilerplate);
    gen.write(fd, array.readAll());
    array.undefineAll();
}
pub fn generateImplementationSummary() void {
    var array: Array = .{};
    const types: *[]const type = comptime slices(type);
    writeDetailStructs(&array, types);
    writeImplementationDetailsFile(&array);
    writeAbstractParams(&array, types);
    writeOptions(&array);
    writeAbstractParametersFile(&array);
}
