//! This stage derives specification variants
const mem = @import("./../mem.zig");
const fmt = @import("./../fmt.zig");
const meta = @import("./../meta.zig");
const file = @import("./../file.zig");
const preset = @import("./../preset.zig");
const testing = @import("./../testing.zig");
const builtin = @import("./../builtin.zig");

const gen = @import("./gen-0.zig");

const abstract_params = @import("./abstract_params.zig").abstract_params;

pub const Array = mem.StaticString(65536);

fn slices(comptime T: type) *[]const T {
    var ptrs: []const T = meta.empty;
    return &ptrs;
}
const close_spec: file.CloseSpec = .{
    .errors = null,
};
const create_spec: file.CreateSpec = .{
    .errors = null,
    .options = .{ .exclusive = false },
};

pub const TypeSpecMap = struct {
    params: type,
    specs: []const type,
    vars: type,
};
const boilerplate: []const u8 =
    \\//! This file is generated by `memgen` stage 1
    \\const gen = @import("./gen-1.zig");
    \\
;
inline fn fieldsSuperSet(comptime types: *[]const type) []const builtin.Type.StructField {
    var all_fields: []const builtin.Type.StructField = meta.empty;
    for (types.*) |T| {
        for (meta.resolve(@typeInfo(T)).fields) |field| {
            for (all_fields) |unique_field| {
                if (mem.testEqualMany(u8, field.name, unique_field.name)) {
                    break;
                }
            } else {
                all_fields = meta.concat(builtin.Type.StructField, all_fields, field);
            }
        }
    }
    return all_fields;
}
fn writeStructFromFields(
    array: *Array,
    comptime struct_fields: []const builtin.Type.StructField,
) void {
    array.writeFormat(comptime fmt.any(@Type(meta.structInfo(struct_fields))));
    array.writeMany(", ");
}
fn getFieldDefault(
    comptime field: builtin.Type.StructField,
    comptime field_name: []const u8,
) ?meta.Field(field.type, field_name) {
    return @field(mem.pointerOpaque(field.type, field.default_value orelse return null), field_name);
}
inline fn writePackedStructFromFields(
    array: *Array,
    comptime types: *[]const type,
    comptime struct_fields: []const builtin.Type.StructField,
) void {
    comptime var type_info: builtin.Type = meta.structInfo(struct_fields);
    type_info.Struct.layout = .Packed;
    meta.concatEqu(type, types, @Type(type_info));
    array.writeFormat(comptime fmt.any(types.*[types.len - 1]));
    array.writeMany(", ");
}
fn addVariant(
    comptime struct_field_slices: []const []const builtin.Type.StructField,
    comptime struct_field: builtin.Type.StructField,
) []const []const builtin.Type.StructField {
    return struct_field_slices ++ addField(struct_field_slices, struct_field);
}
fn addField(
    comptime struct_field_slices: []const []const builtin.Type.StructField,
    comptime struct_field: builtin.Type.StructField,
) []const []const builtin.StructField {
    if (struct_field_slices.len == 0) {
        return &[1][]const builtin.StructField{&[1]builtin.StructField{struct_field}};
    } else {
        var ret: []const []const builtin.StructField = meta.empty;
        for (struct_field_slices) |struct_fields| {
            ret = meta.concat([]const builtin.StructField, ret, struct_fields ++ [1]builtin.StructField{struct_field});
        }
        return ret;
    }
}
fn writeSpecifications(array: *Array, comptime types: *[]const type, comptime T: type) void {
    comptime var p_struct_fields: []const builtin.Type.StructField = meta.empty;
    comptime var v_struct_fields: []const builtin.Type.StructField = meta.empty;
    comptime var s_struct_field_slices: []const []const builtin.Type.StructField = meta.empty;
    inline for (@typeInfo(T).Struct.fields) |field| {
        const field_type_info: builtin.Type = @typeInfo(field.type);
        if (field_type_info != .Union) {
            p_struct_fields = meta.concat(builtin.StructField, p_struct_fields, field);
            s_struct_field_slices = addField(
                s_struct_field_slices,
                meta.structField(field.type, field.name, null),
            );
        } else {
            const field_union_field_name: []const u8 = field_type_info.Union.fields[0].name;
            if (@hasField(gen.Variant, field_union_field_name)) {
                switch (@field(gen.Variant, field_union_field_name)) {
                    .__stripped => {
                        p_struct_fields = meta.concat(builtin.StructField, p_struct_fields, field);
                    },
                    .__derived => {
                        s_struct_field_slices = addField(
                            s_struct_field_slices,
                            meta.structField(field.type, field.name, null),
                        );
                    },
                    .__optional_derived => {
                        const p_field_type: type = meta.Field(field.type, field_union_field_name);
                        const s_field_type: type = meta.Child(p_field_type);
                        p_struct_fields = meta.concat(builtin.StructField, p_struct_fields, meta.structField(
                            p_field_type,
                            field.name,
                            getFieldDefault(field, field_union_field_name),
                        ));
                        s_struct_field_slices = addField(
                            s_struct_field_slices,
                            meta.structField(s_field_type, field.name, null),
                        );
                    },
                    .__optional_variant => {
                        const p_field_type: type = meta.Field(field.type, field_union_field_name);
                        const s_field_type: type = meta.Child(p_field_type);
                        p_struct_fields = meta.concat(builtin.StructField, p_struct_fields, meta.structField(
                            p_field_type,
                            field.name,
                            getFieldDefault(field, field_union_field_name),
                        ));
                        v_struct_fields = meta.concat(
                            builtin.Type.StructField,
                            v_struct_fields,
                            meta.structField(bool, field.name, false),
                        );
                        s_struct_field_slices = addVariant(
                            s_struct_field_slices,
                            meta.structField(s_field_type, field.name, null),
                        );
                    },
                    .__decl_optional_derived => {
                        const p_field_type: type = meta.Field(field.type, field_union_field_name);
                        const fields: []const builtin.StructField = meta.structFields(p_field_type);
                        p_struct_fields = meta.concat(
                            builtin.Type.StructField,
                            p_struct_fields,
                            meta.structField(fields[0].type, fields[0].name, null),
                        );
                        s_struct_field_slices = addField(
                            s_struct_field_slices,
                            meta.structField(fields[1].type, fields[1].name, null),
                        );
                    },
                    .__decl_optional_variant => {
                        const p_field_type: type = meta.Field(field.type, field_union_field_name);
                        const fields: []const builtin.StructField = meta.structFields(p_field_type);
                        p_struct_fields = meta.concat(
                            builtin.Type.StructField,
                            p_struct_fields,
                            meta.structField(fields[0].type, fields[0].name, null),
                        );
                        v_struct_fields = meta.concat(
                            builtin.Type.StructField,
                            v_struct_fields,
                            meta.structField(bool, fields[1].name, false),
                        );
                        s_struct_field_slices = addVariant(
                            s_struct_field_slices,
                            meta.structField(fields[1].type, fields[1].name, null),
                        );
                    },
                }
                continue;
            }
        }
    }
    array.writeMany(".{ .params = ");
    writeStructFromFields(array, p_struct_fields);
    array.writeMany(".specs = &[_]type{");
    inline for (s_struct_field_slices) |s_struct_fields| {
        writeStructFromFields(array, s_struct_fields);
    }
    array.writeMany("}, .vars = ");
    writePackedStructFromFields(array, types, v_struct_fields);
    array.writeMany("},\n");
}
fn writeSpecifiersStruct(array: *Array, comptime types: *[]const type) void {
    comptime var type_info: builtin.Type = meta.structInfo(fieldsSuperSet(types));
    type_info.Struct.layout = .Packed;
    const Specifiers = @Type(type_info);
    array.writeMany("pub const Specifiers = ");
    array.writeFormat(comptime fmt.any(Specifiers));
    array.writeMany(";\n");
}
fn writeFile(array: *Array) void {
    const fd: u64 = file.create(create_spec, builtin.build_root.? ++ "/top/mem/type_specs.zig");
    defer file.close(close_spec, fd);
    file.noexcept.write(fd, array.readAll());
}
pub fn generateSpecificationTypes() void {
    var array: Array = .{};
    array.writeMany(boilerplate);
    array.writeMany("pub const type_specs = [_]gen.TypeSpecMap{\n");
    const types: *[]const type = comptime slices(type);
    inline for (abstract_params) |param| {
        writeSpecifications(&array, types, param);
    }
    array.writeMany("};\n");
    writeSpecifiersStruct(&array, types);
    writeFile(&array);
}
