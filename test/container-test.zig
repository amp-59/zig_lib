const top = @import("../zig_lib.zig");
const mem = top.mem;
const file = top.file;
const meta = top.meta;
const proc = top.proc;
const spec = top.spec;
const builtin = top.builtin;
const testing = top.testing;
const Allocator = mem.GenericArenaAllocator(.{
    .arena_index = 0,
    .AddressSpace = AddressSpace,
});
pub usingnamespace proc.start;
pub const AddressSpace = spec.address_space.regular_128;
pub fn testAutomaticAppend(comptime reinterpret_spec: mem.ReinterpretSpec, comptime dst_type: type, expected: []const dst_type, any: anytype) void {
    const Array = mem.StaticArray(dst_type, 4096);
    var array: Array = .{};
    array.writeAny(reinterpret_spec, any);
    try testing.expectEqualMany(dst_type, array.readAll(), expected);
}
pub fn testDynamicAppend(comptime reinterpret_spec: mem.ReinterpretSpec, allocator: *Allocator, comptime dst_type: type, expected: []const dst_type, any: anytype) !void {
    const Array = Allocator.StructuredVector(dst_type);
    var array: Array = try Array.init(allocator);
    defer array.deinit(allocator);
    try array.appendAny(reinterpret_spec, any);
    try testing.expectEqualMany(dst_type, array.readAll(), expected);
}
pub fn unfairAndUnreasonableTestCases() !void {
    var address_space: AddressSpace = .{};
    var allocator: Allocator = try Allocator.init(&address_space);
    {
        const S = struct {
            a: u16 = 25,
            b: u32 = 44,
            const sentinel: @This() = .{ .a = 0, .b = 0 };
            fn get(n: u16) [5:sentinel]@This() {
                const x = n * 5;
                return .{
                    .{ .a = x + '0', .b = x + '1' }, .{ .a = x + '2', .b = x + '3' },
                    .{ .a = x + '4', .b = x + '5' }, .{ .a = x + '6', .b = x + '7' },
                    .{ .a = x + '8', .b = x + '9' },
                };
            }
        };
        const dst_type: type = []?[]S;
        var v_0 = S.get(0);
        var v_1 = S.get(1);
        var v_2 = S.get(2);
        var v_3 = S.get(3);
        var v_4 = S.get(4);
        var src_0: [5:null]?[:S.sentinel]S = .{ &v_0, &v_1, &v_2, &v_3, &v_4 };
        var src_1 = @as([*:null]?[:S.sentinel]S, @ptrCast(&src_0));
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, src_1, .{ &v_0, &v_1, &v_2, &v_3, &v_4 });
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src_1);
    }
    {
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .dereference = &.{} } };
        const dst_type: type = u8;
        const src_0: [11:0]u8 = "hello_world".*;
        const src_1: *const [11:0]u8 = &src_0;
        const src_2: [:0]const u8 = &src_0;
        const src_3: [*:0]const u8 = src_2.ptr;
        const src = .{ src_0, src_1, src_2, src_3 };
        try testAutomaticAppend(reinterpret_spec, dst_type, 4, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        // The desired response to the following parameters is to iterate over
        // the tuple, identify that the tuple arguments are references to
        // aggregates of the element type, and to copy these in the most
        // efficient way. The array's compile-time-known length must be
        // utilised. So must the compile-time-known length of the pointer to
        // array.
        const dst_type: type = [:0]const u8;
        const src_0: [11:0]u8 = "hello_world".*;
        const src_1: *const [11:0]u8 = &src_0;
        const src_2: [:0]const u8 = &src_0;
        const src_3: [*:0]const u8 = src_2.ptr;
        const src = .{ src_1, src_2, src_3 };
        const reinterpret_spec = .{ .reference = .{ .dereference = &.{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = []const []align(8) const u8;
        const src_0: []align(8) const u8 = @alignCast("hello_world");
        const src_2: []const []align(8) const u8 = &.{src_0};
        const src_4: []const []const []align(8) const u8 = &.{src_2};
        const src_6: []const []const []const []align(8) const u8 = &.{src_4};
        const src_8: []const []const []const []const []align(8) const u8 = &.{src_6};
        try testAutomaticAppend(mem.follow_wr_spec, dst_type, src_8);
        try testDynamicAppend(mem.follow_wr_spec, allocator, dst_type, src_8);
    }
    {
        var p0 = "hello_world".*;
        var p1 = "hello".*;
        var p2 = "world".*;
        const src_0 = &p0;
        const src_1 = .{ &p1, &p2 };
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(reinterpret_spec, u8, src_0);
        try testDynamicAppend(reinterpret_spec, allocator, u8, src_0);
        try testAutomaticAppend(reinterpret_spec, u8, src_1);
        try testDynamicAppend(reinterpret_spec, allocator, u8, src_1);
    }
    {
        const dst_type: type = []u8;
        const src_type: type = [*:0]u8;
        var p0 = "hello_world".*;
        var p1 = @as(src_type, @ptrCast(&p0));
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, p1);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, p1);
    }
    {
        const dst_type: type = [:'k']u8;
        const src_type: type = [:'k']u8;
        var src_0: [32:'k']u8 = .{'a'} ** 32;
        var src: src_type = &src_0;
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, 1, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        const S = struct { c: u8 = 'k', d: u8 = 'l' };
        const dst_type: type = [:.{}]S;
        const src_type: type = [:.{}]S;
        var src_0: [32:.{}]S = .{.{}} ** 32;
        const src: src_type = &src_0;
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, 1, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        const c: u8 = 'k';
        const dst_type: type = []*const u8;
        const src_type: type = [:&c]*const u8;
        const v_0: u8 = 'a';
        const v_1: u8 = 'b';
        const v_2: u8 = 'c';
        const v_3: u8 = 'd';
        var src_0: [4]*const u8 = [_]*const u8{ &v_0, &v_1, &v_2, &v_3, &c };
        var src: src_type = src_0[0..4 :&c];
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, 1, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = [*:0]u8;
        var src_0: [4:0]u8 = "abcd".*;
        const src: [*:0]u8 = @as([:0]u8, &src_0).ptr;
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, 1, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
    {
        const dst_type: type = u8;
        const src = @embedFile("./container-test.zig");
        const reinterpret_spec: mem.ReinterpretSpec = .{ .reference = .{ .coerce = .{}, .dereference = &.{} } };
        try testAutomaticAppend(reinterpret_spec, dst_type, 1, src);
        try testDynamicAppend(reinterpret_spec, allocator, dst_type, src);
    }
}
pub fn main() !void {
    var b: bool = true;
    if (b) return;
    var address_space: AddressSpace = .{};
    var random: file.DeviceRandomBytes(1024 * 1024) = .{};
    inline for (.{ u16, u32, u64 }) |child| {
        { // StructuredAutomaticView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            const Array = mem.StructuredAutomaticView(child, &sentinel, write_count + read_count, @alignOf(child), .{});
            var array: Array = .{};
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // StructuredAutomaticView
        { // StructuredAutomaticStreamView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            const Array = mem.StructuredAutomaticStreamView(child, &sentinel, write_count + read_count, @alignOf(child), .{});
            var array: Array = .{};
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
        } // StructuredAutomaticStreamView
        { // StructuredAutomaticStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            const Array = mem.StructuredAutomaticStreamVector(child, &sentinel, write_count + read_count, @alignOf(child), .{});
            var array: Array = .{};
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredAutomaticStreamVector
        { // StructuredAutomaticVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            const Array = mem.StructuredAutomaticVector(child, &sentinel, write_count + read_count, @alignOf(child), .{});
            var array: Array = .{};
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredAutomaticVector
        { // StructuredStaticView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticView(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // StructuredStaticView
        { // StructuredStaticStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticStreamVector(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredStaticStreamVector
        { // StructuredStaticVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticVector(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredStaticVector
        { // StructuredStaticView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticView(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // StructuredStaticView
        { // StructuredStaticStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticStreamVector(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredStaticStreamVector
        { // StructuredStaticVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStaticVector(child, read_count + write_count);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // StructuredStaticVector
        { // UnstructuredStaticView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStaticView(@sizeOf(child) * (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // UnstructuredStaticView
        { // UnstructuredStaticStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStaticStreamVector(@sizeOf(child) * (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_17: child = array.readOneBehind(child);
            const ret_18: [read_count]child = array.readCountBehind(child, read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(child, read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(child, read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(child, offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(child, sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(child, sentinel, offset);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            const ret_38: child = array.readOneAhead(child);
            const ret_39: [read_count]child = array.readCountAhead(child, read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(child, read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(child, offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(child, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // UnstructuredStaticStreamVector
        { // UnstructuredStaticVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStaticVector(@sizeOf(child) * (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
        } // UnstructuredStaticVector
        { // StructuredStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStreamVector(child);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // StructuredStreamVector
        { // StructuredStreamView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStreamView(child);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
        } // StructuredStreamView
        { // StructuredVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredVector(child);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined();
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // StructuredVector
        { // StructuredView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredView(child);
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll();
            const ret_12: []child = array.referAllDefined();
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(sentinel);
            const ret_24: child = array.readOneAt(offset);
            const ret_25: *child = array.referOneAt(offset);
            const ret_26: void = array.overwriteOneAt(offset, value);
            const ret_27: [read_count]child = array.readCountAt(read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(read_count, offset);
            const ret_29: void = array.overwriteCountAt(write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(offset);
            const ret_33: []child = array.referManyAt(offset);
            const ret_34: void = array.overwriteManyAt(offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // StructuredView
        { // UnstructuredStreamVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStreamVector(@sizeOf(child), (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_17: child = array.readOneBehind(child);
            const ret_18: [read_count]child = array.readCountBehind(child, read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(child, read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(child, read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(child, offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(child, sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(child, sentinel, offset);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            const ret_38: child = array.readOneAhead(child);
            const ret_39: [read_count]child = array.readCountAhead(child, read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(child, read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(child, offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(child, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // UnstructuredStreamVector
        { // UnstructuredStreamView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStreamView(@sizeOf(child), (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_17: child = array.readOneBehind(child);
            const ret_18: [read_count]child = array.readCountBehind(child, read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(child, read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(child, read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(child, offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(child, sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(child, sentinel, offset);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            const ret_38: child = array.readOneAhead(child);
            const ret_39: [read_count]child = array.readCountAhead(child, read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(child, read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(child, offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(child, sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
        } // UnstructuredStreamView
        { // UnstructuredVector
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredVector(@sizeOf(child), (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // UnstructuredVector
        { // UnstructuredView
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredView(@sizeOf(child), (read_count + write_count));
            var array: Array = try Array.init(&allocator, random.readOne(u16));
            const ret_11: []const child = array.readAll(child);
            const ret_12: []child = array.referAllDefined(child);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, sentinel);
            const ret_24: child = array.readOneAt(child, offset);
            const ret_25: *child = array.referOneAt(child, offset);
            const ret_26: void = array.overwriteOneAt(child, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, offset);
            const ret_33: []child = array.referManyAt(child, offset);
            const ret_34: void = array.overwriteManyAt(child, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, sentinel, offset);
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
        } // UnstructuredView
        { // StructuredStreamHolder
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredStreamHolder(child);
            var array: Array = Array.init(&allocator);
            const ret_11: []const child = array.readAll(allocator);
            const ret_12: []child = array.referAllDefined(allocator);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(allocator, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(allocator, sentinel);
            const ret_17: child = array.readOneBehind();
            const ret_18: [read_count]child = array.readCountBehind(read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(sentinel, offset);
            const ret_24: child = array.readOneAt(allocator, offset);
            const ret_25: *child = array.referOneAt(allocator, offset);
            const ret_26: void = array.overwriteOneAt(allocator, offset, value);
            const ret_27: [read_count]child = array.readCountAt(allocator, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(allocator, read_count, offset);
            const ret_29: void = array.overwriteCountAt(allocator, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(allocator, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(allocator, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(allocator, offset);
            const ret_33: []child = array.referManyAt(allocator, offset);
            const ret_34: void = array.overwriteManyAt(allocator, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(allocator, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(allocator, sentinel, offset);
            const ret_38: child = array.readOneAhead();
            const ret_39: [read_count]child = array.readCountAhead(read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined(allocator);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(allocator, sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // StructuredStreamHolder
        { // StructuredHolder
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: u64 = 256;
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.StructuredHolder(child);
            var array: Array = Array.init(&allocator);
            const ret_11: []const child = array.readAll(allocator);
            const ret_12: []child = array.referAllDefined(allocator);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(allocator, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(allocator, sentinel);
            const ret_24: child = array.readOneAt(allocator, offset);
            const ret_25: *child = array.referOneAt(allocator, offset);
            const ret_26: void = array.overwriteOneAt(allocator, offset, value);
            const ret_27: [read_count]child = array.readCountAt(allocator, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(allocator, read_count, offset);
            const ret_29: void = array.overwriteCountAt(allocator, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(allocator, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(allocator, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(allocator, offset);
            const ret_33: []child = array.referManyAt(allocator, offset);
            const ret_34: void = array.overwriteManyAt(allocator, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(allocator, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(allocator, sentinel, offset);
            const ret_45: child = array.readOneBack();
            const ret_46: *child = array.referOneBack();
            const ret_47: void = array.overwriteOneBack(value);
            const ret_48: [read_count]child = array.readCountBack(read_count);
            const ret_49: *[read_count]child = array.referCountBack(read_count);
            const ret_50: void = array.overwriteCountBack(write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(read_count, sentinel);
            const ret_53: []const child = array.readManyBack(offset);
            const ret_54: []child = array.referManyBack(offset);
            const ret_55: void = array.overwriteManyBack(&values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(sentinel, offset);
            const ret_58: []child = array.referAllUndefined(allocator);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(allocator, sentinel);
            const ret_61: *child = array.referOneUndefined();
            const ret_62: void = array.writeOne(value);
            const ret_63: *[read_count]child = array.referCountUndefined(read_count);
            const ret_64: void = array.writeCount(write_count, values);
            const ret_65: []child = array.referManyUndefined(offset);
            const ret_66: void = array.writeMany(&values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(&allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(&allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(&allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // StructuredHolder
        { // UnstructuredStreamHolder
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredStreamHolder(@sizeOf(child), (read_count + write_count));
            var array: Array = Array.init(&allocator);
            const ret_11: []const child = array.readAll(child, allocator);
            const ret_12: []child = array.referAllDefined(child, allocator);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, allocator, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, allocator, sentinel);
            const ret_17: child = array.readOneBehind(child);
            const ret_18: [read_count]child = array.readCountBehind(child, read_count);
            const ret_19: [read_count:sentinel]child = array.readCountWithSentinelBehind(child, read_count, sentinel);
            const ret_20: *[read_count:sentinel]child = array.referCountWithSentinelBehind(child, read_count, sentinel);
            const ret_21: []const child = array.readManyBehind(child, offset);
            const ret_22: [:sentinel]const child = array.readManyWithSentinelBehind(child, sentinel, offset);
            const ret_23: [:sentinel]child = array.referManyWithSentinelBehind(child, sentinel, offset);
            const ret_24: child = array.readOneAt(child, allocator, offset);
            const ret_25: *child = array.referOneAt(child, allocator, offset);
            const ret_26: void = array.overwriteOneAt(child, allocator, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, allocator, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, allocator, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, allocator, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, allocator, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, allocator, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, allocator, offset);
            const ret_33: []child = array.referManyAt(child, allocator, offset);
            const ret_34: void = array.overwriteManyAt(child, allocator, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, allocator, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, allocator, sentinel, offset);
            const ret_38: child = array.readOneAhead(child);
            const ret_39: [read_count]child = array.readCountAhead(child, read_count);
            const ret_40: [read_count:sentinel]child = array.readCountWithSentinelAhead(child, read_count, sentinel);
            const ret_41: []const child = array.readManyAhead(child, offset);
            const ret_42: [:sentinel]const child = array.readManyWithSentinelAhead(child, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child, allocator);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, allocator, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_17;
            _ = ret_18;
            _ = ret_19;
            _ = ret_20;
            _ = ret_21;
            _ = ret_22;
            _ = ret_23;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_38;
            _ = ret_39;
            _ = ret_40;
            _ = ret_41;
            _ = ret_42;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // UnstructuredStreamHolder
        { // UnstructuredHolder
            const read_count: u64 = 512;
            const write_count: u64 = 1024;
            const sentinel: child = 0;
            const value: child = random.readOne(child);
            const offset: mem.Amount = .{ .count = 256 };
            const values: [write_count]child = random.readCount(child, write_count);
            var allocator: Allocator = try Allocator.init(&address_space);
            defer allocator.deinit(&address_space);
            const Array = Allocator.UnstructuredHolder(@sizeOf(child), (read_count + write_count));
            var array: Array = Array.init(&allocator);
            const ret_11: []const child = array.readAll(child, allocator);
            const ret_12: []child = array.referAllDefined(child, allocator);
            const ret_13: [:sentinel]const child = array.readAllWithSentinel(child, allocator, sentinel);
            const ret_14: [:sentinel]child = array.referAllDefinedWithSentinel(child, allocator, sentinel);
            const ret_24: child = array.readOneAt(child, allocator, offset);
            const ret_25: *child = array.referOneAt(child, allocator, offset);
            const ret_26: void = array.overwriteOneAt(child, allocator, offset, value);
            const ret_27: [read_count]child = array.readCountAt(child, allocator, read_count, offset);
            const ret_28: *[read_count]child = array.referCountAt(child, allocator, read_count, offset);
            const ret_29: void = array.overwriteCountAt(child, allocator, write_count, offset, values);
            const ret_30: [read_count:sentinel]child = array.readCountWithSentinelAt(child, allocator, read_count, sentinel, offset);
            const ret_31: *[read_count:sentinel]child = array.referCountWithSentinelAt(child, allocator, read_count, sentinel, offset);
            const ret_32: []const child = array.readManyAt(child, allocator, offset);
            const ret_33: []child = array.referManyAt(child, allocator, offset);
            const ret_34: void = array.overwriteManyAt(child, allocator, offset, &values);
            const ret_35: [:sentinel]const child = array.readManyWithSentinelAt(child, allocator, sentinel, offset);
            const ret_36: [:sentinel]child = array.referManyWithSentinelAt(child, allocator, sentinel, offset);
            const ret_45: child = array.readOneBack(child);
            const ret_46: *child = array.referOneBack(child);
            const ret_47: void = array.overwriteOneBack(child, value);
            const ret_48: [read_count]child = array.readCountBack(child, read_count);
            const ret_49: *[read_count]child = array.referCountBack(child, read_count);
            const ret_50: void = array.overwriteCountBack(child, write_count, values);
            const ret_51: [read_count:sentinel]child = array.readCountWithSentinelBack(child, read_count, sentinel);
            const ret_52: *[read_count:sentinel]child = array.referCountWithSentinelBack(child, read_count, sentinel);
            const ret_53: []const child = array.readManyBack(child, offset);
            const ret_54: []child = array.referManyBack(child, offset);
            const ret_55: void = array.overwriteManyBack(child, &values);
            const ret_56: [:sentinel]const child = array.readManyWithSentinelBack(child, sentinel, offset);
            const ret_57: [:sentinel]child = array.referManyWithSentinelBack(child, sentinel, offset);
            const ret_58: []child = array.referAllUndefined(child, allocator);
            const ret_59: [:sentinel]child = array.referAllUndefinedWithSentinel(child, allocator, sentinel);
            const ret_61: *child = array.referOneUndefined(child);
            const ret_62: void = array.writeOne(child, value);
            const ret_63: *[read_count]child = array.referCountUndefined(child, read_count);
            const ret_64: void = array.writeCount(child, write_count, values);
            const ret_65: []child = array.referManyUndefined(child, offset);
            const ret_66: void = array.writeMany(child, &values);
            const ret_80: Allocator.allocate_void = try meta.wrap(array.appendOne(child, &allocator, value));
            const ret_81: Allocator.allocate_void = try meta.wrap(array.appendCount(child, &allocator, write_count, values));
            const ret_82: Allocator.allocate_void = try meta.wrap(array.appendMany(child, &allocator, &values));
            _ = ret_11;
            _ = ret_12;
            _ = ret_13;
            _ = ret_14;
            _ = ret_24;
            _ = ret_25;
            _ = ret_26;
            _ = ret_27;
            _ = ret_28;
            _ = ret_29;
            _ = ret_30;
            _ = ret_31;
            _ = ret_32;
            _ = ret_33;
            _ = ret_34;
            _ = ret_35;
            _ = ret_36;
            _ = ret_45;
            _ = ret_46;
            _ = ret_47;
            _ = ret_48;
            _ = ret_49;
            _ = ret_50;
            _ = ret_51;
            _ = ret_52;
            _ = ret_53;
            _ = ret_54;
            _ = ret_55;
            _ = ret_56;
            _ = ret_57;
            _ = ret_58;
            _ = ret_59;
            _ = ret_61;
            _ = ret_62;
            _ = ret_63;
            _ = ret_64;
            _ = ret_65;
            _ = ret_66;
            _ = try ret_80;
            _ = try ret_81;
            _ = try ret_82;
        } // UnstructuredHolder
    }
}
